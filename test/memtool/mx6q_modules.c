/*
 * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
 *
 * This is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this software; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */
#include "memtools_register_info.h"

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark AIPSTZ
#endif

// Bitfields in register AIPSTZ_MPR.
static const field_t hw_aipstz_mpr[] =
{
    {
        "MPROT3",
        "Master 3 Priviledge, Buffer, Read, Write Control.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPROT2",
        "Master 2 Priviledge, Buffer, Read, Write Control",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPROT1",
        "Master 1 Priviledge, Buffer, Read, Write Control",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPROT0",
        "Master 0 Priviledge, Buffer, Read, Write Control",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR.
static const field_t hw_aipstz_opacr[] =
{
    {
        "OPAC7",
        "Off-platform Peripheral Access Control 7",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC6",
        "Off-platform Peripheral Access Control 6",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC5",
        "Off-platform Peripheral Access Control 5",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC4",
        "Off-platform Peripheral Access Control 4",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC3",
        "Off-platform Peripheral Access Control 3",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC2",
        "Off-platform Peripheral Access Control 2",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC1",
        "Off-platform Peripheral Access Control 1",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC0",
        "Off-platform Peripheral Access Control 0",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR1.
static const field_t hw_aipstz_opacr1[] =
{
    {
        "OPAC15",
        "Off-platform Peripheral Access Control 15",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC14",
        "Off-platform Peripheral Access Control 14",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC13",
        "Off-platform Peripheral Access Control 13",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC12",
        "Off-platform Peripheral Access Control 12",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC11",
        "Off-platform Peripheral Access Control 11",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC10",
        "Off-platform Peripheral Access Control 10",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC9",
        "Off-platform Peripheral Access Control 9",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC8",
        "Off-platform Peripheral Access Control 8",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR2.
static const field_t hw_aipstz_opacr2[] =
{
    {
        "OPAC23",
        "Off-platform Peripheral Access Control 23",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC22",
        "Off-platform Peripheral Access Control 22",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC21",
        "Off-platform Peripheral Access Control 21",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC20",
        "Off-platform Peripheral Access Control 20",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC19",
        "Off-platform Peripheral Access Control 19",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC18",
        "Off-platform Peripheral Access Control 18",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC17",
        "Off-platform Peripheral Access Control 17",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC16",
        "Off-platform Peripheral Access Control 16",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR3.
static const field_t hw_aipstz_opacr3[] =
{
    {
        "OPAC31",
        "Off-platform Peripheral Access Control 31",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC30",
        "Off-platform Peripheral Access Control 30",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC29",
        "Off-platform Peripheral Access Control 29",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC28",
        "Off-platform Peripheral Access Control 28",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC27",
        "Off-platform Peripheral Access Control 27",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC26",
        "Off-platform Peripheral Access Control 26",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC25",
        "Off-platform Peripheral Access Control 25",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC24",
        "Off-platform Peripheral Access Control 24",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR4.
static const field_t hw_aipstz_opacr4[] =
{
    {
        "OPAC33",
        "Off-platform Peripheral Access Control 33",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC32",
        "Off-platform Peripheral Access Control 32",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a AIPSTZ module.
static const reg_t hw_aipstz[] =
{
    {
        "MPR",
        "Each AIPSTZ_MPR specifies 16 4-bit fields defining the access privileg"
        "e level associated with a bus master in the platform, as well as speci"
        "fying whether write accesses from this master are bufferable shown in "
        " The registers provide one field per bus master, where field 15 corres"
        "ponds to master 15, field 14 to master 14,...",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_aipstz_mpr
    },
    {
        "OPACR",
        "Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_aipstz_opacr
    },
    {
        "OPACR1",
        "Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_aipstz_opacr1
    },
    {
        "OPACR2",
        "Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_aipstz_opacr2
    },
    {
        "OPACR3",
        "Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_aipstz_opacr3
    },
    {
        "OPACR4",
        "Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_aipstz_opacr4
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ARMGLOBALTIMER
#endif

// Bitfields in register ARMGLOBALTIMER_COUNTER0.
static const field_t hw_armglobaltimer_counter0[] =
{
    {
        "VALUE",
        "32-bits of the counter value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_COUNTER1.
static const field_t hw_armglobaltimer_counter1[] =
{
    {
        "VALUE",
        "32-bits of the counter value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_CONTROL.
static const field_t hw_armglobaltimer_control[] =
{
    {
        "TIMER_ENABLE",
        "Timer enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMP_ENABLE",
        "This bit is banked per Cortex-A9 processor.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ENABLE",
        "This bit is banked per Cortex-A9 processor.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_INCREMENT",
        "This bit is banked per Cortex-A9 processor.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER",
        "The prescaler modifies the clock period for the decrementing event for"
        " the Counter Register.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_IRQSTATUS.
static const field_t hw_armglobaltimer_irqstatus[] =
{
    {
        "EVENT_FLAG",
        "The event flag is a sticky bit that is automatically set when the Coun"
        "ter Register reaches the Comparator Register value.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_COMPARATOR0.
static const field_t hw_armglobaltimer_comparator0[] =
{
    {
        "VALUE",
        "32-bits of the comparator value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_COMPARATOR1.
static const field_t hw_armglobaltimer_comparator1[] =
{
    {
        "VALUE",
        "32-bits of the comparator value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_AUTOINCREMENT.
static const field_t hw_armglobaltimer_autoincrement[] =
{
    {
        "VALUE",
        "32-bit auto-increment value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ARMGLOBALTIMER module.
static const reg_t hw_armglobaltimer[] =
{
    {
        "COUNTER0",
        "There are two timer counter registers.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_counter0
    },
    {
        "COUNTER1",
        "There are two timer counter registers.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_counter1
    },
    {
        "CONTROL",
        "Configuration and control of the Global Timer.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_armglobaltimer_control
    },
    {
        "IRQSTATUS",
        "This is a banked register for all Cortex-A9 processors present.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_irqstatus
    },
    {
        "COMPARATOR0",
        "There are two timer counter registers.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_comparator0
    },
    {
        "COMPARATOR1",
        "There are two timer counter registers.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_comparator1
    },
    {
        "AUTOINCREMENT",
        "This 32-bit register gives the increment value of the Comparator Regis"
        "ter when the Auto-increment bit is set in the Timer Control Register.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_autoincrement
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ASRC
#endif

// Bitfields in register ASRC_ASRCTR.
static const field_t hw_asrc_asrctr[] =
{
    {
        "ASRCEN",
        "ASRC Enable  Enable the operation of ASRC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREA",
        "ASRC Enable A  Enable the operation of the conversion A of ASRC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREB",
        "ASRC Enable B  Enable the operation of the conversion B of ASRC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREC",
        "ASRC Enable C  Enable the operation of the conversion C of ASRC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRST",
        "Software Reset  This bit is self-clear bit.",
        4, // LSB
        4, // MSB
        false, // Readable
        true // Writable
    },
    {
        "IDRA",
        "Use Ideal Ratio for Pair A  When USRA=0, this bit has no usage.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRA",
        "Use Ratio for Pair A  Use ratio as the input to ASRC.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDRB",
        "Use Ideal Ratio for Pair B  When USRB=0, this bit has no usage.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRB",
        "Use Ratio for Pair B  Use ratio as the input to ASRC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDRC",
        "Use Ideal Ratio for Pair C  When USRC=0, this bit has no usage.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRC",
        "Use Ratio for Pair C  Use ratio as the input to ASRC.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSA",
        "ASRC Pair A Automatic Selection For Processing Options  When this bit "
        "is 1, pair A will automatic update its pre-processing and post-process"
        "ing options (ASRCFG: PREMODA, ASRCFG:POSTMODA see ASRC Misc Control Re"
        "gister 1 for Pair C ) based on the frequencies it detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSB",
        "ASRC Pair B Automatic Selection For Processing Options  When this bit "
        "is 1, pair B will automatic update its pre-processing and post-process"
        "ing options (ASRCFG: PREMODB, ASRCFG:POSTMODB see ASRC Misc Control Re"
        "gister 1 for Pair C ) based on the frequencies it detected.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSC",
        "ASRC Pair C Automatic Selection For Processing Options  When this bit "
        "is 1, pair C will automatic update its pre-processing and post-process"
        "ing options (ASRCFG: PREMODC, ASRCFG:POSTMODC see ASRC Misc Control Re"
        "gister 1 for Pair C ) based on the frequencies it detected.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIER.
static const field_t hw_asrc_asrier[] =
{
    {
        "ADIEA",
        "Data Input A Interrupt Enable  Enables the data input A Interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADIEB",
        "Data Input B Interrupt Enable  Enables the data input B interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADIEC",
        "Data Input C Interrupt Enable  Enables the data input C interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEA",
        "Data Output A Interrupt Enable  Enables the data output A interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEB",
        "Data Output B Interrupt Enable  Enables the data output B interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEC",
        "Data Output C Interrupt Enable  Enables the data output C interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOLIE",
        "Overload Interrupt Enable  Enables the overload interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AFPWE",
        "FP in Wait State Interrupt Enable  Enables the FP in wait state interr"
        "upt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCNCR.
static const field_t hw_asrc_asrcncr[] =
{
    {
        "ANCA",
        "Number of A Channels",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANCB",
        "Number of B Channels",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANCC",
        "Number of C Channels ANCC+ANCB+ANCA<=10.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCFG.
static const field_t hw_asrc_asrcfg[] =
{
    {
        "PREMODA",
        "Pre-Processing Configuration for Conversion Pair A  These bits will be"
        " read/write by user if ASRCTR:ATSA=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSA=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair C ).",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODA",
        "Post-Processing Configuration for Conversion Pair A  These bits will b"
        "e read/write by user if ASRCTR:ATSA=0, and can also be automatically u"
        "pdated by the ASRC internal logic if ASRCTR:ATSA=1 (see ASRC Misc Cont"
        "rol Register 1 for Pair C ).",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREMODB",
        "Pre-Processing Configuration for Conversion Pair B  These bits will be"
        " read/write by user if ASRCTR:ATSB=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSB=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair C ).",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODB",
        "Post-Processing Configuration for Conversion Pair B  These bits will b"
        "e read/write by user if ASRCTR:ATSB=0, and can also be automatically u"
        "pdated by the ASRC internal logic if ASRCTR:ATSB=1 (see ASRC Misc Cont"
        "rol Register 1 for Pair C ).",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREMODC",
        "Pre-Processing Configuration for Conversion Pair C  These bits will be"
        " read/write by user if ASRCTR:ATSC=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSC=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair C ).",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODC",
        "Post-Processing Configuration for Conversion Pair C  These bits will b"
        "e read/write by user if ASRCTR:ATSC=0, and can also be automatically u"
        "pdated by the ASRC internal logic if ASRCTR:ATSC=1 (see ASRC Misc Cont"
        "rol Register 1 for Pair C ).",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRA",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir A",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRB",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir B",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRC",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir C",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INIRQA",
        "Initialization for Conversion Pair A is served  When this bit is 1, it"
        " means the initialization for conversion pair A is served.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INIRQB",
        "Initialization for Conversion Pair B is served  When this bit is 1, it"
        " means the initialization for conversion pair B is served.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INIRQC",
        "Initialization for Conversion Pair C is served  When this bit is 1, it"
        " means the initialization for conversion pair C is served.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCSR.
static const field_t hw_asrc_asrcsr[] =
{
    {
        "AICSA",
        "Input Clock Source A",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICSB",
        "Input Clock Source B",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICSC",
        "Input Clock Source C",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSA",
        "Output Clock Source A",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSB",
        "Output Clock Source B",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSC",
        "Output Clock Source C",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCDR1.
static const field_t hw_asrc_asrcdr1[] =
{
    {
        "AICPA",
        "Input Clock Prescaler A  Specify the prescaling factor of the input pr"
        "escaler A.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDA",
        "Input Clock Divider A  Specify the divide ratio of the input clock div"
        "ider A.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICPB",
        "Input Clock Prescaler B  Specify the prescaling factor of the input pr"
        "escaler B.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDB",
        "Input Clock Divider B  Specify the divide ratio of the input clock div"
        "ider B.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPA",
        "Output Clock Prescaler A  Specify the prescaling factor of the output "
        "prescaler A.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDA",
        "Output Clock Divider A  Specify the divide ratio of the output clock d"
        "ivider A.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPB",
        "Output Clock Prescaler B  Specify the prescaling factor of the output "
        "prescaler B.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDB",
        "Output Clock Divider B  Specify the divide ratio of the output clock d"
        "ivider B.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCDR2.
static const field_t hw_asrc_asrcdr2[] =
{
    {
        "AICPC",
        "Input Clock Prescaler C  Specify the prescaling factor of the input pr"
        "escaler C.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDC",
        "Input Clock Divider C  Specify the divide ratio of the input clock div"
        "ider C.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPC",
        "Output Clock Prescaler C  Specify the prescaling factor of the output "
        "prescaler C.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDC",
        "Output Clock Divider C  Specify the divide ratio of the output clock d"
        "ivider C.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRSTR.
static const field_t hw_asrc_asrstr[] =
{
    {
        "AIDEA",
        "Number of data in Input Data Buffer A is less than threshold  When set"
        ", this bit indicates that number of data still available in ASRDIRA is"
        " less than threshold and the processor can write data to ASRDIRA.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDEB",
        "Number of data in Input Data Buffer B is less than threshold  When set"
        ", this bit indicates that number of data still available in ASRDIRB is"
        " less than threshold and the processor can write data to ASRDIRB.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDEC",
        "Number of data in Input Data Buffer C is less than threshold  When set"
        ", this bit indicates that number of data still available in ASRDIRC is"
        " less than threshold and the processor can write data to ASRDIRC.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFA",
        "Number of data in Output Data Buffer A is greater than threshold  When"
        " set, this bit indicates that number of data already existing in ASRDO"
        "RA is greater than threshold and the processor can read data from ASRD"
        "ORA.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFB",
        "Number of data in Output Data Buffer B is greater than threshold  When"
        " set, this bit indicates that number of data already existing in ASRDO"
        "RB is greater than threshold and the processor can read data from ASRD"
        "ORB.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFC",
        "Number of data in Output Data Buffer C is greater than threshold  When"
        " set, this bit indicates that number of data already existing in ASRDO"
        "RC is greater than threshold and the processor can read data from ASRD"
        "ORC.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOLE",
        "Overload Error Flag  When set, this bit indicates that the task rate i"
        "s too high for the ASRC to handle.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FPWT",
        "FP is in wait states  This bit is for debug only.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUA",
        "Input Data Buffer A has underflowed  When set, this bit indicates that"
        " input data buffer A has underflowed.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUB",
        "Input Data Buffer B has underflowed  When set, this bit indicates that"
        " input data buffer B has underflowed.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUC",
        "Input Data Buffer C has underflowed  When set, this bit indicates that"
        " input data buffer C has underflowed.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOA",
        "Output Data Buffer A has overflowed  When set, this bit indicates that"
        " output data buffer A has overflowed.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOB",
        "Output Data Buffer B has overflowed  When set, this bit indicates that"
        " output data buffer B has overflowed.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOC",
        "Output Data Buffer C has overflowed  When set, this bit indicates that"
        " output data buffer C has overflowed.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLA",
        "Pair A Input Task Overload  When set, this bit indicates that pair A i"
        "nput task is oveloaded.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLB",
        "Pair B Input Task Overload  When set, this bit indicates that pair B i"
        "nput task is oveloaded.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLC",
        "Pair C Input Task Overload  When set, this bit indicates that pair C i"
        "nput task is oveloaded.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLA",
        "Pair A Output Task Overload  When set, this bit indicates that pair A "
        "output task is oveloaded.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLB",
        "Pair B Output Task Overload  When set, this bit indicates that pair B "
        "output task is oveloaded.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLC",
        "Pair C Output Task Overload  When set, this bit indicates that pair C "
        "output task is oveloaded.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ATQOL",
        "Task Queue FIFO overload  When set, this bit indicates that task queue"
        " FIFO logic is oveloaded.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSLCNT",
        "DSL Counter Input to FIFO ready  When set, this bit indicates that new"
        " DSL counter information is stored in the internal ASRC FIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMN1.
static const field_t hw_asrc_asrpmn1[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMN2.
static const field_t hw_asrc_asrpmn2[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMN3.
static const field_t hw_asrc_asrpmn3[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMN4.
static const field_t hw_asrc_asrpmn4[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMN5.
static const field_t hw_asrc_asrpmn5[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRTFR1.
static const field_t hw_asrc_asrtfr1[] =
{
    {
        "TF_BASE",
        "Base address for task queue FIFO.",
        6, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF_FILL",
        "Current number of entries in task queue FIFO.",
        13, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCCR.
static const field_t hw_asrc_asrccr[] =
{
    {
        "ACIA",
        "The channel counter for Pair A's input FIFO  These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "A's input FIFO's usage.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACIB",
        "The channel counter for Pair B's input FIFO  These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "B's input FIFO's usage.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACIC",
        "The channel counter for Pair C's input FIFO  These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "C's input FIFO's usage.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOA",
        "The channel counter for Pair A's output FIFO  These bits stand for the"
        " current channel being accessed through shared peripheral bus for Pair"
        " A's output FIFO's usage.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOB",
        "The channel counter for Pair B's output FIFO  These bits stand for the"
        " current channel being accessed through shared peripheral bus for Pair"
        " B's output FIFO's usage.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOC",
        "The channel counter for Pair C's output FIFO  These bits stand for the"
        " current channel being accessed through shared peripheral bus for Pair"
        " C's output FIFO's usage.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIA.
static const field_t hw_asrc_asrdia[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOA.
static const field_t hw_asrc_asrdoa[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIB.
static const field_t hw_asrc_asrdib[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOB.
static const field_t hw_asrc_asrdob[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIC.
static const field_t hw_asrc_asrdic[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOC.
static const field_t hw_asrc_asrdoc[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHA.
static const field_t hw_asrc_asridrha[] =
{
    {
        "IDRATIOA",
        "IDRATIOA[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLA.
static const field_t hw_asrc_asridrla[] =
{
    {
        "IDRATIOA",
        "IDRATIOA[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHB.
static const field_t hw_asrc_asridrhb[] =
{
    {
        "IDRATIOB",
        "IDRATIOB[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLB.
static const field_t hw_asrc_asridrlb[] =
{
    {
        "IDRATIOB",
        "IDRATIOB[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHC.
static const field_t hw_asrc_asridrhc[] =
{
    {
        "IDRATIOC",
        "IDRATIOC[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLC.
static const field_t hw_asrc_asridrlc[] =
{
    {
        "IDRATIOC",
        "IDRATIOC[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASR76K.
static const field_t hw_asrc_asr76k[] =
{
    {
        "ASR76K",
        "Value for the period of the 76kHz sampling clock.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASR56K.
static const field_t hw_asrc_asr56k[] =
{
    {
        "ASR56K",
        "Value for the period of the 56kHz sampling clock",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRA.
static const field_t hw_asrc_asrmcra[] =
{
    {
        "INFIFO_THRESHOLDA",
        "The threshold for Pair A's input FIFO per channel  These bits stand fo"
        "r the threshold for Pair A's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFA",
        "Re-sync Output FIFO Channel Counter  If bit set, force ASRCCR:ACOA=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFA",
        "Re-sync Input FIFO Channel Counter  If bit set, force ASRCCR:ACIA=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDA",
        "The threshold for Pair A's output FIFO per channel  These bits stand f"
        "or the threshold for Pair A's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYA",
        "Bypass Polyphase Filtering for Pair A  This bit will determine whether"
        " the polyphase filtering part of Pair A conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLA",
        "Stall Pair A conversion in case of Buffer Near Empty/Full Condition  T"
        "his bit will determine whether the near empty/full FIFO condition will"
        " stall the rate conversion for pair A.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHA",
        "Use external thresholds for FIFO control of Pair A  This bit will dete"
        "rmine whether the FIFO thresholds externally defined in this register "
        "is used to control ASRC internal FIFO logic for pair A.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFA",
        "Initialize buf of Pair A when pair A is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTA.
static const field_t hw_asrc_asrfsta[] =
{
    {
        "INFIFO_FILLA",
        "The fillings for Pair A's input FIFO per channel  These bits stand for"
        " the fillings for Pair A's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEA",
        "Input FIFO is near Empty for Pair A  This bit is to indicate whether t"
        "he input FIFO of Pair A is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLA",
        "The fillings for Pair A's output FIFO per channel  These bits stand fo"
        "r the fillings for Pair A's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFA",
        "Output FIFO is near Full for Pair A  This bit is to indicate whether t"
        "he output FIFO of Pair A is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRB.
static const field_t hw_asrc_asrmcrb[] =
{
    {
        "INFIFO_THRESHOLDB",
        "The threshold for Pair B's input FIFO per channel  These bits stand fo"
        "r the threshold for Pair B's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFB",
        "Re-sync Output FIFO Channel Counter  If bit set, force ASRCCR:ACOB=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFB",
        "Re-sync Input FIFO Channel Counter  If bit set, force ASRCCR:ACIB=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDB",
        "The threshold for Pair B's output FIFO per channel  These bits stand f"
        "or the threshold for Pair B's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYB",
        "Bypass Polyphase Filtering for Pair B  This bit will determine whether"
        " the polyphase filtering part of Pair B conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLB",
        "Stall Pair B conversion in case of Buffer Near Empty/Full Condition  T"
        "his bit will determine whether the near empty/full FIFO condition will"
        " stall the rate conversion for pair B.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHB",
        "Use external thresholds for FIFO control of Pair B  This bit will dete"
        "rmine whether the FIFO thresholds externally defined in this register "
        "is used to control ASRC internal FIFO logic for pair B.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFB",
        "Initialize buf of Pair B when pair B is enabled  This bit is used to c"
        "ontrol whether the buffer is to be zeroized when pair B is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTB.
static const field_t hw_asrc_asrfstb[] =
{
    {
        "INFIFO_FILLB",
        "The fillings for Pair B's input FIFO per channel  These bits stand for"
        " the fillings for Pair B's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEB",
        "Input FIFO is near Empty for Pair B  This bit is to indicate whether t"
        "he input FIFO of Pair B is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLB",
        "The fillings for Pair B's output FIFO per channel  These bits stand fo"
        "r the fillings for Pair B's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFB",
        "Output FIFO is near Full for Pair B  This bit is to indicate whether t"
        "he output FIFO of Pair B is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRC.
static const field_t hw_asrc_asrmcrc[] =
{
    {
        "INFIFO_THRESHOLDC",
        "The threshold for Pair C's input FIFO per channel  These bits stand fo"
        "r the threshold for Pair C's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFC",
        "Re-sync Output FIFO Channel Counter  If bit set, force ASRCCR:ACOC=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFC",
        "Re-sync Input FIFO Channel Counter  If bit set, force ASRCCR:ACIC=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDC",
        "The threshold for Pair C's output FIFO per channel  These bits stand f"
        "or the threshold for Pair C's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYC",
        "Bypass Polyphase Filtering for Pair C  This bit will determine whether"
        " the polyphase filtering part of Pair C conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLC",
        "Stall Pair C conversion in case of Buffer Near Empty/Full Condition  T"
        "his bit will determine whether the near empty/full FIFO condition will"
        " stall the rate conversion for pair C.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHC",
        "Use external thresholds for FIFO control of Pair C  This bit will dete"
        "rmine whether the FIFO thresholds externally defined in this register "
        "is used to control ASRC internal FIFO logic for pair C.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFC",
        "Initialize buf of Pair C when pair C is enabled  This bit is used to c"
        "ontrol whether the buffer is to be zeroized when pair C is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTC.
static const field_t hw_asrc_asrfstc[] =
{
    {
        "INFIFO_FILLC",
        "The fillings for Pair C's input FIFO per channel  These bits stand for"
        " the fillings for Pair C's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEC",
        "Input FIFO is near Empty for Pair C  This bit is to indicate whether t"
        "he input FIFO of Pair C is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLC",
        "The fillings for Pair C's output FIFO per channel  These bits stand fo"
        "r the fillings for Pair C's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFC",
        "Output FIFO is near Full for Pair C  This bit is to indicate whether t"
        "he output FIFO of Pair C is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1A.
static const field_t hw_asrc_asrmcr1a[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO  This bit will determine the bit w"
        "idth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO  This bit will determine the "
        "sign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO  This bit will determine the data al"
        "ignment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO  This bit will determine the data ali"
        "gnment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO  These three bits will determine the bitw"
        "idth for the audio data into ASRC  All other settings not shown are re"
        "served.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1B.
static const field_t hw_asrc_asrmcr1b[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO  This bit will determine the bit w"
        "idth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO  This bit will determine the "
        "sign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO  This bit will determine the data al"
        "ignment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO  This bit will determine the data ali"
        "gnment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO  These three bits will determine the bitw"
        "idth for the audio data into ASRC  All other settings not shown are re"
        "served.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1C.
static const field_t hw_asrc_asrmcr1c[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO  This bit will determine the bit w"
        "idth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO  This bit will determine the "
        "sign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO  This bit will determine the data al"
        "ignment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO  This bit will determine the data ali"
        "gnment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO  These three bits will determine the bitw"
        "idth for the audio data into ASRC  All other settings not shown are re"
        "served.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a ASRC module.
static const reg_t hw_asrc[] =
{
    {
        "ASRCTR",
        "The ASRC control register (ASRCTR) is a 24-bit read/write register tha"
        "t controls the ASRC operations.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_asrc_asrctr
    },
    {
        "ASRIER",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_asrc_asrier
    },
    {
        "ASRCNCR",
        "The ASRC channel number configuration register (ASRCNCR) is a 24-bit r"
        "ead/write register that sets the number of channels used by each ASRC "
        "conversion pair.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_asrc_asrcncr
    },
    {
        "ASRCFG",
        "The ASRC configuration status register (ASRCFG) is a 24-bit read/write"
        " register that sets and/or automatically senses the ASRC operations.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_asrc_asrcfg
    },
    {
        "ASRCSR",
        "The ASRC clock source register (ASRCSR) is a 24-bit read/write registe"
        "r that controls the sources of the input and output clocks of the ASRC"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_asrc_asrcsr
    },
    {
        "ASRCDR1",
        "The ASRC clock divider register (ASRCDR1) is a two 24-bit read/write r"
        "egister that controls the division factors of the ASRC input and outpu"
        "t clock sources.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_asrc_asrcdr1
    },
    {
        "ASRCDR2",
        "The ASRC clock divider register (ASRCDR2) is a two 24-bit read/write r"
        "egister that controls the division factors of the ASRC input and outpu"
        "t clock sources.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_asrc_asrcdr2
    },
    {
        "ASRSTR",
        "The ASRC status register (ASRSTR) is a 24-bit read-write register used"
        " by the processor core to examine the status of the ASRC block and cle"
        "ar the overload interrupt request and AOLE flag bit.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        23, // Number of bitfields
        hw_asrc_asrstr
    },
    {
        "ASRPMN1",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrpmn1
    },
    {
        "ASRPMN2",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrpmn2
    },
    {
        "ASRPMN3",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrpmn3
    },
    {
        "ASRPMN4",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrpmn4
    },
    {
        "ASRPMN5",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrpmn5
    },
    {
        "ASRTFR1",
        "The register defines and shows the parameters for ASRC inner task queu"
        "e FIFOs.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_asrc_asrtfr1
    },
    {
        "ASRCCR",
        "The ASRC channel counter register (ASRCCR) is a 24-bit read/write regi"
        "ster that sets and reflects the current specific input/output FIFO bei"
        "ng accessed through shared peripheral bus for each ASRC conversion pai"
        "r.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_asrc_asrccr
    },
    {
        "ASRDIA",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000060, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrdia
    },
    {
        "ASRDOA",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_asrc_asrdoa
    },
    {
        "ASRDIB",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000068, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrdib
    },
    {
        "ASRDOB",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_asrc_asrdob
    },
    {
        "ASRDIC",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000070, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrdic
    },
    {
        "ASRDOC",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_asrc_asrdoc
    },
    {
        "ASRIDRHA",
        "The ideal ratio registers (ASRIDRHA, ASRIDRLA) hold the ratio value ID"
        "RATIOA.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asridrha
    },
    {
        "ASRIDRLA",
        "The ideal ratio registers (ASRIDRHA, ASRIDRLA) hold the ratio value ID"
        "RATIOA.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asridrla
    },
    {
        "ASRIDRHB",
        "The ideal ratio registers (ASRIDRHB, ASRIDRLB) hold the ratio value ID"
        "RATIOB.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asridrhb
    },
    {
        "ASRIDRLB",
        "The ideal ratio registers (ASRIDRHB, ASRIDRLB) hold the ratio value ID"
        "RATIOB.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asridrlb
    },
    {
        "ASRIDRHC",
        "The ideal ratio registers (ASRIDRHC, ASRIDRLC) hold the ratio value ID"
        "RATIOC.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asridrhc
    },
    {
        "ASRIDRLC",
        "The ideal ratio registers (ASRIDRHC, ASRIDRLC) hold the ratio value ID"
        "RATIOC.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asridrlc
    },
    {
        "ASR76K",
        "The register (ASR76K) holds the period of the 76kHz sampling clock in "
        "terms of the ASRC processing clock with frequency Fs ASRC .",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asr76k
    },
    {
        "ASR56K",
        "The register (ASR56K) holds the period of the 56kHz sampling clock in "
        "terms of the ASRC processing clock with frequency Fs ASRC .",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asr56k
    },
    {
        "ASRMCRA",
        "The register (ASRMCRA) is used to control Pair A internal logic.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_asrc_asrmcra
    },
    {
        "ASRFSTA",
        "The register (ASRFSTA) is used to show Pair A internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_asrc_asrfsta
    },
    {
        "ASRMCRB",
        "The register (ASRMCRB) is used to control Pair B internal logic.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_asrc_asrmcrb
    },
    {
        "ASRFSTB",
        "The register (ASRFSTB) is used to show Pair B internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_asrc_asrfstb
    },
    {
        "ASRMCRC",
        "The register (ASRMCRC) is used to control Pair C internal logic.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_asrc_asrmcrc
    },
    {
        "ASRFSTC",
        "The register (ASRFSTC) is used to show Pair C internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_asrc_asrfstc
    },
    {
        "ASRMCR1A",
        "The register (ASRMCR1A) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_asrc_asrmcr1a
    },
    {
        "ASRMCR1B",
        "The register (ASRMCR1A) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_asrc_asrmcr1b
    },
    {
        "ASRMCR1C",
        "The register (ASRMCR1A) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_asrc_asrmcr1c
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark AUDMUX
#endif

// Bitfields in register AUDMUX_PTCR1.
static const field_t hw_audmux_ptcr1[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR1.
static const field_t hw_audmux_pdcr1[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR2.
static const field_t hw_audmux_ptcr2[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR2.
static const field_t hw_audmux_pdcr2[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR3.
static const field_t hw_audmux_ptcr3[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR3.
static const field_t hw_audmux_pdcr3[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR4.
static const field_t hw_audmux_ptcr4[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR4.
static const field_t hw_audmux_pdcr4[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR5.
static const field_t hw_audmux_ptcr5[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR5.
static const field_t hw_audmux_pdcr5[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR6.
static const field_t hw_audmux_ptcr6[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR6.
static const field_t hw_audmux_pdcr6[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR7.
static const field_t hw_audmux_ptcr7[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR7.
static const field_t hw_audmux_pdcr7[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a AUDMUX module.
static const reg_t hw_audmux[] =
{
    {
        "PTCR1",
        "PTCR1 is the Port Timing Control Register for Port 1.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr1
    },
    {
        "PDCR1",
        "PDCR1 is the Port Data Control Register for Port 1.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr1
    },
    {
        "PTCR2",
        "PTCR2 is the Port Timing Control Register for Port 2.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr2
    },
    {
        "PDCR2",
        "PDCR2 is the Port Data Control Register for Port 2.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr2
    },
    {
        "PTCR3",
        "PTCR3 is the Port Timing Control Register for Port 3.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr3
    },
    {
        "PDCR3",
        "PDCR3 is the Port Data Control Register for Port 3.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr3
    },
    {
        "PTCR4",
        "Port Timing Control Register for Port 4",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr4
    },
    {
        "PDCR4",
        "PDCR4 is the Port Data Control Register for Port 4.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr4
    },
    {
        "PTCR5",
        "Port Timing Control Register for Port 5",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr5
    },
    {
        "PDCR5",
        "PDCR5 is the Port Data Control Register for Port 5.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr5
    },
    {
        "PTCR6",
        "Port Timing Control Register for Port 6",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr6
    },
    {
        "PDCR6",
        "PDCR6 is the Port Data Control Register for Port 6.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr6
    },
    {
        "PTCR7",
        "Port Timing Control Register for Port 7",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr7
    },
    {
        "PDCR7",
        "PDCR7 is the Port Data Control Register for Port 7 .",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr7
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CCM
#endif

// Bitfields in register CCM_CCR.
static const field_t hw_ccm_ccr[] =
{
    {
        "OSCNT",
        "Oscillator ready counter value.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_EN",
        "On chip oscillator enable bit - this bit value is reflected on the out"
        "put cosc_en.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WB_COUNT",
        "Well Bias counter.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG_BYPASS_COUNT",
        "Counter for analog_reg_bypass signal assertion after standby voltage r"
        "equest by pmic_vstby_req.",
        21, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBC_EN",
        "Enable for REG_BYPASS_COUNTER.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCDR.
static const field_t hw_ccm_ccdr[] =
{
    {
        "MMDC_CH1_MASK",
        "During divider ratio mmdc_ch1_axi_podf change or sync mux periph2_clk_"
        "sel change (but not jtag) or SRC request during warm reset, mask hands"
        "hake with mmdc_ch1 module.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_CH0_MASK",
        "During divider ratio mmdc_ch0_axi_podf change or sync mux periph_clk_s"
        "el change (but not jtag) or SRC request during warm reset, mask handsh"
        "ake with mmdc_ch0 module.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSR.
static const field_t hw_ccm_csr[] =
{
    {
        "REF_EN_B",
        "Status of the value of ref_en_b output of ccm",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COSC_READY",
        "Status indication of on board oscillator.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCSR.
static const field_t hw_ccm_ccsr[] =
{
    {
        "PLL3_SW_CLK_SEL",
        "Selects source to generate pll3_sw_clk.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL2_SW_CLK_SEL",
        "Selects source to generate pll2_sw_clk.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL1_SW_CLK_SEL",
        "Selects source to generate pll1_sw_clk.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STEP_SEL",
        "Selects the option to be chosen for the step frequency when shifting A"
        "RM frequency.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_396M_DIS_MASK",
        "Mask of 396M PFD auto-disable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_352M_DIS_MASK",
        "Mask of 352M PFD auto-disable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_594M_DIS_MASK",
        "Mask of 594M PFD auto-disable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_508M_DIS_MASK",
        "Mask of 508M PFD auto-disable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_454M_DIS_MASK",
        "Mask of 454M PFD auto-disable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_720M_DIS_MASK",
        "Mask of 720M PFD auto-disable.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_540M_DIS_MASK",
        "Mask of 540M PFD auto-disable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CACRR.
static const field_t hw_ccm_cacrr[] =
{
    {
        "ARM_PODF",
        "Divider for ARM clock root.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CBCDR.
static const field_t hw_ccm_cbcdr[] =
{
    {
        "PERIPH2_CLK2_PODF",
        "Divider for periph2_clk2 podf.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_CH1_AXI_PODF",
        "Divider for mmdc_ch1_axi podf.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_SEL",
        "AXI clock source select",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_ALT_SEL",
        "AXI alternative clock select",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_PODF",
        "Divider for ipg podf.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_PODF",
        "Divider for ahb podf.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_PODF",
        "Divider for axi podf.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_CH0_AXI_PODF",
        "Divider for mmdc_ch0_axi podf.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK_SEL",
        "Selector for peripheral main clock (source of mmdc_ch0_axi_clk_root).",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK_SEL",
        "Selector for peripheral2 main clock (source of mmdc_ch1_axi_clk_root )"
        ".",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK2_PODF",
        "Divider for periph2 clock podf.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CBCMR.
static const field_t hw_ccm_cbcmr[] =
{
    {
        "GPU2D_AXI_CLK_SEL",
        "Selector for gpu2d_axi clock multiplexer",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU3D_AXI_CLK_SEL",
        "Selector for gpu3d_axi clock multiplexer",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU3D_CORE_CLK_SEL",
        "Selector for gpu3d_core clock multiplexer",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU3D_SHADER_CLK_SEL",
        "Selector for gpu3d_shader clock multiplexer",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_AXI_CLK_SEL",
        "Selector for pcie_axi clock multiplexer",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDOAXI_CLK_SEL",
        "Selector for vdoaxi clock multiplexer",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK2_SEL",
        "Selector for peripheral clk2 clock multiplexer",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPU_AXI_CLK_SEL",
        "Selector for VPU axi clock multiplexer",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU2D_CLK_SEL",
        "Selector for open vg clock multiplexer",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_PERIPH_CLK_SEL",
        "Selector for pre_periph clock multiplexer",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK2_SEL",
        "Selector for periph2_clk2 clock multiplexer",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_PERIPH2_CLK_SEL",
        "Selector for pre_periph2 clock multiplexer",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU2D_CORE_CLK_PODF",
        "Divider for gpu2d_core clock.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU3D_CORE_PODF",
        "Divider for gpu3d_core clock.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU3D_SHADER_PODF",
        "Divider for gpu3d_shader clock.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCMR1.
static const field_t hw_ccm_cscmr1[] =
{
    {
        "PERCLK_PODF",
        "Divider for perclk podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI1_CLK_SEL",
        "Selector for ssi1 clock multiplexer",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI2_CLK_SEL",
        "Selector for ssi2 clock multiplexer",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_SEL",
        "Selector for ssi3 clock multiplexer",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC1_CLK_SEL",
        "Selector for usdhc1 clock multiplexer",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC2_CLK_SEL",
        "Selector for usdhc2 clock multiplexer",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC3_CLK_SEL",
        "Selector for usdhc3 clock multiplexer",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC4_CLK_SEL",
        "Selector for usdhc4 clock multiplexer",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EMI_PODF",
        "Divider for aclk_emi clock root.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EMI_SLOW_PODF",
        "Divider for aclk_emi_slow clock root.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EMI_SEL",
        "Selector for aclk_emi root clock multiplexer",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EMI_SLOW_SEL",
        "Selector for aclk_emi_slow root clock multiplexer",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCMR2.
static const field_t hw_ccm_cscmr2[] =
{
    {
        "CAN_CLK_PODF",
        "Divider for can clock podf.",
        2, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI0_IPU_DIV",
        "Control for divider of ldb clock for IPU di0",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI1_IPU_DIV",
        "Control for divider of ldb clock for IPU di1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESAI_CLK_SEL",
        "Selector for esai clock multiplexer",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR1.
static const field_t hw_ccm_cscdr1[] =
{
    {
        "UART_CLK_PODF",
        "Divider for uart clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC1_PODF",
        "Divider for usdhc1 clock podf.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC2_PODF",
        "Divider for usdhc2 clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC3_PODF",
        "Divider for usdhc3 clock podf.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC4_PODF",
        "Divider for esdhc4 clock pred.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPU_AXI_PODF",
        "Divider for vpu axi clock podf.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CS1CDR.
static const field_t hw_ccm_cs1cdr[] =
{
    {
        "SSI1_CLK_PODF",
        "Divider for ssi1 clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI1_CLK_PRED",
        "Divider for ssi1 clock pred.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESAI_CLK_PRED",
        "Divider for esai clock pred.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_PODF",
        "Divider for ssi3 clock podf.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_PRED",
        "Divider for ssi3 clock pred.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESAI_CLK_PODF",
        "Divider for esai clock podf.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CS2CDR.
static const field_t hw_ccm_cs2cdr[] =
{
    {
        "SSI2_CLK_PODF",
        "Divider for ssi2 clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI2_CLK_PRED",
        "Divider for ssi2 clock pred.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI0_CLK_SEL",
        "Selector for ldb_di1 clock multiplexer",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI1_CLK_SEL",
        "Selector for ldb_di1 clock multiplexer",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENFC_CLK_SEL",
        "Selector for enfc clock multiplexer",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENFC_CLK_PRED",
        "Divider for enfc clock pred divider.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENFC_CLK_PODF",
        "Divider for enfc clock divider.",
        21, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CDCDR.
static const field_t hw_ccm_cdcdr[] =
{
    {
        "SPDIF1_CLK_SEL",
        "Selector for spdif1 clock multiplexer",
        7, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF1_CLK_PODF",
        "Divider for spdif1 clock podf.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF1_CLK_PRED",
        "Divider for spdif1 clock pred.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_SEL",
        "Selector for spdif0 clock multiplexer",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_PODF",
        "Divider for spdif0 clock podf.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_PRED",
        "Divider for spdif0 clock pred.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSI_TX_CLK_SEL",
        "Selector for hsi_tx clock multiplexer",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSI_TX_PODF",
        "Divider for hsi_tx clock podf.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CHSCCDR.
static const field_t hw_ccm_chsccdr[] =
{
    {
        "IPU1_DI0_CLK_SEL",
        "Selector for ipu1 di0 root clock multiplexer",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_DI0_PODF",
        "Divider for ipu1_di0 clock divider.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_DI0_PRE_CLK_SEL",
        "Selector for ipu1 di0 root clock pre-multiplexer",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_DI1_CLK_SEL",
        "Selector for ipu1 di1 root clock multiplexer",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_DI1_PODF",
        "Divider for ipu1_di clock divider.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_DI1_PRE_CLK_SEL",
        "Selector for ipu1 di1 root clock pre-multiplexer",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR2.
static const field_t hw_ccm_cscdr2[] =
{
    {
        "IPU2_DI0_CLK_SEL",
        "Selector for ipu2 di0 root clock multiplexer",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_DI0_PODF",
        "Divider for ipu2_di0 clock divider.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_DI0_PRE_CLK_SEL",
        "Selector for ipu2 di0 root clock pre-multiplexer",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_DI1_CLK_SEL",
        "Selector for ipu1 di2 root clock multiplexer",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_DI1_PODF",
        "Divider for ipu2_di1 clock divider.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_DI1_PRE_CLK_SEL",
        "Selector for ipu2 di1 root clock pre-multiplexer",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECSPI_CLK_PODF",
        "Divider for ecspi clock podf.",
        19, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR3.
static const field_t hw_ccm_cscdr3[] =
{
    {
        "IPU1_HSP_CLK_SEL",
        "Selector for ipu1_hsp clock multiplexer",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_HSP_PODF",
        "Divider for ipu1_hsp clock.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_HSP_CLK_SEL",
        "Selector for ipu2_hsp clock multiplexer",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_HSP_PODF",
        "Divider for ipu2_hsp clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CWDR.
static const field_t hw_ccm_cwdr[] =
{
    { 0 } // Terminator
};

// Bitfields in register CCM_CDHIPR.
static const field_t hw_ccm_cdhipr[] =
{
    {
        "AXI_PODF_BUSY",
        "Busy indicator for axi_podf.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB_PODF_BUSY",
        "Busy indicator for ahb_podf.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MMDC_CH1_PODF_BUSY",
        "Busy indicator for mmdc_ch1_axi_podf.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH2_CLK_SEL_BUSY",
        "Busy indicator for periph2_clk_sel mux control.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MMDC_CH0_PODF_BUSY",
        "Busy indicator for mmdc_ch0_axi_podf.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH_CLK_SEL_BUSY",
        "Busy indicator for periph_clk_sel mux control.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_PODF_BUSY",
        "Busy indicator for arm_podf.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CTOR.
static const field_t hw_ccm_ctor[] =
{
    {
        "OBS_SPARE_OUTPUT_2_SEL",
        "Selection of the signal to be generated on obs_output_2 (output of CCM"
        ") for observability on the pads.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBS_SPARE_OUTPUT_1_SEL",
        "Selection of the signal to be generated on obs_output_1 (output of CCM"
        ") for observability on the pads.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBS_SPARE_OUTPUT_0_SEL",
        "Selection of the signal to be generated on obs_output_0 (output of CCM"
        ") for observability on the pads.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBS_EN",
        "observability enable bit.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CLPCR.
static const field_t hw_ccm_clpcr[] =
{
    {
        "LPM",
        "Setting the low power mode that system will enter on next assertion of"
        " dsm_request signal.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_PMIC_VFUNCTIONAL_READY",
        "By asserting this bit CCM will bypass waiting for pmic_vfunctional_rea"
        "dy signal when coming out of STOP mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_CLK_DIS_ON_LPM",
        "Define if ARM clocks (arm_clk, soc_mxclk, soc_pclk, soc_dbg_pclk, vl_w"
        "rck) will be disabled on wait mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBYOS",
        "Standby clock oscillator bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS_REF_OSC",
        "dis_ref_osc - in run mode, software can manually control closing of ex"
        "ternal reference oscillator clock, i.e.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSTBY",
        "Voltage standby request bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STBY_COUNT",
        "Standby counter definition.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_PWRDOWN",
        "In run mode, software can manually control powering down of on chip os"
        "cillator, i.e.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WB_PER_AT_LPM",
        "Enable periphery charge pump for well biasing at low power mode (stop "
        "or wait)",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_MMDC_CH0_LPM_HS",
        "Bypass handshake with mmdc_ch0 on next entrance to low power mode (wai"
        "t or stop mode).",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_MMDC_CH1_LPM_HS",
        "Bypass handshake with mmdc_ch1 on next entrance to low power mode (wai"
        "t or stop mode).",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CORE0_WFI",
        "Mask WFI of core0 for entering low power mode  Note: assertion of all "
        "bits[27:22] will generate low power mode request",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CORE1_WFI",
        "Mask WFI of core1 for entering low power mode  Note: assertion of all "
        "bits[27:22] will generate low power mode request",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CORE2_WFI",
        "Mask WFI of core2 for entering low power mode  Note: assertion of all "
        "bits[27:22] will generate low power mode request",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CORE3_WFI",
        "Mask WFI of core3 for entering low power mode  Note: assertion of all "
        "bits[27:22] will generate low power mode request",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_SCU_IDLE",
        "Mask SCU IDLE for entering low power mode  Note: assertion of all bits"
        "[27:22] will generate low power mode request",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_L2CC_IDLE",
        "Mask L2CC IDLE for entering low power mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CISR.
static const field_t hw_ccm_cisr[] =
{
    {
        "LRF_PLL",
        "Interrupt ipi_int_2 generated due to lock of all enabled and not bypas"
        "eed pll's",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_READY",
        "Interrupt ipi_int_2 generated due to on board oscillator ready, i.e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_PODF_LOADED",
        "Interrupt ipi_int_1 generated due to frequency change of axi_a_podf",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_B_PODF_LOADED",
        "Interrupt ipi_int_1 generated due to frequency change of axi_b_podf",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH2_CLK_SEL_LOADED",
        "Interrupt ipi_int_1 generated due to frequency change of periph2_clk_s"
        "el",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_PODF_LOADED",
        "Interrupt ipi_int_1 generated due to frequency change of ahb_podf",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_CH1_PODF_LOADED",
        "Interrupt ipi_int_1 generated due to frequency change of mmdc_ch0_podf"
        "_ loaded",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK_SEL_LOADED",
        "Interrupt ipi_int_1 generated due to update of periph_clk_sel.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_CH0_PODF_LOADED",
        "Interrupt ipi_int_1 generated due to update of mmdc_ch0_axi_podf.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_PODF_LOADED",
        "Interrupt ipi_int_1 generated due to frequency change of arm_podf.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CIMR.
static const field_t hw_ccm_cimr[] =
{
    {
        "MASK_LRF_PLL",
        "mask interrupt generation due to lrf of pll's",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_COSC_READY",
        "mask interrupt generation due to on board oscillator ready",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AXI_PODF_LOADED",
        "mask interrupt generation due to frequency change of axi_podf",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AXI_B_PODF_LOADED",
        "mask interrupt generation due to frequency change of axi_b_podf",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MASK_PERIPH2_CLK_SEL_LOADED",
        "mask interrupt generation due to update of periph2_clk_sel.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AHB_PODF_LOADED",
        "mask interrupt generation due to frequency change of ahb_podf",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_MMDC_CH1_PODF_LOADED",
        "mask interrupt generation due to update of mask_mmdc_ch1_podf",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PERIPH_CLK_SEL_LOADED",
        "mask interrupt generation due to update of periph_clk_sel.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_MMDC_CH0_PODF_LOADED",
        "mask interrupt generation due to update of mask_mmdc_ch0_podf",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_PODF_LOADED",
        "mask interrupt generation due to frequency change of arm_podf",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCOSR.
static const field_t hw_ccm_ccosr[] =
{
    {
        "CLKO1_SEL",
        "Selection of the clock to be generated on clko1",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_DIV",
        "Setting the divider of CLKO1",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_EN",
        "Enable of CLKO1 clock",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_CLKO2_SEL",
        "CLKO1 output to reflect clko1 or clko2 clocks",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_SEL",
        "Selection of the clock to be generated on clko2",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_DIV",
        "Setting the divider of CLKO2",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_EN",
        "Enable of CLKO2 clock",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CGPR.
static const field_t hw_ccm_cgpr[] =
{
    {
        "PMIC_DELAY_SCALER",
        "Defines clock dividion of clock for stby_count (pmic delay counter)",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_EXT_CLK_DIS",
        "Disable external clock driver of MMDC during STOP mode",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EFUSE_PROG_SUPPLY_GATE",
        "Defines the value of the output signal cgpr_dout[4].",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPL",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR0.
static const field_t hw_ccm_ccgr0[] =
{
    {
        "CG0",
        "aips_tz1 clocks (aips_tz1_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "aips_tz2 clocks (aips_tz2_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "apbhdma hclk clock (apbhdma_hclk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "asrc clock (asrc_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "caam_secure_mem clock (caam_secure_mem_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "caam_wrapper_aclk clock (caam_wrapper_aclk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "caam_wrapper_ipg clock (caam_wrapper_ipg_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "can1 clock (can1_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "can1_serial clock (can1_serial_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "can2 clock (can2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "can2_serial clock (can2_serial_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "CPU debug clocks (cheetah_dbg_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "dcic 1 clocks (dcic1_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "dcic2 clocks (dcic2_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "dtcp clocks (dtcp_dtcp_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "Reserved",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR1.
static const field_t hw_ccm_ccgr1[] =
{
    {
        "CG0",
        "ecspi1 clocks (ecspi1_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "ecspi2 clocks (ecspi2_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "ecspi3 clocks (ecspi3_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "ecspi4 clocks (ecspi4_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "ecspi5 clocks (ecspi5_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "clock (enet_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "epit1 clocks (epit1_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "epit2 clocks (epit2_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "esai clocks (esai_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "Reserved",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "gpt bus clock (gpt_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "gpt serial clock (gpt_serial_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "gpu2d clock (gpu2d_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "gpu3d clock (gpu3d_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "Reserved",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "Reserved",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR2.
static const field_t hw_ccm_ccgr2[] =
{
    {
        "CG0",
        "hdmi_tx_iahbclk, hdmi_tx_ihclk clock (hdmi_tx_iahbclk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "hdmi_tx_isfrclk clock (hdmi_tx_isfrclk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "i2c1_serial clock (i2c1_serial_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "i2c2_serial clock (i2c2_serial_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "i2c3_serial clock (i2c3_serial_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "OCOTP_CTRL clock (iim_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "iomux_ipt_clk_io clock (iomux_ipt_clk_io_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "ipmux1 clock (ipmux1_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "ipmux2 clock (ipmux2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "ipmux3 clock (ipmux3_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "ipsync_ip2apb_tzasc1_ipg clocks (ipsync_ip2apb_tzasc1_ipg_master_clk_e"
        "nable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "ipsync_vdoa_ipg clocks (ipsync_ip2apb_tzasc2_ipg clocks)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "ipsync_vdoa_ipg clocks (ipsync_vdoa_ipg_master_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "Reserved",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "Reserved",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR3.
static const field_t hw_ccm_ccgr3[] =
{
    {
        "CG0",
        "ipu1_ipu clock (ipu1_ipu_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "ipu1_ipu_di0 clock (ipu1_ipu_di0_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "ipu1_ipu_di1 clock (ipu1_ipu_di1_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "ipu2_ipu clock (ipu2_ipu_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "ipu2_ipu_di0 clock (ipu2_ipu_di0_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "ipu2_ipu_di1 clock (ipu2_ipu_di1_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "ldb_di0 clock (ldb_di0_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "ldb_di1 clock (ldb_di1_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "mipi_core_cfg clock (mipi_core_cfg_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "mlb clock (mlb_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "mmdc_core_aclk_fast_core_p0 clock (mmdc_core_aclk_fast_core_p0_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "mmdc_core_aclk_fast_core_p1 clock (mmdc_core_aclk_fast_core_p1_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "mmdc_core_ipg_clk_p0 clock (mmdc_core_ipg_clk_p0_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "mmdc_core_ipg_clk_p1 clock (mmdc_core_ipg_clk_p1_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "ocram clock (ocram_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "openvgaxiclk clock (openvgaxiclk_clk_root_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR4.
static const field_t hw_ccm_ccgr4[] =
{
    {
        "CG0",
        "125M clocks (125M_root_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "Reserved.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "Reserved.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "pl301_mx6qfast1_s133 clock (pl301_mx6qfast1_s133clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "Reserved",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "pl301_mx6qper1_bch clocks (pl301_mx6qper1_bchclk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "pl301_mx6qper2_mainclk_enable (pl301_mx6qper2_mainclk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "pwm1 clocks (pwm1_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "pwm2 clocks (pwm2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "pwm3 clocks (pwm3_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "pwm4 clocks (pwm4_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "rawnand_u_bch_input_apb clock (rawnand_u_bch_input_apb_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "rawnand_u_gpmi_bch_input_bch clock (rawnand_u_gpmi_bch_input_bch_clk_e"
        "nable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "rawnand_u_gpmi_bch_input_gpmi_io clock (rawnand_u_gpmi_bch_input_gpmi_"
        "io_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "rawnand_u_gpmi_input_apb clock rawnand_u_gpmi_input_apb_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR5.
static const field_t hw_ccm_ccgr5[] =
{
    {
        "CG0",
        "rom clock (rom_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "100M clock (100M_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "sdma clock (sdma_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "Reserved",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "Reserved",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "spba clock (spba_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "spdif clock (spdif_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "Reserved",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "ssi1 clocks (ssi1_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "ssi2 clocks (ssi2_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "ssi3 clocks (ssi3_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "uart clock (uart_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "uart_serial clock (uart_serial_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "Reserved",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "Reserved",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR6.
static const field_t hw_ccm_ccgr6[] =
{
    {
        "CG0",
        "usboh3 clock (usboh3_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "usdhc1 clocks (usdhc1_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "usdhc2 clocks (usdhc2_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "usdhc3 clocks (usdhc3_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "usdhc4 clocks (usdhc4_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "emi_slow clocks (emi_slow_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "vdoaxiclk root clock (vdoaxiclk_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "vpu clocks (vpu_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "Reserved",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "Reserved",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "Reserved",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "Reserved",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "Reserved",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "Reserved",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "Reserved",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "Reserved",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CMEOR.
static const field_t hw_ccm_cmeor[] =
{
    {
        "MOD_EN_OV_VDOA",
        "overide clock enable signal from vdoa - clock will not be gated based "
        "on vdoa signal.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_GPT",
        "overide clock enable signal from gpt - clock will not be gated based o"
        "n gpt's signal 'ipg_enable_clk' .",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_EPIT",
        "overide clock enable signal from epit - clock will not be gated based "
        "on epit's signal 'ipg_enable_clk' .",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_USDHC",
        "overide clock enable signal from usdhc.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_DAP",
        "overide clock enable signal from dap- clock will not be gated based on"
        " dap's signal 'dap_dbgen' .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_VPU",
        "overide clock enable signal from vpu- clock will not be gated based on"
        " vpu's signal 'vpu_idle' .",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_GPU2D",
        "overide clock enable signal from gpu2d - clock will not be gated based"
        " on gpu2d's signal 'gpu2d_busy' .",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_GPU3D",
        "overide clock enable signal from gpu3d - clock will not be gated based"
        " on gpu3d's signal.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_CAN2_CPI",
        "overide clock enable signal from can2 - clock will not be gated based "
        "on can's signal 'enable_clk_cpi'.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_CAN1_CPI",
        "overide clock enable signal from can1 - clock will not be gated based "
        "on can's signal 'enable_clk_cpi'.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CCM module.
static const reg_t hw_ccm[] =
{
    {
        "CCR",
        "The figure below represents the CCM Control Register (CCR), which cont"
        "ains bits to control general operation of CCM.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ccm_ccr
    },
    {
        "CCDR",
        "The figure below represents the CCM Control Divider Register (CCDR), w"
        "hich contains bits that control the loading of the dividers that need "
        "handshake with the modules they affect.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ccm_ccdr
    },
    {
        "CSR",
        "The figure below represents the CCM status Register (CSR).",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_ccm_csr
    },
    {
        "CCSR",
        "The figure below represents the CCM Clock Switcher register (CCSR).",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_ccsr
    },
    {
        "CACRR",
        "The figure below represents the CCM Arm Clock Root register (CACRR).",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_cacrr
    },
    {
        "CBCDR",
        "The figure below represents the CCM Bus Clock Divider Register (CBCDR)"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_cbcdr
    },
    {
        "CBCMR",
        "The figure below represents the CCM Bus Clock Multiplexer Register (CB"
        "CMR).",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_ccm_cbcmr
    },
    {
        "CSCMR1",
        "The figure below represents the CCM Serial Clock Multiplexer Register "
        "1 (CSCMR1).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_cscmr1
    },
    {
        "CSCMR2",
        "The figure below represents the CCM Serial Clock Multiplexer Register "
        "2 (CSCMR2).",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_cscmr2
    },
    {
        "CSCDR1",
        "The figure below represents the CCM Serial Clock Divider Register 1 (C"
        "SCDR1).",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cscdr1
    },
    {
        "CS1CDR",
        "The figure below represents the CCM SSI1, SSI3, ESAI Clock Divider Reg"
        "ister (CS1CDR).",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cs1cdr
    },
    {
        "CS2CDR",
        "The figure below represents the CCM SSI2, LDB Clock Divider Register ("
        "CS2CDR).",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_cs2cdr
    },
    {
        "CDCDR",
        "The figure below represents the CCM DI Clock Divider Register (CDCDR).",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_cdcdr
    },
    {
        "CHSCCDR",
        "The figure below represents the CCM IPU1 DI Clock Divider Register (CH"
        "SCCDR).",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_chsccdr
    },
    {
        "CSCDR2",
        "The figure below represents the CCM Serial Clock Divider Register 2(CS"
        "CDR2).",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_cscdr2
    },
    {
        "CSCDR3",
        "The figure below represents the CCM Serial Clock Divider Register 3(CS"
        "CDR3).",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_cscdr3
    },
    {
        "CWDR",
        "The figure below represents the CCM Wakeup Detector Register (CWDR).",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_ccm_cwdr
    },
    {
        "CDHIPR",
        "The figure below represents the CCM Divider Handshake In-Process Regis"
        "ter (CDHIPR).",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_ccm_cdhipr
    },
    {
        "CTOR",
        "The figure below represents the CCM Testing Observability Register (CT"
        "OR).",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_ctor
    },
    {
        "CLPCR",
        "The figure below represents the CCM Low Power Control Register (CLPCR)"
        ".",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_clpcr
    },
    {
        "CISR",
        "The figure below represents the CCM Interrupt Status Register (CISR).",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cisr
    },
    {
        "CIMR",
        "The figure below represents the CCM Interrupt Mask Register (CIMR).",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cimr
    },
    {
        "CCOSR",
        "The figure below represents the CCM Clock Output Source Register (CCOS"
        "R).",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_ccosr
    },
    {
        "CGPR",
        "Fast PLL enable.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_cgpr
    },
    {
        "CCGR0",
        "CG(i) bits CCGR 0-7  These bits are used to turn on/off the clock to e"
        "ach module independently.The following table details the possible cloc"
        "k activity conditions for each module         CGR value    Clock Activ"
        "ity Description        00    clock is off during all modes.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr0
    },
    {
        "CCGR1",
        "The figure below represents the CCM Clock Gating Register 1(CCM_CCGR1)"
        ".",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr1
    },
    {
        "CCGR2",
        "The figure below represents the CCM Clock Gating Register 2 (CCM_CCGR2"
        ").",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr2
    },
    {
        "CCGR3",
        "The figure below represents the CCM Clock Gating Register 3 (CCM_CCGR3"
        ").",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr3
    },
    {
        "CCGR4",
        "The figure below represents the CCM Clock Gating Register 4 (CCM_CCGR4"
        ").",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr4
    },
    {
        "CCGR5",
        "The figure below represents the CCM Clock Gating Register 5 (CCM_CCGR5"
        ").",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr5
    },
    {
        "CCGR6",
        "The figure below represents the CCM Clock Gating Register 6 (CCM_CCGR6"
        ").",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr6
    },
    {
        "CMEOR",
        "The follow figure represents the CCM Module Enable Override Register ("
        "CMEOR).",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cmeor
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CCM_ANALOG
#endif

// Bitfields in register CCM_ANALOG_PLL_ARM.
static const field_t hw_ccm_analog_pll_arm[] =
{
    {
        "DIV_SELECT",
        "This field controls the pll loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        "Reserved by Freescale.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        "Reserved by Freescale.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        "Reserved by Freescale.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        "Reserved by Freescale.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        "Analog debug bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the pll.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_SEL",
        "Analog Debug Bit",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_24MHZ_SEL",
        "Analog Debug Bit",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_USB1.
static const field_t hw_ccm_analog_pll_usb1[] =
{
    {
        "DIV_SELECT",
        "This field controls the pll loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the pll.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_USB2.
static const field_t hw_ccm_analog_pll_usb2[] =
{
    {
        "DIV_SELECT",
        "This field controls the pll loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the pll.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_SYS.
static const field_t hw_ccm_analog_pll_sys[] =
{
    {
        "DIV_SELECT",
        "This field controls the pll loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        "Reserved by Freescale",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        "Reserved by Freescale",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        "Reserved by Freescale",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        "Reserved by Freescale",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        "Analog Debug bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the pll.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_SYS_SS.
static const field_t hw_ccm_analog_pll_sys_ss[] =
{
    {
        "STEP",
        "frequency change step = step/B*24MHz.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "This bit enables the spread spectrum modulation.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP",
        "Frequency change = stop/B*24MHz.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_SYS_NUM.
static const field_t hw_ccm_analog_pll_sys_num[] =
{
    {
        "A",
        "30 bit numerator (A) of fractional loop divider (signed integer).",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_SYS_DENOM.
static const field_t hw_ccm_analog_pll_sys_denom[] =
{
    {
        "B",
        "30 bit Denominator (B) of fractional loop divider (unsigned integer).",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_AUDIO.
static const field_t hw_ccm_analog_pll_audio[] =
{
    {
        "DIV_SELECT",
        "This field controls the pll loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        "Reserved by Freescale.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        "Reserved by Freescale.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        "Reserved by Freescale.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        "Reserved by Freescale.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        "Analog debug Bit",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the pll.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSC_EN",
        "Reserved Bit",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_AUDIO_NUM.
static const field_t hw_ccm_analog_pll_audio_num[] =
{
    {
        "A",
        "30 bit numerator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_AUDIO_DENOM.
static const field_t hw_ccm_analog_pll_audio_denom[] =
{
    {
        "B",
        "30 bit Denominator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_VIDEO.
static const field_t hw_ccm_analog_pll_video[] =
{
    {
        "DIV_SELECT",
        "This field controls the pll loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        "Reserved by Freescale.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        "Reserved by Freescale.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        "Reserved by Freescale.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        "Reserved by Freescale.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        "Analog Debug bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the pll.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSC_EN",
        "Revserved BIt",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked;  0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_VIDEO_NUM.
static const field_t hw_ccm_analog_pll_video_num[] =
{
    {
        "A",
        "30 bit numerator of fractional loop divider(Signed number), absolute v"
        "alue should be less than denominator",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_VIDEO_DENOM.
static const field_t hw_ccm_analog_pll_video_denom[] =
{
    {
        "B",
        "30 bit Denominator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_MLB.
static const field_t hw_ccm_analog_pll_mlb[] =
{
    {
        "HOLD_RING_OFF",
        "Analog debug bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHASE_SEL",
        "Analog debut bit.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDDA_DELAY_CFG",
        "Configure the phase delay of the MLB PLL by adjusting the delay line i"
        "n Vddio power domain.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDDD_DELAY_CFG",
        "Configure the phase delay of the MLB PLL by adjusting the delay line i"
        "n core Vdd poser domain.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CLK_DELAY_CFG",
        "Configure the phase delay of the MLB PLL RX Clock.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLB_FLT_RES_CFG",
        "Configure the filter resistor for different divider ratio of MLB PLL.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "Lock bit",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_ENET.
static const field_t hw_ccm_analog_pll_enet[] =
{
    {
        "DIV_SELECT",
        "Controls the frequency of the ethernet reference clock.00 - 25MHz; 01 "
        "- 50MHz; 10 - 100MHz (not 50% duty cycle); 11 - 125MHz;",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        "Reserved by Freescale",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        "Reserved by Freescale",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        "Reserved by Freescale",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        "Reserved by Freescale",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        "Analog debug bit",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the ethernet clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the pll.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_100M",
        "Enables an offset in the phase frequency detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PFD_480.
static const field_t hw_ccm_analog_pfd_480[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PFD_528.
static const field_t hw_ccm_analog_pfd_528[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_MISC0.
static const field_t hw_ccm_analog_misc0[] =
{
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        11, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_MISC2.
static const field_t hw_ccm_analog_misc2[] =
{
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL: 0x0=div-by-1(default), 0x1=div-by-2"
        ", 0x2=div-by-1, 0x3=div-by-4.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL: 0x0=div-by-1(default), 0x1=div-by-2"
        ", 0x2=div-by-1, 0x3=div-by-4.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video: 0x0=div-by-1(default), 0x1=div-by-2, 0x2=div-b"
        "y-1, 0x3=div-by-4.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CCM_ANALOG module.
static const reg_t hw_ccm_analog[] =
{
    {
        "PLL_ARM",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_pll_arm
    },
    {
        "PLL_USB1",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_pll_usb1
    },
    {
        "PLL_USB2",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_pll_usb2
    },
    {
        "PLL_SYS",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_pll_sys
    },
    {
        "PLL_SYS_SS",
        "This register contains the 528 PLL spread spectrum controls.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ccm_analog_pll_sys_ss
    },
    {
        "PLL_SYS_NUM",
        "This register contains the numerator of 528MHz PLL fractional loop div"
        "ider (signed number).",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_sys_num
    },
    {
        "PLL_SYS_DENOM",
        "This register contains the Denominator of 528MHz PLL fractional loop d"
        "ivider.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_sys_denom
    },
    {
        "PLL_AUDIO",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_pll_audio
    },
    {
        "PLL_AUDIO_NUM",
        "This register contains the numerator (A) of Audio PLL fractional loop "
        "divider.(Signed number), absolute value should be less than denominato"
        "r  Absolute value should be less than denominator",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_audio_num
    },
    {
        "PLL_AUDIO_DENOM",
        "This register contains the Denominator (B) of Audio PLL fractional loo"
        "p divider.(unsigned number)",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_audio_denom
    },
    {
        "PLL_VIDEO",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_pll_video
    },
    {
        "PLL_VIDEO_NUM",
        "This register contains the numerator (A) of Video PLL fractional loop "
        "divider.(Signed number)  Absolute value should be less than denominato"
        "r",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_video_num
    },
    {
        "PLL_VIDEO_DENOM",
        "This register contains the Denominator (B) of Video PLL fractional loo"
        "p divider.(Unsigned number)",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_video_denom
    },
    {
        "PLL_MLB",
        "This register defines the control bits for the MLB PLL.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_pll_mlb
    },
    {
        "PLL_ENET",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_pll_enet
    },
    {
        "PFD_480",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_pfd_480
    },
    {
        "PFD_528",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_pfd_528
    },
    {
        "MISC0",
        "This register defines the control for miscellaneous CCM Analog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_misc0
    },
    {
        "MISC2",
        "This register defines the control for miscellaneous CCM Analog blocks.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_analog_misc2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CSI2IPU
#endif

// Bitfields in register CSI2IPU_SW_RST.
static const field_t hw_csi2ipu_sw_rst[] =
{
    {
        "SW_RST",
        "Software Reset",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_SEL",
        "Clock mode selection",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YUV422_8BIT_FM",
        "YUV422 8-bit mode selection",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB444_FM",
        "rgb444 mode selection",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CSI2IPU module.
static const reg_t hw_csi2ipu[] =
{
    {
        "SW_RST",
        "This register describes the IPU interface signals.",
        4, // Width in bytes
        0x00000f00, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_csi2ipu_sw_rst
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CSU
#endif

// Bitfields in register CSU_CSL0.
static const field_t hw_csu_csl0[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL1.
static const field_t hw_csu_csl1[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL2.
static const field_t hw_csu_csl2[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL3.
static const field_t hw_csu_csl3[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL4.
static const field_t hw_csu_csl4[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL5.
static const field_t hw_csu_csl5[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL6.
static const field_t hw_csu_csl6[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL7.
static const field_t hw_csu_csl7[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL8.
static const field_t hw_csu_csl8[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL9.
static const field_t hw_csu_csl9[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL10.
static const field_t hw_csu_csl10[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL11.
static const field_t hw_csu_csl11[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL12.
static const field_t hw_csu_csl12[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL13.
static const field_t hw_csu_csl13[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL14.
static const field_t hw_csu_csl14[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL15.
static const field_t hw_csu_csl15[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL16.
static const field_t hw_csu_csl16[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL17.
static const field_t hw_csu_csl17[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL18.
static const field_t hw_csu_csl18[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL19.
static const field_t hw_csu_csl19[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL20.
static const field_t hw_csu_csl20[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL21.
static const field_t hw_csu_csl21[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL22.
static const field_t hw_csu_csl22[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL23.
static const field_t hw_csu_csl23[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL24.
static const field_t hw_csu_csl24[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL25.
static const field_t hw_csu_csl25[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL26.
static const field_t hw_csu_csl26[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL27.
static const field_t hw_csu_csl27[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL28.
static const field_t hw_csu_csl28[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL29.
static const field_t hw_csu_csl29[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL30.
static const field_t hw_csu_csl30[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL31.
static const field_t hw_csu_csl31[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL32.
static const field_t hw_csu_csl32[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL33.
static const field_t hw_csu_csl33[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL34.
static const field_t hw_csu_csl34[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL35.
static const field_t hw_csu_csl35[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL36.
static const field_t hw_csu_csl36[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL37.
static const field_t hw_csu_csl37[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL38.
static const field_t hw_csu_csl38[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL39.
static const field_t hw_csu_csl39[] =
{
    {
        "SUR_S2",
        "Secure user read access control for the second slave",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        "Secure supervisor read access control for the second slave",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        "Non-secure user read access control for the second slave",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        "Non-secure supervisor read access control for the second slave",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        "Secure user write access control for the second slave",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        "Secure supervisor write access control for the second slave",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        "Non-secure user write access control for the second slave",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        "Non-secure supervisor write access control for the second slave",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        "Lock bit corresponding to the second slave.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        "Secure user read access control for the first slave",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        "Secure supervisor read access control for the first slave",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        "Non-secure user read access control for the first slave",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        "Non-secure supervisor read access control for the first slave",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        "Secure user write access control for the first slave",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        "Secure supervisor write access control for the first slave",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        "Non-secure user write access control for the first slave",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        "Non-secure supervisor write access control for the first slave",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        "Lock bit corresponding to the first slave.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_HP0.
static const field_t hw_csu_hp0[] =
{
    {
        "HP_PCIE",
        "Indicates the Privilege/User Mode for PCIE",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_PCIE",
        "Lock bit set by TZ software for HP_PCIE.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_SATA",
        "Indicates the Privilege/User Mode for SATA",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_SATA",
        "Lock bit set by TZ software for HP_SATA.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_SDMA",
        "Indicates the Privilege/User Mode for SDMA.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_SDMA",
        "Lock bit set by TZ software for HP_SDMA.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_PU",
        "Indicates the Privilege/User Mode for GPU3D, GPU2D, VPU, IPU1, IPU2, O"
        "penVG and VDOA.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_PU",
        "Lock bit set by TZ software for HP_PU.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_USB",
        "Indicates the Privilege/User Mode for USB.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USB",
        "Lock bit set by TZ software for HP_USB.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_TEST",
        "Indicates the Privilege/User Mode for IOMUX Test Port.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_TEST",
        "Lock bit set by TZ software for HP_TEST.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_MLB",
        "Indicate the mode Privilege/User Mode for MLB.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_MLB",
        "Lock bit set by TZ software for HP_MLB.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_CAAM",
        "Indicates the Privilege/User Mode for CAAM",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_CAAM",
        "Lock bit set by TZ software for HP_CAAM.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_RAWNAND",
        "Indicates the Privilege/User Mode for RawNAND",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_RAWNAND",
        "Lock bit set by TZ software for HP_RAWNAND.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_APBHDMA",
        "Indicates the Privilege/User Mode for APBHDMA",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_ABPHDMA",
        "Lock bit set by TZ software for HP_APBHDMA.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_ENET",
        "Indicates the Privilege/User Mode for ENET",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_ENET",
        "Lock bit set by TZ software for HP_ENET.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_DAP",
        "Indicates the Privilege/User Mode for DAP",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_DAP",
        "Lock bit set by TZ software for HP_DAP.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_USDHC1",
        "Indicates the Privilege/User Mode for USDHC1",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC1",
        "Lock bit set by TZ software for HP_USDHC1.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_USDHC2",
        "Indicates the Privilege/User Mode for USDHC2",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC2",
        "Lock bit set by TZ software for HP_USDHC2.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_USDHC3",
        "Indicates the Privilege/User Mode for USDHC3",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC3",
        "Lock bit set by TZ software for HP_USDHC3.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_USDHC4",
        "Indicates the Privilege/User Mode for USDHC4.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC4",
        "Lock bit set by TZ software for HP_USDHC4.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_HP1.
static const field_t hw_csu_hp1[] =
{
    {
        "HP_HDMI_HSI",
        "Indicates the Privilege/User Mode for HDMI Tx and HSI.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_HDMI_HSI",
        "Lock bit set by TZ software for HP_HDMI_HSI.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_SA.
static const field_t hw_csu_sa[] =
{
    {
        "NSA_CP15",
        "Indicate the Type (Secured/Non-Secured) Access to ARM CP15 register.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_CP15",
        "Lock bit set by TZ software for NSA_CP15.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_SATA",
        "Indicates the type of access (Secured/Non-Secured) for SATA",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_SATA",
        "Lock bit set by TZ software for NSA_SATA.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_SDMA",
        "Indicate the Type (Secured/Non-Secured) Access for SDMA.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_SDMA",
        "Lock bit set by TZ software for NSA_SDMA.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_PU",
        "Indicate the Type (Secured/Non-Secured) Access for GPU3D, VDOA, GPU2D,"
        " IPU1, IPU2, OPENVG and VPU.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_PU",
        "Lock bit set by TZ software for NSA_PU.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_USB_MLB",
        "Indicate the Type (Secured/Non-Secured) Access for USB and MLB.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USB_MLB",
        "Lock bit set by TZ software for NSA_USB_MLB.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_PCIE_TEST",
        "Indicate the Type (Secured/Non-Secured) Access for PCIe and IOMUX Test"
        " Port.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_PCIE_TEST",
        "Lock bit set by TZ software for NSA_PCIE_TEST.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_RAWNAND_APBHDMA",
        "Indicate the Type (Secured/Non-Secured) Access for RawNAND and apbhdma"
        "t.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_RAWNAND_APBHDMA",
        "Lock bit set by TZ software for NSA_RAWNAND_APBHDMA.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_ENET",
        "Indicate the Type (Secured/Non-Secured) Access for ENET.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_ENET",
        "Lock bit set by TZ software for NSA_ENET.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_DAP",
        "Access Policy indicator bits",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_DAP",
        "Lock bit set by TZ software for NSA_DAP.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_USDHC1",
        "Indicate the Type (Secured/Non-Secured) Access for USDHC1.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC1",
        "Lock bit set by TZ software for NSA_USDHC1.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_USDHC2",
        "Indicate the Type (Secured/Non-Secured) Access for USDHC2.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC2",
        "Lock bit set by TZ software for NSA_USDHC2.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_USDHC3",
        "Indicate the Type (Secured/Non-Secured) Access for USDHC3.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC3",
        "Lock bit set by TZ software for NSA_USDHC3.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_USDHC4",
        "Indicate the Type (Secured/Non-Secured) Access for USDHC4.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC4",
        "Lock bit set by TZ software for NSA_USDHC14.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA_HDMI_HSI",
        "Indicate the Type (Secured/Non-Secured) Access for HDMI Tx and HSI.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_HDMI_HSI",
        "Lock bit set by TZ software for NSA_HDMI_HSI.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_HPCONTROL0.
static const field_t hw_csu_hpcontrol0[] =
{
    {
        "HPC_PCIE",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of PCIE.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_PCIE",
        "Lock bit set by TZ software for HPC_PCIE.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_SATA",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of SATA.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_SATA",
        "Lock bit set by TZ software for HPC_SATA.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_SDMA",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of SDMA.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_SDMA",
        "Lock bit set by TZ software for HPC_SDMA.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_PU",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of GPU3D, GPU2D, VPU, IPU1, IPU2, OpenVG and VDO"
        "A.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_PU",
        "Lock bit set by TZ software for HPC_PU.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_USB",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of USB.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USB",
        "Lock bit set by TZ software for HPC_USB.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_TEST",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of IOMUX Test Port.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_TEST",
        "Lock bit set by TZ software for HPC_TEST.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_MLB",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of MLB.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_MLB",
        "Lock bit set by TZ software for HPC_MLB.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_CAAM",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of CAAM.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_CAAM",
        "Lock bit set by TZ software for HPC_CAAM.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_RAWNAND",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of RawNAND.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_RAWNAND",
        "Lock bit set by TZ software for HPC_RAWNAND.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_APBHDMA",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of apbhdma.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_ABPHDMA",
        "Lock bit set by TZ software for HPC_APBHDMA.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_ENET",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of ENET.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_ENET",
        "Lock bit set by TZ software for HPC_ENET.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_DAP",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of DAP.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_DAP",
        "Lock bit set by TZ software for HPC_DAP.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_USDHC1",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of USDHC1.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC1",
        "Lock bit set by TZ software for HPC_USDHC1.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_USDHC2",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of USDHC2.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC2",
        "Lock bit set by TZ software for HPC_USDHC2.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_USDHC3",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of USDHC3.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC3",
        "Lock bit set by TZ software for HPC_USDHC3.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPC_USDHC4",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of USDHC4.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_USDHC4",
        "Lock bit set by TZ software for HPC_USDHC4.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_HPCONTROL1.
static const field_t hw_csu_hpcontrol1[] =
{
    {
        "HPC_HDMI_HSI",
        "Determines if the Register value of the HP field corresponding will be"
        " pass as the hprot[1] of HDMI Tx and HSI.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L_HDMI_HSI",
        "Lock bit set by TZ software for HPC_HDMI_HSI.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CSU module.
static const reg_t hw_csu[] =
{
    {
        "CSL0",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl0
    },
    {
        "CSL1",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl1
    },
    {
        "CSL2",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl2
    },
    {
        "CSL3",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl3
    },
    {
        "CSL4",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl4
    },
    {
        "CSL5",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl5
    },
    {
        "CSL6",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl6
    },
    {
        "CSL7",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl7
    },
    {
        "CSL8",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl8
    },
    {
        "CSL9",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl9
    },
    {
        "CSL10",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl10
    },
    {
        "CSL11",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl11
    },
    {
        "CSL12",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl12
    },
    {
        "CSL13",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl13
    },
    {
        "CSL14",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl14
    },
    {
        "CSL15",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl15
    },
    {
        "CSL16",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl16
    },
    {
        "CSL17",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl17
    },
    {
        "CSL18",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl18
    },
    {
        "CSL19",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl19
    },
    {
        "CSL20",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl20
    },
    {
        "CSL21",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl21
    },
    {
        "CSL22",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl22
    },
    {
        "CSL23",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl23
    },
    {
        "CSL24",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl24
    },
    {
        "CSL25",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl25
    },
    {
        "CSL26",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl26
    },
    {
        "CSL27",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl27
    },
    {
        "CSL28",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl28
    },
    {
        "CSL29",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl29
    },
    {
        "CSL30",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl30
    },
    {
        "CSL31",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl31
    },
    {
        "CSL32",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl32
    },
    {
        "CSL33",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl33
    },
    {
        "CSL34",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl34
    },
    {
        "CSL35",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl35
    },
    {
        "CSL36",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl36
    },
    {
        "CSL37",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl37
    },
    {
        "CSL38",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl38
    },
    {
        "CSL39",
        "There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl39
    },
    {
        "HP0",
        "The SCU_HP0 and SCU_HP1 registers may be programmed to determine the p"
        "rivilege (either User Mode or Supervisor Mode) for seventeen different"
        " master groups.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_csu_hp0
    },
    {
        "HP1",
        "The SCU_HP1 register is an expansion of the SCU_HP0 register.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_csu_hp1
    },
    {
        "SA",
        "The Secure Access register may be programmed to specify the access pol"
        "icy (either Secure or Non-secure) for up to sixteen different masters.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        28, // Number of bitfields
        hw_csu_sa
    },
    {
        "HPCONTROL0",
        "The HP Control registers CSU_HPCONTROL0 and CSU_HPCONTROL1 enable CSU "
        "to control the USER/SUPERVISOR mode state for the specified masters.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_csu_hpcontrol0
    },
    {
        "HPCONTROL1",
        "The SCU_HPCONTROL1 register is expansion of SCU_HPCONTROL0 register.",
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_csu_hpcontrol1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DCIC
#endif

// Bitfields in register DCIC_DCICC.
static const field_t hw_dcic_dcicc[] =
{
    {
        "IC_EN",
        "Integrity Check enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_POL",
        "DATA_EN_IN signal polarity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "HSYNC_IN signal polarity.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "VSYNC_IN signal polarity.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_POL",
        "DISP_CLK signal polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICIC.
static const field_t hw_dcic_dcicic[] =
{
    {
        "EI_MASK",
        "Error Interrupt mask.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FI_MASK",
        "Functional Interrupt mask.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FREEZE_MASK",
        "Disable change of interrupt masks.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXT_SIG_EN",
        "External controller mismatch indication signal.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICS.
static const field_t hw_dcic_dcics[] =
{
    {
        "ROI_MATCH_STAT",
        "Each set bit of this field indicates there was a mismatch at appropria"
        "te ROIs signature during the last frame.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EI_STAT",
        "Error Interrupt status.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FI_STAT",
        "Functional Interrupt status.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICRC.
static const field_t hw_dcic_dcicrc[] =
{
    {
        "START_OFFSET_X",
        "Column number of ROIs upper-left corner (X coordinate)  Range: 0 to 2^"
        " 13 -1",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_OFFSET_Y",
        "Row number of ROIs upper-left corner (Y coordinate)  Range: 0 to 2^ 12"
        " -1",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI_FREEZE",
        "When set, the only parameter of ROI #m that can be changed is referenc"
        "e signature.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI_EN",
        "ROI #m tracking enable",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICRS.
static const field_t hw_dcic_dcicrs[] =
{
    {
        "END_OFFSET_X",
        "Column number of ROIs lower-right corner (X coordinate)  Range: 1 to 2"
        "^ 13 -1",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "END_OFFSET_Y",
        "Row number of ROIs lower-right corner (Y coordinate)  Range: 1 to 2^ 1"
        "2 -1",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICRRS.
static const field_t hw_dcic_dcicrrs[] =
{
    {
        "REFERENCE_SIGNATURE",
        "32-bit expected signature (CRC calculation result) for ROI #m",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICRCS.
static const field_t hw_dcic_dcicrcs[] =
{
    {
        "CALCULATED_SIGNATURE",
        "32-bit actual signature (CRC calculation result) for ROI #m during the"
        " last frame.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a DCIC module.
static const reg_t hw_dcic[] =
{
    {
        "DCICC",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_dcic_dcicc
    },
    {
        "DCICIC",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dcic_dcicic
    },
    {
        "DCICS",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dcic_dcics
    },
    {
        "DCICRC",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dcic_dcicrc
    },
    {
        "DCICRS",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcic_dcicrs
    },
    {
        "DCICRRS",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcic_dcicrrs
    },
    {
        "DCICRCS",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dcic_dcicrcs
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DVFSC
#endif

// Bitfields in register DVFSC_THRS.
static const field_t hw_dvfsc_thrs[] =
{
    {
        "PNCTHR",
        "Panic threshold for load tracking",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DWTHR",
        "Down threshold for load tracking",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPTHR",
        "Upper threshold for load tracking",
        22, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_COUN.
static const field_t hw_dvfsc_coun[] =
{
    {
        "UPCNT",
        "UP counter threshold value",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DN_CNT",
        "Down counter threshold value",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_SIG1.
static const field_t hw_dvfsc_sig1[] =
{
    {
        "WSW6",
        "General purpose load tracking signal weight dvfs_w_sig[6]",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW7",
        "General purpose load tracking signal weight dvfs_w_sig[7]",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW8",
        "General purpose load tracking signal weight dvfs_w_sig[8]",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW9",
        "General purpose load tracking signal weight dvfs_w_sig[9]",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW10",
        "General purpose load tracking signal weight dvfs_w_sig[10]",
        14, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW11",
        "General purpose load tracking signal weight dvfs_w_sig[11]",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW12",
        "General purpose load tracking signal weight dvfs_w_sig[12]",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW13",
        "General purpose load tracking signal weight dvfs_w_sig[13]",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW14",
        "General purpose load tracking signal weight dvfs_w_sig[14]",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW15",
        "General purpose load tracking signal weight dvfs_w_sig[15]",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSSIG0.
static const field_t hw_dvfsc_dvfssig0[] =
{
    {
        "WSW0",
        "General purpose load tracking signal weight dvfs_w_sig[0].",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW1",
        "General purpose load tracking signal weight dvfs_w_sig[1].",
        6, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW2",
        "General purpose load tracking signal weight dvfs_w_sig[2]",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW3",
        "General purpose load tracking signal weight dvfs_w_sig[3]",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW4",
        "General purpose load tracking signal weight dvfs_w_sig[4]",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW5",
        "General purpose load tracking signal weight dvfs_w_sig[5]",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPC0.
static const field_t hw_dvfsc_dvfsgpc0[] =
{
    {
        "GPBC0",
        "GPBC0 - General Purpose bits Counter 0  During period of this counter "
        "the GeP bit 0 will be set and WSW0 will be added to the calculations.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C0ACT",
        "C0ACT - Counter 0 active indicator",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C0STRT",
        "C0STRT - Counter 0 start  Setting of this bit will initialize down cou"
        "nting of the GPC0 value.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPC1.
static const field_t hw_dvfsc_dvfsgpc1[] =
{
    {
        "GPBC1",
        "GPBC1 - General Purpose bits Counter 1  During period of this counter "
        "the GeP bit 1 will be set and WSW1 will be added to the calculations.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C1ACT",
        "C1ACT - Counter 1 active indicator",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C1STRT",
        "C1STRT - Counter 1start  Setting of this bit will initialize down coun"
        "ting of the GPC1 value.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPBT.
static const field_t hw_dvfsc_dvfsgpbt[] =
{
    {
        "GPB0",
        "General purpose bit 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB1",
        "General purpose bit 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB2",
        "General purpose bit 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB3",
        "General purpose bit 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB4",
        "General purpose bit 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB5",
        "General purpose bit 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB6",
        "General purpose bit 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB7",
        "General purpose bit 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB8",
        "General purpose bit 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB9",
        "General purpose bit 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB10",
        "General purpose bit 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB11",
        "General purpose bit 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB12",
        "General purpose bit 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB13",
        "General purpose bit 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB14",
        "General purpose bit 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB15",
        "General purpose bit 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSEMAC.
static const field_t hw_dvfsc_dvfsemac[] =
{
    {
        "EMAC",
        "EMAC - EMA control value",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEN0",
        "DVFS tracking for core0 enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEN1",
        "DVFS tracking for core1 enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEN2",
        "DVFS tracking for core2 enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEN3",
        "DVFS tracking for core3 enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSVAI0",
        "DVFS Frequency adjustment status of core 0.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FSVAI1",
        "DVFS Frequency adjustment status of core 1.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FSVAI2",
        "DVFS Frequency adjustment status of core 2.",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FSVAI3",
        "DVFS Frequency adjustment status of core 3.",
        22, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFIM0",
        "DVFS Wait for Interrupt of core 0 mask bit",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFIM1",
        "DVFS Wait for Interrupt of core 1 mask bit",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFIM2",
        "DVFS Wait for Interrupt of core 2mask bit",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFIM3",
        "DVFS Wait for Interrupt of core 3 mask bit",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_CNTR.
static const field_t hw_dvfsc_cntr[] =
{
    {
        "LTBRSR",
        "LTBRSR - Load Tracking Buffer Register Source:",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LTBRSH",
        "LTBRSH - Load Tracking Buffer Register Shift:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFUS",
        "PFUS - Periodic Frequency Update Status",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFUE",
        "PFUE - Period Frequency Update Enable",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV_RATIO",
        "DIV_RATIO - Divider value.",
        11, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MINF",
        "Minimum frequency reached.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAXF",
        "Maximum frequency reached.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSVAI",
        "FSVAI  DVFS Frequency adjustment interrupt.",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FSVAIM",
        "DVFS Frequency adjustment interrupt mask.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIRQS",
        "PIRQS - Pattern IRQ Source  * write '1' to clear.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFIS",
        "DVFS Interrupt select.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBFL0",
        "Load buffer 0 - full status bit.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBFL1",
        "Load buffer 1 - full status bit.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBMI",
        "Load buffer full mask interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEV",
        "Always give a DVFS event.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV3CK",
        "DIV3CK - div_3_clk division ratio inside the DVFS module.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR0_0.
static const field_t hw_dvfsc_dvfsltr0_0[] =
{
    {
        "LTS0_0",
        "core 0 Load Tracking Sample 0",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_1",
        "core 0 Load Tracking Sample 1",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_2",
        "core 0 Load Tracking Sample 2",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_3",
        "core 0 Load Tracking Sample 3",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_4",
        "core 0 Load Tracking Sample 4",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_5",
        "core 0 Load Tracking Sample 5",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_6",
        "core 0 Load Tracking Sample 6",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_7",
        "core 0 Load Tracking Sample 7",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR0_1.
static const field_t hw_dvfsc_dvfsltr0_1[] =
{
    {
        "LTS0_8",
        "core 0 Load Tracking Sample 8",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_9",
        "core 0 Load Tracking Sample 9",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_10",
        "core 0 Load Tracking Sample 10",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_11",
        "core 0 Load Tracking Sample 11",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_12",
        "core 0 Load Tracking Sample 12",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_13",
        "core 0 Load Tracking Sample 13",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_14",
        "core 0 Load Tracking Sample 14",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_15",
        "core 0 Load Tracking Sample 15",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR1_0.
static const field_t hw_dvfsc_dvfsltr1_0[] =
{
    {
        "LTS1_0",
        "core 0 Load Tracking Sample 0",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_1",
        "core 0 Load Tracking Sample 1",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_2",
        "core 0 Load Tracking Sample 2",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_3",
        "core 0 Load Tracking Sample 3",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_4",
        "core 0 Load Tracking Sample 4",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_5",
        "core 0 Load Tracking Sample 5",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_6",
        "core 0 Load Tracking Sample 6",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_7",
        "core 0 Load Tracking Sample 7",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR1_1.
static const field_t hw_dvfsc_dvfsltr1_1[] =
{
    {
        "LTS1_8",
        "core 0 Load Tracking Sample 8",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_9",
        "core 0 Load Tracking Sample 9",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_10",
        "core 0 Load Tracking Sample 10",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_11",
        "core 0 Load Tracking Sample 11",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_12",
        "core 0 Load Tracking Sample 12",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_13",
        "core 0 Load Tracking Sample 13",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_14",
        "core 0 Load Tracking Sample 14",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_15",
        "core 0 Load Tracking Sample 15",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT0.
static const field_t hw_dvfsc_dvfspt0[] =
{
    {
        "FPTN0",
        "FPTN0 - Frequency pattern 0 counter  During period of this counter the"
        " frequency will be reduced from the EMA-detected level.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT0A",
        "PT0A - Pattern 0 currently active (read-only)",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT1.
static const field_t hw_dvfsc_dvfspt1[] =
{
    {
        "FPTN1",
        "FPTN1 - Frequency pattern 1 counter  During period of this counter the"
        " frequency will be set to the EMA-detected level.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT1A",
        "PT1A - Pattern 1 currently active (read-only)",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT2.
static const field_t hw_dvfsc_dvfspt2[] =
{
    {
        "FPTN2",
        "FPTN2 - Frequency pattern 2 counter  During period of this counter the"
        " frequency will be increased to higher, than detected by the EMA-detec"
        "ted level.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT2A",
        "PT2A - Pattern 2 currently active (read-only)",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "P2THR",
        "P2THR - Pattern 2 Threshold  Threshold of current DVFS load (after EMA"
        "), for generating interrupts with PFUS indicators 110, 111.",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT3.
static const field_t hw_dvfsc_dvfspt3[] =
{
    {
        "FPTN3",
        "FPTN3 - Frequency pattern 3 counter  During period of this counter the"
        " frequency will be set to the EMA-detected level.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT3A",
        "PT3A - Pattern 3 currently active (read-only)",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a DVFSC module.
static const reg_t hw_dvfsc[] =
{
    {
        "THRS",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_thrs
    },
    {
        "COUN",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_coun
    },
    {
        "SIG1",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dvfsc_sig1
    },
    {
        "DVFSSIG0",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_dvfsc_dvfssig0
    },
    {
        "DVFSGPC0",
        "DVFS general purpose bits weight counter.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfsgpc0
    },
    {
        "DVFSGPC1",
        "DVFS general purpose bits weight counter1.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfsgpc1
    },
    {
        "DVFSGPBT",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_dvfsc_dvfsgpbt
    },
    {
        "DVFSEMAC",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_dvfsc_dvfsemac
    },
    {
        "CNTR",
        "DIV3CK division         DIV3CK setting  dividing ratio  sum_3 passing "
        "bits  div_1_clk cumulative divider      00  1  4-0  1*512=512    001  "
        "4  6-2  4*512=2048    010  16  8-4  16*512=8192    011  64  10-6  64*5"
        "12=32768    100  256  12-8  256*512=131072    101  1024  16-10  1024*5"
        "12=524288       Preliminary Divider definition       DIV_RATIO value  "
        "ARM clk division ratio      000000  1    000001  2    000010  3    ...",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_dvfsc_cntr
    },
    {
        "DVFSLTR0_0",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr0_0
    },
    {
        "DVFSLTR0_1",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr0_1
    },
    {
        "DVFSLTR1_0",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr1_0
    },
    {
        "DVFSLTR1_1",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr1_1
    },
    {
        "DVFSPT0",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt0
    },
    {
        "DVFSPT1",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt1
    },
    {
        "DVFSPT2",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfspt2
    },
    {
        "DVFSPT3",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt3
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ECSPI
#endif

// Bitfields in register ECSPI_RXDATA.
static const field_t hw_ecspi_rxdata[] =
{
    {
        "ECSPI_RXDATA",
        "Receive Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_TXDATA.
static const field_t hw_ecspi_txdata[] =
{
    {
        "ECSPI_TXDATA",
        "Transmit Data.",
        0, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_CONREG.
static const field_t hw_ecspi_conreg[] =
{
    {
        "EN",
        "SPI Block Enable Control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HT",
        "Hardware Trigger Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XCH",
        "SPI Exchange Bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMC",
        "Start Mode Control.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHANNEL_MODE",
        "SPI CHANNEL MODE selects the mode for each SPI channel.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIVIDER",
        "SPI Post Divider.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_DIVIDER",
        "SPI Pre Divider.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRCTL",
        "SPI Data Ready Control.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHANNEL_SELECT",
        "SPI CHANNEL SELECT bits.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LENGTH",
        "Burst Length.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_CONFIGREG.
static const field_t hw_ecspi_configreg[] =
{
    {
        "SCLK_PHA",
        "SPI Clock/Data Phase Control.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLK_POL",
        "SPI Clock Polarity Control.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS_CTL",
        "SPI SS Wave Form Select.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS_POL",
        "SPI SS Polarity Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_CTL",
        "DATA CTL.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLK_CTL",
        "SCLK CTL.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HT_LENGTH",
        "HT LENGTH.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_INTREG.
static const field_t hw_ecspi_intreg[] =
{
    {
        "TEEN",
        "TXFIFO Empty Interrupt enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDREN",
        "TXFIFO Data Request Interrupt enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN",
        "TXFIFO Full Interrupt enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RREN",
        "RXFIFO Ready Interrupt enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDREN",
        "RXFIFO Data Request Interrupt enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN",
        "RXFIFO Full Interrupt enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROEN",
        "RXFIFO Overflow Interrupt enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCEN",
        "Transfer Completed Interrupt enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_DMAREG.
static const field_t hw_ecspi_dmareg[] =
{
    {
        "TX_THRESHOLD",
        "TX THRESHOLD.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEDEN",
        "TXFIFO Empty DMA Request Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_THRESHOLD",
        "RX THRESHOLD.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDEN",
        "RXFIFO DMA Request Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_DMA_LENGTH",
        "RX DMA LENGTH.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXTDEN",
        "RXFIFO TAIL DMA Request Enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_STATREG.
static const field_t hw_ecspi_statreg[] =
{
    {
        "TE",
        "TXFIFO Empty.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDR",
        "TXFIFO Data Request.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF",
        "TXFIFO Full.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RR",
        "RXFIFO Ready.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR",
        "RXFIFO Data Request.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RF",
        "RXFIFO Full.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RO",
        "RXFIFO Overflow.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        "Transfer Completed Status bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_PERIODREG.
static const field_t hw_ecspi_periodreg[] =
{
    {
        "SAMPLE_PERIOD",
        "Sample Period Control.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSRC",
        "Clock Source Control.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSD_CTL",
        "Chip Select Delay Control bits.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_TESTREG.
static const field_t hw_ecspi_testreg[] =
{
    {
        "TXCNT",
        "TXFIFO Counter.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXCNT",
        "RXFIFO Counter.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBC",
        "Loop Back Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_MSGDATA.
static const field_t hw_ecspi_msgdata[] =
{
    {
        "ECSPI_MSGDATA",
        "ECSPI_MSGDATA holds the top word of MSG Data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ECSPI module.
static const reg_t hw_ecspi[] =
{
    {
        "RXDATA",
        "The Receive Data register (ECSPI_RXDATA) is a read-only register that "
        "forms the top word of the 64 x 32 receive FIFO.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ecspi_rxdata
    },
    {
        "TXDATA",
        "The Transmit Data (ECSPI_TXDATA) register is a write-only data registe"
        "r that forms the bottom word of the 64 x 32 TXFIFO.",
        4, // Width in bytes
        0x00000004, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ecspi_txdata
    },
    {
        "CONREG",
        "The Control Register (ECSPI_CONREG) allows software to enable the ECSP"
        "I , configure its operating modes, specify the divider value, and SPI_"
        "RDY control signal, and define the transfer length.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ecspi_conreg
    },
    {
        "CONFIGREG",
        "The Config Register (ECSPI_CONFIGREG) allows software to configure eac"
        "h SPI channel, configure its operating modes, specify the phase and po"
        "larity of the clock, configure the Chip Select (SS), and define the HT"
        " transfer length.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ecspi_configreg
    },
    {
        "INTREG",
        "The Interrupt Control Register (ECSPI_INTREG) enables the generation o"
        "f interrupts to the host processor.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ecspi_intreg
    },
    {
        "DMAREG",
        "The Direct Memory Access Control Register (ECSPI_DMAREG) provides soft"
        "ware a way to use an on-chip DMA controller for ECSPI data.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ecspi_dmareg
    },
    {
        "STATREG",
        "The ECSPI Status Register (ECSPI_STATREG) reflects the status of the E"
        "CSPI's operating condition.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ecspi_statreg
    },
    {
        "PERIODREG",
        "The Sample Period Control Register (ECSPI_PERIODREG) provides software"
        " a way to insert delays (wait states) between consecutive SPI transfer"
        "s.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ecspi_periodreg
    },
    {
        "TESTREG",
        "The Test Control Register (ECSPI_TESTREG) provides software a mechanis"
        "m to internally connect the receive and transmit devices of the ECSPI "
        " , and monitor the contents of the receive and transmit FIFOs.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ecspi_testreg
    },
    {
        "MSGDATA",
        "The Message Data Register (ECSPI_MSGDATA) forms the top word of the 16"
        " x 32 MSG Data FIFO.",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ecspi_msgdata
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EIM
#endif

// Bitfields in register EIM_CS0GCR1.
static const field_t hw_eim_cs0gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0GCR2.
static const field_t hw_eim_cs0gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0RCR1.
static const field_t hw_eim_cs0rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0RCR2.
static const field_t hw_eim_cs0rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0WCR1.
static const field_t hw_eim_cs0wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0WCR2.
static const field_t hw_eim_cs0wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1GCR1.
static const field_t hw_eim_cs1gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1GCR2.
static const field_t hw_eim_cs1gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1RCR1.
static const field_t hw_eim_cs1rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1RCR2.
static const field_t hw_eim_cs1rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1WCR1.
static const field_t hw_eim_cs1wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1WCR2.
static const field_t hw_eim_cs1wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2GCR1.
static const field_t hw_eim_cs2gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2GCR2.
static const field_t hw_eim_cs2gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2RCR1.
static const field_t hw_eim_cs2rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2RCR2.
static const field_t hw_eim_cs2rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2WCR1.
static const field_t hw_eim_cs2wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2WCR2.
static const field_t hw_eim_cs2wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3GCR1.
static const field_t hw_eim_cs3gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3GCR2.
static const field_t hw_eim_cs3gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3RCR1.
static const field_t hw_eim_cs3rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3RCR2.
static const field_t hw_eim_cs3rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3WCR1.
static const field_t hw_eim_cs3wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3WCR2.
static const field_t hw_eim_cs3wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_WCR.
static const field_t hw_eim_wcr[] =
{
    {
        "BCM",
        "Burst Clock Mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBCD",
        "General Burst Clock Divisor.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTEN",
        "Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTPOL",
        "Interrupt Polarity.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_EN",
        "Memory WDog enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_LIMIT",
        "Memory Watch Dog (WDog) cycle limit.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_WIAR.
static const field_t hw_eim_wiar[] =
{
    {
        "IPS_REQ",
        "IPS request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPS_ACK",
        "IPS ACK.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT",
        "Interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERRST",
        "READY After Reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EN",
        "ACLK enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_EAR.
static const field_t hw_eim_ear[] =
{
    {
        "ERROR_ADDR",
        "Error Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a EIM module.
static const reg_t hw_eim[] =
{
    {
        "CS0GCR1",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs0gcr1
    },
    {
        "CS0GCR2",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs0gcr2
    },
    {
        "CS0RCR1",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs0rcr1
    },
    {
        "CS0RCR2",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs0rcr2
    },
    {
        "CS0WCR1",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs0wcr1
    },
    {
        "CS0WCR2",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs0wcr2
    },
    {
        "CS1GCR1",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs1gcr1
    },
    {
        "CS1GCR2",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs1gcr2
    },
    {
        "CS1RCR1",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs1rcr1
    },
    {
        "CS1RCR2",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs1rcr2
    },
    {
        "CS1WCR1",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs1wcr1
    },
    {
        "CS1WCR2",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs1wcr2
    },
    {
        "CS2GCR1",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs2gcr1
    },
    {
        "CS2GCR2",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs2gcr2
    },
    {
        "CS2RCR1",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs2rcr1
    },
    {
        "CS2RCR2",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs2rcr2
    },
    {
        "CS2WCR1",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs2wcr1
    },
    {
        "CS2WCR2",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs2wcr2
    },
    {
        "CS3GCR1",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs3gcr1
    },
    {
        "CS3GCR2",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs3gcr2
    },
    {
        "CS3RCR1",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs3rcr1
    },
    {
        "CS3RCR2",
        "",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs3rcr2
    },
    {
        "CS3WCR1",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs3wcr1
    },
    {
        "CS3WCR2",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs3wcr2
    },
    {
        "WCR",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_wcr
    },
    {
        "WIAR",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_wiar
    },
    {
        "EAR",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_ear
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ENET
#endif

// Bitfields in register ENET_EIR.
static const field_t hw_enet_eir[] =
{
    {
        "TS_TIMER",
        "The adjustable timer reached the period event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TS_AVAIL",
        "Indicates that the timestamp of the last transmitted timing frame is a"
        "vailable in the ATSTMP register.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "Read-only status bit to indicate that a magic packet has been detected"
        ".",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLR",
        "Indicates a frame was received with a payload length error.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UN",
        "Indicates the transmit FIFO became empty before the complete frame was"
        " transmitted.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Indicates a collision occurred on each of 16 successive attempts to tr"
        "ansmit the frame.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LC",
        "Indicates a collision occurred beyond the collision window (slot time)"
        " in half-duplex mode.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EBERR",
        "Indicates a system bus error occurred when a uDMA transaction is under"
        "way.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII",
        "Indicates that the MII has completed the data transfer requested.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB",
        "Indicates a receive buffer descriptor is not the last in the frame has"
        " been updated.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF",
        "Indicates a frame has been received and the last corresponding buffer "
        "descriptor has been updated.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB",
        "Indicates a transmit buffer descriptor has been updated.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF",
        "Indicates a frame has been transmitted and the last corresponding buff"
        "er descriptor has been updated.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRA",
        "This interrupt is asserted after the transmitter is put into a pause s"
        "tate after completion of the frame currently being transmitted.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABT",
        "Indicates the transmitted frame length exceeds RCR[MAX_FL] bytes.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABR",
        "Indicates a frame was received with length in excess of RCR[MAX_FL] by"
        "tes.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_EIMR.
static const field_t hw_enet_eimr[] =
{
    {
        "TS_TIMER",
        "Corresponds to interrupt source TS_TIMER defined by the EIR register a"
        "nd determines whether an interrupt condition can generate an interrupt"
        ".",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TS_AVAIL",
        "Corresponds to interrupt source TS_AVAIL defined by the EIR register a"
        "nd determines whether an interrupt condition can generate an interrupt"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "Corresponds to interrupt source WAKEUP defined by the EIR register and"
        " determines whether an interrupt condition can generate an interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLR",
        "Corresponds to interrupt source PLR defined by the EIR register and de"
        "termines whether an interrupt condition can generate an interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UN",
        "Corresponds to interrupt source UN defined by the EIR register and det"
        "ermines whether an interrupt condition can generate an interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Corresponds to interrupt source RL defined by the EIR register and det"
        "ermines whether an interrupt condition can generate an interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LC",
        "Corresponds to interrupt source LC defined by the EIR register and det"
        "ermines whether an interrupt condition can generate an interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EBERR",
        "Corresponds to interrupt source EBERR defined by the EIR register and "
        "determines whether an interrupt condition can generate an interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII",
        "Corresponds to interrupt source MII defined by the EIR register and de"
        "termines whether an interrupt condition can generate an interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB",
        "Corresponds to interrupt source RXB defined by the EIR register and de"
        "termines whether an interrupt condition can generate an interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF",
        "Corresponds to interrupt source RXF defined by the EIR register and de"
        "termines whether an interrupt condition can generate an interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB",
        "Corresponds to interrupt source TXB defined by the EIR register and de"
        "termines whether an interrupt condition can generate an interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF",
        "Corresponds to interrupt source TXF defined by the EIR register and de"
        "termines whether an interrupt condition can generate an interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRA",
        "Corresponds to interrupt source GRA defined by the EIR register and de"
        "termines whether an interrupt condition can generate an interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABT",
        "Corresponds to interrupt source BABT defined by the EIR register and d"
        "etermines whether an interrupt condition can generate an interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABR",
        "Corresponds to interrupt source BABR defined by the EIR register and d"
        "etermines whether an interrupt condition can generate an interrupt.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDAR.
static const field_t hw_enet_rdar[] =
{
    {
        "RDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDAR.
static const field_t hw_enet_tdar[] =
{
    {
        "TDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ECR.
static const field_t hw_enet_ecr[] =
{
    {
        "RESET",
        "When this field is set, it clears the ETHER_EN field.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETHEREN",
        "Enables/disables the Ethernet MAC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAGICEN",
        "Enables/disables magic packet detection.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLEEP",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN1588",
        "Enables enhanced functionality of the MAC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "Enables the MAC to enter hardware freeze mode when the device enters d"
        "ebug mode.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "Controls device behavior in doze mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MMFR.
static const field_t hw_enet_mmfr[] =
{
    {
        "DATA",
        "This is the field for data to be written to or read from the PHY regis"
        "ter.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TA",
        "This field must be programmed to 10 to generate a valid MII management"
        " frame.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RA",
        "Specifies one of up to 32 registers within the specified PHY device.",
        18, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "Specifies one of up to 32 attached PHY devices.",
        23, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OP",
        "Determines the frame operation.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ST",
        "These fields must be programmed to 01 for a valid MII management frame"
        ".",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MSCR.
static const field_t hw_enet_mscr[] =
{
    {
        "MII_SPEED",
        "Controls the frequency of the MII management interface clock (MDC) rel"
        "ative to the internal module clock.",
        1, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS_PRE",
        "Enables/disables prepending a preamble to the MII management frame.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLDTIME",
        "IEEE802.3 clause 22 defines a minimum of 10 ns for the holdtime on the"
        " MDIO output.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MIBC.
static const field_t hw_enet_mibc[] =
{
    {
        "MIB_CLEAR",
        "If set, all statistics counters are reset to 0.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIB_IDLE",
        "If this status field is set, the MIB block is not currently updating a"
        "ny MIB counters.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIB_DIS",
        "If this control field is set, the MIB logic halts and does not update "
        "any MIB counters.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RCR.
static const field_t hw_enet_rcr[] =
{
    {
        "LOOP",
        "This is an MII internal loopback, therefore MII_MODE must be written t"
        "o 1 and RMII_MODE must be written to 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRT",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII_MODE",
        "This field must always be set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROM",
        "All frames are accepted regardless of address matching.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BC_REJ",
        "If set, frames with destination address (DA) equal to 0xFFFF_FFFF_FFFF"
        " are rejected unless the PROM field is set.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCE",
        "If set, the receiver detects PAUSE frames.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RMII_MODE",
        "Specifies whether the MAC is configured for MII mode or RMII operation"
        " .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RMII_10T",
        "Enables 10-Mbps mode of the RMII .",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PADEN",
        "Specifies whether the MAC removes padding from received frames.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAUFWD",
        "Specifies whether pause frames are terminated or forwarded.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCFWD",
        "Specifies whether the CRC field of received frames is transmitted or s"
        "tripped.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFEN",
        "Enables/disables the MAC control frame.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAX_FL",
        "Resets to decimal 1518.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NLC",
        "Enables/disables a payload length check.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRS",
        "Read-only status indicating that the MAC receive datapath is stopped.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCR.
static const field_t hw_enet_tcr[] =
{
    {
        "GTS",
        "When this field is set, MAC stops transmission after any frame current"
        "ly transmitted is complete and EIR[GRA] is set.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FDEN",
        "If this field is set, frames transmit independent of carrier sense and"
        " collision inputs.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFC_PAUSE",
        "Pauses frame transmission.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFC_PAUSE",
        "This status field is set when a full-duplex flow control pause frame i"
        "s received and the transmitter pauses for the duration defined in this"
        " pause frame.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDSEL",
        "If ADDINS is set, indicates the MAC address that overwrites the source"
        " MAC address.",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDINS",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCFWD",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_PALR.
static const field_t hw_enet_palr[] =
{
    {
        "PADDR1",
        "Bytes 0 (bits 31:24), 1 (bits 23:16), 2 (bits 15:8), and 3 (bits 7:0) "
        "of the 6-byte individual address are used for exact match and the sour"
        "ce address field in PAUSE frames.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_PAUR.
static const field_t hw_enet_paur[] =
{
    {
        "TYPE",
        "These fields have a constant value of 0x8808.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PADDR2",
        "Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual addre"
        "ss used for exact match, and the source address field in PAUSE frames.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_OPD.
static const field_t hw_enet_opd[] =
{
    {
        "PAUSE_DUR",
        "Pause duration field used in PAUSE frames.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE",
        "These fields have a constant value of 0x0001.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IAUR.
static const field_t hw_enet_iaur[] =
{
    {
        "IADDR1",
        "Contains the upper 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a unicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IALR.
static const field_t hw_enet_ialr[] =
{
    {
        "IADDR2",
        "Contains the lower 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a unicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_GAUR.
static const field_t hw_enet_gaur[] =
{
    {
        "GADDR1",
        "Contains the upper 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a multicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_GALR.
static const field_t hw_enet_galr[] =
{
    {
        "GADDR2",
        "Contains the lower 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a multicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TFWR.
static const field_t hw_enet_tfwr[] =
{
    {
        "TFWR",
        "If STRFWD is cleared, indicates the number of bytes written to the tra"
        "nsmit FIFO before transmission of a frame begins.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STRFWD",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDSR.
static const field_t hw_enet_rdsr[] =
{
    {
        "R_DES_START",
        "Pointer to the beginning of the receive buffer descriptor queue.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDSR.
static const field_t hw_enet_tdsr[] =
{
    {
        "X_DES_START",
        "Pointer to the beginning of the transmit buffer descriptor queue.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MRBR.
static const field_t hw_enet_mrbr[] =
{
    {
        "R_BUF_SIZE",
        "Receive buffer size in bytes.",
        4, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RSFL.
static const field_t hw_enet_rsfl[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_RSEM.
static const field_t hw_enet_rsem[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_RAEM.
static const field_t hw_enet_raem[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_RAFL.
static const field_t hw_enet_rafl[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_TSEM.
static const field_t hw_enet_tsem[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_TAEM.
static const field_t hw_enet_taem[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_TAFL.
static const field_t hw_enet_tafl[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_TIPG.
static const field_t hw_enet_tipg[] =
{
    {
        "IPG",
        "Indicates the IPG, in bytes, between transmitted frames.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_FTRL.
static const field_t hw_enet_ftrl[] =
{
    {
        "TRUNC_FL",
        "Indicates the value a receive frame is truncated, if it is greater tha"
        "n this value.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TACC.
static const field_t hw_enet_tacc[] =
{
    {
        "SHIFT16",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPCHK",
        "Enables insertion of IP header checksum.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROCHK",
        "Enables insertion of protocol checksum.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RACC.
static const field_t hw_enet_racc[] =
{
    {
        "PADREM",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPDIS",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRODIS",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINEDIS",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT16",
        "When this field is set, the actual frame data starts at bit 16 of the "
        "first word read from the RX FIFO aligning the Ethernet payload on a 32"
        "-bit boundary.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATCR.
static const field_t hw_enet_atcr[] =
{
    {
        "EN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFRST",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEREN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPER",
        "Enables event signal output assertion on period event.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESTART",
        "Resets the timer to zero.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAPTURE",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLAVE",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATVR.
static const field_t hw_enet_atvr[] =
{
    {
        "ATIME",
        "A write sets the timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATOFF.
static const field_t hw_enet_atoff[] =
{
    {
        "OFFSET",
        "Offset value for one-shot event generation.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATPER.
static const field_t hw_enet_atper[] =
{
    {
        "PERIOD",
        "Value for generating periodic events.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATCOR.
static const field_t hw_enet_atcor[] =
{
    {
        "COR",
        "Defines after how many timer clock cycles (ts_clk) the correction coun"
        "ter should be reset and trigger a correction increment on the timer.",
        0, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATINC.
static const field_t hw_enet_atinc[] =
{
    {
        "INC",
        "The timer increments by this amount each clock cycle.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_CORR",
        "This value is added every time the correction timer expires (every clo"
        "ck cycle given in ATCOR).",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATSTMP.
static const field_t hw_enet_atstmp[] =
{
    {
        "TIMESTAMP",
        "Timestamp of the last frame transmitted by the core that had TxBD[TS] "
        "set .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ENET module.
static const reg_t hw_enet[] =
{
    {
        "EIR",
        "When an event occurs that sets a bit in EIR, an interrupt occurs if th"
        "e corresponding bit in the interrupt mask register (EIMR) is also set.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_enet_eir
    },
    {
        "EIMR",
        "EIMR controls which interrupt events are allowed to generate actual in"
        "terrupts.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_enet_eimr
    },
    {
        "RDAR",
        "RDAR is a command register, written by the user, to indicate that the "
        "receive descriptor ring has been updated, that is, that the driver pro"
        "duced empty receive buffers with the empty bit set.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdar
    },
    {
        "TDAR",
        "The TDAR is a command register that the user writes to indicate that t"
        "he transmit descriptor ring has been updated, that is, that transmit b"
        "uffers have been produced by the driver with the ready bit set in the "
        "buffer descriptor.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdar
    },
    {
        "ECR",
        "ECR is a read/write user register, though hardware may also alter fiel"
        "ds in this register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_enet_ecr
    },
    {
        "MMFR",
        "Writing to MMFR triggers a management frame transaction to the PHY dev"
        "ice unless MSCR is programmed to zero.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_enet_mmfr
    },
    {
        "MSCR",
        "MSCR provides control of the MII clock (MDC pin) frequency and allows "
        "a preamble drop on the MII management frame.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_mscr
    },
    {
        "MIBC",
        "MIBC is a read/write register controlling and observing the state of t"
        "he MIB block.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_mibc
    },
    {
        "RCR",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_enet_rcr
    },
    {
        "TCR",
        "TCR is read/write and configures the transmit block.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_enet_tcr
    },
    {
        "PALR",
        "PALR contains the lower 32 bits (bytes 0, 1, 2, 3) of the 48-bit addre"
        "ss used in the address recognition process to compare with the destina"
        "tion address (DA) field of receive frames with an individual DA.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_palr
    },
    {
        "PAUR",
        "PAUR contains the upper 16 bits (bytes 4 and 5) of the 48-bit address "
        "used in the address recognition process to compare with the destinatio"
        "n address (DA) field of receive frames with an individual DA.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_paur
    },
    {
        "OPD",
        "OPD is read/write accessible.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_opd
    },
    {
        "IAUR",
        "IAUR contains the upper 32 bits of the 64-bit individual address hash "
        "table.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_iaur
    },
    {
        "IALR",
        "IALR contains the lower 32 bits of the 64-bit individual address hash "
        "table.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_ialr
    },
    {
        "GAUR",
        "GAUR contains the upper 32 bits of the 64-bit hash table used in the a"
        "ddress recognition process for receive frames with a multicast address"
        ".",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_gaur
    },
    {
        "GALR",
        "GALR contains the lower 32 bits of the 64-bit hash table used in the a"
        "ddress recognition process for receive frames with a multicast address"
        ".",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_galr
    },
    {
        "TFWR",
        "If TFR[STRFWD] is cleared, TFWR[TFWR] controls the amount of data requ"
        "ired in the transmit FIFO before transmission of a frame can begin.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_tfwr
    },
    {
        "RDSR",
        "RDSR points to the beginning of the circular receive buffer descriptor"
        " queue in external memory.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdsr
    },
    {
        "TDSR",
        "TDSR provides a pointer to the beginning of the circular transmit buff"
        "er descriptor queue in external memory.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdsr
    },
    {
        "MRBR",
        "The MRBR is a user-programmable register that dictates the maximum siz"
        "e of all receive buffers.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_mrbr
    },
    {
        "RSFL",
        "",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_enet_rsfl
    },
    {
        "RSEM",
        "",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_enet_rsem
    },
    {
        "RAEM",
        "",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_enet_raem
    },
    {
        "RAFL",
        "",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_enet_rafl
    },
    {
        "TSEM",
        "",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_enet_tsem
    },
    {
        "TAEM",
        "",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_enet_taem
    },
    {
        "TAFL",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_enet_tafl
    },
    {
        "TIPG",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tipg
    },
    {
        "FTRL",
        "",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_ftrl
    },
    {
        "TACC",
        "TACC controls accelerator actions when sending frames.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_tacc
    },
    {
        "RACC",
        "",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_racc
    },
    {
        "ATCR",
        "ATCR command fields can trigger the corresponding events directly.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_enet_atcr
    },
    {
        "ATVR",
        "",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atvr
    },
    {
        "ATOFF",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atoff
    },
    {
        "ATPER",
        "",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atper
    },
    {
        "ATCOR",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atcor
    },
    {
        "ATINC",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_atinc
    },
    {
        "ATSTMP",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_atstmp
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EPIT
#endif

// Bitfields in register EPIT_CR.
static const field_t hw_epit_cr[] =
{
    {
        "EN",
        "This bit enables the EPIT.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENMOD",
        "EPIT enable mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCIEN",
        "Output compare interrupt enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RLD",
        "Counter reload control.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALAR",
        "Counter clock prescaler value.",
        4, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software reset.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IOVW",
        "EPIT counter overwrite enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "This bit is used to keep the EPIT functional in debug mode.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "This read/write control bit enables the operation of the EPIT during w"
        "ait mode.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "EPIT stop mode enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM",
        "EPIT output mode.This bit field determines the mode of EPIT output on "
        "the output pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Select clock source  These bits determine which clock input is to be s"
        "elected for running the counter.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_SR.
static const field_t hw_epit_sr[] =
{
    {
        "OCIF",
        "Output compare interrupt flag.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_LR.
static const field_t hw_epit_lr[] =
{
    {
        "LOAD",
        "Load value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_CMPR.
static const field_t hw_epit_cmpr[] =
{
    {
        "COMPARE",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_CNR.
static const field_t hw_epit_cnr[] =
{
    {
        "COUNT",
        "Counter value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a EPIT module.
static const reg_t hw_epit[] =
{
    {
        "CR",
        "The EPIT control register (EPIT_CR) is used to configure the operating"
        " settings of the EPIT.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_epit_cr
    },
    {
        "SR",
        "The EPIT status register (EPIT_SR) has a single status bit for the out"
        "put compare event.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_sr
    },
    {
        "LR",
        "The EPIT load register (EPIT_LR) contains the value that is to be load"
        "ed into the counter when EPIT counter reaches zero if the RLD bit in E"
        "PIT_CR is set.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_lr
    },
    {
        "CMPR",
        "The EPIT compare register (EPIT_CMPR) holds the value that determines "
        "when a compare event is generated.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_cmpr
    },
    {
        "CNR",
        "The EPIT counter register (EPIT_CNR) contains the current count value "
        "and can be read at any time without disturbing the counter.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_epit_cnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ESAI
#endif

// Bitfields in register ESAI_ETDR.
static const field_t hw_esai_etdr[] =
{
    {
        "ETDR",
        "ESAI Transmit Data Register.",
        0, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_ERDR.
static const field_t hw_esai_erdr[] =
{
    {
        "ERDR",
        "ESAI Receive Data Register.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_ECR.
static const field_t hw_esai_ecr[] =
{
    {
        "ESAIEN",
        "ESAI Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERST",
        "ESAI Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERO",
        "EXTAL Receiver Out.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERI",
        "EXTAL Receiver In.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETO",
        "EXTAL Transmitter Out.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETI",
        "EXTAL Transmitter In.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_ESR.
static const field_t hw_esai_esr[] =
{
    {
        "RD",
        "Receive Data.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RED",
        "Receive Even Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDE",
        "Receive Data Exception.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RLS",
        "Receive Last Slot.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TD",
        "Transmit Data.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TED",
        "Transmit Even Data.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDE",
        "Transmit Data Exception.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TLS",
        "Transmit Last Slot.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFE",
        "Transmit FIFO Empty.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFF",
        "Receive FIFO Full.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TINIT",
        "Transmit Initialization.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TFCR.
static const field_t hw_esai_tfcr[] =
{
    {
        "TFE",
        "Transmit FIFO Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFR",
        "Transmit FIFO Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE0",
        "Transmitter #0 FIFO Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE1",
        "Transmitter #1 FIFO Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE2",
        "Transmitter #2 FIFO Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE3",
        "Transmitter #3 FIFO Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE4",
        "Transmitter #4 FIFO Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE5",
        "Transmitter #5 FIFO Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFWM",
        "Transmit FIFO Watermark.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWA",
        "Transmit Word Alignment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIEN",
        "Transmitter Initialization Enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TFSR.
static const field_t hw_esai_tfsr[] =
{
    {
        "TFCNT",
        "Transmit FIFO Counter.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NTFI",
        "Next Transmitter FIFO In.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NTFO",
        "Next Transmitter FIFO Out.",
        12, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RFCR.
static const field_t hw_esai_rfcr[] =
{
    {
        "RFE",
        "Receive FIFO Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFR",
        "Receive FIFO Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE0",
        "Receiver #0 FIFO Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE1",
        "Receiver #1 FIFO Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE2",
        "Receiver #2 FIFO Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE3",
        "Receiver #3 FIFO Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFWM",
        "Receive FIFO Watermark.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWA",
        "Receive Word Alignment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REXT",
        "Receive Extension.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RFSR.
static const field_t hw_esai_rfsr[] =
{
    {
        "RFCNT",
        "Receive FIFO Counter.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NRFO",
        "Next Receiver FIFO Out.",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NRFI",
        "Next Receiver FIFO In.",
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX0.
static const field_t hw_esai_tx0[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX1.
static const field_t hw_esai_tx1[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX2.
static const field_t hw_esai_tx2[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX3.
static const field_t hw_esai_tx3[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX4.
static const field_t hw_esai_tx4[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX5.
static const field_t hw_esai_tx5[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX.
static const field_t hw_esai_tx[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RX0.
static const field_t hw_esai_rx0[] =
{
    {
        "RXN",
        "Accept data from the receive shift registers when they become full  Se"
        "e",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RX1.
static const field_t hw_esai_rx1[] =
{
    {
        "RXN",
        "Accept data from the receive shift registers when they become full  Se"
        "e",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RX2.
static const field_t hw_esai_rx2[] =
{
    {
        "RXN",
        "Accept data from the receive shift registers when they become full  Se"
        "e",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RX3.
static const field_t hw_esai_rx3[] =
{
    {
        "RXN",
        "Accept data from the receive shift registers when they become full  Se"
        "e",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_SAISR.
static const field_t hw_esai_saisr[] =
{
    {
        "IF0",
        "ESAI_SAISR Serial Input Flag 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IF1",
        "ESAI_SAISR Serial Inout Flag 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IF2",
        "ESAI_SAISR Serial Input Flag 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFS",
        "ESAI_SAISR Receive Frame Sync Flag.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROE",
        "ESAI_SAISR Receive Overrun Error Flag.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDF",
        "ESAI_SAISR Receive Data Register Full.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REDF",
        "ESAI_SAISR Receive Even-Data Register Full.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RODF",
        "ESAI_SAISR Receive Odd-Data Register Full.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFS",
        "ESAI_SAISR Transmit Frame Sync Flar.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TUE",
        "ESAI_SAISR Transmit Underrun Error Flag.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDE",
        "ESAI_SAISR Transmit Data Register Empty.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEDE",
        "ESAI_SAISR Transmit Even-DataRegister Empty.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TODFE",
        "ESAI_SAISR Transmit Odd-Data Register Empty.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_SAICR.
static const field_t hw_esai_saicr[] =
{
    {
        "OF0",
        "ESAI_SAICR Serial Output Flag 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF1",
        "ESAI_SAICR Serial Output Flag 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2",
        "ESAI_SAICR Serial Output Flag 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYN",
        "ESAI_SAICR Synchronous Mode Selection.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEBE",
        "ESAI_SAICR Transmit External Buffer Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALC",
        "ESAI_SAICR Alignment Control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TCR.
static const field_t hw_esai_tcr[] =
{
    {
        "TE0",
        "ESAI_TCR ESAI Transmit 0 Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE1",
        "ESAI_TCR ESAI Transmit 1 Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE2",
        "ESAI_TCR ESAI Transmit 2 Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE3",
        "ESAI_TCR ESAI Transmit 3 Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE4",
        "ESAI_TCR ESAI Transmit 4 Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE5",
        "ESAI_TCR ESAI Transmit 5 Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSHFD",
        "ESAI_TCR Transmit Shift Direction.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWA",
        "ESAI_TCR Transmit Word Alignment Control.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMOD",
        "ESAI_TCR Transmit Network Mode Control (TMOD1-TMOD0).",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSWS",
        "ESAI_TCR Tx Slot and Word Length Select (TSWS4-TSWS0).",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSL",
        "ESAI_TCR Transmit Frame Sync Length.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSR",
        "ESAI_TCR Transmit Frame Sync Relative Timing.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PADC",
        "ESAI_TCR Transmit Zero Padding Control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPR",
        "ESAI_TCR Transmit Section Personal Reset.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEIE",
        "ESAI_TCR Transmit Exception Interrupt Enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEDIE",
        "ESAI_TCR Transmit Even Slot Data Interrupt Enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "ESAI_TCR Transmit Interrupt Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TLIE",
        "ESAI_TCR Transmit Last Slot Interrupt Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TCCR.
static const field_t hw_esai_tccr[] =
{
    {
        "TPM",
        "ESAI_TCCR Transmit Prescale Modulus Select.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPSR",
        "ESAI_TCCR Transmit Prescaler Range.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDC",
        "ESAI_TCCR Tx Frame Rate Divider Control.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFP",
        "ESAI_TCCR Tx High Frequency Clock Divider.",
        14, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKP",
        "ESAI_TCCR Transmit Clock Polarity.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSP",
        "ESAI_TCCR Transmit Frame Sync Polarity.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "THCKP",
        "ESAI_TCCR Transmit High Frequency Clock Polarity.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKD",
        "ESAI_TCCR Transmit Clock Source Direction.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSD",
        "ESAI_TCCR Transmit Frame Sync Signal Direction.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "THCKD",
        "ESAI_TCCR Transmit High Frequency Clock Direction.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RCR.
static const field_t hw_esai_rcr[] =
{
    {
        "RE0",
        "ESAI_RCR ESAI Receiver 0 Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE1",
        "ESAI_RCR ESAI Receiver 1 Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE2",
        "ESAI_RCR ESAI Receiver 2 Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE3",
        "ESAI_RCR ESAI Receiver 3 Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSHFD",
        "ESAI_RCR Receiver Shift Direction.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWA",
        "ESAI_RCR Receiver Word Alignment Control.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RMOD",
        "ESAI_RCR Receiver Network Mode Control.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSWS",
        "ESAI_RCR Receiver Slot and Word Select.",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSL",
        "ESAI_RCR Receiver Frame Sync Length.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSR",
        "ESAI_RCR Receiver Frame Sync Relative Timing.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RPR",
        "ESAI_RCR Receiver Section Personal Reset.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REIE",
        "ESAI_RCR Receive Exception Interrupt Enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REDIE",
        "ESAI_RCR Receive Even Slot Data Interrupt Enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "ESAI_RCR Receive Interrupt Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RLIE",
        "ESAI_RCR Receive Last Slot Interrupt Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RCCR.
static const field_t hw_esai_rccr[] =
{
    {
        "RPM",
        "ESAI_RCCR Receiver Prescale Modulus Select.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RPSP",
        "ESAI_RCCR Receiver Prescaler Range.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDC",
        "ESAI_RCCR Rx Frame Rate Divider Control.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFP",
        "ESAI_RCCR Rx High Frequency Clock Divider.",
        14, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCKP",
        "The Receiver Clock Polarity (RCKP) bit controls on which bit clock edg"
        "e data and frame sync are clocked out and latched in.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSP",
        "ESAI_RCCR Receiver Frame Sync Polarity.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RHCKP",
        "ESAI_RCCR Receiver High Frequency Clock Polarity.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCKD",
        "ESAI_RCCR Receiver Clock Source Direction.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSD",
        "ESAI_RCCR Receiver Frame Sync Signal Direction.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RHCKD",
        "ESAI_RCCR Receiver High Frequency Clock Direction.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TSMA.
static const field_t hw_esai_tsma[] =
{
    {
        "TS",
        "When bit number N in ESAI_TSMA is cleared, all the transmit data pins "
        "of the enabled transmitters are tri-stated during transmit time slot n"
        "umber N.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TSMB.
static const field_t hw_esai_tsmb[] =
{
    {
        "TS",
        "When bit number N in ESAI_TSMB is cleared, all the transmit data pins "
        "of the enabled transmitters are tri-stated during transmit time slot n"
        "umber N.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RSMA.
static const field_t hw_esai_rsma[] =
{
    {
        "RS",
        "When bit number N in the ESAI_RSMA register is cleared, the data from "
        "the enabled receivers input pins are shifted into their receive shift "
        "registers during slot number N.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RSMB.
static const field_t hw_esai_rsmb[] =
{
    {
        "RS",
        "When bit number N in the ESAI_RSMB register is cleared, the data from "
        "the enabled receivers input pins are shifted into their receive shift "
        "registers during slot number N.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_PRRC.
static const field_t hw_esai_prrc[] =
{
    {
        "PDC",
        "See .",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_PCRC.
static const field_t hw_esai_pcrc[] =
{
    {
        "PC",
        "See .",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ESAI module.
static const reg_t hw_esai[] =
{
    {
        "ETDR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_etdr
    },
    {
        "ERDR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_erdr
    },
    {
        "ECR",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_esai_ecr
    },
    {
        "ESR",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        11, // Number of bitfields
        hw_esai_esr
    },
    {
        "TFCR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_esai_tfcr
    },
    {
        "TFSR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_esai_tfsr
    },
    {
        "RFCR",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_esai_rfcr
    },
    {
        "RFSR",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_esai_rfsr
    },
    {
        "TX0",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000080, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx0
    },
    {
        "TX1",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000088, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx1
    },
    {
        "TX2",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx2
    },
    {
        "TX3",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000090, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx3
    },
    {
        "TX4",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000094, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx4
    },
    {
        "TX5",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000098, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx5
    },
    {
        "TX",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx
    },
    {
        "RX0",
        "ESAI_RX3, ESAI_RX2, ESAI_RX1, and ESAI_RX0 are 32-bit read-only regist"
        "ers that accept data from the receive shift registers when they become"
        " full ( and ).",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_rx0
    },
    {
        "RX1",
        "ESAI_RX3, ESAI_RX2, ESAI_RX1, and ESAI_RX0 are 32-bit read-only regist"
        "ers that accept data from the receive shift registers when they become"
        " full ( and ).",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_rx1
    },
    {
        "RX2",
        "ESAI_RX3, ESAI_RX2, ESAI_RX1, and ESAI_RX0 are 32-bit read-only regist"
        "ers that accept data from the receive shift registers when they become"
        " full ( and ).",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_rx2
    },
    {
        "RX3",
        "ESAI_RX3, ESAI_RX2, ESAI_RX1, and ESAI_RX0 are 32-bit read-only regist"
        "ers that accept data from the receive shift registers when they become"
        " full ( and ).",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_rx3
    },
    {
        "SAISR",
        "The Status Register (ESAI_SAISR) is a read-only status register used b"
        "y the ARM Core to read the status and serial input flags of the ESAI.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        false, // Writable
        13, // Number of bitfields
        hw_esai_saisr
    },
    {
        "SAICR",
        "The read/write Common Control Register (ESAI_SAICR) contains control b"
        "its for functions that affect both the receive and transmit sections o"
        "f the ESAI.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_esai_saicr
    },
    {
        "TCR",
        "The read/write Transmit Control Register (ESAI_TCR) controls the ESAI "
        "transmitter section.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_esai_tcr
    },
    {
        "TCCR",
        "The read/write Transmitter Clock Control Register (ESAI_TCCR) controls"
        " the ESAI transmitter clock generator bit and frame sync rates, the bi"
        "t clock and high frequency clock sources and the directions of the HCK"
        "T, FST and SCKT signals.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_esai_tccr
    },
    {
        "RCR",
        "The read/write Receive Control Register (ESAI_RCR) controls the ESAI r"
        "eceiver section.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_esai_rcr
    },
    {
        "RCCR",
        "The read/write Receiver Clock Control Register (ESAI_RCCR) controls th"
        "e ESAI receiver clock generator bit and frame sync rates, word length,"
        " and number of words per frame for the serial data.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_esai_rccr
    },
    {
        "TSMA",
        "The Transmit Slot Mask Register A together with Transmit Slot Mask Reg"
        "ister B (ESAI_TSMA and ESAI_TSMB) are two read/write registers used by"
        " the transmitters in network mode to determine for each slot whether t"
        "o transmit a data word and generate a transmitter empty condition (TDE"
        "=1), or to tri-state the transmitter data pins.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tsma
    },
    {
        "TSMB",
        "The Transmit Slot Mask Register B together with Transmit Slot Mask Reg"
        "ister A (ESAI_TSMA and ESAI_TSMB) are two read/write registers used by"
        " the transmitters in network mode to determine for each slot whether t"
        "o transmit a data word and generate a transmitter empty condition (TDE"
        "=1), or to tri-state the transmitter data pins.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tsmb
    },
    {
        "RSMA",
        "The Receive Slot Mask Register A together with Receive Slot Mask Regis"
        "ter B (ESAI_RSMA and ESAI_RSMB) are two read/write registers used by t"
        "he receiver in network mode to determine for each slot whether to rece"
        "ive a data word and generate a receiver full condition (RDF=1), or to "
        "ignore the received data.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_rsma
    },
    {
        "RSMB",
        "The Receive Slot Mask Register B together with Receive Slot Mask Regis"
        "ter A (ESAI_RSMA and ESAI_RSMB) are two read/write registers used by t"
        "he receiver in network mode to determine for each slot whether to rece"
        "ive a data word and generate a receiver full condition (RDF=1), or to "
        "ignore the received data.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_rsmb
    },
    {
        "PRRC",
        "There are two registers to control the ESAI personal reset status: Por"
        "t C Direction Register (ESAI_PRRC) and Port C Control Register (ESAI_P"
        "CRC).",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_prrc
    },
    {
        "PCRC",
        "The read/write 32-bit Port C Control Register (ESAI_PCRC) in conjuncti"
        "on with the Port C Direction Register (ESAI_PRRC) controls the functio"
        "nality of the ESAI personal reset state.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_pcrc
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark FLEXCAN
#endif

// Bitfields in register FLEXCAN_MCR.
static const field_t hw_flexcan_mcr[] =
{
    {
        "MAXMB",
        "This 6-bit field defines the maximum number of message buffers that wi"
        "ll take part in the matching and arbitration processes.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDAM",
        "This 2-bit field identifies the format of the elements of the Rx FIFO "
        "filter table, as shown below.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AEN",
        "This bit is supplied for backwards compatibility reasons.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPRIO_EN",
        "This bit is provided for backwards compatibility reasons.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCC",
        "This bit is provided to support Backwards Compatibility with previous "
        "FLEXCAN versions.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRX_DIS",
        "This bit defines whether FLEXCAN is allowed to receive frames transmit"
        "ted by itself.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZE",
        "This bit defines whether FLEXCAN is allowed to enter low power mode wh"
        "en Doze Mode is requested at ARM platform level.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAK_SRC",
        "This bit defines whether the integrated low-pass filter is applied to "
        "protect the Rx CAN input.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPM_ACK",
        "This read-only bit indicates that FLEXCAN is either in Disable Mode an"
        "d Stop Mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WRN_EN",
        "When asserted, this bit enables the generation of the TWRN_INT and RWR"
        "N_INT flags in the Error and Status Register.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLF_WAK",
        "This bit enables the Self Wake Up feature when FLEXCAN is in Stop Mode"
        ".",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUPV",
        "This bit configures some of the FLEXCAN registers to be either in Supe"
        "rvisor or Unrestricted memory space.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRZ_ACK",
        "This read-only bit indicates that FLEXCAN is in Freeze Mode and its pr"
        "escaler is stopped.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOFT_RST",
        "When this bit is asserted, FLEXCAN resets its internal state machines "
        "and some of the memory mapped registers.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAK_MSK",
        "This bit enables the Wake Up Interrupt generation.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NOT_RDY",
        "This read-only bit indicates that FLEXCAN is either in Disable Mode, S"
        "top Mode or Freeze Mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALT",
        "Assertion of this bit puts the FLEXCAN block into Freeze Mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEN",
        "This bit controls whether the FIFO feature is enabled or not.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRZ",
        "The FRZ bit specifies the FLEXCAN behavior when the HALT bit in the MC"
        "R Register is set or when Debug Mode is requested at ARM platform leve"
        "l.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDIS",
        "This bit controls whether FLEXCAN is enabled or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_CTRL.
static const field_t hw_flexcan_ctrl[] =
{
    {
        "PROP_SEG",
        "This 3-bit field defines the length of the Propagation Segment in the "
        "bit time.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOM",
        "This bit configures FLEXCAN to operate in Listen Only Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBUF",
        "This bit defines the ordering mechanism for Message Buffer transmissio"
        "n.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSYN",
        "This bit enables a mechanism that resets the free-running timer each t"
        "ime a message is received in Message Buffer 0.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_REC",
        "This bit defines how FLEXCAN recovers from Bus Off state.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP",
        "This bit defines the sampling mode of CAN bits at the Rx input.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWRN_MSK",
        "This bit provides a mask for the Rx Warning Interrupt associated with "
        "the RWRN_INT flag in the Error and Status Register.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWRN_MSK",
        "This bit provides a mask for the Tx Warning Interrupt associated with "
        "the TWRN_INT flag in the Error and Status Register.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPB",
        "This bit configures FLEXCAN to operate in Loop-Back Mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR_MSK",
        "This bit provides a mask for the Error Interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_MSK",
        "This bit provides a mask for the Bus Off Interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSEG2",
        "This 3-bit field defines the length of Phase Buffer Segment 2 in the b"
        "it time.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSEG1",
        "This 3-bit field defines the length of Phase Buffer Segment 1 in the b"
        "it time.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RJW",
        "This 2-bit field defines the maximum number of time quanta One time qu"
        "antum is equal to the Sclock period.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESDIV",
        "This 8-bit field defines the ratio between the CPI clock frequency and"
        " the Serial Clock (Sclock) frequency.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_TIMER.
static const field_t hw_flexcan_timer[] =
{
    {
        "TIMER",
        "Timer value  Contains the free-running counter value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXGMASK.
static const field_t hw_flexcan_rxgmask[] =
{
    {
        "MI31_MI0",
        "For normal Rx message buffers, the mask bits affect the ID filter prog"
        "rammed on the message buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RX14MASK.
static const field_t hw_flexcan_rx14mask[] =
{
    {
        "MI31_MI0",
        "Acceptance mask for the Identifier in Message Buffer 14",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RX15MASK.
static const field_t hw_flexcan_rx15mask[] =
{
    {
        "MI31_MI0",
        "Acceptance mask for the Identifier in Message Buffer 15",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_ECR.
static const field_t hw_flexcan_ecr[] =
{
    {
        "TX_ERR_COUNTER",
        "Transmit Error Counter",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_ERR_COUNTER",
        "Receive Error Counter",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_ESR.
static const field_t hw_flexcan_esr[] =
{
    {
        "WAK_INT",
        "When FLEXCAN is Stop Mode and a recessive to dominant transition is de"
        "tected on the CAN bus and if the WAK_MSK bit in the MCR Register is se"
        "t, an interrupt is generated to the ARM.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR_INT",
        "This bit indicates that at least one of the Error Bits (bits 15-10) is"
        " set.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_INT",
        "This bit is set when FLEXCAN enters Bus Off state.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLT_CONF",
        "This 2-bit field indicates the Confinement State of the FLEXCAN block,"
        " as shown in below:  If the LOM bit in the Control Register is asserte"
        "d, the FLT_CONF field will indicate Error Passive.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXRX",
        "This bit indicates if FLEXCAN is transmitting or receiving a message w"
        "hen the CAN bus is not in IDLE state.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE",
        "This bit indicates when CAN bus is in IDLE state.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_WRN",
        "This bit indicates when repetitive errors are occurring during message"
        " reception.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_WRN",
        "This bit indicates when repetitive errors are occurring during message"
        " transmission.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STF_ERR",
        "This bit indicates that a Stuffing Error has been detected.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRM_ERR",
        "This bit indicates that a Form Error has been detected by the receiver"
        " node, that is, a fixed-form bit field contains at least one illegal b"
        "it.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CRC_ERR",
        "This bit indicates that a CRC Error has been detected by the receiver "
        "node, that is, the calculated CRC is different from the received.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ACK_ERR",
        "This bit indicates that an Acknowledge Error has been detected by the "
        "transmitter node, that is, a dominant bit has not been detected during"
        " the ACK SLOT.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BIT0_ERR",
        "This bit indicates when an inconsistency occurs between the transmitte"
        "d and the received bit in a message.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BIT1_ERR",
        "This bit indicates when an inconsistency occurs between the transmitte"
        "d and the received bit in a message.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RWRN_INT",
        "If the WRN_EN bit in MCR is asserted, the RWRN_INT bit is set when the"
        " RX_WRN flag transitions from 0 to 1, meaning that the Rx error counte"
        "rs reached 96.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWRN_INT",
        "If the WRN_EN bit in MCR is asserted, the TWRN_INT bit is set when the"
        " TX_WRN flag transitions from 0 to 1, meaning that the Tx error counte"
        "r reached 96.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IMASK2.
static const field_t hw_flexcan_imask2[] =
{
    {
        "BUF63M",
        "Each bit enables or disables the respective FLEXCAN Message Buffer (MB"
        "32 to MB63) Interrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IMASK1.
static const field_t hw_flexcan_imask1[] =
{
    {
        "BUF31M_BUF0M",
        "Each bit enables or disables the respective FLEXCAN Message Buffer (MB"
        "0 to MB31) Interrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IFLAG2.
static const field_t hw_flexcan_iflag2[] =
{
    {
        "BUF63I_BUF32I",
        "Each bit flags the respective FLEXCAN Message Buffer (MB32 to MB63) in"
        "terrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IFLAG1.
static const field_t hw_flexcan_iflag1[] =
{
    {
        "BUF4I_BUF0I",
        "If the FIFO is not enabled, these bits flag the interrupts for MB0 to "
        "MB4.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF5I",
        "If the FIFO is not enabled, this bit flags the interrupt for MB5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF6I",
        "If the FIFO is not enabled, this bit flags the interrupt for MB6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF7I",
        "If the FIFO is not enabled, this bit flags the interrupt for MB7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF31I_BUF8I",
        "Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) int"
        "errupt.",
        8, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_GFWR.
static const field_t hw_flexcan_gfwr[] =
{
    {
        "GFWR",
        "It determines the Glitch Filter Width.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RX0IMR.
static const field_t hw_flexcan_rx0imr[] =
{
    {
        "MI31_MI0",
        "For normal Rx message buffers, the mask bits affect the ID filter prog"
        "rammed on the message buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RX63IMR.
static const field_t hw_flexcan_rx63imr[] =
{
    {
        "MI31_MI0",
        "For normal Rx message buffers, the mask bits affect the ID filter prog"
        "rammed on the message buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a FLEXCAN module.
static const reg_t hw_flexcan[] =
{
    {
        "MCR",
        "This register defines global system configurations, such as the block "
        "operation mode (low power, for example) and maximum message buffer con"
        "figuration.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        20, // Number of bitfields
        hw_flexcan_mcr
    },
    {
        "CTRL",
        "This register is defined for specific FLEXCAN control features related"
        " to the CAN bus, such as bit-rate, programmable sampling point within "
        "an Rx bit, Loop Back Mode, Listen Only Mode, Bus Off recovery behavior"
        " and interrupt enabling (Bus-Off, Error, Warning).",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_flexcan_ctrl
    },
    {
        "TIMER",
        "This register represents a 16-bit free running counter that can be rea"
        "d and written by the ARM.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_timer
    },
    {
        "RXGMASK",
        "Supports individual masks per message buffer, setting the BCC bit in M"
        "CR causes the RXGMASK Register to have no effect on the block operatio"
        "n.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rxgmask
    },
    {
        "RX14MASK",
        "Setting the BCC bit in MCR causes the RX14MASK Register to have no eff"
        "ect on the block operation.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rx14mask
    },
    {
        "RX15MASK",
        "Setting the BCC bit in MCR causes the RX15MASK Register to have no eff"
        "ect on the block operation.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rx15mask
    },
    {
        "ECR",
        "This register has 2 8-bit fields reflecting the value of two FLEXCAN e"
        "rror counters: Transmit Error Counter (Tx_Err_Counter field) and Recei"
        "ve Error Counter (Rx_Err_Counter field).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_flexcan_ecr
    },
    {
        "ESR",
        "This register reflects various error conditions.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_flexcan_esr
    },
    {
        "IMASK2",
        "This register allows any number of a range of 32 Message Buffer Interr"
        "upts to be enabled or disabled.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_imask2
    },
    {
        "IMASK1",
        "This register allows the enabling or disabling of any number of a rang"
        "e of 32 Message Buffer Interrupts.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_imask1
    },
    {
        "IFLAG2",
        "This register defines the flags for 32 Message Buffer interrupts.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_iflag2
    },
    {
        "IFLAG1",
        "This register defines the flags for 32 Message Buffer interrupts and F"
        "IFO interrupts.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_flexcan_iflag1
    },
    {
        "GFWR",
        "The Glitch Filter just takes effects when FLEXCAN enters the STOP mode"
        ".",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_gfwr
    },
    {
        "RX0IMR",
        "These registers are used as acceptance masks for ID filtering in Rx me"
        "ssage buffers and the FIFO.",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rx0imr
    },
    {
        "RX63IMR",
        "These registers are used as acceptance masks for ID filtering in Rx me"
        "ssage buffers and the FIFO.",
        4, // Width in bytes
        0x0000097c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rx63imr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPC
#endif

// Bitfields in register GPC_CNTR.
static const field_t hw_gpc_cntr[] =
{
    {
        "GPU_VPU_PDN_REQ",
        "GPU /VPU Power Down request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_VPU_PUP_REQ",
        "GPU /VPU Power Up request.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS0CR",
        "DVFS0 (ARM) Change request (bit is read-only)",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPCIRQM",
        "GPC interrupt/event masking",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_PGR.
static const field_t hw_gpc_pgr[] =
{
    {
        "DRCIC",
        "Debug ref cir in mux control",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR1.
static const field_t hw_gpc_imr1[] =
{
    {
        "IMR1",
        "IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR2.
static const field_t hw_gpc_imr2[] =
{
    {
        "IMR2",
        "IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR3.
static const field_t hw_gpc_imr3[] =
{
    {
        "IMR3",
        "IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR4.
static const field_t hw_gpc_imr4[] =
{
    {
        "IMR4",
        "IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR1.
static const field_t hw_gpc_isr1[] =
{
    {
        "ISR1",
        "IRQ[63:32] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR2.
static const field_t hw_gpc_isr2[] =
{
    {
        "ISR2",
        "IRQ[95:64] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR3.
static const field_t hw_gpc_isr3[] =
{
    {
        "ISR3",
        "IRQ[127:96] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR4.
static const field_t hw_gpc_isr4[] =
{
    {
        "ISR4",
        "IRQ[159:128] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPC module.
static const reg_t hw_gpc[] =
{
    {
        "CNTR",
        "CNTR - Interface control register",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpc_cntr
    },
    {
        "PGR",
        "PGR - Power Gating Register",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_pgr
    },
    {
        "IMR1",
        "IMR1 Register - masking of irq[63:32].",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr1
    },
    {
        "IMR2",
        "IMR2 Register - masking of irq[95:64].",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr2
    },
    {
        "IMR3",
        "IMR3 Register - masking of irq[127:96].",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr3
    },
    {
        "IMR4",
        "IMR4 Register - masking of irq[159:128].",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr4
    },
    {
        "ISR1",
        "ISR1 Register - status of irq [63:32].",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr1
    },
    {
        "ISR2",
        "ISR2 Register - status of irq [95:64].",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr2
    },
    {
        "ISR3",
        "ISR3 Register - status of irq [127:96].",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr3
    },
    {
        "ISR4",
        "ISR4 Register - status of irq [159:128].",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr4
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPIO
#endif

// Bitfields in register GPIO_DR.
static const field_t hw_gpio_dr[] =
{
    {
        "DR",
        "Data bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_GDIR.
static const field_t hw_gpio_gdir[] =
{
    {
        "GDIR",
        "GPIO direction bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PSR.
static const field_t hw_gpio_psr[] =
{
    {
        "PSR",
        "GPIO pad status bits (status bits).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ICR1.
static const field_t hw_gpio_icr1[] =
{
    {
        "ICR0",
        "Interrupt configuration 1 fields.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR1",
        "Interrupt configuration 1 fields.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR2",
        "Interrupt configuration 1 fields.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR3",
        "Interrupt configuration 1 fields.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR4",
        "Interrupt configuration 1 fields.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR5",
        "Interrupt configuration 1 fields.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR6",
        "Interrupt configuration 1 fields.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR7",
        "Interrupt configuration 1 fields.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR8",
        "Interrupt configuration 1 fields.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR9",
        "Interrupt configuration 1 fields.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR10",
        "Interrupt configuration 1 fields.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR11",
        "Interrupt configuration 1 fields.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR12",
        "Interrupt configuration 1 fields.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR13",
        "Interrupt configuration 1 fields.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR14",
        "Interrupt configuration 1 fields.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR15",
        "Interrupt configuration 1 fields.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ICR2.
static const field_t hw_gpio_icr2[] =
{
    {
        "ICR16",
        "Interrupt configuration 2 fields.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR17",
        "Interrupt configuration 2 fields.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR18",
        "Interrupt configuration 2 fields.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR19",
        "Interrupt configuration 2 fields.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR20",
        "Interrupt configuration 2 fields.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR21",
        "Interrupt configuration 2 fields.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR22",
        "Interrupt configuration 2 fields.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR23",
        "Interrupt configuration 2 fields.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR24",
        "Interrupt configuration 2 fields.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR25",
        "Interrupt configuration 2 fields.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR26",
        "Interrupt configuration 2 fields.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR27",
        "Interrupt configuration 2 fields.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR28",
        "Interrupt configuration 2 fields.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR29",
        "Interrupt configuration 2 fields.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR30",
        "Interrupt configuration 2 fields.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR31",
        "Interrupt configuration 2 fields.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_IMR.
static const field_t hw_gpio_imr[] =
{
    {
        "IMR",
        "Interrupt Mask bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ISR.
static const field_t hw_gpio_isr[] =
{
    {
        "ISR",
        "Interrupt status bits - Bit n of this register is asserted (active hig"
        "h) when the active condition (as determined by the corresponding ICR b"
        "it) is detected on the GPIO input and is waiting for service.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_EDGE_SEL.
static const field_t hw_gpio_edge_sel[] =
{
    {
        "GPIO_EDGE_SEL",
        "Edge select.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPIO module.
static const reg_t hw_gpio[] =
{
    {
        "DR",
        "The 32-bit GPIO_DR register stores data that is ready to be driven to "
        "the output lines.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_dr
    },
    {
        "GDIR",
        "GPIO_GDIR functions as direction control when the IOMUXC is in GPIO mo"
        "de.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_gdir
    },
    {
        "PSR",
        "GPIO_PSR is a read-only register.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpio_psr
    },
    {
        "ICR1",
        "GPIO_ICR1 contains 16 two-bit fields, where each field specifies the i"
        "nterrupt configuration for a different input signal.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_gpio_icr1
    },
    {
        "ICR2",
        "GPIO_ICR2 contains 16 two-bit fields, where each field specifies the i"
        "nterrupt configuration for a different input signal.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_gpio_icr2
    },
    {
        "IMR",
        "GPIO_IMR contains masking bits for each interrupt line.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_imr
    },
    {
        "ISR",
        "The GPIO_ISR functions as an interrupt status indicator.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_isr
    },
    {
        "EDGE_SEL",
        "GPIO_EDGE_SEL may be used to override the ICR registers' configuration"
        ".",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_edge_sel
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPT
#endif

// Bitfields in register GPT_CR.
static const field_t hw_gpt_cr[] =
{
    {
        "EN",
        "GPT Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENMOD",
        "GPT Enable mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "GPT debug mode enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "GPT Wait Mode enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEEN",
        "GPT Doze Mode Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "GPT Stop Mode enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Clock Source select.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRR",
        "Free-Run or Restart mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software reset.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IM1",
        "See IM2",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IM2",
        "IM2 (bits 19-18, Input Capture Channel 2 operating mode)  IM1 (bits 17"
        "-16, Input Capture Channel 1 operating mode)  The IM n bit field deter"
        "mines the transition on the input pin (for Input capture channel n ), "
        "which will trigger a capture event.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM1",
        "See OM3",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM2",
        "See OM3",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM3",
        "OM3 (bits 28-26) controls the Output Compare Channel 3 operating mode.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FO1",
        "See F03",
        29, // LSB
        29, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FO2",
        "See F03",
        30, // LSB
        30, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FO3",
        "FO3 Force Output Compare Channel 3  FO2 Force Output Compare Channel 2"
        "  FO1 Force Output Compare Channel 1  The FO n bit causes the pin acti"
        "on programmed for the timer Output Compare n pin (according to the OM "
        "n bits in this register).",
        31, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_PR.
static const field_t hw_gpt_pr[] =
{
    {
        "PRESCALER",
        "Prescaler bits.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_SR.
static const field_t hw_gpt_sr[] =
{
    {
        "OF1",
        "See OF3",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2",
        "See OF3",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF3",
        "OF3 Output Compare 3 Flag  OF2 Output Compare 2 Flag  OF1 Output Compa"
        "re 1 Flag  The OF n bit indicates that a compare event has occurred on"
        " Output Compare channel n .",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF1",
        "See IF2",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF2",
        "IF2 Input capture 2 Flag  IF1 Input capture 1 Flag  The IF n bit indic"
        "ates that a capture event has occurred on Input Capture channel n .",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROV",
        "Rollover Flag.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_IR.
static const field_t hw_gpt_ir[] =
{
    {
        "OF1IE",
        "See OF3IE",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2IE",
        "See OF3IE",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF3IE",
        "OF3IE Output Compare 3 Interrupt Enable  OF2IE Output Compare 2 Interr"
        "upt Enable  OF1IE Output Compare 1 Interrupt Enable  The OF n IE bit c"
        "ontrols the Output Compare Channel n interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF1IE",
        "See IF2IE",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF2IE",
        "IF2IE Input capture 2 Interrupt Enable  IF1IE Input capture 1 Interrup"
        "t Enable  The IF n IE bit controls the IF n IE Input Capture n Interru"
        "pt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROVIE",
        "Rollover Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR1.
static const field_t hw_gpt_ocr1[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR2.
static const field_t hw_gpt_ocr2[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR3.
static const field_t hw_gpt_ocr3[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_ICR1.
static const field_t hw_gpt_icr1[] =
{
    {
        "CAPT",
        "Capture Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_ICR2.
static const field_t hw_gpt_icr2[] =
{
    {
        "CAPT",
        "Capture Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_CNT.
static const field_t hw_gpt_cnt[] =
{
    {
        "COUNT",
        "Counter Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPT module.
static const reg_t hw_gpt[] =
{
    {
        "CR",
        "The GPT Control Register (GPT_CR) is used to program and configure GPT"
        " operations.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_gpt_cr
    },
    {
        "PR",
        "The GPT Prescaler Register (GPT_PR) contains bits that determine the d"
        "ivide value of the clock that runs the counter.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_pr
    },
    {
        "SR",
        "The GPT Status Register (GPT_SR) contains bits that indicate that a co"
        "unter has rolled over, and if any event has occurred on the Input Capt"
        "ure and Output Compare channels.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpt_sr
    },
    {
        "IR",
        "The GPT Interrupt Register (GPT_IR) contains bits that control whether"
        " interrupts are generated after rollover, input capture and output com"
        "pare events.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpt_ir
    },
    {
        "OCR1",
        "The GPT Compare Register 1 (GPT_OCR1) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 1.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr1
    },
    {
        "OCR2",
        "The GPT Compare Register 2 (GPT_OCR2) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 2.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr2
    },
    {
        "OCR3",
        "The GPT Compare Register 3 (GPT_OCR3) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 3.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr3
    },
    {
        "ICR1",
        "The GPT Input Capture Register 1 (GPT_ICR1) is a read-only register th"
        "at holds the value that was in the counter during the last capture eve"
        "nt on Input Capture Channel 1.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_icr1
    },
    {
        "ICR2",
        "The GPT Input capture Register 2 (GPT_ICR2) is a read-only register wh"
        "ich holds the value that was in the counter during the last capture ev"
        "ent on input capture channel 2.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_icr2
    },
    {
        "CNT",
        "The GPT Counter Register (GPT_CNT) is the main counter's register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_cnt
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPU2D
#endif

// Bitfields in register GPU2D_AQHICLOCKCONTROL.
static const field_t hw_gpu2d_aqhiclockcontrol[] =
{
    {
        "MULTI_PIPE_USE_SINGLE_AXI",
        "Force all the transactions to go to one AXI.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULTI_PIPE_REG_SELECT",
        "Determines which HI/MC to use while reading registers.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISOLATE_GPU",
        "Isolate GPU bit",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE_VG",
        "VG pipe is idle.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE2_D",
        "2D pipe is idle.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE3_D",
        "3D pipe is idle.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOFT_RESET",
        "Soft resets the IP.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_DEBUG_REGISTERS",
        "Disable debug registers.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_RAM_CLOCK_GATING",
        "Disables clock gating for rams.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSCALE_CMD_LOAD",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSCALE_VAL",
        "",
        23, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK2D_DIS",
        "Disable 2D clock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK3D_DIS",
        "Disable 3D clock.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQHIIDLE.
static const field_t hw_gpu2d_aqhiidle[] =
{
    {
        "AXI_LP",
        "AXI is in low power mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_TS",
        "TS is idle.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_FP",
        "FP is idle.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_IM",
        "IM is idle.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_VG",
        "VG is idle.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_TX",
        "TX is idle.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_RA",
        "RA is idle.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_SE",
        "SE is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_PA",
        "PA is idle.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_SH",
        "SH is idle.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_PE",
        "PE is idle.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_DE",
        "DE is idle.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_FE",
        "FE is idle.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQAXICONFIG.
static const field_t hw_gpu2d_aqaxiconfig[] =
{
    {
        "ARCACHE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWCACHE",
        "",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARID",
        "",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWID",
        "",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQAXISTATUS.
static const field_t hw_gpu2d_aqaxistatus[] =
{
    {
        "WR_ERR_ID",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_ERR_ID",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DET_WR_ERR",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DET_RD_ERR",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQINTRACKNOWLEDGE.
static const field_t hw_gpu2d_aqintracknowledge[] =
{
    {
        "INTR_VEC",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQINTRENBL.
static const field_t hw_gpu2d_aqintrenbl[] =
{
    {
        "INTR_ENBL_VEC",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQIDENT.
static const field_t hw_gpu2d_aqident[] =
{
    {
        "CUSTOMER",
        "Customer value.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TECHNOLOGY",
        "Technology value.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision value.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRODUCT",
        "Product value.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAMILY",
        "Family value.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_FEATURES.
static const field_t hw_gpu2d_features[] =
{
    {
        "FE20_BIT_INDEX",
        "Supports 20 bit index.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RS_YUV_TARGET",
        "Supports resolving into YUV target.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYTE_WRITE_3D",
        "3D PE has byte write capability.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FE20",
        "FE 2.0 is present.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VGTS",
        "VG tessellator is present.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_VG",
        "VG pipe is present.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEM32_BIT_SUPPORT",
        "32 bit memory address support.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUY2_RENDER_TARGET",
        "YUY2 support in PE and YUY2 to RGB conversion in resolve.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALF_TX_CACHE",
        "TX cache is half.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALF_PE_CACHE",
        "PE cache is half.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUY2_AVERAGING",
        "YUY2 averaging support in resolve.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO_SCALER",
        "IP does not have 2D scaler.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYTE_WRITE_2D",
        "Supports byte write in 2D.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUFFER_INTERLEAVING",
        "IP supports interleaving depth and color buffers.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO422_TEXTURE",
        "IP does not have 422 texture input format.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO_EZ",
        "IP does not have early-Z.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIN_AREA",
        "IP is configured to have minimum area.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CG",
        "Second level clock gating is available.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUV420_TILER",
        "YUV 4:2:0 tiler is available.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HIGH_DYNAMIC_RANGE",
        "Shows if the IP has HDR support.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAST_SCALER",
        "Shows if the IP has HD scaler.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETC1_TEXTURE_COMPRESSION",
        "ETC1 texture compression.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_2D",
        "Shows if there is 2D engine.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        "Shows if there is a display controller in the IP.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MSAA",
        "MSAA support.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUV420_FILTER",
        "YUV 4:2:0 support in filter blit.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZCOMPRESSION",
        "Depth and color compression.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_MODE",
        "Debug registers.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DXT_TEXTURE_COMPRESSION",
        "DXT texture compression.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_3D",
        "3D pipe.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPECIAL_ANTI_ALIASING",
        "Full-screen anti-aliasing.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAST_CLEAR",
        "Fast clear.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPID.
static const field_t hw_gpu2d_chipid[] =
{
    {
        "ID",
        "Id.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPREV.
static const field_t hw_gpu2d_chiprev[] =
{
    {
        "REV",
        "Revision.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPDATE.
static const field_t hw_gpu2d_chipdate[] =
{
    {
        "DATE",
        "Date.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPTIME.
static const field_t hw_gpu2d_chiptime[] =
{
    {
        "TIME",
        "Time.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPCUSTOMER.
static const field_t hw_gpu2d_chipcustomer[] =
{
    {
        "GROUP",
        "Group.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPANY",
        "Company.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MINORFEATURES0.
static const field_t hw_gpu2d_minorfeatures0[] =
{
    {
        "FLIP_Y",
        "Y flipping capability is added to resolve.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DUAL_RETURN_BUS",
        "Dual Return Bus from HI to clients.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENDIANNESS_CONFIG",
        "Configurable endianness support.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEXTURE8_K",
        "Supports 8Kx8K textures.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_TEXTURE_CONVERTER",
        "Driver hack is not needed.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPECIAL_MSAA_LOD",
        "Special LOD calculation when MSAA is on.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAST_CLEAR_FLUSH",
        "Proper flush is done in fast clear cache.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "_2DPE20",
        "2D PE 2.0 is present.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_AUTO_DISABLE",
        "Auto disable in FC is correct.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RENDER_8K",
        "Supports 8K render target.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TILE_STATUS_2BITS",
        "2 bits are used instead of 4 bits for tile status.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEPARATE_TILE_STATUS_WHEN_INTERLEAVED",
        "Use 2 separate tile status buffers in interleaved mode.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SUPER_TILED_32X32",
        "32x32 super tile is available.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_20",
        "Major updates to VG pipe (TS buffer tiling.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TS_EXTENDED_COMMANDS",
        "New commands added to the tessellator.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPRESSION_FIFO_FIXED",
        "If this bit is not set, the FIFO counter should be set to 50.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXTRA_SHADER_INSTRUCTIONS0",
        "Floor, ceil, and sign instructions are available.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_FILTER",
        "VG filter is available.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_21",
        "Minor updates to VG pipe (Event generation from VG, TS, PE).",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SHADER_GETS_W",
        "W is sent to SH from RA.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXTRA_SHADER_INSTRUCTIONS1",
        "Sqrt, sin, cos instructions are available.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEFAULT_REG0",
        "Unavailable registers will return 0.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MC_20",
        "New style MC with separate paths for color and depth.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SHADER_MSAA_SIDEBAND",
        "Put the MSAA data into sideband fifo.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES0",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VAA",
        "VAA is available or not.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYPASS_IN_MSAA",
        "Shader supports bypass mode when MSAA is enabled.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HIERARCHICAL_Z",
        "Hierarchiccal Z is supported.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEW_TEXTURE",
        "New texture unit is available.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A8_TARGET_SUPPORT",
        "2D engine supports A8 target.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_STENCIL",
        "Correct stencil behavior in depth only.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENHANCE_VR",
        "Enhance VR and add a mode to walk 16 pixels in 16-bit mode in Vertical"
        " pass to improve $ hit rate when rotating 90/270.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CACHECONTROL.
static const field_t hw_gpu2d_cachecontrol[] =
{
    {
        "NOT_USED",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_RESETMEMCOUNTERS.
static const field_t hw_gpu2d_resetmemcounters[] =
{
    {
        "RESET",
        "",
        0, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALREADS.
static const field_t hw_gpu2d_totalreads[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALWRITES.
static const field_t hw_gpu2d_totalwrites[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPSPECS.
static const field_t hw_gpu2d_chipspecs[] =
{
    {
        "VERTEX_OUTPUT_BUFFER_SIZE",
        "Log2 of vertex output buffer size.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_PIXEL_PIPES",
        "Number of pixel pipes.",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_SHADER_CORES",
        "Number of shader cores.",
        7, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VERTEX_CACHE_SIZE",
        "Number of entries in the vertex shader cache.",
        15, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "THREAD_COUNT",
        "Log2 of thread count.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_REGISTERS",
        "Log2 of temporary registers.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STREAMS",
        "Number of vertex streams.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALWRITEBURSTS.
static const field_t hw_gpu2d_totalwritebursts[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALWRITEREQS.
static const field_t hw_gpu2d_totalwritereqs[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALWRITELASTS.
static const field_t hw_gpu2d_totalwritelasts[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALREADBURSTS.
static const field_t hw_gpu2d_totalreadbursts[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALREADREQS.
static const field_t hw_gpu2d_totalreadreqs[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALREADLASTS.
static const field_t hw_gpu2d_totalreadlasts[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_GPOUT0.
static const field_t hw_gpu2d_gpout0[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_GPOUT1.
static const field_t hw_gpu2d_gpout1[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_GPOUT2.
static const field_t hw_gpu2d_gpout2[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AXICONTROL.
static const field_t hw_gpu2d_axicontrol[] =
{
    {
        "WR_FULL_BURST_MODE",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MINORFEATURES1.
static const field_t hw_gpu2d_minorfeatures1[] =
{
    {
        "TEXTURE_STRIDE",
        "Texture has stride and memory addressing.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES2",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES1",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_DOUBLE_BUFFER",
        "Double buffering support for VG (second TS-->VG semaphore is present).",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "V2_COMPRESSION",
        "V2 compression.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSUV_SWIZZLE",
        "Resolve UV swizzle.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALCYCLES.
static const field_t hw_gpu2d_totalcycles[] =
{
    {
        "CYCLES",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALIDLECYLES.
static const field_t hw_gpu2d_totalidlecyles[] =
{
    {
        "CYCLES",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPSPECS2.
static const field_t hw_gpu2d_chipspecs2[] =
{
    {
        "CYCLES",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MODULEPOWERCONTROLS.
static const field_t hw_gpu2d_modulepowercontrols[] =
{
    {
        "TURN_OFF_COUNTER",
        "Counter value for clock gating the module if the module is idle for th"
        "is amount of clock cycles.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TURN_ON_COUNTER",
        "Number of clock cycles to wait after turning on the clock.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_STARVE_MODULE_CLOCK_GATING",
        "Disables module level clock gating for starve/idle condition.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_STALL_MODULE_CLOCK_GATING",
        "Disables module level clock gating for stall condition.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_MODULE_CLOCK_GATING",
        "Enables module level clock gating.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MODULEPOWERMODULECONTROL.
static const field_t hw_gpu2d_modulepowermodulecontrol[] =
{
    {
        "DISABLE_MODULE_CLOCK_GATING_TS",
        "Disables module level clock gating for TS.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_FP",
        "Disables module level clock gating for FP.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_IM",
        "Disables module level clock gating for IM.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_VG",
        "Disables module level clock gating for VG.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_TX",
        "Disables module level clock gating for TX.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_RA",
        "Disables module level clock gating for RA.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_SE",
        "Disables module level clock gating for SE.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_PA",
        "Disables module level clock gating for PA.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_SH",
        "Disables module level clock gating for SH.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_PE",
        "Disables module level clock gating for PE.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_DE",
        "Disables module level clock gating for DE.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_FE",
        "Disables module level clock gating for FE.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MODULEPOWERMODULESTATUS.
static const field_t hw_gpu2d_modulepowermodulestatus[] =
{
    {
        "MODULE_CLOCK_GATED_TS",
        "Module level clock gating is ON for TS.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_FP",
        "Module level clock gating is ON for FP.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_IM",
        "Module level clock gating is ON for IM.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_VG",
        "Module level clock gating is ON for VG.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_TX",
        "Module level clock gating is ON for TX.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_RA",
        "Module level clock gating is ON for RA.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_SE",
        "Module level clock gating is ON for SE.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_PA",
        "Module level clock gating is ON for PA.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_SH",
        "Module level clock gating is ON for SH.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_PE",
        "Module level clock gating is ON for PE.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_DE",
        "Module level clock gating is ON for DE.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_FE",
        "Module level clock gating is ON for FE.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPU2D module.
static const reg_t hw_gpu2d[] =
{
    {
        "AQHICLOCKCONTROL",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_gpu2d_aqhiclockcontrol
    },
    {
        "AQHIIDLE",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        13, // Number of bitfields
        hw_gpu2d_aqhiidle
    },
    {
        "AQAXICONFIG",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpu2d_aqaxiconfig
    },
    {
        "AQAXISTATUS",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpu2d_aqaxistatus
    },
    {
        "AQINTRACKNOWLEDGE",
        "Interrupt acknowledge register.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_aqintracknowledge
    },
    {
        "AQINTRENBL",
        "Interrupt enable register.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_aqintrenbl
    },
    {
        "AQIDENT",
        "Identification register.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_gpu2d_aqident
    },
    {
        "FEATURES",
        "Shows which features are enabled in this chip.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_gpu2d_features
    },
    {
        "CHIPID",
        "Shows the ID for the chip in BCD.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_chipid
    },
    {
        "CHIPREV",
        "Shows the revision for the chip in BCD.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_chiprev
    },
    {
        "CHIPDATE",
        "Shows the release date for the IP.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_chipdate
    },
    {
        "CHIPTIME",
        "Shows the release time for the IP.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_chiptime
    },
    {
        "CHIPCUSTOMER",
        "Shows the customer and group for the IP.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_gpu2d_chipcustomer
    },
    {
        "MINORFEATURES0",
        "Shows which minor features are enabled in this chip.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_gpu2d_minorfeatures0
    },
    {
        "CACHECONTROL",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_cachecontrol
    },
    {
        "RESETMEMCOUNTERS",
        "Writing 1 will reset the counters and stop counting.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_resetmemcounters
    },
    {
        "TOTALREADS",
        "Total reads in terms of 64bits.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalreads
    },
    {
        "TOTALWRITES",
        "Total writes in terms of 64bits.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalwrites
    },
    {
        "CHIPSPECS",
        "Specs for the chip.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_gpu2d_chipspecs
    },
    {
        "TOTALWRITEBURSTS",
        "Total write Data Count in terms of 64bits.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalwritebursts
    },
    {
        "TOTALWRITEREQS",
        "Total write Request Count.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalwritereqs
    },
    {
        "TOTALWRITELASTS",
        "Total WLAST Count.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalwritelasts
    },
    {
        "TOTALREADBURSTS",
        "Total Read Data Count in terms of 64bits.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalreadbursts
    },
    {
        "TOTALREADREQS",
        "Total Read Request Count.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalreadreqs
    },
    {
        "TOTALREADLASTS",
        "Total RLAST Count.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalreadlasts
    },
    {
        "GPOUT0",
        "General Purpose output register0.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_gpout0
    },
    {
        "GPOUT1",
        "General Purpose output register1.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_gpout1
    },
    {
        "GPOUT2",
        "General Purpose output register2.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_gpout2
    },
    {
        "AXICONTROL",
        "Special Handling on AXI Bus",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_axicontrol
    },
    {
        "MINORFEATURES1",
        "Shows which features are enabled in this chip.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_gpu2d_minorfeatures1
    },
    {
        "TOTALCYCLES",
        "Total cycles.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalcycles
    },
    {
        "TOTALIDLECYLES",
        "Total cycles where the GPU is idle.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalidlecyles
    },
    {
        "CHIPSPECS2",
        "Specs for the chip.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_chipspecs2
    },
    {
        "MODULEPOWERCONTROLS",
        "The Power Management register set has just a few registers for control"
        "ling clock gating within the core.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_gpu2d_modulepowercontrols
    },
    {
        "MODULEPOWERMODULECONTROL",
        "Module level control registers.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpu2d_modulepowermodulecontrol
    },
    {
        "MODULEPOWERMODULESTATUS",
        "Module level control status.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        false, // Writable
        12, // Number of bitfields
        hw_gpu2d_modulepowermodulestatus
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPU3D
#endif

// Bitfields in register GPU3D_AQH_CLK_CTRL.
static const field_t hw_gpu3d_aqh_clk_ctrl[] =
{
    {
        "CLK3D_DIS",
        "Disable 3D clock.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK2D_DIS",
        "Disable 2D clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSCALE_VAL",
        "",
        2, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSCALE_CMD_LOAD",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_RAM_CLOCK_GATING",
        "Disables clock gating for rams.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_DEBUG_REGISTERS",
        "Disable debug registers.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOFT_RESET",
        "Soft resets the IP.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE3_D",
        "3D pipe is idle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE2_D",
        "2D pipe is idle.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE_VG",
        "VG is idle.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISOLATE_GPU",
        "Isolate GPU bit",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULTI_PIPE_REG_SELECT",
        "Determines which HI/MC to use while reading registers.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULTI_PIPE_USE_SINGLE_AXI",
        "Force all the transactions to go to one AXI",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_AQH_IDLE.
static const field_t hw_gpu3d_aqh_idle[] =
{
    {
        "IDLE_FE",
        "FE is idle.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_DE",
        "DE is idle.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_PE",
        "PE is idle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_SH",
        "SH is idle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_PA",
        "PA is idle.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_SE",
        "SE is idle.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_RA",
        "RA is idle.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_TX",
        "TX is idle.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_VG",
        "VG is idle.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_IM",
        "IM is idle.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_FP",
        "FP is idle.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_TS",
        "TS is idle.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AXI_LP",
        "AXI is in low power mode.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_AQA_CFG.
static const field_t hw_gpu3d_aqa_cfg[] =
{
    {
        "AWID",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARID",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWCACHE",
        "",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCACHE",
        "",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_AQA_STATUS.
static const field_t hw_gpu3d_aqa_status[] =
{
    {
        "WR_ERR_ID",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_ERR_ID",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DET_WR_ERR",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DET_RD_ERR",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_AQI_ACK.
static const field_t hw_gpu3d_aqi_ack[] =
{
    {
        "INTR_VEC",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_AQI_ENBL.
static const field_t hw_gpu3d_aqi_enbl[] =
{
    {
        "INTR_ENBL_VEC",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_AQIDENT.
static const field_t hw_gpu3d_aqident[] =
{
    {
        "CUSTOMER",
        "Customer value.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TECHNOLOGY",
        "Technology value.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision value.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRODUCT",
        "Product value.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAMILY",
        "Family value.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GC_FEAT.
static const field_t hw_gpu3d_gc_feat[] =
{
    {
        "FAST_CLEAR",
        "Fast clear.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPECIAL_ANTI_ALIASING",
        "Full-screen anti-aliasing.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_3D",
        "3D pipe.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DXT_TEXTURE_COMPRESSION",
        "DXT texture compression.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_MODE",
        "Debug registers.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZCOMPRESSION",
        "Depth and color compression.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUV420_FILTER",
        "YUV 4:2:0 support in filter blit.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MSAA",
        "MSAA support.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        "Shows if there is a display controller in the IP.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_2D",
        "Shows if there is 2D engine.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETC1_TEXTURE_COMPRESSION",
        "ETC1 texture compression.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAST_SCALER",
        "Shows if the IP has HD scaler.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HIGH_DYNAMIC_RANGE",
        "Shows if the IP has HDR support.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUV420_TILER",
        "YUV 4:2:0 tiler is available.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CG",
        "Secong level clock gating is available.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIN_AREA",
        "IP is configured to have minimum area.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO_EZ",
        "IP does not have early-Z.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO422_TEXTURE",
        "IP does not have 422 texture input format.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUFFER_INTERLEAVING",
        "IP supports interleaving depth and color buffers.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYTE_WRITE_2D",
        "Supports byte write in 2D.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO_SCALER",
        "IP does not have 2D scaler.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUY2_AVERAGING",
        "YUY2 averaging support in resolve.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALF_PE_CACHE",
        "PE cache is half.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALF_TX_CACHE",
        "TX cache is half.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUY2_RENDER_TARGET",
        "YUY2 support in PE and YUY2 to RGB conversion in resolve.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEM32_BIT_SUPPORT",
        "32 bit memory address support.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_VG",
        "VCG pipe is present.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VGTS",
        "VG tessellator is present.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FE20",
        "FE 2.0 is present.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYTE_WRITE_3D",
        "3D PE has byte write capability.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RS_YUV_TARGET",
        "Supports resolving into YUV target.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FE20_BIT_INDEX",
        "Supports 20 bit index.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCC_ID.
static const field_t hw_gpu3d_gcc_id[] =
{
    {
        "ID",
        "Id",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCC_REV.
static const field_t hw_gpu3d_gcc_rev[] =
{
    {
        "REV",
        "Revision",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCC_DATE.
static const field_t hw_gpu3d_gcc_date[] =
{
    {
        "DATE",
        "Date",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCC_TIME.
static const field_t hw_gpu3d_gcc_time[] =
{
    {
        "TIME",
        "Time",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCC_CUST.
static const field_t hw_gpu3d_gcc_cust[] =
{
    {
        "GROUP",
        "Group",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPANY",
        "Company",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCM_FEAT_0.
static const field_t hw_gpu3d_gcm_feat_0[] =
{
    {
        "FLIP_Y",
        "Y flipping capability is added to resolve.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DUAL_RETURN_BUS",
        "Dual Return Bus from HI to clients.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENDIANNESS_CONFIG",
        "Configurable endianness support.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TESTURE8_K",
        "Supports 8Kx8K textures.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_TEXTURE_CONVERTER",
        "Driver hack is not needed.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPECIAL_MSAA_LOD",
        "Special LOD calculation when MSAA is on.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAST_CLEAR_FLUSH",
        "Proper flush is done in fast clear cache.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "_2DPE20",
        "2D PE 2.0 is present.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_AUTO_DISABLE",
        "Auto disable in FC is correct.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RENDER_8K",
        "Supports 8K render target.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TILE_STATUS_2BITS",
        "2 bits are used instead of 4 bits for tile status.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEPARATE_TILE_STATUS_WHEN_INTERLEAVED",
        "Use 2 separate tile status buffers in interleaved mode.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SUPER_TILED_32X32",
        "32x32 super tile is available.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_20",
        "Major updates to VG pipe (TS buffer tiling.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TS_EXTENDED_COMMANDS",
        "New commands added to the tessellator.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPRESSION_FIFO_FIXED",
        "If this bit is not set, the FIFO counter should be set to 50.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXTRA_SHADER_INSTRUCTIONS0",
        "Floor, ceil, and sign instructions are available.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_FILTER",
        "VG filter is available.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_21",
        "Minor updates to VG pipe (Event generation from VG, TS, PE).",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SHADER_GETS_W",
        "W is sent to SH from RA.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXTRA_SHADER_INSTRUCTIONS1",
        "Sqrt, sin, cos intructions are available.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEFAULT_REG0",
        "Unavailable registers will return 0.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MC_20",
        "New stlye MC with separate paths for color and depth.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SHADER_MSAA_SIDEBAND",
        "Put the MSAA data into sideband fifo.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES0",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VAA",
        "VAA is available or not.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYPASS_IN_MSAA",
        "Shader supports bypass modew when MSAA is enabled.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HIERARCHICAL_Z",
        "Hierarchical Z is supported.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEW_TEXTURE",
        "New texture unit is available.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A8_TARGET_SUPPORT",
        "2D engine supports A8 target.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_STENCIL",
        "Correct stencil behavior in depth only.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENHANCE_VR",
        "Enhance VR and add a mode to walk 16 pixels in 16-bit mode in Vertical"
        " pass to improve $ hit rate when rotating 90/270.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCC_CRTL.
static const field_t hw_gpu3d_gcc_crtl[] =
{
    {
        "NOT_USED",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCR_MEM_CTRS.
static const field_t hw_gpu3d_gcr_mem_ctrs[] =
{
    {
        "RESET",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_READS.
static const field_t hw_gpu3d_gct_reads[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_WRITES.
static const field_t hw_gpu3d_gct_writes[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCC_SPECS.
static const field_t hw_gpu3d_gcc_specs[] =
{
    {
        "STREAMS",
        "Number of vertex streams.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEAMP_REGISTERS",
        "Log2 of temporary registers.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "THREAD_COUNT",
        "Log2 of thread count.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VERTEX_CACHE_SIZE",
        "Number of entries in the vertex shader cache.",
        12, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_SHADER_CORES",
        "Number of shader cores.",
        20, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_PIXEL_PIPES",
        "Number of pixel pipes.",
        25, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VERTEX_OUTPUT_BUFFER_SIZE",
        "Log2 of vertex output buffer size.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_WRITE_BURSTS.
static const field_t hw_gpu3d_gct_write_bursts[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_WRITE_REQS.
static const field_t hw_gpu3d_gct_write_reqs[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_WRITE_LASTS.
static const field_t hw_gpu3d_gct_write_lasts[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_READ_BURSTS.
static const field_t hw_gpu3d_gct_read_bursts[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_READ_REQS.
static const field_t hw_gpu3d_gct_read_reqs[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_READ_LASTS.
static const field_t hw_gpu3d_gct_read_lasts[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCGPO_0.
static const field_t hw_gpu3d_gcgpo_0[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCGPO_1.
static const field_t hw_gpu3d_gcgpo_1[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCGPO_2.
static const field_t hw_gpu3d_gcgpo_2[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCA_CRTL.
static const field_t hw_gpu3d_gca_crtl[] =
{
    {
        "WR_FULL_BURST_MODE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCM_FEAT_1.
static const field_t hw_gpu3d_gcm_feat_1[] =
{
    {
        "RSUV_SWIZZLE",
        "Resolve UV swizzle.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "V2_COMPRESSION",
        "V2 compression.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_DOUBLE_BUFFER",
        "Double buffering support for VG (second TS-->VG semaphore is present).",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES1",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES2",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEXTURE_STRIDE",
        "Texture has stride and memory addressing.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_CYCLES.
static const field_t hw_gpu3d_gct_cycles[] =
{
    {
        "CYCLES",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU3D_GCT_IDLE_CYCLES.
static const field_t hw_gpu3d_gct_idle_cycles[] =
{
    {
        "CYCLES",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPU3D module.
static const reg_t hw_gpu3d[] =
{
    {
        "AQH_CLK_CTRL",
        "Clock control register.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_gpu3d_aqh_clk_ctrl
    },
    {
        "AQH_IDLE",
        "Idle status register.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        13, // Number of bitfields
        hw_gpu3d_aqh_idle
    },
    {
        "AQA_CFG",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpu3d_aqa_cfg
    },
    {
        "AQA_STATUS",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_gpu3d_aqa_status
    },
    {
        "AQI_ACK",
        "Interrupt acknowledge register.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_aqi_ack
    },
    {
        "AQI_ENBL",
        "Interrupt enable register.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_aqi_enbl
    },
    {
        "AQIDENT",
        "Identification register.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_gpu3d_aqident
    },
    {
        "GC_FEAT",
        "Shows which features are enabled in this chip.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_gpu3d_gc_feat
    },
    {
        "GCC_ID",
        "Shows the ID for the chip in SBCD.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcc_id
    },
    {
        "GCC_REV",
        "Shows the revision for the chip in BCD.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcc_rev
    },
    {
        "GCC_DATE",
        "Shows the release date for the IP.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcc_date
    },
    {
        "GCC_TIME",
        "Shows the release time for the IP.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcc_time
    },
    {
        "GCC_CUST",
        "Shows the customer and group for the IP.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_gpu3d_gcc_cust
    },
    {
        "GCM_FEAT_0",
        "Shows which minor features are enabled in this chip.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_gpu3d_gcm_feat_0
    },
    {
        "GCC_CRTL",
        "Not used.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcc_crtl
    },
    {
        "GCR_MEM_CTRS",
        "Writing 1 will reset the counters and stop counting.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcr_mem_ctrs
    },
    {
        "GCT_READS",
        "Total reads in terms of 64 bits.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_reads
    },
    {
        "GCT_WRITES",
        "Total writes in terms of 64 bits.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_writes
    },
    {
        "GCC_SPECS",
        "Specs for the chip.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_gpu3d_gcc_specs
    },
    {
        "GCT_WRITE_BURSTS",
        "Total write Data Count in terms of 64 bits.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_write_bursts
    },
    {
        "GCT_WRITE_REQS",
        "Total write Request Count.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_write_reqs
    },
    {
        "GCT_WRITE_LASTS",
        "Total WLAST Count.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_write_lasts
    },
    {
        "GCT_READ_BURSTS",
        "Total Read Data COunt in terms of 64 bits.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_read_bursts
    },
    {
        "GCT_READ_REQS",
        "Total Read Request Count.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_read_reqs
    },
    {
        "GCT_READ_LASTS",
        "Total RLAST Count.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_read_lasts
    },
    {
        "GCGPO_0",
        "General Purpose output register 0.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcgpo_0
    },
    {
        "GCGPO_1",
        "General Purpose output register 1.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcgpo_1
    },
    {
        "GCGPO_2",
        "General Purpose output register 2.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_gcgpo_2
    },
    {
        "GCA_CRTL",
        "Speacial Handling on AXI Bus.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_gca_crtl
    },
    {
        "GCM_FEAT_1",
        "Shows which features are enabled in this chip.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_gpu3d_gcm_feat_1
    },
    {
        "GCT_CYCLES",
        "Total cycles.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_cycles
    },
    {
        "GCT_IDLE_CYCLES",
        "Total cycles where the GPU is idle.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu3d_gct_idle_cycles
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark HDMI
#endif

// Bitfields in register HDMI_DESIGN_ID.
static const field_t hw_hdmi_design_id[] =
{
    {
        "DESIGN_ID",
        "This is a 1 byte design ID code fixed by Freescale that Identifies the"
        " main revision of the HDMI TX controller.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_REVISION_ID.
static const field_t hw_hdmi_revision_id[] =
{
    {
        "REVISION_ID",
        "This is a one byte revision ID code fixed by Freescale that Identifies"
        " the main revision of the HDMI TX controller.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PRODUCT_ID0.
static const field_t hw_hdmi_product_id0[] =
{
    {
        "PRODUCT_ID0",
        "This one byte fixed code Identifies Freescale's product line (\"A0h\" "
        "for HDMI TX products).",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PRODUCT_ID1.
static const field_t hw_hdmi_product_id1[] =
{
    {
        "PRODUCT_ID1",
        "This one byte fixed code identifies Freescale's product line according"
        " to:  01h HDMI TX Controller  02h DWC_hdmi_rx Controller  C1h HDMI TX "
        "Controller with HDCP encryption engine  C2h DWC_hdmi_rx Controller wit"
        "h encryption engine",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CONFIG0_ID.
static const field_t hw_hdmi_config0_id[] =
{
    {
        "HDCP",
        "Indicates if HDCP is present",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CEC",
        "Indicates if CEC is present",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Indicates if Color Space Conversion block is present",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HDMI14",
        "Indicates if HDMI 1.4 features are present",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDI2S",
        "Indicates if I2S interface is present",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDSPDIF",
        "Indicates if SPDIF interface is present",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDHBR",
        "Indicates if HBR interface is present",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PREPEN",
        "Indicates if it is possible to use internal pixel repetition",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CONFIG1_ID.
static const field_t hw_hdmi_config1_id[] =
{
    {
        "CONFAHB",
        "Indicates that configuration interface is AHB interface",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CONFAPB",
        "Indicates that configuration interface is APB interface",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CONFOCP",
        "Indicates that configuration interface is OCP interface",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CONFI2C",
        "Indicates that configuration interface is I2C interface",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CONFSFRDIR",
        "Indicates that configuration interface is SFR interface",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CONFIG2_ID.
static const field_t hw_hdmi_config2_id[] =
{
    {
        "PHYTYPE",
        "Indicates the type of PHY interface selected:  00h Legacy PHY (HDMI TX"
        " PHY)  F2h PHY_Gen2 (HDMI 3D TX PHY)  E2h PHY_Gen2 (HDMI 3D TX PHY) + "
        "HEAC PHY",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CONFIG3_ID.
static const field_t hw_hdmi_config3_id[] =
{
    {
        "CONFGPAUD",
        "Indicates that configuration interface is Generic Parallel Audio (GPAU"
        "D) interface",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_FC_STAT0.
static const field_t hw_hdmi_ih_fc_stat0[] =
{
    {
        "NULL_",
        "Active after successful transmission of an Null packet.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        "Active after successful transmission of an Audio Clock Regeneration (N"
        "/CTS transmission) packet.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDS",
        "Active after successful transmission of an Audio Sample packet.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBA",
        "Reserved",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DST",
        "Reserved",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBR",
        "Active after successful transmission of an Audio HBR packet.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACP",
        "Active after successful transmission of an Audio Content Protection pa"
        "cket.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDI",
        "Active after successful transmission of an Audio InfoFrame packet.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_FC_STAT1.
static const field_t hw_hdmi_ih_fc_stat1[] =
{
    {
        "GCP",
        "Active after successful transmission of an General Control Packet.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVI",
        "Active after successful transmission of an AVI infoFrame packet.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPEG",
        "Reserved",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD",
        "Active after successful transmission of an Source Product Descriptor i"
        "nfoFrame packet.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSD",
        "Active after successful transmission of an Vendor Specific Data infoFr"
        "ame packet.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR2",
        "Active after successful transmission of an International Standard Reco"
        "rding Code 2 packet.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR1",
        "Active after successful transmission of an International Standard Reco"
        "rding Code 1 packet.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GMD",
        "Active after successful transmission of an Gamut metadata packet.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_FC_STAT2.
static const field_t hw_hdmi_ih_fc_stat2[] =
{
    {
        "HIGHPRIORITY_OVERFLOW",
        "Frame Composer high priority packet queue descriptor overflow indicati"
        "on.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOWPRIORITY_OVERFLOW",
        "Frame Composer low priority packet queue descriptor overflow indicatio"
        "n.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_AS_STAT0.
static const field_t hw_hdmi_ih_as_stat0[] =
{
    {
        "AUD_FIFO_OVERFLOW",
        "Audio Sampler audio FIFO full indication.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUD_FIFO_UNDERFLOW",
        "Audio Sampler audio FIFO empty indication.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUD_FIFO_UNDERFLOW_THR",
        "Audio Sampler audio FIFO empty threshold (four samples) indication.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_PHY_STAT0.
static const field_t hw_hdmi_ih_phy_stat0[] =
{
    {
        "HDP",
        "HDMI Hot Plug Detect indication.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_PHY_LOCK",
        "TX PHY PLL lock indication.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE",
        "TX PHY RX_SENSE indication for driver 0.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE1",
        "TX PHY RX_SENSE indication for driver 1.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE2",
        "TX PHY RX_SENSE indication for driver 2.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE3",
        "TX PHY RX_SENSE indication for driver 3.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_I2CM_STAT0.
static const field_t hw_hdmi_ih_i2cm_stat0[] =
{
    {
        "I2CMASTER_ERROR",
        "I2C Master error indication",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "I2CMASTERDONE",
        "I2C Master done indication",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_CEC_STAT0.
static const field_t hw_hdmi_ih_cec_stat0[] =
{
    {
        "DONE",
        "CEC Done Indication",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOM",
        "CEC End of Message Indication",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK",
        "CEC Nack indication",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARB_LOST",
        "CEC Arb_Lost indication",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_INITIATOR",
        "CEC Error_follow indication",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_FOLLOW",
        "CEC Error_follow indication",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "CEC Wake-up indication",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_VP_STAT0.
static const field_t hw_hdmi_ih_vp_stat0[] =
{
    {
        "FIFOEMPTYBYP",
        "Video packetizer 8-bit bypass fifo empty interrupt",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOFULLBYP",
        "Video packetizer 8-bit bypass fifo full interrupt",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOEMPTYREMAP",
        "Video packetizer pixel YCC 422 re-mapper FIFO empty interrupt",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOFULLREMAP",
        "Video packetizer pixel YCC 422 re-mapper FIFO full interrupt",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOEMPTYPP",
        "Video packetizer pixel packing FIFO empty interrupt",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOFULLPP",
        "Video packetizer pixel packing FIFO full interrupt",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOEMPTYREPET",
        "Video packetizer pixel repeater FIFO empty interrupt",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOFULLREPET",
        "Video packetizer pixel repeater FIFO full interrupt",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_I2CMPHY_STAT0.
static const field_t hw_hdmi_ih_i2cmphy_stat0[] =
{
    {
        "I2CMPHYERROR",
        "I2C Master PHY error indication",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "I2CMPHYDONE",
        "I2C Master PHY done indication",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_AHBDMAAUD_STAT0.
static const field_t hw_hdmi_ih_ahbdmaaud_stat0[] =
{
    {
        "AHBDMAAUD_INTBUFFEMPTY",
        "AHB audio DMA Buffer empty interrupt",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTBUFFFULL",
        "AHB audio DMA Buffer full interrupt",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTDONE",
        "AHB audio DMA done interrupt",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTRETRYSPLIT",
        "AHB audio DMA RETRY/SPLIT interrupt",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTLOSTOWNERSHIP",
        "AHB audio DMA lost ownership interrupt",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTERROR",
        "AHB audio DMA error interrupt",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_FC_STAT0.
static const field_t hw_hdmi_ih_mute_fc_stat0[] =
{
    {
        "NULL_",
        "When set to 1, mutes IH_ FC_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        "When set to 1, mutes IH_ FC_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDS",
        "When set to 1, mutes IH_ FC_STAT0[2]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBA",
        "When set to 1, mutes IH_ FC_STAT0[3]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DST",
        "When set to 1, mutes IH_ FC_STAT0[4]",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBR",
        "When set to 1, mutes IH_ FC_STAT0[5]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACP",
        "When set to 1, mutes IH_ FC_STAT0[6]",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDI",
        "When set to 1, mutes IH_ FC_STAT0[7]",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_FC_STAT1.
static const field_t hw_hdmi_ih_mute_fc_stat1[] =
{
    {
        "GCP",
        "When set to 1, mutes IH_ FC_STAT1[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVI",
        "When set to 1, mutes IH_ FC_STAT1[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPEG",
        "When set to 1, mutes IH_ FC_STAT1[2]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD",
        "When set to 1, mutes IH_ FC_STAT1[3]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSD",
        "When set to 1, mutes IH_ FC_STAT1[4]",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR2",
        "When set to 1, mutes IH_ FC_STAT1[5]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR1",
        "When set to 1, mutes IH_ FC_STAT1[6]",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GMD",
        "When set to 1, mutes IH_ FC_STAT1[7]",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_FC_STAT2.
static const field_t hw_hdmi_ih_mute_fc_stat2[] =
{
    {
        "HIGHPRIORITY_OVERFLOW",
        "When set to 1, mutes IH_ FC_STAT2[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOWPRIORITY_OVERFLOW",
        "When set to 1, mutes IH_ FC_STAT2[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_AS_STAT0.
static const field_t hw_hdmi_ih_mute_as_stat0[] =
{
    {
        "AUD_FIFO_OVERFLOW",
        "When set to 1, mutes IH_ AS_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUD_FIFO_UNDERFLOW",
        "When set to 1, mutes IH_ AS_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUD_FIFO_UNDERFLOW_THR",
        "When set to 1, mutes IH_ AS_STAT0[2]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_PHY_STAT0.
static const field_t hw_hdmi_ih_mute_phy_stat0[] =
{
    {
        "HDP",
        "When set to 1, mutes IH_ PHY_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_PHY_LOCK",
        "When set to 1, mutes IH_ PHY_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE",
        "When set to 1, mutes IH_ PHY_STAT0[2]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE1",
        "When set to 1, mutes IH_ PHY_STAT0[3]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE2",
        "When set to 1, mutes IH_ PHY_STAT0[4]",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE3",
        "When set to 1, mutes IH_ PHY_STAT0[5]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_I2CM_STAT0.
static const field_t hw_hdmi_ih_mute_i2cm_stat0[] =
{
    {
        "I2CMASTER_ERROR",
        "When set to 1, mutes IH_ I2CM_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "I2CMASTERDONE",
        "When set to 1, mutes IH_ I2CM_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_CEC_STAT0.
static const field_t hw_hdmi_ih_mute_cec_stat0[] =
{
    {
        "DONE",
        "When set to 1, mutes IH_ CEC_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOM",
        "When set to 1, mutes IH_ CEC_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK",
        "When set to 1, mutes IH_ CEC_STAT0[2]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARB_LOST",
        "When set to 1, mutes IH_ CEC_STAT0[3]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_INITIATOR",
        "When set to 1, mutes IH_ CEC_STAT0[4]",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_FOLLOW",
        "When set to 1, mutes IH_ CEC_STAT0[5]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "When set to 1, mutes IH_ CEC_STAT0[6]",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_VP_STAT0.
static const field_t hw_hdmi_ih_mute_vp_stat0[] =
{
    {
        "FIFOEMPTYBYP",
        "When set to 1, mutes IH_ VP_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOFULLBYP",
        "When set to 1, mutes IH_ VP_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOEMPTYREMAP",
        "When set to 1, mutes IH_ VP_STAT0[2]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOFULLREMAP",
        "When set to 1, mutes IH_ VP_STAT0[3]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOEMPTYPP",
        "When set to 1, mutes IH_ VP_STAT0[4]",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOFULLPP",
        "When set to 1, mutes IH_ VP_STAT0[5]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOEMPTYREPET",
        "When set to 1, mutes IH_ VP_STAT0[6]",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOFULLREPET",
        "When set to 1, mutes IH_ VP_STAT0[7]",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_I2CMPHY_STAT0.
static const field_t hw_hdmi_ih_mute_i2cmphy_stat0[] =
{
    {
        "I2CMPHYERROR",
        "When set to 1, mutes IH_ I2CMPHY_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "I2CMPHYDONE",
        "When set to 1, mutes IH_ I2CMPHY_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE_AHBDMAAUD_STAT0.
static const field_t hw_hdmi_ih_mute_ahbdmaaud_stat0[] =
{
    {
        "AHBDMAAUD_INTBUFFEMPTY",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTBUFFFULL",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTDONE",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[2]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTRETRYSPLIT",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[3]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTLOSTOWNERSHIP",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[4]",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTERROR",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[5]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_IH_MUTE.
static const field_t hw_hdmi_ih_mute[] =
{
    {
        "AHBDMAAUD_INTBUFFEMPTY",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[0]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTBUFFFULL",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[1]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTDONE",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[2]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTRETRYSPLIT",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[3]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTLOSTOWNERSHIP",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[4]",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHBDMAAUD_INTERROR",
        "When set to 1, mutes IH_AHBDMAAUD_STAT0[5]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_TX_INVID0.
static const field_t hw_hdmi_tx_invid0[] =
{
    {
        "VIDEO_MAPPING",
        "video_mapping",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERNAL_DE_GENERATOR",
        "Internal data enable (DE) generator enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_TX_INSTUFFING.
static const field_t hw_hdmi_tx_instuffing[] =
{
    {
        "GYDATA_STUFFING",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCRDATA_STUFFING",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCBDATA_STUFFING",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_TX_GYDATA0.
static const field_t hw_hdmi_tx_gydata0[] =
{
    {
        "GYDATA",
        "gydata[7:0].This register defines the value of gydata[7:0] when TX_INS"
        "TUFFING[0] (gydata_stuffing) is set to 1b.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_TX_GYDATA1.
static const field_t hw_hdmi_tx_gydata1[] =
{
    {
        "GYDATA",
        "gydata[15:8].This register defines the value of gydata[15:8] when TX_I"
        "NSTUFFING[0] (gydata_stuffing) is set to 1b.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_TX_RCRDATA0.
static const field_t hw_hdmi_tx_rcrdata0[] =
{
    {
        "RCRDATA",
        "rcrdata[7:0].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_TX_RCRDATA1.
static const field_t hw_hdmi_tx_rcrdata1[] =
{
    {
        "RCRDATA",
        "rcrdata[15:8].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_TX_BCBDATA0.
static const field_t hw_hdmi_tx_bcbdata0[] =
{
    {
        "BCBDATA",
        "bcbdata[7:0].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_TX_BCBDATA1.
static const field_t hw_hdmi_tx_bcbdata1[] =
{
    {
        "BCBDATA",
        "bcbdata[15:8].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_STATUS.
static const field_t hw_hdmi_vp_status[] =
{
    {
        "PACKING_PHASE",
        "Read only register that holds the \"packing phase\" output by the Vide"
        "o packetizer block.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_PR_CD.
static const field_t hw_hdmi_vp_pr_cd[] =
{
    {
        "DESIRED_PR_FACTOR",
        "Desired pixel repetition factor configuration.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COLOR_DEPTH",
        "Color depth configuration:  other Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_STUFF.
static const field_t hw_hdmi_vp_stuff[] =
{
    {
        "PR_STUFFING",
        "Pixel repeater stuffing control",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_STUFFING",
        "Pixel packing stuffing control",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCC422_STUFFING",
        "YCC 422 remap stuffing control.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICX_GOTO_P0_ST",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IFIX_PP_TO_LAST",
        "Reserved.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDEFAULT_PHASE",
        "Controls the default phase packing machine used according to: \"If the"
        " transmitted video format has timing such that the phase of the first "
        "pixel of every Video Data Period corresponds to pixel packing phase 0 "
        "(for example, 10P0, 12P0, 16P0), the Source may set the Default_Phase "
        "bit in the GCP.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_REMAP.
static const field_t hw_hdmi_vp_remap[] =
{
    {
        "YCC422_SIZE",
        "YCC 422 remap input video size:",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_CONF.
static const field_t hw_hdmi_vp_conf[] =
{
    {
        "OUTPUT_SELECTOR",
        "Video packetizer output selection.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_SELECT",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCC422_EN",
        "YCC 422 select enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR_EN",
        "Pixel repeater enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_EN",
        "Pixel packing enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_EN",
        "Bypass enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_STAT.
static const field_t hw_hdmi_vp_stat[] =
{
    {
        "OSTEMPTYBYP",
        "Video packetizer 8-bit bypass FIFO empty status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSTFULLBYP",
        "Video packetizer 8-bit bypass FIFO full status.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSTEMPTYREMAP",
        "Video packetizer pixel YCC 422 re-mapper FIFO empty status.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSTFULLREMAP",
        "Video packetizer pixel YCC 422 re-mapper FIFO full status.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSTEMPTYPP",
        "Video packetizer pixel packing FIFO empty status.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSTFULLPP",
        "Video packetizer pixel packing FIFO full status.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSTEMPTYREPET",
        "Video packetizer pixel repeater FIFO empty status.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSTFULLREPET",
        "Video packetizer pixel repeater FIFO full status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_INT.
static const field_t hw_hdmi_vp_int[] =
{
    {
        "OINTEMPTYBYP",
        "Video packetizer 8-bit bypass FIFO empty status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OINTFULLBYP",
        "Video packetizer 8-bit bypass FIFO full status.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OINTEMPTYREMAP",
        "Video packetizer pixel YCC 422 re-mapper FIFO empty status.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OINTFULLREMAP",
        "Video packetizer pixel YCC 422 re-mapper FIFO full status.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OINTEMPTYPP",
        "Video packetizer pixel packing FIFO empty status",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OINTFULLPP",
        "Video packetizer pixel packing FIFO full status",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OINTEMPTYREPET",
        "Video packetizer pixel repeater FIFO empty status",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OINTFULLREPET",
        "Video packetizer pixel repeater FIFO full status",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_MASK.
static const field_t hw_hdmi_vp_mask[] =
{
    {
        "VPMASK",
        "Mask bit for VP_INT[0] interrupt bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPMASK1",
        "Mask bit for VP_INT[1] interrupt bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPMASK2",
        "Mask bit for VP_INT[2] interrupt bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPMASK3",
        "Mask bit for VP_INT[3] interrupt bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPMASK4",
        "Mask bit for VP_INT[4] interrupt bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPMASK5",
        "Mask bit for VP_INT[5] interrupt bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPMASK6",
        "Mask bit for VP_INT[6] interrupt bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPMASK7",
        "Mask bit for VP_INT[7] interrupt bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_VP_POL.
static const field_t hw_hdmi_vp_pol[] =
{
    {
        "VPPOL",
        "Polarity bit for VP_INT[0] interrupt bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPPOL1",
        "Polarity bit for VP_INT[1] interrupt bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPPOL2",
        "Polarity bit for VP_INT[2] interrupt bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPPOL3",
        "Polarity bit for VP_INT[3] interrupt bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPPOL4",
        "Polarity bit for VP_INT[4] interrupt bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPPOL5",
        "Polarity bit for VP_INT[5] interrupt bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPPOL6",
        "Polarity bit for VP_INT[6] interrupt bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPPOL7",
        "Polarity bit for VP_INT[7] interrupt bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INHACTIV0.
static const field_t hw_hdmi_fc_inhactiv0[] =
{
    {
        "H_IN_ACTIV",
        "Input video Horizontal active pixel region width.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INHACTIV1.
static const field_t hw_hdmi_fc_inhactiv1[] =
{
    {
        "H_IN_ACTIV",
        "Input video Horizontal active pixel region width.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INHBLANK0.
static const field_t hw_hdmi_fc_inhblank0[] =
{
    {
        "H_IN_BLANK",
        "Input video Horizontal blanking pixel region width.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INHBLANK1.
static const field_t hw_hdmi_fc_inhblank1[] =
{
    {
        "H_IN_BLANK",
        "Input video Horizontal blanking pixel region width.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INVACTIV0.
static const field_t hw_hdmi_fc_invactiv0[] =
{
    {
        "V_IN_ACTIV",
        "Input video Vertical active pixel region width.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INVACTIV1.
static const field_t hw_hdmi_fc_invactiv1[] =
{
    {
        "V_IN_ACTIV",
        "Input video Vertical active pixel region width.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INVBLANK.
static const field_t hw_hdmi_fc_invblank[] =
{
    {
        "V_IN_BLANK",
        "Input video Vertical blanking pixel region width.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_HSYNCINDELAY0.
static const field_t hw_hdmi_fc_hsyncindelay0[] =
{
    {
        "H_IN_DELAY",
        "Input video Hsync active edge delay.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_HSYNCINDELAY1.
static const field_t hw_hdmi_fc_hsyncindelay1[] =
{
    {
        "H_IN_DELAY",
        "Input video Hsync active edge delay.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_HSYNCINWIDTH0.
static const field_t hw_hdmi_fc_hsyncinwidth0[] =
{
    {
        "H_IN_WIDTH",
        "Input video Hsync active pulse width.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_HSYNCINWIDTH1.
static const field_t hw_hdmi_fc_hsyncinwidth1[] =
{
    {
        "H_IN_WIDTH",
        "Input video Hsync active pulse width.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSYNCINDELAY.
static const field_t hw_hdmi_fc_vsyncindelay[] =
{
    {
        "V_IN_DELAY",
        "Input video Vsync active edge delay.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSYNCINWIDTH.
static const field_t hw_hdmi_fc_vsyncinwidth[] =
{
    {
        "V_IN_WIDTH",
        "Value after Reset: 000000b  Input video Vsync active pulse width: Inte"
        "ger number of pixel clock cycles [0...63].",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INFREQ0.
static const field_t hw_hdmi_fc_infreq0[] =
{
    {
        "INFREQ",
        "Video refresh rate in Hz*1E3 format.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INFREQ1.
static const field_t hw_hdmi_fc_infreq1[] =
{
    {
        "INFREQ",
        "Video refresh rate in Hz*1E3 format.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INFREQ2.
static const field_t hw_hdmi_fc_infreq2[] =
{
    {
        "INFREQ",
        "Video refresh rate in Hz*1E3 format.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_CTRLDUR.
static const field_t hw_hdmi_fc_ctrldur[] =
{
    {
        "CTRLPERIODDURATION",
        "Configuration of the control period minimum duration (min.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_EXCTRLDUR.
static const field_t hw_hdmi_fc_exctrldur[] =
{
    {
        "EXCTRLPERIODDURATION",
        "Configuration of the extended control period minimum duration (min.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_EXCTRLSPAC.
static const field_t hw_hdmi_fc_exctrlspac[] =
{
    {
        "EXCTRLPERIODSPACING",
        "Configuration of the maximum spacing between consecutive extended cont"
        "rol periods (max of 50msec, see HDMI 1.4a specification):  generated s"
        "pacing = (1/freq tmds clock)*256*256*extctrlperiodspacing",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_CH0PREAM.
static const field_t hw_hdmi_fc_ch0pream[] =
{
    {
        "CH0_PREAMBLE_FILTER",
        "When in control mode, configures 8-bits that are going to fill the cha"
        "nnel 0 data lines not used to transmit the preamble (for more clarific"
        "ations refer to HDMI 1.4a specification).",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_CH1PREAM.
static const field_t hw_hdmi_fc_ch1pream[] =
{
    {
        "CH1_PREAMBLE_FILTER",
        "When in control mode, configures 6-bits that are going to fill the cha"
        "nnel 1 data lines not used to transmit the preamble (for more clarific"
        "ations refer to HDMI 1.4a specification).",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_CH2PREAM.
static const field_t hw_hdmi_fc_ch2pream[] =
{
    {
        "CH2_PREAMBLE_FILTER",
        "When in control mode, configures 6-bits that are going to fill the cha"
        "nnel 2 data lines not used to transmit the preamble (for more clarific"
        "ations, see HDMI 1.4a specification).",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVICONF3.
static const field_t hw_hdmi_fc_aviconf3[] =
{
    {
        "CN1",
        "IT content type according to CEA specification",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YQ1",
        "Quantization range according to CEA specification.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GCP.
static const field_t hw_hdmi_fc_gcp[] =
{
    {
        "CLEAR_AVMUTE",
        "Value of \"clear_avmute\" in the GCP packet.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SET_AVMUTE",
        "Value of \"set_avmute\" in the GCP packet.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEFAULT_PHASE",
        "Value of \"default_phase\" in the GCP packet.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVICONF0.
static const field_t hw_hdmi_fc_aviconf0[] =
{
    {
        "FC_AVICONF0",
        "RGB/YCC indication  Value after Reset: 0b",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FC_AVICONF01",
        "Bar information",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FC_AVICONF02",
        "Scan information",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FC_AVICONF03",
        "Active format present",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FC_AVICONF04",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVICONF1.
static const field_t hw_hdmi_fc_aviconf1[] =
{
    {
        "FC_AVICONF1",
        "Active aspect ratio  Value after Reset: 0b",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FC_AVICONF11",
        "Picture aspect ratio",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FC_AVICONF0",
        "Colorimetry",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVICONF2.
static const field_t hw_hdmi_fc_aviconf2[] =
{
    {
        "FC_AVICONF2",
        "Non-uniform picture scaling  Value after Reset: 0b",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FC_AVICONF21",
        "Extended colorimetry",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FC_AVICONF22",
        "IT content",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVIVID.
static const field_t hw_hdmi_fc_avivid[] =
{
    {
        "FC_AVIVID",
        "the AVI infoFrame Video Identification code.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVIETB0.
static const field_t hw_hdmi_fc_avietb0[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVIETB1.
static const field_t hw_hdmi_fc_avietb1[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVISBB0.
static const field_t hw_hdmi_fc_avisbb0[] =
{
    {
        "FC_AVISBB0",
        "Line number of Start of Bottom Bar (lower 8 bits)",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVISBB1.
static const field_t hw_hdmi_fc_avisbb1[] =
{
    {
        "FC_AVISBB1",
        "Line number of Start of Bottom Bar (upper 8 bits)",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVIELB0.
static const field_t hw_hdmi_fc_avielb0[] =
{
    {
        "FC_AVIELB0",
        "Pixel number of end of left Bar (lower 8 bits)",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVIELB1.
static const field_t hw_hdmi_fc_avielb1[] =
{
    {
        "FC_AVIELB1",
        "Pixel number of end of left Bar (lower 8 bits)",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVISRB0.
static const field_t hw_hdmi_fc_avisrb0[] =
{
    {
        "FC_AVISRB0",
        "Pixel number of start of right Bar (lower 8 bits)",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AVISRB1.
static const field_t hw_hdmi_fc_avisrb1[] =
{
    {
        "FC_AVISRB1",
        "Pixel number of start of right Bar (upper 8 bits)",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AUDICONF0.
static const field_t hw_hdmi_fc_audiconf0[] =
{
    {
        "CT",
        "Coding Type",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CC",
        "Channel count",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AUDICONF1.
static const field_t hw_hdmi_fc_audiconf1[] =
{
    {
        "SF",
        "Sampling frequency",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS",
        "Sampling size",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AUDICONF2.
static const field_t hw_hdmi_fc_audiconf2[] =
{
    {
        "CA",
        "Channel allocation",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AUDICONF3.
static const field_t hw_hdmi_fc_audiconf3[] =
{
    {
        "LSV",
        "Level shift value (for down mixing)",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DM_INH",
        "Down mix enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LFEPBL",
        "LFE playback information",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDIEEEID0.
static const field_t hw_hdmi_fc_vsdieeeid0[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDSIZE.
static const field_t hw_hdmi_fc_vsdsize[] =
{
    {
        "VSDSIZE",
        "Packet size as described in HDMI Vendor Specific InfoFrame (from HDMI "
        "specification).",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDIEEEID1.
static const field_t hw_hdmi_fc_vsdieeeid1[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDIEEEID2.
static const field_t hw_hdmi_fc_vsdieeeid2[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD0.
static const field_t hw_hdmi_fc_vsdpayload0[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD1.
static const field_t hw_hdmi_fc_vsdpayload1[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD2.
static const field_t hw_hdmi_fc_vsdpayload2[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD3.
static const field_t hw_hdmi_fc_vsdpayload3[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD4.
static const field_t hw_hdmi_fc_vsdpayload4[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD5.
static const field_t hw_hdmi_fc_vsdpayload5[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD6.
static const field_t hw_hdmi_fc_vsdpayload6[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD7.
static const field_t hw_hdmi_fc_vsdpayload7[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD8.
static const field_t hw_hdmi_fc_vsdpayload8[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD9.
static const field_t hw_hdmi_fc_vsdpayload9[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD10.
static const field_t hw_hdmi_fc_vsdpayload10[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD11.
static const field_t hw_hdmi_fc_vsdpayload11[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD12.
static const field_t hw_hdmi_fc_vsdpayload12[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD13.
static const field_t hw_hdmi_fc_vsdpayload13[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD14.
static const field_t hw_hdmi_fc_vsdpayload14[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD15.
static const field_t hw_hdmi_fc_vsdpayload15[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD16.
static const field_t hw_hdmi_fc_vsdpayload16[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD17.
static const field_t hw_hdmi_fc_vsdpayload17[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD18.
static const field_t hw_hdmi_fc_vsdpayload18[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD19.
static const field_t hw_hdmi_fc_vsdpayload19[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD20.
static const field_t hw_hdmi_fc_vsdpayload20[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD21.
static const field_t hw_hdmi_fc_vsdpayload21[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD22.
static const field_t hw_hdmi_fc_vsdpayload22[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_VSDPAYLOAD23.
static const field_t hw_hdmi_fc_vsdpayload23[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_SPDVENDORNAME0.
static const field_t hw_hdmi_fc_spdvendorname0[] =
{
    {
        "VENDOR_NAME",
        "Vendor name",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_SPDPRODUCTNAME0.
static const field_t hw_hdmi_fc_spdproductname0[] =
{
    {
        "PRODUCT_NAME",
        "Product name",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_SPDDEVICEINF.
static const field_t hw_hdmi_fc_spddeviceinf[] =
{
    {
        "PRODUCT_DESCRIPTOR",
        "Product descriptor",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AUDSCONF.
static const field_t hw_hdmi_fc_audsconf[] =
{
    {
        "AUD_PACKET_LAYOUT",
        "Set the audio packet layout to be sent in the packet:",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUD_PACKET_SAMPFIT",
        "Set the audio packet sample flat value to be sent on the packet.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_AUDSSTAT.
static const field_t hw_hdmi_fc_audsstat[] =
{
    {
        "PACKET_SAMPPRS",
        "Shows the data sample present indication of the last Audio sample pack"
        "et sent by the HDMI TX Controller.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_CTRLQHIGH.
static const field_t hw_hdmi_fc_ctrlqhigh[] =
{
    {
        "ONHIGHATTENDED",
        "Configures the number of high priority packets or audio sample packets"
        " consecutively attended before checking low priority queue status.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_CTRLQLOW.
static const field_t hw_hdmi_fc_ctrlqlow[] =
{
    {
        "ONLOWATTENDED",
        "Configures the number of low priority packets or null packets consecut"
        "ively attended before checking high priority queue status or audio sam"
        "ple availability.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_ACP0.
static const field_t hw_hdmi_fc_acp0[] =
{
    {
        "ACPTYPE",
        "Configures the ACP packet type.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_ACP1.
static const field_t hw_hdmi_fc_acp1[] =
{
    {
        "AUDIO_CONTENTPACKET",
        "Audio content packet",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_ISCR1_0.
static const field_t hw_hdmi_fc_iscr1_0[] =
{
    {
        "ISRC_CONT",
        "Indication of ISRC2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISRC_VALID",
        "Valid of ISRC1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISRC_STATUS",
        "Status of ISRC1.",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_ISCR1_1.
static const field_t hw_hdmi_fc_iscr1_1[] =
{
    {
        "ISRC1",
        "Configures the contents of the ISRC1 packet:",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_ISCR2_0.
static const field_t hw_hdmi_fc_iscr2_0[] =
{
    {
        "ISRC2",
        "Configures the contents of the ISRC1 packet:",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DATAUTO0.
static const field_t hw_hdmi_fc_datauto0[] =
{
    {
        "ACP_AUTO",
        "Enables ACP automatic packet scheduling",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR1_AUTO",
        "Enables ISRC1 automatic packet scheduling",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR2_AUTO",
        "Enables ISRC2 automatic packet scheduling",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSD_AUTO",
        "Enables VSD automatic packet scheduling",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD_AUTO",
        "Enables SPD automatic packet scheduling",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DATAUTO1.
static const field_t hw_hdmi_fc_datauto1[] =
{
    {
        "AUTO_FRAME_INTERPOLATION",
        "Packet frame interpolation, for automatic packet scheduling",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DATAUTO2.
static const field_t hw_hdmi_fc_datauto2[] =
{
    {
        "AUTO_LINE_SPACING",
        "Packets line spacing, for automatic packet scheduling",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_FRAME_PACKETS",
        "Packets per frame, for automatic packet scheduling",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DATMAN.
static const field_t hw_hdmi_fc_datman[] =
{
    {
        "ACP_TX",
        "ACP packet",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    {
        "ISR1_TX",
        "ISRC1 packet",
        1, // LSB
        1, // MSB
        false, // Readable
        true // Writable
    },
    {
        "ISCR2_TX",
        "ISRC2 packet",
        2, // LSB
        2, // MSB
        false, // Readable
        true // Writable
    },
    {
        "VSD_TX",
        "VSD packet",
        3, // LSB
        3, // MSB
        false, // Readable
        true // Writable
    },
    {
        "SPD_TX",
        "SPD packet",
        4, // LSB
        4, // MSB
        false, // Readable
        true // Writable
    },
    {
        "NULL_TX",
        "Null packet",
        5, // LSB
        5, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DATAUTO3.
static const field_t hw_hdmi_fc_datauto3[] =
{
    {
        "ACR_AUTO",
        "Enable ACR packet insertion",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDI_AUTO",
        "Enable AUDI packet insertion",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GCP_AUTO",
        "Enable GCP packet insertion",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVI_AUTO",
        "Enable AVI packet insertion",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_RDRB0.
static const field_t hw_hdmi_fc_rdrb0[] =
{
    {
        "ACRFRAMEINTERPOLATION",
        "ACR frame interpolation",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_RDRB1.
static const field_t hw_hdmi_fc_rdrb1[] =
{
    {
        "ACRPACKETLINESPACING",
        "ACR packet line spacing",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACRPACKETSINFRAME",
        "ACR packets in frame",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_RDRB2.
static const field_t hw_hdmi_fc_rdrb2[] =
{
    {
        "AUDIFRAMEINTERPOLATION",
        "Audio frame interpolation",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_RDRB3.
static const field_t hw_hdmi_fc_rdrb3[] =
{
    {
        "AUDIPACKETLINESPACING",
        "Audio packets line spacing",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIPACKETSINFRAME",
        "Audio packets per frame",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_RDRB4.
static const field_t hw_hdmi_fc_rdrb4[] =
{
    {
        "GCPFRAMEINTERPOLATION",
        "GCP packets line spacing",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_RDRB5.
static const field_t hw_hdmi_fc_rdrb5[] =
{
    {
        "GCPPACKETLINESPACING",
        "GCP packets line spacing",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GCPPACKETSINFRAME",
        "GCP packets per frame",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_RDRB6.
static const field_t hw_hdmi_fc_rdrb6[] =
{
    {
        "AVIFRAMEINTERPOLATION",
        "GCP packets line spacing",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_RDRB7.
static const field_t hw_hdmi_fc_rdrb7[] =
{
    {
        "AVIPACKETLINESPACING",
        "AVI packets line spacing",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVIPACKETSINFRAME",
        "AVI packets per frame",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_STAT0.
static const field_t hw_hdmi_fc_stat0[] =
{
    {
        "NULL_",
        "Status bit  Active after successful transmission of an Null packet.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ACR",
        "Status bit  Active after successful transmission of an Audio Clock Reg"
        "eneration (N/CTS transmission) packet.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDS",
        "Status bit  Active after successful transmission of an Audio Sample pa"
        "cket.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HBR",
        "Status bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ACP",
        "Status bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDI",
        "Status bit  Active after successful transmission of an Audio InfoFrame"
        " packet.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INT0.
static const field_t hw_hdmi_fc_int0[] =
{
    {
        "NULL_",
        "Interrupt indication bit  Active after successful transmission of an N"
        "ull packet interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        "Interrupt indication bit  Active after successful transmission of an A"
        "udio Clock Regeneration (N/CTS transmission) packet interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDS",
        "Interrupt indication bit  Active after successful transmission of an A"
        "udio Sample packet interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBR",
        "Interrupt indication bit  Active after successful transmission of a Au"
        "dio HBR packet interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACP",
        "Interrupt indication bit  Active after successful transmission of an A"
        "udio Content Protection packet interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDI",
        "Interrupt indication bit  Active after successful transmission of an A"
        "udio InfoFrame packet interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_MASK0.
static const field_t hw_hdmi_fc_mask0[] =
{
    {
        "NULL_",
        "Mask bit for FC_INT0.NULL interrupt bit  Value after Reset: 0b",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        "Mask bit for FC_INT0.ACR interrupt bit  Value after Reset: 0b",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDS",
        "Mask bit for FC_INT0.AUDS interrupt bit  Value after Reset: 0b",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBR",
        "Mask bit for FC_INT0.HBR interrupt bit  Value after Reset: 0b",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACP",
        "Mask bit for FC_INT0.ACP interrupt bit  Value after Reset: 0b",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDI",
        "Mask bit for FC_INT0.AUDI interrupt bit  Value after Reset: 0b",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_POL0.
static const field_t hw_hdmi_fc_pol0[] =
{
    {
        "NULL_",
        "Polarity bit for FC_INT0.NULL interrupt bit  Value after Reset: 0b",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        "Polarity bit for FC_INT0.ACR interrupt bit  Value after Reset: 0b",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDS",
        "Polarity bit for FC_INT0.AUDS interrupt bit  Value after Reset: 0b",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBR",
        "Polarity bit for FC_INT0.HBR interrupt bit  Value after Reset: 0b",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACP",
        "Polarity bit for FC_INT0.ACP interrupt bit  Value after Reset: 0b",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDI",
        "Polarity bit for FC_INT0.AUDI interrupt bit  Value after Reset: 0b",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_STAT1.
static const field_t hw_hdmi_fc_stat1[] =
{
    {
        "GCP",
        "Status bit  Active after successful transmission of an General Content"
        " Packet.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVI",
        "Status bit  Active after successful transmission of an AVI infoFrame p"
        "acket.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD",
        "Active after successful transmission of an Source Product Descriptor i"
        "nfoFrame packet.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSD",
        "Active after successful transmission of an Vendor Specific Data infoFr"
        "ame packet.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR2",
        "Active after successful transmission of an International Standard Reco"
        "rding Code 2 packet.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR1",
        "Status bit  Active after successful transmission of an International S"
        "tandard Recording Code 1 packet.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GMD",
        "Status bit  Active after successful transmission of an Gamut metadata "
        "packet.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INT1.
static const field_t hw_hdmi_fc_int1[] =
{
    {
        "GCP",
        "Interrupt indication bit  Active after successful transmission of an G"
        "eneral Content Packet interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVI",
        "Interrupt indication bit  Active after successful transmission of an A"
        "VI infoFrame packet interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD",
        "Interrupt indication bit  Active after successful transmission of an S"
        "ource Product Descriptor infoFrame packet interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSD",
        "Interrupt indication bit  Active after successful transmission of an V"
        "endor Specific Data infoFrame packet interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR2",
        "Interrupt indication bit  Active after successful transmission of an I"
        "nternational Standard Recording  Code 2 packet interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR1",
        "Interrupt indication bit  Active after successful transmission of an I"
        "nternational Standard Recording  Code 1 packet interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GMD",
        "Interrupt indication bit  Active after successful transmission of an G"
        "amut metadata packet interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_MASK1.
static const field_t hw_hdmi_fc_mask1[] =
{
    {
        "GCP",
        "Mask bit for FC_INT1.GCP interrupt bit",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVI",
        "Mask bit for FC_INT1.AVI interrupt bit",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD",
        "Mask bit for FC_INT1.SPD interrupt bit",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSD",
        "Mask bit for FC_INT1.VSD interrupt bit",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR2",
        "Mask bit for FC_INT1.ISRC2 interrupt bit",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR1",
        "Mask bit for FC_INT1.ISRC1 interrupt bit",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GMD",
        "Mask bit for FC_INT1.GMD interrupt bit",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_POL1.
static const field_t hw_hdmi_fc_pol1[] =
{
    {
        "GCP",
        "Polarity bit for FC_INT1.GCP interrupt bit",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVI",
        "Polarity bit for FC_INT1.AVI interrupt bit",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD",
        "Polarity bit for FC_INT1.SPD interrupt bit",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSD",
        "Polarity bit for FC_INT1.VSD interrupt bit",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR2",
        "Polarity bit for FC_INT1.ISRC2 interrupt bit",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISCR1",
        "Polarity bit for FC_INT1.ISRC1 interrupt bit",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GMD",
        "Polarity bit for FC_INT1.GMD interrupt bit",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_STAT2.
static const field_t hw_hdmi_fc_stat2[] =
{
    {
        "HIGHPRIORITY_OVERFLOW",
        "Status bit  Frame Composer high priority packet queue descriptor overf"
        "low indication.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOWPRIORITY_OVERFLOW",
        "Status bit  Frame Composer low priority packet queue descriptor overfl"
        "ow indication.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_INT2.
static const field_t hw_hdmi_fc_int2[] =
{
    {
        "HIGHPRIORITY_OVERFLOW",
        "Interrupt indication bit  Frame Composer high priority packet queue de"
        "scriptor overflow indication interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOWPRIORITY_OVERFLOW",
        "Interrupt indication bit  Frame Composer low priority packet queue des"
        "criptor overflow indication interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_MASK2.
static const field_t hw_hdmi_fc_mask2[] =
{
    {
        "HIGHPRIORITY_OVERFLOW",
        "Mask bit for FC_INT1.HighPriority_overflow interrupt bit  Value after "
        "Reset: 0b",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOWPRIORITY_OVERFLOW",
        "Mask bit for FC_INT1.LowPriority_overflow interrupt bit  Value after R"
        "eset: 0b",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_POL2.
static const field_t hw_hdmi_fc_pol2[] =
{
    {
        "HIGHPRIORITY_OVERFLOW",
        "Polarity bit for FC_INT1.HighPriority_overflow interrupt bit  Value af"
        "ter Reset: 1b",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOWPRIORITY_OVERFLOW",
        "Polarity bit for FC_INT1.LowPriority_overflow interrupt bit  Value aft"
        "er Reset: 1b",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_PRCONF.
static const field_t hw_hdmi_fc_prconf[] =
{
    {
        "OUTPUT_PR_FACTOR",
        "Configures the video pixel repetition ratio to be sent on the AVI info"
        "Frame.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INCOMING_PR_FACTOR",
        "Configures the input video pixel repetition.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_STAT.
static const field_t hw_hdmi_fc_gmd_stat[] =
{
    {
        "IGMDCURRENT_GAMUT_SEQ_NUM",
        "Gamut scheduling: Current Gamut packet sequence number",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IGMDPACKET_SEQ",
        "Gamut scheduling: Gamut packet sequence",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IGMDDNEXT_FIELD",
        "Gamut scheduling: Gamut Next field",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IGMDNO_CRNT_GBD",
        "Gamut scheduling: No current gamut data",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_EN.
static const field_t hw_hdmi_fc_gmd_en[] =
{
    {
        "GMDENABLETX",
        "Gamut Metadata packet transmission enable (1b).",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_UP.
static const field_t hw_hdmi_fc_gmd_up[] =
{
    {
        "GMDUPDATEPACKET",
        "Gamut Metadata packet update.",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_CONF.
static const field_t hw_hdmi_fc_gmd_conf[] =
{
    {
        "GMDPACKETLINESPACING",
        "Number of line spacing between the transmitted GMD packets",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GMDPACKETSINFRAME",
        "Number of GMD packets per frame or video field (profile P0)",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_HB.
static const field_t hw_hdmi_fc_gmd_hb[] =
{
    {
        "GMDAFFECTED_GAMUT_SEQ_NUM",
        "Affected gamut sequence number",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GMDGBD_PROFILE",
        "GMD profile bits",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB0.
static const field_t hw_hdmi_fc_gmd_pb0[] =
{
    {
        "FC_GMD_PB0",
        "Gamut Metadata packet byte0",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB1.
static const field_t hw_hdmi_fc_gmd_pb1[] =
{
    {
        "FC_GMD_PB1",
        "Gamut Metadata packet byte1",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB2.
static const field_t hw_hdmi_fc_gmd_pb2[] =
{
    {
        "FC_GMD_PB2",
        "Gamut Metadata packet byte2",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB3.
static const field_t hw_hdmi_fc_gmd_pb3[] =
{
    {
        "FC_GMD_PB3",
        "Gamut Metadata packet byte3",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB4.
static const field_t hw_hdmi_fc_gmd_pb4[] =
{
    {
        "FC_GMD_PB4",
        "Gamut Metadata packet byte4",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB5.
static const field_t hw_hdmi_fc_gmd_pb5[] =
{
    {
        "FC_GMD_PB5",
        "Gamut Metadata packet byte5",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB6.
static const field_t hw_hdmi_fc_gmd_pb6[] =
{
    {
        "FC_GMD_PB6",
        "Gamut Metadata packet byte6",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB7.
static const field_t hw_hdmi_fc_gmd_pb7[] =
{
    {
        "FC_GMD_PB2",
        "Gamut Metadata packet byte7",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB8.
static const field_t hw_hdmi_fc_gmd_pb8[] =
{
    {
        "FC_GMD_PB8",
        "Gamut Metadata packet byte8",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB9.
static const field_t hw_hdmi_fc_gmd_pb9[] =
{
    {
        "FC_GMD_PB9",
        "Gamut Metadata packet byte9",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB10.
static const field_t hw_hdmi_fc_gmd_pb10[] =
{
    {
        "FC_GMD_PB10",
        "Gamut Metadata packet byte10",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB11.
static const field_t hw_hdmi_fc_gmd_pb11[] =
{
    {
        "FC_GMD_PB11",
        "Gamut Metadata packet byte11",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB12.
static const field_t hw_hdmi_fc_gmd_pb12[] =
{
    {
        "FC_GMD_PB12",
        "Gamut Metadata packet byte12",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB13.
static const field_t hw_hdmi_fc_gmd_pb13[] =
{
    {
        "FC_GMD_PB13",
        "Gamut Metadata packet byte13",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB14.
static const field_t hw_hdmi_fc_gmd_pb14[] =
{
    {
        "FC_GMD_PB14",
        "Gamut Metadata packet byte14",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB15.
static const field_t hw_hdmi_fc_gmd_pb15[] =
{
    {
        "FC_GMD_PB15",
        "Gamut Metadata packet byte15",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB16.
static const field_t hw_hdmi_fc_gmd_pb16[] =
{
    {
        "FC_GMD_PB16",
        "Gamut Metadata packet byte16",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB17.
static const field_t hw_hdmi_fc_gmd_pb17[] =
{
    {
        "FC_GMD_PB17",
        "Gamut Metadata packet byte17",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB18.
static const field_t hw_hdmi_fc_gmd_pb18[] =
{
    {
        "FC_GMD_PB18",
        "Gamut Metadata packet byte18",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB19.
static const field_t hw_hdmi_fc_gmd_pb19[] =
{
    {
        "FC_GMD_PB18",
        "Gamut Metadata packet byte18",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB20.
static const field_t hw_hdmi_fc_gmd_pb20[] =
{
    {
        "FC_GMD_PB20",
        "Gamut Metadata packet byte20",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB21.
static const field_t hw_hdmi_fc_gmd_pb21[] =
{
    {
        "FC_GMD_PB21",
        "Gamut Metadata packet byte21",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB22.
static const field_t hw_hdmi_fc_gmd_pb22[] =
{
    {
        "FC_GMD_PB22",
        "Gamut Metadata packet byte22",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB23.
static const field_t hw_hdmi_fc_gmd_pb23[] =
{
    {
        "FC_GMD_PB23",
        "Gamut Metadata packet byte23",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB24.
static const field_t hw_hdmi_fc_gmd_pb24[] =
{
    {
        "FC_GMD_PB24",
        "Gamut Metadata packet byte24",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB25.
static const field_t hw_hdmi_fc_gmd_pb25[] =
{
    {
        "FC_GMD_PB25",
        "Gamut Metadata packet byte25",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB26.
static const field_t hw_hdmi_fc_gmd_pb26[] =
{
    {
        "FC_GMD_PB26",
        "Gamut Metadata packet byte26",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_GMD_PB27.
static const field_t hw_hdmi_fc_gmd_pb27[] =
{
    {
        "FC_GMD_PB27",
        "Gamut Metadata packet byte27",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGFORCE.
static const field_t hw_hdmi_fc_dbgforce[] =
{
    {
        "FORCEVIDEO",
        "Force fixed video output with FC_DBGTMDSx registers contain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORCEAUDIO",
        "Force fixed audio output with FC_DBGAUDxCHx registers contain.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD0CH0.
static const field_t hw_hdmi_fc_dbgaud0ch0[] =
{
    {
        "FC_DBGAUD0CH0",
        "the audio fixed data byte0 to be used in channel 0 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD1CH0.
static const field_t hw_hdmi_fc_dbgaud1ch0[] =
{
    {
        "FC_DBGAUD1CH0",
        "the audio fixed data byte1 to be used in channel 0 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD2CH0.
static const field_t hw_hdmi_fc_dbgaud2ch0[] =
{
    {
        "FC_DBGAUD2CH0",
        "the audio fixed data byte2 to be used in channel 0 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD0CH1.
static const field_t hw_hdmi_fc_dbgaud0ch1[] =
{
    {
        "FC_DBGAUD0CH1",
        "the audio fixed data byte2 to be used in channel 0 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD1CH1.
static const field_t hw_hdmi_fc_dbgaud1ch1[] =
{
    {
        "FC_DBGAUD1CH1",
        "the audio fixed data byte1 to be used in channel 1 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD2CH1.
static const field_t hw_hdmi_fc_dbgaud2ch1[] =
{
    {
        "FC_DBGAUD2CH1",
        "the audio fixed data byte2 to be used in channel 1 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD0CH2.
static const field_t hw_hdmi_fc_dbgaud0ch2[] =
{
    {
        "FC_DBGAUD0CH2",
        "the audio fixed data byte0 to be used in channel 2 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD1CH2.
static const field_t hw_hdmi_fc_dbgaud1ch2[] =
{
    {
        "FC_DBGAUD1CH2",
        "the audio fixed data byte1 to be used in channel 2 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD2CH2.
static const field_t hw_hdmi_fc_dbgaud2ch2[] =
{
    {
        "FC_DBGAUD2CH2",
        "the audio fixed data byte2 to be used in channel 2 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD0CH3.
static const field_t hw_hdmi_fc_dbgaud0ch3[] =
{
    {
        "FC_DBGAUD0CH3",
        "the audio fixed data byte0 to be used in channel 3 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD1CH3.
static const field_t hw_hdmi_fc_dbgaud1ch3[] =
{
    {
        "FC_DBGAUD1CH3",
        "the audio fixed data byte1 to be used in channel 3 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD2CH3.
static const field_t hw_hdmi_fc_dbgaud2ch3[] =
{
    {
        "FC_DBGAUD2CH3",
        "the audio fixed data byte2 to be used in channel 3 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD0CH4.
static const field_t hw_hdmi_fc_dbgaud0ch4[] =
{
    {
        "FC_DBGAUD0CH4",
        "the audio fixed data byte0 to be used in channel 4 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD1CH4.
static const field_t hw_hdmi_fc_dbgaud1ch4[] =
{
    {
        "FC_DBGAUD1CH4",
        "the audio fixed data byte1 to be used in channel 4 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD2CH4.
static const field_t hw_hdmi_fc_dbgaud2ch4[] =
{
    {
        "FC_DBGAUD2CH4",
        "the audio fixed data byte2 to be used in channel 4 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD0CH5.
static const field_t hw_hdmi_fc_dbgaud0ch5[] =
{
    {
        "FC_DBGAUD0CH5",
        "the audio fixed data byte0 to be used in channel 5 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD1CH5.
static const field_t hw_hdmi_fc_dbgaud1ch5[] =
{
    {
        "FC_DBGAUD1CH5",
        "the audio fixed data byte1 to be used in channel 5 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD2CH5.
static const field_t hw_hdmi_fc_dbgaud2ch5[] =
{
    {
        "FC_DBGAUD2CH5",
        "the audio fixed data byte2 to be used in channel 5 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD0CH6.
static const field_t hw_hdmi_fc_dbgaud0ch6[] =
{
    {
        "FC_DBGAUD0CH6",
        "The audio fixed data byte0 to be used in channel 6 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD1CH6.
static const field_t hw_hdmi_fc_dbgaud1ch6[] =
{
    {
        "FC_DBGAUD1CH6",
        "the audio fixed data byte1 to be used in channel 6 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD2CH6.
static const field_t hw_hdmi_fc_dbgaud2ch6[] =
{
    {
        "FC_DBGAUD2CH6",
        "the audio fixed data byte2 to be used in channel 6 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD0CH7.
static const field_t hw_hdmi_fc_dbgaud0ch7[] =
{
    {
        "FC_DBGAUD0CH7",
        "the audio fixed data byte0 to be used in channel 7 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD1CH7.
static const field_t hw_hdmi_fc_dbgaud1ch7[] =
{
    {
        "FC_DBGAUD1CH7",
        "the audio fixed data byte1 to be used in channel 0 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGAUD2CH7.
static const field_t hw_hdmi_fc_dbgaud2ch7[] =
{
    {
        "FC_DBGAUD2CH7",
        "the audio fixed data byte2 to be used in channel 0 when in fixed audio"
        " selection",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGTMDS0.
static const field_t hw_hdmi_fc_dbgtmds0[] =
{
    {
        "FC_DBGTMDS0",
        "set B pixel component value in RGB video or Cb pixel component value i"
        "n YCbCr",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGTMDS1.
static const field_t hw_hdmi_fc_dbgtmds1[] =
{
    {
        "FC_DBGTMDS1",
        "set G pixel component value in RGB video or Y pixel component value in"
        " YCbCr",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_FC_DBGTMDS2.
static const field_t hw_hdmi_fc_dbgtmds2[] =
{
    {
        "FC_DBGTMDS2",
        "set R pixel component value in RGB video or Cr pixel component value i"
        "n YCbCr",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_CONF0.
static const field_t hw_hdmi_phy_conf0[] =
{
    {
        "SELDIPIF",
        "Select interface control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SELDATAENPOL",
        "Select data enable polarity.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN2_ENHPDRXSENSE",
        "PHY_Gen2 ENHPDRXSENSE signal  Value after Reset: 1b",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN2_TXPWRON",
        "PHY_Gen2 TXPWRON signal  Value after Reset: 0b",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN2_PDDQ",
        "PHY_Gen2 PDDQ signal  Value after Reset: 0b",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARECTRL",
        "Reserved.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTMDS",
        "Enable TMDS drivers, bias, and TMDS digital logic.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDZ",
        "Power-down enable (active low 0b).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_TST0.
static const field_t hw_hdmi_phy_tst0[] =
{
    {
        "TESTCLK",
        "Test clock signal.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TESTEN",
        "Reserved.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TESTCLR",
        "Enable TMDS drivers, bias and tmds digital logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_TST1.
static const field_t hw_hdmi_phy_tst1[] =
{
    {
        "TESTDIN",
        "Test data input.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_TST2.
static const field_t hw_hdmi_phy_tst2[] =
{
    {
        "TESTDOUT",
        "Test data output.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_STAT0.
static const field_t hw_hdmi_phy_stat0[] =
{
    {
        "TX_PHY_LOCK",
        "Status bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HPD",
        "Status bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_SENSE",
        "Status bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_SENSE1",
        "Status bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_SENSE2",
        "Status bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_SENSE3",
        "Status bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_INT0.
static const field_t hw_hdmi_phy_int0[] =
{
    {
        "TX_PHY_LOCK",
        "Interrupt indication bit  TX PHY PLL lock indication interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HPD",
        "Interrupt indication bit  HDMI Hot Plug Detect indication interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_SENSE",
        "Interrupt indication bit  TX PHY RX_SENSE indication interrupt for TMD"
        "S channel 0 driver.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_SENSE1",
        "Interrupt indication bit  TX PHY RX_SENSE indication interrupt for TMD"
        "S channel 1 driver.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_SENSE2",
        "Interrupt indication bit  TX PHY RX_SENSE indication interrupt for TMD"
        "S channel 2 driver.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_SENSE3",
        "Interrupt indication bit  TX PHY RX_SENSE indication interrupt for TMD"
        "S CLK driver.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_MASK0.
static const field_t hw_hdmi_phy_mask0[] =
{
    {
        "TX_PHY_LOCK",
        "Mask bit for PHY_INT0.TX_PHY_LOCK interrupt bit",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPD",
        "Mask bit for PHY_INT0.HPD interrupt bit",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE",
        "Mask bit for PHY_INT0.RX_SENSE[0] interrupt bit",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE1",
        "Mask bit for PHY_INT0.RX_SENSE[1] interrupt bit",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE2",
        "Mask bit for PHY_INT0.RX_SENSE[2] interrupt bit",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE3",
        "Mask bit for PHY_INT0.RX_SENSE[3] interrupt bit",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_POL0.
static const field_t hw_hdmi_phy_pol0[] =
{
    {
        "TX_PHY_LOCK",
        "Polarity bit for PHY_INT0.TX_PHY_LOCK interrupt bit",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPD",
        "Polarity bit for PHY_INT0.HPD interrupt bit",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE",
        "Polarity bit for PHY_INT0.RX_SENSE[0] interrupt bit",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE1",
        "Polarity bit for PHY_INT0.RX_SENSE[1] interrupt bit",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE2",
        "Polarity bit for PHY_INT0.RX_SENSE[2] interrupt bit",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_SENSE3",
        "Polarity bit for PHY_INT0.RX_SENSE[3] interrupt bit",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_SLAVE_ADDR.
static const field_t hw_hdmi_phy_i2cm_slave_addr[] =
{
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_ADDRESS_ADDR.
static const field_t hw_hdmi_phy_i2cm_address_addr[] =
{
    {
        "ADDRESS",
        "Register address for read and write operations.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_DATAO_1_ADDR.
static const field_t hw_hdmi_phy_i2cm_datao_1_addr[] =
{
    {
        "DATAO",
        "MSB's of data to be written on register pointed by address [7:0].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_DATAO_0_ADDR.
static const field_t hw_hdmi_phy_i2cm_datao_0_addr[] =
{
    {
        "DATAO",
        "LSB's of data to be written on register pointed by address [7:0].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_DATAI_1_ADDR.
static const field_t hw_hdmi_phy_i2cm_datai_1_addr[] =
{
    {
        "DATAI",
        "MSB's of data read from the register pointed by address [7:0].",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_DATAI_0_ADDR.
static const field_t hw_hdmi_phy_i2cm_datai_0_addr[] =
{
    {
        "DATAI",
        "LSB's of data read from the register pointed by address [7:0].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_OPERATION_ADDR.
static const field_t hw_hdmi_phy_i2cm_operation_addr[] =
{
    {
        "READ",
        "Read operation request.",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    {
        "WRITE",
        "Write operation request",
        4, // LSB
        4, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_INT_ADDR.
static const field_t hw_hdmi_phy_i2cm_int_addr[] =
{
    {
        "DONE_STATUS",
        "Operation done status bit.Marks the end of a rd or write operation.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE_INTERRUPT",
        "Operation done interrupt bit.{done_interrupt =(done_mask==0b)&& (done_"
        "status==done_pol)}.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE_MASK",
        "Done interrupt mask signal  Value after Reset: 0b",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE_POL",
        "Done interrupt polarity configuration  Value after Reset: 1b",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_CTLINT_ADDR.
static const field_t hw_hdmi_phy_i2cm_ctlint_addr[] =
{
    {
        "ARBITRATION_STATUS",
        "Arbitration error status bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARBITRATION_INTERRUPT",
        "Arbitration error interrupt bit.{arbitration_interrupt = (arbitration_"
        "mask==0b)&& (arbitration_status==arbitration_pol)}.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARBITRATION_MASK",
        "Arbitration error interrupt mask signal.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARBITRATION_POL",
        "Arbitration error interrupt polarity configuration.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_STATUS",
        "Not acknowledge error status bit.Error on I2C not acknowledge.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_INTERRUPT",
        "Not acknowledge error interrupt bit.{nack_interrupt = nack_mask==0b) &"
        "& (nack_status==nack_pol)}.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_MASK",
        "Not acknowledge error interrupt mask signal  Value after Reset: 0b",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_POL",
        "Not acknowledge error interrupt polarity configuration.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_DIV_ADDR.
static const field_t hw_hdmi_phy_i2cm_div_addr[] =
{
    {
        "FAST_MODE",
        "Sets the I2C Master to work in Fast Mode or Standard Mode  (x implies "
        "that it can take any value)  Value after Reset: 1011b  1xxxb Fast Mode"
        "  0xxxb Standard Mode",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_SOFTRSTZ_ADDR.
static const field_t hw_hdmi_phy_i2cm_softrstz_addr[] =
{
    {
        "I2C_SOFTRST",
        "I2C Master PHY Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_SS_SCL_HCNT_1_ADDR.
static const field_t hw_hdmi_phy_i2cm_ss_scl_hcnt_1_addr[] =
{
    {
        "I2CMP_SS_SCL_HCNT",
        "Value after Reset: 8'h00",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_SS_SCL_HCNT_0_ADDR.
static const field_t hw_hdmi_phy_i2cm_ss_scl_hcnt_0_addr[] =
{
    {
        "I2CMP_SS_SCL_HCNT",
        "Value after Reset: 8'h6C",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_SS_SCL_LCNT_1_ADDR.
static const field_t hw_hdmi_phy_i2cm_ss_scl_lcnt_1_addr[] =
{
    {
        "I2CMP_SS_SCL_LCNT",
        "Value after Reset: 8'h00",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_SS_SCL_LCNT_0_ADDR.
static const field_t hw_hdmi_phy_i2cm_ss_scl_lcnt_0_addr[] =
{
    {
        "I2CMP_SS_SCL_LCNT",
        "Value after Reset: 8'h7F",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_FS_SCL_HCNT_1_ADDR.
static const field_t hw_hdmi_phy_i2cm_fs_scl_hcnt_1_addr[] =
{
    {
        "I2CMP_FS_SCL_HCNT",
        "Value after Reset: 8'h00",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_FS_SCL_HCNT_0_ADDR.
static const field_t hw_hdmi_phy_i2cm_fs_scl_hcnt_0_addr[] =
{
    {
        "I2CMP_FS_SCL_HCNT",
        "Value after Reset: 8'h11",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_FS_SCL_LCNT_1_ADDR.
static const field_t hw_hdmi_phy_i2cm_fs_scl_lcnt_1_addr[] =
{
    {
        "I2CMP_FS_SCL_LCNT",
        "Value after Reset: 8'h00",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_PHY_I2CM_FS_SCL_LCNT_0_ADDR.
static const field_t hw_hdmi_phy_i2cm_fs_scl_lcnt_0_addr[] =
{
    {
        "I2CMP_FS_SCL_LCNT",
        "Value after Reset: 8'h24",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AUD_N1.
static const field_t hw_hdmi_aud_n1[] =
{
    {
        "AUDN",
        "HDMI Audio Clock Regenerator N value",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AUD_N2.
static const field_t hw_hdmi_aud_n2[] =
{
    {
        "AUDN",
        "HDMI Audio Clock Regenerator N value",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AUD_N3.
static const field_t hw_hdmi_aud_n3[] =
{
    {
        "AUDN",
        "HDMI Audio Clock Regenerator N value",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AUD_CTS1.
static const field_t hw_hdmi_aud_cts1[] =
{
    {
        "AUDCTS",
        "HDMI Audio Clock Regenerator CTS calculated value.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AUD_CTS2.
static const field_t hw_hdmi_aud_cts2[] =
{
    {
        "AUDCTS",
        "HDMI Audio Clock Regenerator CTS calculated value.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AUD_CTS3.
static const field_t hw_hdmi_aud_cts3[] =
{
    {
        "AUDCTS",
        "HDMI Audio Clock Regenerator CTS calculated value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_CONF0.
static const field_t hw_hdmi_ahb_dma_conf0[] =
{
    {
        "BURST_MODE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INCR_TYPE",
        "Forced size burst mode.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_HLOCK",
        "Enable request of locked burst AHB mechanism.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBR",
        "HBR packets enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_FIFO_RST",
        "This is the software reset bit for the audio and FIFOs clear.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_START.
static const field_t hw_hdmi_ahb_dma_start[] =
{
    {
        "DATA_BUFFER_READY",
        "Data buffer ready",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STOP.
static const field_t hw_hdmi_ahb_dma_stop[] =
{
    {
        "STOP_DMA_TRANSACTION",
        "Stop DMA transaction",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_THRSLD.
static const field_t hw_hdmi_ahb_dma_thrsld[] =
{
    {
        "FIFO_THRESHOLD",
        "FIFO medium threshold occupation value",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STRADDR0.
static const field_t hw_hdmi_ahb_dma_straddr0[] =
{
    {
        "INITIAL_ADDR",
        "Defines init_addr[7:0] for bits 7-0 to initiate DMA burst transactions",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STRADDR1.
static const field_t hw_hdmi_ahb_dma_straddr1[] =
{
    {
        "INITIAL_ADDR",
        "Defines init_addr[15:8] for bits 7-0 to initiate DMA burst transaction"
        "s",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STRADDR2.
static const field_t hw_hdmi_ahb_dma_straddr2[] =
{
    {
        "INITIAL_ADDR",
        "Defines init_addr[23:16] for bits 7-0 to initiate DMA burst transactio"
        "ns",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STRADDR3.
static const field_t hw_hdmi_ahb_dma_straddr3[] =
{
    {
        "INITIAL_ADDR",
        "Defines init_addr[31:24] for bits 7-0 to initiate DMA burst transactio"
        "ns",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STPADDR0.
static const field_t hw_hdmi_ahb_dma_stpaddr0[] =
{
    {
        "FINAL_ADDR",
        "Defines final_addr[7:0] for bits 7-0 to initiate DMA burst transaction"
        "s",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STPADDR1.
static const field_t hw_hdmi_ahb_dma_stpaddr1[] =
{
    {
        "FINAL_ADDR",
        "Defines final_addr[15:8] for bits 7-0 to initiate DMA burst transactio"
        "ns",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STPADDR2.
static const field_t hw_hdmi_ahb_dma_stpaddr2[] =
{
    {
        "FINAL_ADDR",
        "Defines final_addr[23:16] for bits 7-0 to initiate DMA burst transacti"
        "ons",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STPADDR3.
static const field_t hw_hdmi_ahb_dma_stpaddr3[] =
{
    {
        "FINAL_ADDR",
        "Defines final_addr[31:24] for bits 7-0 to initiate DMA burst transacti"
        "ons",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_BSTADDR0.
static const field_t hw_hdmi_ahb_dma_bstaddr0[] =
{
    {
        "BURST_START",
        "Start address for the current burst operation",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_BSTADDR1.
static const field_t hw_hdmi_ahb_dma_bstaddr1[] =
{
    {
        "BURST_START",
        "Start address for the current burst operation",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_BSTADDR2.
static const field_t hw_hdmi_ahb_dma_bstaddr2[] =
{
    {
        "BURST_START",
        "Start address for the current burst operation",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_BSTADDR3.
static const field_t hw_hdmi_ahb_dma_bstaddr3[] =
{
    {
        "BURST_START",
        "Start address for the current burst operation",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_MBLENGTH0.
static const field_t hw_hdmi_ahb_dma_mblength0[] =
{
    {
        "MBURSTLENGTH",
        "Requested burst length",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_MBLENGTH1.
static const field_t hw_hdmi_ahb_dma_mblength1[] =
{
    {
        "MBURSTLENGTH",
        "Requested burst length",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MBURSTLENGTH1",
        "Requested burst length",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MBURSTLENGTH2",
        "Requested burst length",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_STAT.
static const field_t hw_hdmi_ahb_dma_stat[] =
{
    {
        "STATFIFOEMPTY",
        "Status of audio FIFO empty interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATFIFOFULL",
        "Status of audio FIFO full interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATTHRFIFOEMPTY",
        "Status of audio FIFO empty when audio FIFO has less than four samples.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATERROR",
        "Status of error interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATLOSTOWNERSHIP",
        "Status of master lost ownership when in burst transfer.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATRETRYSPLIT",
        "Status of retry/split interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATDONE",
        "Status of DMA end of operation interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_INT.
static const field_t hw_hdmi_ahb_dma_int[] =
{
    {
        "INTFIFOEMPTY",
        "Audio FIFO empty interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTFIFOFULL",
        "Audio FIFO full interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTTHRFIFOEMPTY",
        "Audio FIFO empty interrupt when audio FIFO has less than four samples.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTERROR",
        "Error interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTLOSTOWNERSHIP",
        "Master lost ownership interrupt when in burst transfer.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTRETRYSPLIT",
        "Retry/split interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTDONE",
        "DMA end of operation interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_MASK.
static const field_t hw_hdmi_ahb_dma_mask[] =
{
    {
        "FIFO_EMPTY_MASK",
        "Audio FIFO empty interrupt mask.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_FULL_MASK",
        "Audio FIFO full interrupt mask.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_THREMPTY_MASK",
        "Audio FIFO empty interrupt mask when audio FIFO has less than four sam"
        "ples.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_MASK",
        "Error interrupt mask.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOSTOWNERSHIP_MASK",
        "Master lost ownership interrupt mask when in burst transfer.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RETRYSPLIT_MASK",
        "Retry/split interrupt mask.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE_MASK",
        "DMA end of operation interrupt mask.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_POL.
static const field_t hw_hdmi_ahb_dma_pol[] =
{
    {
        "FIFO_EMPTY_POLARITY",
        "Audio FIFO empty interrupt mask.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_FULL_POLARITY",
        "Audio FIFO full interrupt mask.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_THRFIFOEMPTY_POLARITY",
        "Audio FIFO empty interrupt mask when audio FIFO has less than four sam"
        "ples.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_POLARITY",
        "Error interrupt mask.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOSTOWNERSHIP_POLARITY",
        "Master lost ownership interrupt mask when in burst transfer.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RETRYSPLIT_POLARITY",
        "Retry/split interrupt mask.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE_POLARITY",
        "DMA end of operation interrupt mask.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_CONF1.
static const field_t hw_hdmi_ahb_dma_conf1[] =
{
    {
        "CH_IN_EN",
        "Channel 0 is always enabled.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH_IN_EN1",
        "Channel 1 is always enabled.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH_IN_EN2",
        "Channel 2 enable bit",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH_IN_EN3",
        "Channel 3 enable bit",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH_IN_EN4",
        "Channel 4 enable bit",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH_IN_EN5",
        "Channel 5 enable bit",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH_IN_EN6",
        "Channel 6 enable bit",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH_IN_EN7",
        "Channel 7 enable bit",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_BUFFSTAT.
static const field_t hw_hdmi_ahb_dma_buffstat[] =
{
    {
        "BUFF_EMPTY",
        "Buffer empty flag status",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUFF_FULL",
        "Buffer full flag status",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_BUFFINT.
static const field_t hw_hdmi_ahb_dma_buffint[] =
{
    {
        "INT_BUFF_EMPTY",
        "Buffer empty flag interrupt",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INT_BUFF_FULL",
        "Buffer full flag interrupt",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_BUFFMASK.
static const field_t hw_hdmi_ahb_dma_buffmask[] =
{
    {
        "INT_BUFF_EMPTY",
        "Buffer empty flag mask",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_BUFF_FULL",
        "Buffer full flag mask",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_AHB_DMA_BUFFPOL.
static const field_t hw_hdmi_ahb_dma_buffpol[] =
{
    {
        "INT_BUFF_EMPTY",
        "Buffer empty flag polarity",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_BUFF_FULL",
        "Buffer full flag polarity",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_MC_CLKDIS.
static const field_t hw_hdmi_mc_clkdis[] =
{
    {
        "PIXELCLK_DISABLE",
        "Pixel clock synchronous disable signal.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMDSCLK_DISABLE",
        "TMDS clock synchronous disable signal.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREPCLK_DISABLE",
        "Pixel Repetition clock synchronous disable signal.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDCLK_DISABLE",
        "Audio Sampler clock synchronous disable signal.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCCLK_DISABLE",
        "Color Space Converter clock synchronous disable signal.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CECCLK_DISABLE",
        "CEC Engine clock synchronous disable signal.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HDCPCLK_DISABLE",
        "Reserved",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_MC_SWRSTZREQ.
static const field_t hw_hdmi_mc_swrstzreq[] =
{
    {
        "PIXELSWRST_REQ",
        "Pixel software reset request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMDSSWRST_REQ",
        "TMDS software reset request.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREPSWRST_REQ",
        "Pixel Repetition clock synchronous disable signal.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CECSWRST_REQ",
        "CEC software reset request.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_MC_FLOWCTRL.
static const field_t hw_hdmi_mc_flowctrl[] =
{
    {
        "FEED_THROUGH_OFF",
        "Video path Feed Through enable bit:",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_MC_PHYRSTZ.
static const field_t hw_hdmi_mc_phyrstz[] =
{
    {
        "PHYRSTZ",
        "HDMI Source PHY active low reset control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_MC_LOCKONCLOCK.
static const field_t hw_hdmi_mc_lockonclock[] =
{
    {
        "CECCLK",
        "CEC clock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREPCLK",
        "Pixel repetition clock status.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKTCLK",
        "TMDS clock status.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCLK",
        "Pixel clock status.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_MC_HEACPHY_RST.
static const field_t hw_hdmi_mc_heacphy_rst[] =
{
    {
        "HEACPHYRST",
        "HEAC PHY reset (active high)",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_CFG.
static const field_t hw_hdmi_csc_cfg[] =
{
    {
        "DECMODE",
        "Chroma decimation configuration: decmode[1:0] Chroma decimation 00 dec"
        "imation disabled 01 H d?",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMODE",
        "Chroma interpolation configuration:  00 interpolation disabled  01 H u"
        " (z) = 1 + z -1   10 H u (z)=1/2 + Z -1 +1/2 z -2   11 interpolation d"
        "isabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_SCALE.
static const field_t hw_hdmi_csc_scale[] =
{
    {
        "CSC_COLORDE_PTH",
        "Color space converter color depth configuration:  Other: Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_A1_MSB.
static const field_t hw_hdmi_csc_coef_a1_msb[] =
{
    {
        "CSC_COEF_A1_MSB",
        "Color Space Conversion A1 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_A1_LSB.
static const field_t hw_hdmi_csc_coef_a1_lsb[] =
{
    {
        "CSC_COEF_A1_LSB",
        "Color Space Conversion A1 LSB coefficient",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_A2_MSB.
static const field_t hw_hdmi_csc_coef_a2_msb[] =
{
    {
        "CSC_COEF_A2_MSB",
        "Color Space Conversion A2 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_A2_LSB.
static const field_t hw_hdmi_csc_coef_a2_lsb[] =
{
    {
        "CSC_COEF_A2_LSB",
        "Color Space Conversion A2 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_A3_MSB.
static const field_t hw_hdmi_csc_coef_a3_msb[] =
{
    {
        "CSC_COEF_A3_MSB",
        "Color Space Conversion A3 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_A3_LSB.
static const field_t hw_hdmi_csc_coef_a3_lsb[] =
{
    {
        "CSC_COEF_A3_LSB",
        "Color Space Conversion A3 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_A4_MSB.
static const field_t hw_hdmi_csc_coef_a4_msb[] =
{
    {
        "CSC_COEF_A4_MSB",
        "Color Space Conversion A4 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_A4_LSB.
static const field_t hw_hdmi_csc_coef_a4_lsb[] =
{
    {
        "CSC_COEF_A4_LSB",
        "Color Space Conversion A4 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_B1_MSB.
static const field_t hw_hdmi_csc_coef_b1_msb[] =
{
    {
        "CSC_COEF_B1_MSB",
        "Color Space Conversion B1 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_B1_LSB.
static const field_t hw_hdmi_csc_coef_b1_lsb[] =
{
    {
        "CSC_COEF_B1_LSB",
        "Color Space Conversion B1 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_B2_MSB.
static const field_t hw_hdmi_csc_coef_b2_msb[] =
{
    {
        "CSC_COEF_B2_MSB",
        "Color Space Conversion B2 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_B2_LSB.
static const field_t hw_hdmi_csc_coef_b2_lsb[] =
{
    {
        "CSC_COEF_B2_LSB",
        "Color Space Conversion B2 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_B3_MSB.
static const field_t hw_hdmi_csc_coef_b3_msb[] =
{
    {
        "CSC_COEF_B3_MSB",
        "Color Space Conversion B3 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_B3_LSB.
static const field_t hw_hdmi_csc_coef_b3_lsb[] =
{
    {
        "CSC_COEF_B3_LSB",
        "Color Space Conversion B3 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_B4_MSB.
static const field_t hw_hdmi_csc_coef_b4_msb[] =
{
    {
        "CSC_COEF_B4_MSB",
        "Color Space Conversion B4 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_B4_LSB.
static const field_t hw_hdmi_csc_coef_b4_lsb[] =
{
    {
        "CSC_COEF_B4_LSB",
        "Color Space Conversion B4 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_C1_MSB.
static const field_t hw_hdmi_csc_coef_c1_msb[] =
{
    {
        "CSC_COEF_C1_MSB",
        "Color Space Conversion C1 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_C1_LSB.
static const field_t hw_hdmi_csc_coef_c1_lsb[] =
{
    {
        "CSC_COEF_C1_LSB",
        "Color Space Conversion C1 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_C2_MSB.
static const field_t hw_hdmi_csc_coef_c2_msb[] =
{
    {
        "CSC_COEF_C2_MSB",
        "Color Space Conversion C2 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_C2_LSB.
static const field_t hw_hdmi_csc_coef_c2_lsb[] =
{
    {
        "CSC_COEF_C2_LSB",
        "Color Space Conversion C2 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_C3_MSB.
static const field_t hw_hdmi_csc_coef_c3_msb[] =
{
    {
        "CSC_COEF_C3_MSB",
        "Color Space Conversion C3 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEF_C3_LSB.
static const field_t hw_hdmi_csc_coef_c3_lsb[] =
{
    {
        "CSC_COEF_C3_LSB",
        "Color Space Conversion C3 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEFC4_MSB.
static const field_t hw_hdmi_csc_coefc4_msb[] =
{
    {
        "CSC_COEFC4_MSB",
        "Color Space Conversion C4 MSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CSC_COEFC4_LSB.
static const field_t hw_hdmi_csc_coefc4_lsb[] =
{
    {
        "CSC_COEFC4_LSB",
        "Color Space Conversion C4 LSB coefficient.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_CTRL.
static const field_t hw_hdmi_cec_ctrl[] =
{
    {
        "SEND",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAME_TYP",
        "",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BC_NACK",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STANDBY",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_STAT.
static const field_t hw_hdmi_cec_stat[] =
{
    {
        "DONE",
        "The current transmission is successful (for initiator only).",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EOM",
        "EOM is detected so that the received data is ready in the receiver dat"
        "a buffer (for follower only).",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NACK",
        "A frame is not acknowledged in a directly addressed message.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARB_LOST",
        "The initiator losses the CEC line arbitration to a second initiator.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR_INIT",
        "An error is detected on cec line (for initiator only).",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR_FOLL",
        "An error is notified by a follower.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAKEUP",
        "Follower received wake-up command (for follower only).",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_MASK.
static const field_t hw_hdmi_cec_mask[] =
{
    {
        "DONE_MASK",
        "The current transmission is successful (for initiator only).",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOM_MASK",
        "EOM is detected so that the received data is ready in the receiver dat"
        "a buffer (for follower only).",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_MASK",
        "A frame is not acknowledged in a directly addressed message.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARB_LOST_MASK",
        "The initiator losses the CEC line arbitration to a second initiator.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_INIT_MASK",
        "An error is detected on cec line (for initiator only).",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_FOLL__MASK",
        "An error is notified by a follower.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_MASK",
        "Follower wake-up signal mask",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_POLARITY.
static const field_t hw_hdmi_cec_polarity[] =
{
    {
        "DONE_POL",
        "Current transmission success or not signal polarity",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOM_POL",
        "EOM detect signal polarity (follower only)",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_POL",
        "Frame NACK signal polarity",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARB_LOST_POL",
        "Initiator Arbitration lost signal polarity",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_INIT_POL",
        "CEC line error polarity (for initiator only)",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_FOLL_POL",
        "CEC line error polarity (for follower only)",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_POL",
        "Follower wakeup signal polarity",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_INT.
static const field_t hw_hdmi_cec_int[] =
{
    {
        "DONE_INT",
        "EOM detect interrupt (for follower only)",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EOM_INT",
        "Frame NACK interrupt",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NACK_INT",
        "Initiator Arbitration lost interrupt",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARB_LOST_INT",
        "CEC line error interrupt (for initiator only)",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR_INIT_INT",
        "CEC line error interrupt (for follower only)",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR_FOLL_INT",
        "Follower wakeup interrupt",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAKEUP_INT",
        "Follower wakeup signal polarity",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_ADDR_L.
static const field_t hw_hdmi_cec_addr_l[] =
{
    {
        "CEC_ADDR_L",
        "Logical address 0 - Device TV",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_L1",
        "Logical address 1 - Recording Device 1",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_L2",
        "Logical address 2 - Recording Device 2",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_L3",
        "Logical address 3 - Tuner 1",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_L4",
        "Logical address 4 - Playback Device 1",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_L5",
        "Logical address 5 - Audio System",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_L6",
        "Logical address 6 - Tuner 2",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_L7",
        "Logical address 7 - Tuner 3",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_ADDR_H.
static const field_t hw_hdmi_cec_addr_h[] =
{
    {
        "CEC_ADDR_H",
        "Logical address 8 - Playback Device 2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_H1",
        "Logical address 9 - Playback Device 3",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_H2",
        "Logical address 10 - Tuner 4",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_H3",
        "Logical address 11 - Playback Device 3",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_H4",
        "Logical address 12 - Reserved",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_H5",
        "Logical address 13 - Reserved",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_H6",
        "Logical address 14 - Free use",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEC_ADDR_H7",
        "Logical address 15 - Unregistered (as initiator address), Broadcast (a"
        "s destination address)",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_TX_CNT.
static const field_t hw_hdmi_cec_tx_cnt[] =
{
    {
        "CEC_TX_CNT",
        "CEC Transmitter Counter register:  Value after Reset: 5'b00000",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_RX_CNT.
static const field_t hw_hdmi_cec_rx_cnt[] =
{
    {
        "TX_DATA",
        "Header block in CEC_TX_DATA0  Data blockn in CEC_TX_DATAn",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_TX_DATAN.
static const field_t hw_hdmi_cec_tx_datan[] =
{
    {
        "RX_DATA",
        "Header block in CEC_RX_DATA0  Data blockn in CEC_RX_DATAn",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_RX_DATAN.
static const field_t hw_hdmi_cec_rx_datan[] =
{
    {
        "CEC_RX_CNT",
        "CEC Receiver Counter register  Value after Reset: 5'b00000",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_LOCK.
static const field_t hw_hdmi_cec_lock[] =
{
    {
        "LOCKED_BUFFER",
        "When a frame is received, this bit would be active.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_CEC_WKUPCTRL.
static const field_t hw_hdmi_cec_wkupctrl[] =
{
    {
        "OPCODE0X04EN",
        "OPCODE 0x04 wake up enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE0X0DEN",
        "OPCODE 0x0D wake up enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE0X41EN",
        "OPCODE 0x41 wake up enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE0X42EN",
        "OPCODE 0x42 wake up enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE0X44EN",
        "OPCODE 0x44 wake up enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE0X70EN",
        "OPCODE 0x70 wake up enable",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE0X82EN",
        "OPCODE 0x82 wake up enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE0X86EN",
        "OPCODE 0x86 wake up enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_SLAVE.
static const field_t hw_hdmi_i2cm_slave[] =
{
    {
        "SLAVEADDR",
        "Slave address to be sent during read and write normal operations.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_ADDRESS.
static const field_t hw_hdmi_i2cm_address[] =
{
    {
        "ADDRESS",
        "Register address for read and write operations.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_DATAO.
static const field_t hw_hdmi_i2cm_datao[] =
{
    {
        "DATAO",
        "Data to be written on register pointed by address[7:0].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_DATAI.
static const field_t hw_hdmi_i2cm_datai[] =
{
    {
        "DATAI",
        "Data read from register pointed by address[7:0].",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_OPERATION.
static const field_t hw_hdmi_i2cm_operation[] =
{
    {
        "RD",
        "Read operation request.",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RD_EXT",
        "After writing 1'b1 to rd_ext bit a extended data read operation is sta"
        "rted (E- DDC read operation).",
        1, // LSB
        1, // MSB
        false, // Readable
        true // Writable
    },
    {
        "WR",
        "Write operation request.",
        4, // LSB
        4, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_INT.
static const field_t hw_hdmi_i2cm_int[] =
{
    {
        "DONE_STATUS",
        "Operation done status bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE_INTERRUPT",
        "Operation done interrupt bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE_MASK",
        "Done interrupt mask signal.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE_POL",
        "Done interrupt polarity configuration.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_CTLINT.
static const field_t hw_hdmi_i2cm_ctlint[] =
{
    {
        "ARBITRATION_STATUS",
        "Arbitration error status bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARBITRATION_INTERRUPT",
        "Arbitration error interrupt bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARBITRATION_MASK",
        "Arbitration error interrupt mask signal.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARBITRATION_POL",
        "Arbitration error interrupt polarity configuration.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_STATUS",
        "Not acknowledge error status bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_INTERRUPT",
        "Not acknowledge error interrupt bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_MASK",
        "Not acknowledge error interrupt mask signal.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NACK_POL",
        "Not acknowledge error interrupt polarity configuration.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_DIV.
static const field_t hw_hdmi_i2cm_div[] =
{
    {
        "FAST_STD_MODE",
        "Sets the I2C Master to work in Fast Mode or Standard Mode:",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_SEGADDR.
static const field_t hw_hdmi_i2cm_segaddr[] =
{
    {
        "SEGADDR",
        "E-DDC Extended read segment address",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_SOFTRSTZ.
static const field_t hw_hdmi_i2cm_softrstz[] =
{
    {
        "I2C_SOFTRST",
        "I2C Master Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_SEGPTR.
static const field_t hw_hdmi_i2cm_segptr[] =
{
    {
        "I2CM_SEGPTR",
        "I2CM_SEGPTR is used for EDID reading operations, particularly for the "
        "Extended Data Read Operation (See \") which is used for Enhanced DDC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_SS_SCL_HCNT_1_ADDR.
static const field_t hw_hdmi_i2cm_ss_scl_hcnt_1_addr[] =
{
    {
        "I2CMP_SS_SCL_HCNT",
        "Value after Reset: 8'h00",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_SS_SCL_HCNT_0_ADDR.
static const field_t hw_hdmi_i2cm_ss_scl_hcnt_0_addr[] =
{
    {
        "I2CMP_SS_SCL_HCNT",
        "Value after Reset: 8'h6C",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_SS_SCL_LCNT_1_ADDR.
static const field_t hw_hdmi_i2cm_ss_scl_lcnt_1_addr[] =
{
    {
        "I2CMP_SS_SCL_LCNT",
        "Value after Reset: 8'h00",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_SS_SCL_LCNT_0_ADDR.
static const field_t hw_hdmi_i2cm_ss_scl_lcnt_0_addr[] =
{
    {
        "I2CMP_SS_SCL_LCNT",
        "Value after Reset: 8'h7F",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_FS_SCL_HCNT_1_ADDR.
static const field_t hw_hdmi_i2cm_fs_scl_hcnt_1_addr[] =
{
    {
        "I2CMP_FS_SCL_HCNT",
        "Value after Reset: 8'h00",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_FS_SCL_HCNT_0_ADDR.
static const field_t hw_hdmi_i2cm_fs_scl_hcnt_0_addr[] =
{
    {
        "I2CMP_FS_SCL_HCNT",
        "Value after Reset: 8'h11",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_FS_SCL_LCNT_1_ADDR.
static const field_t hw_hdmi_i2cm_fs_scl_lcnt_1_addr[] =
{
    {
        "I2CMP_FS_SCL_LCNT",
        "Value after Reset: 8'h00",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_I2CM_FS_SCL_LCNT_0_ADDR.
static const field_t hw_hdmi_i2cm_fs_scl_lcnt_0_addr[] =
{
    {
        "I2CMP_FS_SCL_LCNT",
        "Value after Reset: 8'h24",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register HDMI_BASE_POINTER_ADDR.
static const field_t hw_hdmi_base_pointer_addr[] =
{
    {
        "BASE_POINTER_BASE_ADDR",
        "Defines the base address for base pointer operation mode.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_BASE_POINTER_ADDR",
        "Enables the base pointer operation mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a HDMI module.
static const reg_t hw_hdmi[] =
{
    {
        "DESIGN_ID",
        "The following are the registers used to identify the HDMI TX controlle"
        "r.",
        1, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_design_id
    },
    {
        "REVISION_ID",
        "Name: Revision Identification Register  Address Offset: 0x0001  Size: "
        "8 bits  Value after Reset: Implementation Dependent  Access: Read",
        1, // Width in bytes
        0x00000001, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_revision_id
    },
    {
        "PRODUCT_ID0",
        "Name: Product Identification Register 0  Address Offset: 0x0002  Size:"
        " 8 bits  Value after Reset: Implementation Dependent  Access: Read",
        1, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_product_id0
    },
    {
        "PRODUCT_ID1",
        "Name: Product Identification Register 1  Address Offset: 0x0003  Size:"
        " 8 bits  Value after Reset: Implementation Dependent  Access: Read",
        1, // Width in bytes
        0x00000003, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_product_id1
    },
    {
        "CONFIG0_ID",
        "Name: Configuration Identification Register 0  Address Offset: 0x0004 "
        " Size: 8 bits  Value after Reset: Implementation Dependent  Access: Re"
        "ad",
        1, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_hdmi_config0_id
    },
    {
        "CONFIG1_ID",
        "Name: Configuration Identification Register 1  Address Offset: 0x0005 "
        " Size: 8 bits  Value after Reset: Implementation Dependent  Access: Re"
        "ad",
        1, // Width in bytes
        0x00000005, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_hdmi_config1_id
    },
    {
        "CONFIG2_ID",
        "Name: Configuration Identification Register 2  Address Offset: 0x0006 "
        " Size: 8 bits  Value after Reset: Implementation Dependent  Access: Re"
        "ad",
        1, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_config2_id
    },
    {
        "CONFIG3_ID",
        "Name: Configuration Identification Register 3  Address Offset: 0x0007 "
        " Size: 8 bits  Value after Reset: Implementation Dependent  Access: Re"
        "ad",
        1, // Width in bytes
        0x00000007, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_config3_id
    },
    {
        "IH_FC_STAT0",
        "This section describes clear on write (1 to corresponding bit) status "
        "registers, which contain the following active-high, sticky bit interru"
        "pts.",
        1, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_ih_fc_stat0
    },
    {
        "IH_FC_STAT1",
        "Address Offset: 0x0101  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Clear on Write",
        1, // Width in bytes
        0x00000101, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_ih_fc_stat1
    },
    {
        "IH_FC_STAT2",
        "Address Offset: 0x0102  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Clear on Write",
        1, // Width in bytes
        0x00000102, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_ih_fc_stat2
    },
    {
        "IH_AS_STAT0",
        "Address Offset: 0x0103  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Clear on Write",
        1, // Width in bytes
        0x00000103, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_ih_as_stat0
    },
    {
        "IH_PHY_STAT0",
        "Address Offset: 0x0104  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Clear on Write/Read",
        1, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_ih_phy_stat0
    },
    {
        "IH_I2CM_STAT0",
        "Address Offset: 0x0105  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Clear on Write/Read",
        1, // Width in bytes
        0x00000105, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_ih_i2cm_stat0
    },
    {
        "IH_CEC_STAT0",
        "Address Offset: 0x0106  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Clear on Write",
        1, // Width in bytes
        0x00000106, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_ih_cec_stat0
    },
    {
        "IH_VP_STAT0",
        "Address Offset: 0x0107  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Clear on Write",
        1, // Width in bytes
        0x00000107, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_ih_vp_stat0
    },
    {
        "IH_I2CMPHY_STAT0",
        "This clear on write (1 to corresponding bit) register contains the fol"
        "lowing active high sticky bit interrupts.",
        1, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_ih_i2cmphy_stat0
    },
    {
        "IH_AHBDMAAUD_STAT0",
        "Address Offset: 0x0109  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Clear on Write",
        1, // Width in bytes
        0x00000109, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_ih_ahbdmaaud_stat0
    },
    {
        "IH_MUTE_FC_STAT0",
        "Address Offset: 0x0180  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_ih_mute_fc_stat0
    },
    {
        "IH_MUTE_FC_STAT1",
        "Address Offset: 0x0181  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000181, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_ih_mute_fc_stat1
    },
    {
        "IH_MUTE_FC_STAT2",
        "Address Offset: 0x0182  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000182, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_ih_mute_fc_stat2
    },
    {
        "IH_MUTE_AS_STAT0",
        "Address Offset: 0x0183  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000183, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_ih_mute_as_stat0
    },
    {
        "IH_MUTE_PHY_STAT0",
        "Address Offset: 0x0184  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_ih_mute_phy_stat0
    },
    {
        "IH_MUTE_I2CM_STAT0",
        "Address Offset: 0x0185  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000185, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_ih_mute_i2cm_stat0
    },
    {
        "IH_MUTE_CEC_STAT0",
        "Address Offset: 0x0186  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000186, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_ih_mute_cec_stat0
    },
    {
        "IH_MUTE_VP_STAT0",
        "Address Offset: 0x0187  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000187, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_ih_mute_vp_stat0
    },
    {
        "IH_MUTE_I2CMPHY_STAT0",
        "Address Offset: 0x0188  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_ih_mute_i2cmphy_stat0
    },
    {
        "IH_MUTE_AHBDMAAUD_STAT0",
        "Address Offset: 0x0189  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000189, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_ih_mute_ahbdmaaud_stat0
    },
    {
        "IH_MUTE",
        "Address Offset: 0x01FF  Size: 8 bits  Value after Reset: 0x03  Access:"
        " Read/Write",
        1, // Width in bytes
        0x000001ff, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_ih_mute
    },
    {
        "TX_INVID0",
        "This registers contains the input video mapping code as defined in Tab"
        "le 2-1.",
        1, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_tx_invid0
    },
    {
        "TX_INSTUFFING",
        "This register enables the stuffing mechanism of the Video Sampler modu"
        "le in order to correctly perform Color Space Conversion of the ITU.601"
        " standard YCC video.",
        1, // Width in bytes
        0x00000201, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_tx_instuffing
    },
    {
        "TX_GYDATA0",
        "Address Offset: 0x0202  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000202, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_tx_gydata0
    },
    {
        "TX_GYDATA1",
        "Address Offset: 0x0203  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000203, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_tx_gydata1
    },
    {
        "TX_RCRDATA0",
        "Address Offset: 0x0204  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_tx_rcrdata0
    },
    {
        "TX_RCRDATA1",
        "Address Offset: 0x0205  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000205, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_tx_rcrdata1
    },
    {
        "TX_BCBDATA0",
        "Address Offset: 0x0206  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000206, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_tx_bcbdata0
    },
    {
        "TX_BCBDATA1",
        "Address Offset: 0x0207  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00000207, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_tx_bcbdata1
    },
    {
        "VP_STATUS",
        "Address Offset: 0x0800  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read",
        1, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_vp_status
    },
    {
        "VP_PR_CD",
        "This register configures the Color Depth of the input video and Pixel "
        "repetition to apply to video.",
        1, // Width in bytes
        0x00000801, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_vp_pr_cd
    },
    {
        "VP_STUFF",
        "This register controls the Pixel repetition, pixel packing and YCC422 "
        "stuffing.",
        1, // Width in bytes
        0x00000802, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_vp_stuff
    },
    {
        "VP_REMAP",
        "This register controls YCC422 remap of the Video Packetizer.",
        1, // Width in bytes
        0x00000803, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_vp_remap
    },
    {
        "VP_CONF",
        "This register controls the Video Packetizer output selection, bypass s"
        "elect, YCC422 enable, Pixel repeater, and pixel packing enabling.",
        1, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_vp_conf
    },
    {
        "VP_STAT",
        "This register contains the following active high FIFO status indicatio"
        "ns:   Address Offset: 0x0805  Size: 8 bits  Value after Reset: 0x00  A"
        "ccess: Read",
        1, // Width in bytes
        0x00000805, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_hdmi_vp_stat
    },
    {
        "VP_INT",
        "This register contains the interrupt indication of the VP_STAT status "
        "interrupts.",
        1, // Width in bytes
        0x00000806, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_hdmi_vp_int
    },
    {
        "VP_MASK",
        "Mask register for generation of VP_INT interrupts.",
        1, // Width in bytes
        0x00000807, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_vp_mask
    },
    {
        "VP_POL",
        "Polarity register for generation of VP_INT interrupts.",
        1, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_vp_pol
    },
    {
        "FC_INHACTIV0",
        "Address Offset: 0x1001  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001001, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_inhactiv0
    },
    {
        "FC_INHACTIV1",
        "Address Offset: 0x1002  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001002, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_inhactiv1
    },
    {
        "FC_INHBLANK0",
        "Address Offset: 0x1003  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001003, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_inhblank0
    },
    {
        "FC_INHBLANK1",
        "Address Offset: 0x1004  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_inhblank1
    },
    {
        "FC_INVACTIV0",
        "Address Offset: 0x1005  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001005, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_invactiv0
    },
    {
        "FC_INVACTIV1",
        "Address Offset: 0x1006  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001006, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_invactiv1
    },
    {
        "FC_INVBLANK",
        "Address Offset: 0x1007  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001007, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_invblank
    },
    {
        "FC_HSYNCINDELAY0",
        "Address Offset: 0x1008  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_hsyncindelay0
    },
    {
        "FC_HSYNCINDELAY1",
        "Address Offset: 0x1009  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001009, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_hsyncindelay1
    },
    {
        "FC_HSYNCINWIDTH0",
        "Address Offset: 0x100A  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000100a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_hsyncinwidth0
    },
    {
        "FC_HSYNCINWIDTH1",
        "Address Offset: 0x100B  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000100b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_hsyncinwidth1
    },
    {
        "FC_VSYNCINDELAY",
        "Address Offset: 0x100C  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000100c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_vsyncindelay
    },
    {
        "FC_VSYNCINWIDTH",
        "Address Offset: 0x100D  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000100d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_vsyncinwidth
    },
    {
        "FC_INFREQ0",
        "Address Offset: 0x100E  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000100e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_infreq0
    },
    {
        "FC_INFREQ1",
        "Address Offset: 0x100F  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000100f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_infreq1
    },
    {
        "FC_INFREQ2",
        "Address Offset: 0x1010  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_infreq2
    },
    {
        "FC_CTRLDUR",
        "Address Offset: 0x1011  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001011, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_ctrldur
    },
    {
        "FC_EXCTRLDUR",
        "Address Offset: 0x1012  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001012, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_exctrldur
    },
    {
        "FC_EXCTRLSPAC",
        "Address Offset: 0x1013  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001013, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_exctrlspac
    },
    {
        "FC_CH0PREAM",
        "Address Offset: 0x1014  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_ch0pream
    },
    {
        "FC_CH1PREAM",
        "Address Offset: 0x1015  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001015, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_ch1pream
    },
    {
        "FC_CH2PREAM",
        "Address Offset: 0x1016  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001016, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_ch2pream
    },
    {
        "FC_AVICONF3",
        "Address Offset: 0x1017  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write   configuration of Quantization range and IT content type.",
        1, // Width in bytes
        0x00001017, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_aviconf3
    },
    {
        "FC_GCP",
        "Configures the General Control Packet A/V mute indicators and the defa"
        "ult phase.",
        1, // Width in bytes
        0x00001018, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_fc_gcp
    },
    {
        "FC_AVICONF0",
        "Configures the following contents of the AVI infoFrame:   RGB/YCC indi"
        "cation  Bar information  Scan information  Active format present  Prog"
        "ressive/Interlaced indicator  Active aspect ratio  Picture aspect rati"
        "o  Colorimetry  IT content  Extended colorimetry  Quantization range  "
        "Non-uniform picture scaling   For more information, refer to HDMI 1.4a"
        " and CEA - 861D specifications.",
        1, // Width in bytes
        0x00001019, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_hdmi_fc_aviconf0
    },
    {
        "FC_AVICONF1",
        "Address Offset: 0x101A  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000101a, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_fc_aviconf1
    },
    {
        "FC_AVICONF2",
        "Address Offset: 0x101B  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000101b, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_fc_aviconf2
    },
    {
        "FC_AVIVID",
        "Configures the AVI infoFrame Video Identification code.",
        1, // Width in bytes
        0x0000101c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_avivid
    },
    {
        "FC_AVIETB0",
        "These registers define the AVI infoFrame End of Top Bar value.",
        1, // Width in bytes
        0x0000101d, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_avietb0
    },
    {
        "FC_AVIETB1",
        "Address Offset: 0x101E  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000101e, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_avietb1
    },
    {
        "FC_AVISBB0",
        "These registers define the AVI infoFrame Start of Bottom Bar value.",
        1, // Width in bytes
        0x0000101f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_avisbb0
    },
    {
        "FC_AVISBB1",
        "Address Offset: 0x1020  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_avisbb1
    },
    {
        "FC_AVIELB0",
        "These registers define the AVI infoFrame End of Left Bar value.",
        1, // Width in bytes
        0x00001021, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_avielb0
    },
    {
        "FC_AVIELB1",
        "Address Offset: 0x1022  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001022, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_avielb1
    },
    {
        "FC_AVISRB0",
        "These registers define the AVI infoFrame Start of Right Bar value.",
        1, // Width in bytes
        0x00001023, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_avisrb0
    },
    {
        "FC_AVISRB1",
        "Address Offset: 0x1024  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_avisrb1
    },
    {
        "FC_AUDICONF0",
        "These registers configure the following contents of the AUDIO infoFram"
        "e:   Coding type  Channel count  Sampling frequency  Sampling size  Ch"
        "annel allocation  Audio level shift value  Down mix enable   For more "
        "information, refer to CEA-861D specification.",
        1, // Width in bytes
        0x00001025, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_audiconf0
    },
    {
        "FC_AUDICONF1",
        "",
        1, // Width in bytes
        0x00001026, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_audiconf1
    },
    {
        "FC_AUDICONF2",
        "",
        1, // Width in bytes
        0x00001027, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_audiconf2
    },
    {
        "FC_AUDICONF3",
        "",
        1, // Width in bytes
        0x00001028, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_fc_audiconf3
    },
    {
        "FC_VSDIEEEID0",
        "These registers configure the Vendor Specific infoFrame IEEE registrat"
        "ion identifier.",
        1, // Width in bytes
        0x00001029, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdieeeid0
    },
    {
        "FC_VSDSIZE",
        "Address Offset: 0x102A  Size: 8 bits  Value after Reset: 0x1B  Access:"
        " Read/Write   configuration of Packet size.",
        1, // Width in bytes
        0x0000102a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_vsdsize
    },
    {
        "FC_VSDIEEEID1",
        "Address Offset: 0x102a  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001030, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdieeeid1
    },
    {
        "FC_VSDIEEEID2",
        "Address Offset: 0x102b  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001031, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdieeeid2
    },
    {
        "FC_VSDPAYLOAD0",
        "These registers configure the Vendor Specific infoFrame 24 bytes speci"
        "fic payload.",
        1, // Width in bytes
        0x00001032, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload0
    },
    {
        "FC_VSDPAYLOAD1",
        "Address Offset: 0x1033  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001033, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload1
    },
    {
        "FC_VSDPAYLOAD2",
        "Address Offset: 0x1034  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001034, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload2
    },
    {
        "FC_VSDPAYLOAD3",
        "Address Offset: 0x1035  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001035, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload3
    },
    {
        "FC_VSDPAYLOAD4",
        "Address Offset: 0x1036  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001036, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload4
    },
    {
        "FC_VSDPAYLOAD5",
        "Address Offset: 0x1037  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001037, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload5
    },
    {
        "FC_VSDPAYLOAD6",
        "Address Offset: 0x1038  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001038, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload6
    },
    {
        "FC_VSDPAYLOAD7",
        "Address Offset: 0x1039  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001039, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload7
    },
    {
        "FC_VSDPAYLOAD8",
        "Address Offset: 0x103a  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000103a, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload8
    },
    {
        "FC_VSDPAYLOAD9",
        "Address Offset: 0x103b  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000103b, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload9
    },
    {
        "FC_VSDPAYLOAD10",
        "Address Offset: 0x103c  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000103c, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload10
    },
    {
        "FC_VSDPAYLOAD11",
        "Address Offset: 0x103d  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000103d, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload11
    },
    {
        "FC_VSDPAYLOAD12",
        "Address Offset: 0x103e  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000103e, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload12
    },
    {
        "FC_VSDPAYLOAD13",
        "Address Offset: 0x103f  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000103f, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload13
    },
    {
        "FC_VSDPAYLOAD14",
        "Address Offset: 0x1040  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001040, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload14
    },
    {
        "FC_VSDPAYLOAD15",
        "Address Offset: 0x1041  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001041, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload15
    },
    {
        "FC_VSDPAYLOAD16",
        "Address Offset: 0x1042  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001042, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload16
    },
    {
        "FC_VSDPAYLOAD17",
        "Address Offset: 0x1043  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001043, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload17
    },
    {
        "FC_VSDPAYLOAD18",
        "Address Offset: 0x1044  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001044, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload18
    },
    {
        "FC_VSDPAYLOAD19",
        "Address Offset: 0x1045  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001045, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload19
    },
    {
        "FC_VSDPAYLOAD20",
        "Address Offset: 0x1046  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001046, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload20
    },
    {
        "FC_VSDPAYLOAD21",
        "Address Offset: 0x1047  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001047, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload21
    },
    {
        "FC_VSDPAYLOAD22",
        "Address Offset: 0x1048  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001048, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload22
    },
    {
        "FC_VSDPAYLOAD23",
        "Address Offset: 0x1049  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001049, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_fc_vsdpayload23
    },
    {
        "FC_SPDVENDORNAME0",
        "These registers configure the Source Product Descriptor infoFrame 8 by"
        "tes Vendor name.",
        1, // Width in bytes
        0x0000104a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_spdvendorname0
    },
    {
        "FC_SPDPRODUCTNAME0",
        "These registers configure the Source Product Descriptor infoFrame 16 b"
        "ytes Product name.",
        1, // Width in bytes
        0x00001052, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_spdproductname0
    },
    {
        "FC_SPDDEVICEINF",
        "This register configures Source Product Descriptor infoFrame descripti"
        "on device field.",
        1, // Width in bytes
        0x00001062, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_spddeviceinf
    },
    {
        "FC_AUDSCONF",
        "Configures the Audio sample packet sample flat and layout configuratio"
        "n.",
        1, // Width in bytes
        0x00001063, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_audsconf
    },
    {
        "FC_AUDSSTAT",
        "Shows the data sample present indication of the last Audio sample pack"
        "et sent by the HDMI TX Controller.",
        1, // Width in bytes
        0x00001064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_audsstat
    },
    {
        "FC_CTRLQHIGH",
        "Address Offset: 0x1073  Size: 8 bits  Value after Reset: 0x0F  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001073, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_ctrlqhigh
    },
    {
        "FC_CTRLQLOW",
        "Address Offset: 0x1074  Size: 8 bits  Value after Reset: 0x03  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001074, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_ctrlqlow
    },
    {
        "FC_ACP0",
        "Configures the following contents of the ACP packet.",
        1, // Width in bytes
        0x00001075, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_acp0
    },
    {
        "FC_ACP1",
        "Configures the following contents of the Audio Content Packet (ACP) bo"
        "dy:   Address Offset: 0x1091 to 0x1082  Size: 8 bits  Value after Rese"
        "t: 0x00  Access: Read/Write",
        1, // Width in bytes
        0x00001091, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_acp1
    },
    {
        "FC_ISCR1_0",
        "Configures the following contents of the ISRC1 packet:   Address Offse"
        "t: 0x1092  Size: 8 bits  Value after Reset: 0x00  Access: Read/Write  "
        " For more information, see the HDMI 1.4 specification.",
        1, // Width in bytes
        0x00001092, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_fc_iscr1_0
    },
    {
        "FC_ISCR1_1",
        "Configures the following contents of the ISRC1 packet:   ISRC1 packet "
        "body  Address Offset: 0x10A2 to 0x1093  Size: 8 bits  Value after Rese"
        "t: 0x00  Access: Read/Write   For more information, see the HDMI 1.4 s"
        "pecification.",
        1, // Width in bytes
        0x00001093, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_iscr1_1
    },
    {
        "FC_ISCR2_0",
        "Configures the following contents of the ISRC2 packet:   ISRC2 packet "
        "body  Address Offset: 0x10B2 to 0x10A3  Size: 8 bits  Value after Rese"
        "t: 0x00  Access: Read/Write   For more information, see the HDMI 1.4 s"
        "pecification.",
        1, // Width in bytes
        0x000010a3, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_iscr2_0
    },
    {
        "FC_DATAUTO0",
        "Configures the Frame Composer RDRB(1)/Manual(0) data island packet ins"
        "ertion for SPD, VSD, ISRC2, ISRC1 and ACP packets.",
        1, // Width in bytes
        0x000010b3, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_hdmi_fc_datauto0
    },
    {
        "FC_DATAUTO1",
        "Configures the Frame Composer (FC) RDRB frame interpolation for SPD, V"
        "SD, ISRC2, ISRC1 and ACP packet insertion on data island when FC is on"
        " RDRB mode for the listed packets.",
        1, // Width in bytes
        0x000010b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_datauto1
    },
    {
        "FC_DATAUTO2",
        "Configures the Frame Composer (FC) RDRB line interpolation and number "
        "of packets in frame for SPD, VSD, ISRC2, ISRC1 and ACP packet insertio"
        "n on data island when FC is on RDRB mode for the listed packets.",
        1, // Width in bytes
        0x000010b5, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_datauto2
    },
    {
        "FC_DATMAN",
        "Requests to the Frame Composer the data island packet insertion for NU"
        "LL, SPD, VSD, ISRC2, ISRC1 and ACP packets when FC_DATAUTO0 bit is in "
        "manual mode for the packet requested.",
        1, // Width in bytes
        0x000010b6, // Base address offset
        false, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_fc_datman
    },
    {
        "FC_DATAUTO3",
        "Configures the Frame Composer Automatic(1)/RDRB(0) data island packet "
        "insertion for AVI, GCP, AUDI and ACR packets.",
        1, // Width in bytes
        0x000010b7, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_hdmi_fc_datauto3
    },
    {
        "FC_RDRB0",
        "Configures the Frame Composer (FC) RDRB frame interpolation for ACR pa"
        "cket insertion on data island when FC is on RDRB mode for this packet.",
        1, // Width in bytes
        0x000010b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_rdrb0
    },
    {
        "FC_RDRB1",
        "Configures the Frame Composer (FC) RDRB line interpolation and number "
        "of packets in frame for the ACR packet insertion on data island when F"
        "C is on RDRB mode this packet.",
        1, // Width in bytes
        0x000010b9, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_rdrb1
    },
    {
        "FC_RDRB2",
        "Configures the Frame Composer (FC) RDRB frame interpolation for AUDI p"
        "acket insertion on data island when FC is on RDRB mode for this packet"
        ".",
        1, // Width in bytes
        0x000010ba, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_rdrb2
    },
    {
        "FC_RDRB3",
        "Configures the Frame Composer (FC) RDRB line interpolation and number "
        "of packets in frame for the AUDI packet insertion on data island when "
        "FC is on RDRB mode this packet.",
        1, // Width in bytes
        0x000010bb, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_rdrb3
    },
    {
        "FC_RDRB4",
        "Configures the Frame Composer (FC) RDRB frame interpolation for GCP pa"
        "cket insertion on data island when FC is on RDRB mode for this packet.",
        1, // Width in bytes
        0x000010bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_rdrb4
    },
    {
        "FC_RDRB5",
        "Configures the Frame Composer (FC) RDRB line interpolation and number "
        "of packets in frame for the GCP packet insertion on data island when F"
        "C is on RDRB mode this packet.",
        1, // Width in bytes
        0x000010bd, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_rdrb5
    },
    {
        "FC_RDRB6",
        "Configures the Frame Composer (FC) RDRB frame interpolation for AVI pa"
        "cket insertion on data island when FC is on RDRB mode for this packet.",
        1, // Width in bytes
        0x000010be, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_rdrb6
    },
    {
        "FC_RDRB7",
        "Configures the Frame Composer (FC) RDRB line interpolation and number "
        "of packets in frame for the AVI packet insertion on data island when F"
        "C is on RDRB mode this packet.",
        1, // Width in bytes
        0x000010bf, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_rdrb7
    },
    {
        "FC_STAT0",
        "Configures the Frame Composer (FC) RDRB line interpolation and number "
        "of packets in frame for the AVI packet insertion on data island when F"
        "C is on RDRB mode this packet.",
        1, // Width in bytes
        0x000010d0, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_hdmi_fc_stat0
    },
    {
        "FC_INT0",
        "This register contains the interrupt indication of the FC_STAT0 status"
        " interrupts.",
        1, // Width in bytes
        0x000010d1, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_fc_int0
    },
    {
        "FC_MASK0",
        "Mask register for generation of FC_INT0 interrupts.",
        1, // Width in bytes
        0x000010d2, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_fc_mask0
    },
    {
        "FC_POL0",
        "Polarity register for generation of FC_INT0 interrupts.",
        1, // Width in bytes
        0x000010d3, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_fc_pol0
    },
    {
        "FC_STAT1",
        "This register contains the following active high packet sent status in"
        "dications:   Address Offset: 0x10D4  Size: 8 bits  Value after Reset: "
        "0x00  Access: Read/Write",
        1, // Width in bytes
        0x000010d4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_fc_stat1
    },
    {
        "FC_INT1",
        "This register contains the interrupt indication of the FC_STAT1 status"
        " interrupts.",
        1, // Width in bytes
        0x000010d5, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_fc_int1
    },
    {
        "FC_MASK1",
        "Mask register for generation of FC_INT1 interrupts.",
        1, // Width in bytes
        0x000010d6, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_fc_mask1
    },
    {
        "FC_POL1",
        "Polarity register for generation of FC_INT1 interrupts.",
        1, // Width in bytes
        0x000010d7, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_fc_pol1
    },
    {
        "FC_STAT2",
        "This register contains the following active high packet sent status in"
        "dications:   Address Offset: 0x10D8  Size: 8 bits  Value after Reset: "
        "0x00  Access: Read/Write",
        1, // Width in bytes
        0x000010d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_stat2
    },
    {
        "FC_INT2",
        "This register contains the interrupt indication of the FC_STAT2 status"
        " interrupts.",
        1, // Width in bytes
        0x000010d9, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_int2
    },
    {
        "FC_MASK2",
        "Mask register for generation of FC_INT2 interrupts.",
        1, // Width in bytes
        0x000010da, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_mask2
    },
    {
        "FC_POL2",
        "Polarity register for generation of FC_INT2 interrupts.",
        1, // Width in bytes
        0x000010db, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_pol2
    },
    {
        "FC_PRCONF",
        "Defines the Pixel Repetition ratio factor of the input and output vide"
        "o signal.",
        1, // Width in bytes
        0x000010e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_prconf
    },
    {
        "FC_GMD_STAT",
        "Gamut metadata packet status bit information for no_current_gmd, next_"
        "gmd_field, gmd_packet_sequence and current_gamut_seq_num.",
        1, // Width in bytes
        0x00001100, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_hdmi_fc_gmd_stat
    },
    {
        "FC_GMD_EN",
        "This register enables Gamut metadata (GMD) packet transmission.",
        1, // Width in bytes
        0x00001101, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_en
    },
    {
        "FC_GMD_UP",
        "This register performs an GMD packet content update according to the c"
        "onfigured packet body (FC_GMD_PB0 to FC_GMD_PB27) and packet header (F"
        "C_GMD_HB).",
        1, // Width in bytes
        0x00001102, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_up
    },
    {
        "FC_GMD_CONF",
        "This register configures the number of GMD packets to be inserted per "
        "frame (starting always in the line where the active Vsync appears) and"
        " the line spacing between the transmitted GMD packets.",
        1, // Width in bytes
        0x00001103, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_gmd_conf
    },
    {
        "FC_GMD_HB",
        "This register configures the GMD packet header affected_gamut_seq_num "
        "and gmd_profile bits.",
        1, // Width in bytes
        0x00001104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_gmd_hb
    },
    {
        "FC_GMD_PB0",
        "Configures the following contents of the GMD packet:   GMD packet body"
        " byte0  Address Offset: 0x1105  Size: 8 bits  Value after Reset: 0x00 "
        " Access: Read/Write   For more information, refer to the HDMI 1.4a spe"
        "cification.",
        1, // Width in bytes
        0x00001105, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb0
    },
    {
        "FC_GMD_PB1",
        "GMD packet body byte1  Address Offset: 0x1106  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001106, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb1
    },
    {
        "FC_GMD_PB2",
        "GMD packet body byte2  Address Offset: 0x1107  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001107, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb2
    },
    {
        "FC_GMD_PB3",
        "GMD packet body byte3  Address Offset: 0x1108  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb3
    },
    {
        "FC_GMD_PB4",
        "GMD packet body byte4  Address Offset: 0x1109  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001109, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb4
    },
    {
        "FC_GMD_PB5",
        "GMD packet body byte5  Address Offset: 0x110a  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000110a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb5
    },
    {
        "FC_GMD_PB6",
        "GMD packet body byte6  Address Offset: 0x110b  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000110b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb6
    },
    {
        "FC_GMD_PB7",
        "GMD packet body byte7  Address Offset: 0x110c  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000110c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb7
    },
    {
        "FC_GMD_PB8",
        "GMD packet body byte8  Address Offset: 0x110d  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000110d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb8
    },
    {
        "FC_GMD_PB9",
        "GMD packet body byte9  Address Offset: 0x110e  Size: 8 bits  Value aft"
        "er Reset: 0x00  Access: Read/Write   For more information, refer to th"
        "e HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000110e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb9
    },
    {
        "FC_GMD_PB10",
        "GMD packet body byte10  Address Offset: 0x110f  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000110f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb10
    },
    {
        "FC_GMD_PB11",
        "GMD packet body byte11  Address Offset: 0x1110  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb11
    },
    {
        "FC_GMD_PB12",
        "GMD packet body byte12  Address Offset: 0x1111  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001111, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb12
    },
    {
        "FC_GMD_PB13",
        "GMD packet body byte13  Address Offset: 0x1112  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001112, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb13
    },
    {
        "FC_GMD_PB14",
        "GMD packet body byte14  Address Offset: 0x1113  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001113, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb14
    },
    {
        "FC_GMD_PB15",
        "GMD packet body byte15  Address Offset: 0x1114  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb15
    },
    {
        "FC_GMD_PB16",
        "GMD packet body byte16  Address Offset: 0x1115  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001115, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb16
    },
    {
        "FC_GMD_PB17",
        "GMD packet body byte17  Address Offset: 0x1116  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001116, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb17
    },
    {
        "FC_GMD_PB18",
        "GMD packet body byte18  Address Offset: 0x1117  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001117, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb18
    },
    {
        "FC_GMD_PB19",
        "GMD packet body byte19  Address Offset: 0x1118  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb19
    },
    {
        "FC_GMD_PB20",
        "GMD packet body byte20  Address Offset: 0x1119  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001119, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb20
    },
    {
        "FC_GMD_PB21",
        "GMD packet body byte21  Address Offset: 0x111a  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000111a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb21
    },
    {
        "FC_GMD_PB22",
        "GMD packet body byte22  Address Offset: 0x111b  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000111b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb22
    },
    {
        "FC_GMD_PB23",
        "GMD packet body byte23  Address Offset: 0x111c  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000111c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb23
    },
    {
        "FC_GMD_PB24",
        "GMD packet body byte24  Address Offset: 0x111d  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000111d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb24
    },
    {
        "FC_GMD_PB25",
        "GMD packet body byte25  Address Offset: 0x111e  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000111e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb25
    },
    {
        "FC_GMD_PB26",
        "GMD packet body byte26  Address Offset: 0x111f  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x0000111f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb26
    },
    {
        "FC_GMD_PB27",
        "GMD packet body byte27  Address Offset: 0x1120  Size: 8 bits  Value af"
        "ter Reset: 0x00  Access: Read/Write   For more information, refer to t"
        "he HDMI 1.4a specification.",
        1, // Width in bytes
        0x00001120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_gmd_pb27
    },
    {
        "FC_DBGFORCE",
        "This register allows to force the controller to output audio and video"
        " data the values configured in the FC_DBGAUD and FC_DBGTMDS registers.",
        1, // Width in bytes
        0x00001200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_fc_dbgforce
    },
    {
        "FC_DBGAUD0CH0",
        "Configures the audio fixed data to be used in channel 0 when in fixed "
        "audio selection.",
        1, // Width in bytes
        0x00001201, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud0ch0
    },
    {
        "FC_DBGAUD1CH0",
        "Address Offset: 0x1202  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001202, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud1ch0
    },
    {
        "FC_DBGAUD2CH0",
        "Address Offset: 0x1203  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001203, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud2ch0
    },
    {
        "FC_DBGAUD0CH1",
        "Configures the audio fixed data to be used in channel 0 when in fixed "
        "audio selection.",
        1, // Width in bytes
        0x00001204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud0ch1
    },
    {
        "FC_DBGAUD1CH1",
        "Address Offset: 0x1205  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001205, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud1ch1
    },
    {
        "FC_DBGAUD2CH1",
        "Address Offset: 0x1206  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001206, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud2ch1
    },
    {
        "FC_DBGAUD0CH2",
        "Configures the audio fixed data to be used in channel 0 when in fixed "
        "audio selection.",
        1, // Width in bytes
        0x00001207, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud0ch2
    },
    {
        "FC_DBGAUD1CH2",
        "Address Offset: 0x1208  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud1ch2
    },
    {
        "FC_DBGAUD2CH2",
        "Address Offset: 0x1209  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001209, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud2ch2
    },
    {
        "FC_DBGAUD0CH3",
        "Configures the audio fixed data to be used in channel 0 when in fixed "
        "audio selection.",
        1, // Width in bytes
        0x0000120a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud0ch3
    },
    {
        "FC_DBGAUD1CH3",
        "Address Offset: 0x120B  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000120b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud1ch3
    },
    {
        "FC_DBGAUD2CH3",
        "Address Offset: 0x120C  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000120c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud2ch3
    },
    {
        "FC_DBGAUD0CH4",
        "Configures the audio fixed data to be used in channel 0 when in fixed "
        "audio selection.",
        1, // Width in bytes
        0x0000120d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud0ch4
    },
    {
        "FC_DBGAUD1CH4",
        "Address Offset: 0x120E  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000120e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud1ch4
    },
    {
        "FC_DBGAUD2CH4",
        "Address Offset: 0x120F  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000120f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud2ch4
    },
    {
        "FC_DBGAUD0CH5",
        "Configures the audio fixed data to be used in channel 0 when in fixed "
        "audio selection.",
        1, // Width in bytes
        0x00001210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud0ch5
    },
    {
        "FC_DBGAUD1CH5",
        "Address Offset: 0x1211  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001211, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud1ch5
    },
    {
        "FC_DBGAUD2CH5",
        "Address Offset: 0x1212  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001212, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud2ch5
    },
    {
        "FC_DBGAUD0CH6",
        "Configures the audio fixed data to be used in channel 0 when in fixed "
        "audio selection.",
        1, // Width in bytes
        0x00001213, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud0ch6
    },
    {
        "FC_DBGAUD1CH6",
        "Address Offset: 0x1214  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud1ch6
    },
    {
        "FC_DBGAUD2CH6",
        "Address Offset: 0x1215  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001215, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud2ch6
    },
    {
        "FC_DBGAUD0CH7",
        "Configures the audio fixed data to be used in channel 7 when in fixed "
        "audio selection.",
        1, // Width in bytes
        0x00001216, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud0ch7
    },
    {
        "FC_DBGAUD1CH7",
        "Address Offset: 0x1217  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001217, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud1ch7
    },
    {
        "FC_DBGAUD2CH7",
        "Address Offset: 0x1218  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00001218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgaud2ch7
    },
    {
        "FC_DBGTMDS0",
        "Configures the video fixed data to be used in tmds channel 0 when in f"
        "ixed video selection.",
        1, // Width in bytes
        0x00001219, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgtmds0
    },
    {
        "FC_DBGTMDS1",
        "Configures the video fixed data to be used in tmds channel 1 when in f"
        "ixed video selection.",
        1, // Width in bytes
        0x0000121a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgtmds1
    },
    {
        "FC_DBGTMDS2",
        "Configures the video fixed data to be used in tmds channel 2 when in f"
        "ixed video selection.",
        1, // Width in bytes
        0x0000121b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_fc_dbgtmds2
    },
    {
        "PHY_CONF0",
        "This register holds the power down, data enable polarity and interface"
        " control of the HDMI Source PHY control.",
        1, // Width in bytes
        0x00003000, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_phy_conf0
    },
    {
        "PHY_TST0",
        "PHY TX mapped text interface (control).",
        1, // Width in bytes
        0x00003001, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_phy_tst0
    },
    {
        "PHY_TST1",
        "PHY TX mapped text interface (data in).",
        1, // Width in bytes
        0x00003002, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_tst1
    },
    {
        "PHY_TST2",
        "PHY TX mapped text interface (data out).",
        1, // Width in bytes
        0x00003003, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_tst2
    },
    {
        "PHY_STAT0",
        "This register contains the following active high packet sent status in"
        "dications.",
        1, // Width in bytes
        0x00003004, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_hdmi_phy_stat0
    },
    {
        "PHY_INT0",
        "This register contains the interrupt indication of the PHY_STAT0 statu"
        "s interrupts.",
        1, // Width in bytes
        0x00003005, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_hdmi_phy_int0
    },
    {
        "PHY_MASK0",
        "Mask register for generation of PHY_INT0 interrupts.",
        1, // Width in bytes
        0x00003006, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_phy_mask0
    },
    {
        "PHY_POL0",
        "Polarity register for generation of PHY_INT0 interrupts.",
        1, // Width in bytes
        0x00003007, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_hdmi_phy_pol0
    },
    {
        "PHY_I2CM_SLAVE_ADDR",
        "This register writes the slave address of the I2C Master PHY.",
        1, // Width in bytes
        0x00003020, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_hdmi_phy_i2cm_slave_addr
    },
    {
        "PHY_I2CM_ADDRESS_ADDR",
        "This register writes the address for read and writer operations.",
        1, // Width in bytes
        0x00003021, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_address_addr
    },
    {
        "PHY_I2CM_DATAO_1_ADDR",
        "Address Offset: 0x3022  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00003022, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_datao_1_addr
    },
    {
        "PHY_I2CM_DATAO_0_ADDR",
        "Address Offset: 0x3023  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00003023, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_datao_0_addr
    },
    {
        "PHY_I2CM_DATAI_1_ADDR",
        "Address Offset: 0x3024  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read",
        1, // Width in bytes
        0x00003024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_datai_1_addr
    },
    {
        "PHY_I2CM_DATAI_0_ADDR",
        "Address Offset: 0x3025  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read",
        1, // Width in bytes
        0x00003025, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_datai_0_addr
    },
    {
        "PHY_I2CM_OPERATION_ADDR",
        "This register requests read and write operations from the I2C Master P"
        "HY.",
        1, // Width in bytes
        0x00003026, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_phy_i2cm_operation_addr
    },
    {
        "PHY_I2CM_INT_ADDR",
        "This register contains and configures I2C master PHY done interrupt.",
        1, // Width in bytes
        0x00003027, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_hdmi_phy_i2cm_int_addr
    },
    {
        "PHY_I2CM_CTLINT_ADDR",
        "This register contains and configures the I2C master PHY error interru"
        "pts.",
        1, // Width in bytes
        0x00003028, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_phy_i2cm_ctlint_addr
    },
    {
        "PHY_I2CM_DIV_ADDR",
        "This register wets the I2C Master PHY to work in either Fast or Standa"
        "rd mode.",
        1, // Width in bytes
        0x00003029, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_div_addr
    },
    {
        "PHY_I2CM_SOFTRSTZ_ADDR",
        "This register sets the I2C Master PHY software reset.",
        1, // Width in bytes
        0x0000302a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_softrstz_addr
    },
    {
        "PHY_I2CM_SS_SCL_HCNT_1_ADDR",
        "Address Offset: 0x302B  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000302b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_ss_scl_hcnt_1_addr
    },
    {
        "PHY_I2CM_SS_SCL_HCNT_0_ADDR",
        "Address Offset: 0x302C  Size: 8 bits  Value after Reset: 0x6C  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000302c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_ss_scl_hcnt_0_addr
    },
    {
        "PHY_I2CM_SS_SCL_LCNT_1_ADDR",
        "Address Offset: 0x302D  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000302d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_ss_scl_lcnt_1_addr
    },
    {
        "PHY_I2CM_SS_SCL_LCNT_0_ADDR",
        "Address Offset: 0x302E  Size: 8 bits  Value after Reset: 0x7F  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000302e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_ss_scl_lcnt_0_addr
    },
    {
        "PHY_I2CM_FS_SCL_HCNT_1_ADDR",
        "Address Offset: 0x302F  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000302f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_fs_scl_hcnt_1_addr
    },
    {
        "PHY_I2CM_FS_SCL_HCNT_0_ADDR",
        "Address Offset: 0x3030  Size: 8 bits  Value after Reset: 0x11  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00003030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_fs_scl_hcnt_0_addr
    },
    {
        "PHY_I2CM_FS_SCL_LCNT_1_ADDR",
        "Address Offset: 0x3031  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00003031, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_fs_scl_lcnt_1_addr
    },
    {
        "PHY_I2CM_FS_SCL_LCNT_0_ADDR",
        "Address Offset: 0x3032  Size: 8 bits  Value after Reset: 0x24  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00003032, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_phy_i2cm_fs_scl_lcnt_0_addr
    },
    {
        "AUD_N1",
        "For N expected values, refer to the HDMI 1.4a specification.",
        1, // Width in bytes
        0x00003200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_aud_n1
    },
    {
        "AUD_N2",
        "For N expected values, refer to the HDMI 1.4a specification.",
        1, // Width in bytes
        0x00003201, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_aud_n2
    },
    {
        "AUD_N3",
        "For N expected values, refer to the HDMI 1.4a specification.",
        1, // Width in bytes
        0x00003202, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_aud_n3
    },
    {
        "AUD_CTS1",
        "For CTS expected values, refer to the HDMI 1.4a specification.",
        1, // Width in bytes
        0x00003203, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_aud_cts1
    },
    {
        "AUD_CTS2",
        "For CTS expected values, refer to the HDMI 1.4a specification.",
        1, // Width in bytes
        0x00003204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_aud_cts2
    },
    {
        "AUD_CTS3",
        "For CTS expected values, refer to the HDMI 1.4a specification.",
        1, // Width in bytes
        0x00003205, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_aud_cts3
    },
    {
        "AHB_DMA_CONF0",
        "This register contains the software reset bit for the audio FIFOs.",
        1, // Width in bytes
        0x00003600, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_hdmi_ahb_dma_conf0
    },
    {
        "AHB_DMA_START",
        "The data_ buffer_ready bit field signals the AHB audio DMA to start ac"
        "cessing system memory in order to fetch data samples to store in the F"
        "IFO.",
        1, // Width in bytes
        0x00003601, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_start
    },
    {
        "AHB_DMA_STOP",
        "The stop_dma_transaction bit field signals the AHB audio DMA to stop c"
        "urrent memory access.",
        1, // Width in bytes
        0x00003602, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_stop
    },
    {
        "AHB_DMA_THRSLD",
        "This register defines the FIFO medium threshold occupation value.",
        1, // Width in bytes
        0x00003603, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_thrsld
    },
    {
        "AHB_DMA_STRADDR0",
        "These registers define the initial_addr[31:0] used to initiate the DMA"
        " burst read transactions upon data_buffer_ready configuration.",
        1, // Width in bytes
        0x00003604, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_straddr0
    },
    {
        "AHB_DMA_STRADDR1",
        "",
        1, // Width in bytes
        0x00003605, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_straddr1
    },
    {
        "AHB_DMA_STRADDR2",
        "",
        1, // Width in bytes
        0x00003606, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_straddr2
    },
    {
        "AHB_DMA_STRADDR3",
        "",
        1, // Width in bytes
        0x00003607, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_straddr3
    },
    {
        "AHB_DMA_STPADDR0",
        "This registers define the final_addr[31:0] used as the final point to "
        "the DMA burst read transactions.",
        1, // Width in bytes
        0x00003608, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_stpaddr0
    },
    {
        "AHB_DMA_STPADDR1",
        "",
        1, // Width in bytes
        0x00003609, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_stpaddr1
    },
    {
        "AHB_DMA_STPADDR2",
        "",
        1, // Width in bytes
        0x0000360a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_stpaddr2
    },
    {
        "AHB_DMA_STPADDR3",
        "",
        1, // Width in bytes
        0x0000360b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_stpaddr3
    },
    {
        "AHB_DMA_BSTADDR0",
        "This read-only register composes the start address of the current burs"
        "t operation.",
        1, // Width in bytes
        0x0000360c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_bstaddr0
    },
    {
        "AHB_DMA_BSTADDR1",
        "",
        1, // Width in bytes
        0x0000360d, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_bstaddr1
    },
    {
        "AHB_DMA_BSTADDR2",
        "",
        1, // Width in bytes
        0x0000360e, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_bstaddr2
    },
    {
        "AHB_DMA_BSTADDR3",
        "",
        1, // Width in bytes
        0x0000360f, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_bstaddr3
    },
    {
        "AHB_DMA_MBLENGTH0",
        "These registers hold the length of the current burst operation.",
        1, // Width in bytes
        0x00003610, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_ahb_dma_mblength0
    },
    {
        "AHB_DMA_MBLENGTH1",
        "",
        1, // Width in bytes
        0x00003611, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_hdmi_ahb_dma_mblength1
    },
    {
        "AHB_DMA_STAT",
        "This register contains the status bits of the following interrupts:   "
        "Address Offset: 0x3612  Size: 8 bits per register  Value after Reset: "
        "0x00  Access: Read",
        1, // Width in bytes
        0x00003612, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_hdmi_ahb_dma_stat
    },
    {
        "AHB_DMA_INT",
        "This register contains the interrupt bits of the following interrupts:"
        "   Address Offset: 0x3613  Size: 8 bits per register  Value after Rese"
        "t: 0x00  Access: Read",
        1, // Width in bytes
        0x00003613, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_hdmi_ahb_dma_int
    },
    {
        "AHB_DMA_MASK",
        "Mask for each of the interrupts present in the AHB audio DMA module.",
        1, // Width in bytes
        0x00003614, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_ahb_dma_mask
    },
    {
        "AHB_DMA_POL",
        "Polarity for each of the interrupts present in the AHB audio DMA modul"
        "e.",
        1, // Width in bytes
        0x00003615, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_ahb_dma_pol
    },
    {
        "AHB_DMA_CONF1",
        "Address Offset: 0x3616  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00003616, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_ahb_dma_conf1
    },
    {
        "AHB_DMA_BUFFSTAT",
        "Address Offset: 0x3617  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read",
        1, // Width in bytes
        0x00003617, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_hdmi_ahb_dma_buffstat
    },
    {
        "AHB_DMA_BUFFINT",
        "Address Offset: 0x3618  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read",
        1, // Width in bytes
        0x00003618, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_hdmi_ahb_dma_buffint
    },
    {
        "AHB_DMA_BUFFMASK",
        "Address Offset: 0x3619  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00003619, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_ahb_dma_buffmask
    },
    {
        "AHB_DMA_BUFFPOL",
        "Address Offset: 0x361A  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x0000361a, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_ahb_dma_buffpol
    },
    {
        "MC_CLKDIS",
        "Main controller synchronous disable control per clock domain.",
        1, // Width in bytes
        0x00004001, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_mc_clkdis
    },
    {
        "MC_SWRSTZREQ",
        "Main controller software reset request per clock domain.",
        1, // Width in bytes
        0x00004002, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_hdmi_mc_swrstzreq
    },
    {
        "MC_FLOWCTRL",
        "Address Offset: 0x4004  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00004004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_mc_flowctrl
    },
    {
        "MC_PHYRSTZ",
        "Address Offset: 0x4005  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00004005, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_mc_phyrstz
    },
    {
        "MC_LOCKONCLOCK",
        "Address Offset: 0x4006  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Clear on Write",
        1, // Width in bytes
        0x00004006, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_hdmi_mc_lockonclock
    },
    {
        "MC_HEACPHY_RST",
        "Address Offset: 0x4007  Size: 8 bits  Value after Reset: N/A  Access: "
        "Read/Write",
        1, // Width in bytes
        0x00004007, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_mc_heacphy_rst
    },
    {
        "CSC_CFG",
        "Color Space Conversion configuration register.",
        1, // Width in bytes
        0x00004100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_csc_cfg
    },
    {
        "CSC_SCALE",
        "Address Offset: 0x4101  Size: 8 bits  Value after Reset: 0x01  Access:"
        " Read/Write       CSC Conversion Functions",
        1, // Width in bytes
        0x00004101, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_scale
    },
    {
        "CSC_COEF_A1_MSB",
        "Color Space Conversion A1 coefficient.",
        1, // Width in bytes
        0x00004102, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_a1_msb
    },
    {
        "CSC_COEF_A1_LSB",
        "Color Space Conversion A1 coefficient.",
        1, // Width in bytes
        0x00004103, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_a1_lsb
    },
    {
        "CSC_COEF_A2_MSB",
        "Color Space Conversion A2 coefficient.",
        1, // Width in bytes
        0x00004104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_a2_msb
    },
    {
        "CSC_COEF_A2_LSB",
        "Color Space Conversion A2 coefficient.",
        1, // Width in bytes
        0x00004105, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_a2_lsb
    },
    {
        "CSC_COEF_A3_MSB",
        "Color Space Conversion A3 coefficient.",
        1, // Width in bytes
        0x00004106, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_a3_msb
    },
    {
        "CSC_COEF_A3_LSB",
        "Color Space Conversion A3 coefficient.",
        1, // Width in bytes
        0x00004107, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_a3_lsb
    },
    {
        "CSC_COEF_A4_MSB",
        "Color Space Conversion A4 coefficient.",
        1, // Width in bytes
        0x00004108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_a4_msb
    },
    {
        "CSC_COEF_A4_LSB",
        "Color Space Conversion A4 coefficient.",
        1, // Width in bytes
        0x00004109, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_a4_lsb
    },
    {
        "CSC_COEF_B1_MSB",
        "Color Space Conversion B1 coefficient.",
        1, // Width in bytes
        0x0000410a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_b1_msb
    },
    {
        "CSC_COEF_B1_LSB",
        "Color Space Conversion B1 coefficient.",
        1, // Width in bytes
        0x0000410b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_b1_lsb
    },
    {
        "CSC_COEF_B2_MSB",
        "Color Space Conversion B2 coefficient.",
        1, // Width in bytes
        0x0000410c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_b2_msb
    },
    {
        "CSC_COEF_B2_LSB",
        "Color Space Conversion B2 coefficient.",
        1, // Width in bytes
        0x0000410d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_b2_lsb
    },
    {
        "CSC_COEF_B3_MSB",
        "Color Space Conversion B3 coefficient.",
        1, // Width in bytes
        0x0000410e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_b3_msb
    },
    {
        "CSC_COEF_B3_LSB",
        "Color Space Conversion B3 coefficient.",
        1, // Width in bytes
        0x0000410f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_b3_lsb
    },
    {
        "CSC_COEF_B4_MSB",
        "Color Space Conversion B4 coefficient.",
        1, // Width in bytes
        0x00004110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_b4_msb
    },
    {
        "CSC_COEF_B4_LSB",
        "Color Space Conversion B4 coefficient.",
        1, // Width in bytes
        0x00004111, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_b4_lsb
    },
    {
        "CSC_COEF_C1_MSB",
        "Color Space Conversion C1 coefficient.",
        1, // Width in bytes
        0x00004112, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_c1_msb
    },
    {
        "CSC_COEF_C1_LSB",
        "Color Space Conversion C1 coefficient.",
        1, // Width in bytes
        0x00004113, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_c1_lsb
    },
    {
        "CSC_COEF_C2_MSB",
        "Color Space Conversion C2 coefficient.",
        1, // Width in bytes
        0x00004114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_c2_msb
    },
    {
        "CSC_COEF_C2_LSB",
        "Color Space Conversion C2 coefficient.",
        1, // Width in bytes
        0x00004115, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_c2_lsb
    },
    {
        "CSC_COEF_C3_MSB",
        "Color Space Conversion C3 coefficient.",
        1, // Width in bytes
        0x00004116, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_c3_msb
    },
    {
        "CSC_COEF_C3_LSB",
        "Color Space Conversion C3 coefficient.",
        1, // Width in bytes
        0x00004117, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coef_c3_lsb
    },
    {
        "CSC_COEFC4_MSB",
        "Color Space Conversion C4 coefficient.",
        1, // Width in bytes
        0x00004118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coefc4_msb
    },
    {
        "CSC_COEFC4_LSB",
        "Color Space Conversion C4 coefficient.",
        1, // Width in bytes
        0x00004119, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_csc_coefc4_lsb
    },
    {
        "CEC_CTRL",
        "CEC registers control the CEC feature that is implemented in HDMI TX.",
        1, // Width in bytes
        0x00007d00, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_hdmi_cec_ctrl
    },
    {
        "CEC_STAT",
        "This register indicates the status of CEC line.",
        1, // Width in bytes
        0x00007d01, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_hdmi_cec_stat
    },
    {
        "CEC_MASK",
        "This read/write register masks/unmasks the interrupt events.",
        1, // Width in bytes
        0x00007d02, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_cec_mask
    },
    {
        "CEC_POLARITY",
        "This register is readable and writable, which controls the polarity of"
        " the interrupt status register as well as the polarity of the interrup"
        "t signals at system interface.",
        1, // Width in bytes
        0x00007d03, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_hdmi_cec_polarity
    },
    {
        "CEC_INT",
        "This register is read only.",
        1, // Width in bytes
        0x00007d04, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_hdmi_cec_int
    },
    {
        "CEC_ADDR_L",
        "CEC_ADDR_L and CEC_ADDR_H registers indicate the logical address(es) a"
        "llocated to the CEC device.",
        1, // Width in bytes
        0x00007d05, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_cec_addr_l
    },
    {
        "CEC_ADDR_H",
        "CEC_ADDR_L and CEC_ADDR_H registers indicate the logical address(es) a"
        "llocated to the CEC device.",
        1, // Width in bytes
        0x00007d06, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_cec_addr_h
    },
    {
        "CEC_TX_CNT",
        "This register indicates the size of the frame in bytes (including head"
        "er and data blocks), which are available in the transmitter data buffe"
        "r.",
        1, // Width in bytes
        0x00007d07, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_cec_tx_cnt
    },
    {
        "CEC_RX_CNT",
        "These registers (8 bits each) are the buffers used for storing the dat"
        "a waiting for transmission (including header and data blocks).",
        1, // Width in bytes
        0x00007d08, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_cec_rx_cnt
    },
    {
        "CEC_TX_DATAN",
        "These registers (8 bit each) are the buffers used for storing the rece"
        "ived data (including header and data blocks).",
        1, // Width in bytes
        0x00007d10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_cec_tx_datan
    },
    {
        "CEC_RX_DATAN",
        "This register indicates the size of the frame in bytes (including head"
        "er and data blocks), which are available in the receiver data buffer.",
        1, // Width in bytes
        0x00007d20, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_cec_rx_datan
    },
    {
        "CEC_LOCK",
        "Address Offset: 0x7D30  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007d30, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_cec_lock
    },
    {
        "CEC_WKUPCTRL",
        "Address Offset: 0x7D31  Size: 8 bits  Value after Reset: 0xFF  Access:"
        " Read/Write   After receiving a message in the CEC_RX_DATA1 (OPCODE) r"
        "egisters, the CEC engine verifies the message opcode[7:0] against one "
        "of the previously defined values to generate the wake-up status:  Wake"
        "upstatus is 1 when:  received opcode is 0x04 and opcode0x04en is 1 or "
        "received opcode is 0x0D and opcode0x0Den is 1 or received opcode is 0x"
        "41 and opcode0x41en is 1 or received opcode is 0x42 and opcode0x42en i"
        "s 1 or received opcode is 0x44 and opcode0x44en is 1 or received opcod"
        "e is 0x70 and opcode0x70en is 1 or received opcode is 0x82 and opcode0"
        "x82en is 1 or received opcode is 0x86 and opcode0x86en is 1  Wakeupsta"
        "tus is 0 when none of the previous conditions are true.",
        1, // Width in bytes
        0x00007d31, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_cec_wkupctrl
    },
    {
        "I2CM_SLAVE",
        "I2C Master Registers (E-DDC) registers are responsible for the Master'"
        "s coordination with the Slave, by coordinating the Slave address, data"
        " identification, transaction status, acknowledgement, and reset functi"
        "ons.",
        1, // Width in bytes
        0x00007e00, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_slave
    },
    {
        "I2CM_ADDRESS",
        "Address Offset: 0x7E01  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e01, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_address
    },
    {
        "I2CM_DATAO",
        "Address Offset: 0x7E02  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e02, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_datao
    },
    {
        "I2CM_DATAI",
        "Address Offset: 0x7E03  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read",
        1, // Width in bytes
        0x00007e03, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_datai
    },
    {
        "I2CM_OPERATION",
        "Read and write operation request.",
        1, // Width in bytes
        0x00007e04, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_hdmi_i2cm_operation
    },
    {
        "I2CM_INT",
        "This register contains and configures I2C master done interrupt.",
        1, // Width in bytes
        0x00007e05, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_hdmi_i2cm_int
    },
    {
        "I2CM_CTLINT",
        "This register contains and configures I2C master arbitration error and"
        " not acknowledge error interrupt.",
        1, // Width in bytes
        0x00007e06, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_hdmi_i2cm_ctlint
    },
    {
        "I2CM_DIV",
        "This register configures the division relation between master and scl "
        "clock.",
        1, // Width in bytes
        0x00007e07, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_div
    },
    {
        "I2CM_SEGADDR",
        "This register configures the segment address for extended RD/WR destin"
        "ation.",
        1, // Width in bytes
        0x00007e08, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_segaddr
    },
    {
        "I2CM_SOFTRSTZ",
        "This register resets the I2C master.",
        1, // Width in bytes
        0x00007e09, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_softrstz
    },
    {
        "I2CM_SEGPTR",
        "This register configures the segment pointer for extended RD/WR reques"
        "t.",
        1, // Width in bytes
        0x00007e0a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_segptr
    },
    {
        "I2CM_SS_SCL_HCNT_1_ADDR",
        "Address Offset: 0x7E0B  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e0b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_ss_scl_hcnt_1_addr
    },
    {
        "I2CM_SS_SCL_HCNT_0_ADDR",
        "Address Offset: 0x7E0C  Size: 8 bits  Value after Reset: 0x6C  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e0c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_ss_scl_hcnt_0_addr
    },
    {
        "I2CM_SS_SCL_LCNT_1_ADDR",
        "Address Offset: 0x7E0D  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e0d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_ss_scl_lcnt_1_addr
    },
    {
        "I2CM_SS_SCL_LCNT_0_ADDR",
        "Address Offset: 0x7E0E  Size: 8 bits  Value after Reset: 0x7F  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e0e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_ss_scl_lcnt_0_addr
    },
    {
        "I2CM_FS_SCL_HCNT_1_ADDR",
        "Address Offset: 0x7E0F  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e0f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_fs_scl_hcnt_1_addr
    },
    {
        "I2CM_FS_SCL_HCNT_0_ADDR",
        "Address Offset: 0x7E10  Size: 8 bits  Value after Reset: 0x11  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_fs_scl_hcnt_0_addr
    },
    {
        "I2CM_FS_SCL_LCNT_1_ADDR",
        "Address Offset: 0x7E11  Size: 8 bits  Value after Reset: 0x00  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e11, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_fs_scl_lcnt_1_addr
    },
    {
        "I2CM_FS_SCL_LCNT_0_ADDR",
        "Address Offset: 0x7E12  Size: 8 bits  Value after Reset: 0x24  Access:"
        " Read/Write",
        1, // Width in bytes
        0x00007e12, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_hdmi_i2cm_fs_scl_lcnt_0_addr
    },
    {
        "BASE_POINTER_ADDR",
        "The I2C Slave Registers allow register memory pagination, and function"
        " in the incremental burst operation mode that increases the data throu"
        "ghput when consecutive addressed registers need to be read or write.",
        1, // Width in bytes
        0x00007f00, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_hdmi_base_pointer_addr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark I2C
#endif

// Bitfields in register I2C_IADR.
static const field_t hw_i2c_iadr[] =
{
    {
        "ADR",
        "Slave address.",
        1, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_IFDR.
static const field_t hw_i2c_ifdr[] =
{
    {
        "IC",
        "I2C clock rate.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2CR.
static const field_t hw_i2c_i2cr[] =
{
    {
        "RSTA",
        "Repeat start.",
        2, // LSB
        2, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TXAK",
        "Transmit acknowledge enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MTX",
        "Transmit/receive mode select bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSTA",
        "Master/slave mode select bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IIEN",
        "I2C interrupt enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IEN",
        "I2C enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2SR.
static const field_t hw_i2c_i2sr[] =
{
    {
        "RXAK",
        "Received acknowledge.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IIF",
        "I2C interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRW",
        "Slave read/write.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAL",
        "Arbitration lost.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBB",
        "I2C bus busy bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAAS",
        "I2C addressed as a slave bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ICF",
        "Data transferring bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2DR.
static const field_t hw_i2c_i2dr[] =
{
    {
        "DATA",
        "Data Byte.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a I2C module.
static const reg_t hw_i2c[] =
{
    {
        "IADR",
        "",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_iadr
    },
    {
        "IFDR",
        "The I2C_IFDR provides a programmable prescaler to configure the clock "
        "for bit-rate selection.",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_ifdr
    },
    {
        "I2CR",
        "The I2C_I2CR is used to enable the I2C and the I2C interrupt.",
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_i2c_i2cr
    },
    {
        "I2SR",
        "The I2C_I2SR contains bits that indicate transaction direction and sta"
        "tus.",
        2, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_i2c_i2sr
    },
    {
        "I2DR",
        "In master-receive mode, reading the data register allows a read to occ"
        "ur and initiates the next byte to be received.",
        2, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_i2dr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC
#endif

// Bitfields in register IOMUXC_GPR0.
static const field_t hw_iomuxc_gpr0[] =
{
    {
        "DMAREQ_MUX_SEL0",
        "Selects between two possible sources for SDMA_EVENT[2]:",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL1",
        "Selects between two possible sources for SDMA_EVENT[3]:",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL2",
        "Selects between two possible sources for SDMA_EVENT[4]:",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL3",
        "Selects between two possible sources for SDMA_EVENT[5]:",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL4",
        "Selects between two possible sources for SDMA_EVENT[10]:",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL5",
        "Selects between two possible sources for SDMA_EVENT[9]:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL6",
        "Selects between two possible sources for SDMA_EVENT[23]:",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL7",
        "Selects between two possible sources for SDMA_EVENT[14]:",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_VIDEO_MUXING",
        "See section (TBD) for details.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CLK2_MUX_SEL",
        "Selects the source of tx_clk2 in SPDIF according to ASRC clock muxing "
        "scheme:",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_1_MUX_SEL",
        "Selects the source of asrck_clock_1 in ASRC according to clock muxing "
        "scheme:",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_9_MUX_SEL",
        "Selects the source of asrck_clock_9 in ASRC according to clock muxing "
        "scheme:",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_2_MUX_SEL",
        "Selects the source of asrck_clock_2 in ASRC according to clock muxing "
        "scheme:",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_A_MUX_SEL",
        "Selects the source of asrck_clock_a in ASRC according to clock muxing "
        "scheme:",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_3_MUX_SEL",
        "Selects the source of asrck_clock_3 in ASRC according to clock muxing "
        "scheme:",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_B_MUX_SEL",
        "Selects the source of asrck_clock_b in ASRC according to clock muxing "
        "scheme:",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_0_MUX_SEL",
        "Selects the source of asrck_clock_0 in ASRC according to clock muxing "
        "scheme:",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_8_MUX_SEL",
        "Selects the source of asrck_clock_8 in ASRC according to clock muxing "
        "scheme",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR1.
static const field_t hw_iomuxc_gpr1[] =
{
    {
        "ACT_CS0",
        "See description for ADDRS3[10]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS0",
        "See description for ADDRS3[10]",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS1",
        "See description for ADDRS3[10]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS1",
        "See description for ADDRS3[10]",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS2",
        "See description for ADDRS3[10]",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS2",
        "See description for ADDRS3[10]",
        7, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS3",
        "See description for ADDRS3[10]",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS3",
        "Active Chip Select and Address Space.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GINT",
        "Global interrupt \"0\" bit (connected to ARM IRQ#0 and GPC)",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB_OTG_ID_SEL",
        "''usb_otg_id' pin iomux select control.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYS_INT",
        "PCIe_CTL - When SYS_INT goes from low to high, the core generates an A"
        "ssert_INTx Message.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB_EXP_MODE",
        "USB Exposure mode",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_SSP_EN",
        "PCIe_PHY - Reference Clock Enable for SS function.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_VPU_MUX",
        "IPU-1/IPU-2 to VPU signals control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_POWERDOWN",
        "PCIe_PHY - All Circuits Power-Down Control Function: Powers down all c"
        "ircuitry in the PHY for IDDQ testing.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIPI_IPU2_MUX",
        "MIPI sensor to IPU-2 mux control",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIPI_IPU1_MUX",
        "MIPI sensor to IPU-1 mux control",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_CLK_SEL",
        "ENET TX reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_MON",
        "Exclusive monitor response select of illegal command (of lal gaskets, "
        "except MMDC)",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIPI_DPI_OFF",
        "MIPI DPI shutdown request",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIPI_COLOR_SW",
        "MIPI color switch control",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_REQ_ENTR_L1",
        "PCIe_CTL - Application Request to Enter L1.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_READY_ENTR_L23",
        "PCIe_CTL - Application Ready to Enter L23.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_REQ_EXIT_L1",
        "PCIe_CTL - Application Request to Exit L1.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_CLK_REQ_N",
        "PCIe_CTL (CLK LOGIC CONTROLLER GLUE) - Indicates that application logi"
        "c is ready to have reference clock removed.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFG_L1_CLK_REMOVAL_EN",
        "PCIe_CTL (CLK LOGIC CONTROLLER GLUE) - Enable the reference clock remo"
        "val in L1 state.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR2.
static const field_t hw_iomuxc_gpr2[] =
{
    {
        "CH0_MODE",
        "LVDS channel 0 operation mode",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_MODE",
        "LVDS channel 1 operation mode",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLIT_MODE_EN",
        "Enable split mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_WIDTH_CH0",
        "Data width for LVDS channel 0.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BIT_MAPPING_CH0",
        "Data mapping for LVDS channel 0.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_WIDTH_CH1",
        "Data width for LVDS channel 1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BIT_MAPPING_CH1",
        "Data mapping for LVDS channel 1.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_VS_POLARITY",
        "Vsync polarity for IPU's DI0 interface.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_VS_POLARITY",
        "Vsync polarity for IPU's DI1 interface.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_CLK_SHIFT",
        "Shifts the LVDS output clock in relation to the data.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNTER_RESET_VAL",
        "Reset value for the LDB counter which determines when the shift regist"
        "ers are loaded with data.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR3.
static const field_t hw_iomuxc_gpr3[] =
{
    {
        "HDMI_MUX_CTL",
        "HDMI MUX control",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIPI_MUX_CTL",
        "MIPI MUX control",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS0_MUX_CTL",
        "LVDS0 MUX control",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS1_MUX_CTL",
        "LVDS1 MUX control",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_DIAG",
        "IPU diagnostic debug bus mux",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZASC1_BOOT_LOCK",
        "TZASC-1 secure boot lock",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZASC2_BOOT_LOCK",
        "TZASC-2 secure boot lock",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_DBG_ACK_EN",
        "Mask control of Core 1 debug acknowledge to global debug acknowledge",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE1_DBG_ACK_EN",
        "Mask control of Core 1 debug acknowledge to global debug acknowledge.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE2_DBG_ACK_EN",
        "Mask control of Core 2 debug acknowledge to global debug acknowledge",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE3_DBG_ACK_EN",
        "Mask control of Core 3 debug acknowledge to global debug acknowledge",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_STATUS",
        "This field shows the OCRAM pipeline settings status, controlled by OCR"
        "AM_CTL[24:21] bits respectively.",
        17, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCRAM_CTL",
        "OCRAM_CTL[24] write address pipeline control bit.",
        21, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHCX_RD_CACHE_CTL",
        "Control uSDHCx [1-4] blocks cacheable attribute of AXI read transactio"
        "ns",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHCX_WR_CACHE_CTL",
        "Control uSDHCx [1-4] blocks cacheable attribute of AXI write transacti"
        "ons",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_RD_CACHE_CTL",
        "Control BCH block cacheable attribute of AXI read transactions Set of "
        "the cache bits, enable packet optimization through the bus system to D"
        "DR controller.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_WR_CACHE_CTL",
        "Control BCH block cacheable attribute of AXI write transactions",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_DBG",
        "GPU debug busses to IOMUX",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR4.
static const field_t hw_iomuxc_gpr4[] =
{
    {
        "IPU_RD_CACHE_CTL",
        "Control IPU-1 and IPU-2 block cacheable attribute of AXI read transact"
        "ions Set of the cache bits, enable packet optimization through the bus"
        " system to DDR controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_WR_CACHE_CTL",
        "Control IPU-1 and IPU-2 block cacheable attribute of AXI write transac"
        "tions",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPU_P_RD_CACHE_VAL",
        "VPU (primary bus) block cacheable attribute value of AXI read transact"
        "ions  The value of VPU_P_RD_CACHE_VAL is affecting the transactions on"
        "ly if VPU_RD_CACHE_SEL is set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPU_P_WR_CACHE_VAL",
        "VPU (primary bus) block cacheable attribute value of AXI write transac"
        "tions  The value of VPU_P_WR_CACHE_VAL is affecting the transactions o"
        "nly if VPU_WR_CACHE_SEL is set.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPU_RD_CACHE_SEL",
        "This bit selects the cacheable attribute of VPU AXI read transcations "
        "(both primary and secondary AXI buses)",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VPU_WR_CACHE_SEL",
        "This bit selects the cacheable attribute of VPU AXI write transcations"
        " (both primary and secondary AXI buses)",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOC_VERSION",
        "This is status (read only) field.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_STOP_ACK",
        "ENET stop acknowledge.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAN1_STOP_ACK",
        "CAN-1 stop acknowledge.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAN2_STOP_ACK",
        "CAN-2 stop acknowledge.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDMA_STOP_ACK",
        "SDMA stop acknowledge.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_RD_CACHE_VAL",
        "PCIe block cacheable attribute value of AXI read transactions  The val"
        "ue of PCIe_RD_CACHE_VAL is affecting the transactions only if PCIe_RD_"
        "CACHE_SEL is set.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_WR_CACHE_VAL",
        "PCIe block cacheable attribute value of AXI write transactions  The va"
        "lue of PCIe_WR_CACHE_VAL is affecting the transactions only if PCIe_WR"
        "_CACHE_SEL is set.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_RD_CACHE_SEL",
        "This bit selects the cacheable attribute of PCIe AXI read transcations"
        ")",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_WR_CACHE_SEL",
        "This bit selects the cacheable attribute of PCIe AXI write transcation"
        "s",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDOA_RD_CACHE_VAL",
        "VDOA block cacheable attribute value of AXI read transactions  The val"
        "ue of VDOA_RD_CACHE_VAL is affecting the transactions only if VDOA_RD_"
        "CACHE_SEL is set.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDOA_WR_CACHE_VAL",
        "VDOA block cacheable attribute value of AXI write transactions  The va"
        "lue of VDOA_WR_CACHE_VAL is affecting the transactions only if VDOA_WR"
        "_CACHE_SEL is set.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDOA_RD_CACHE_SEL",
        "This bit selects the cacheable attribute of VDOA AXI read transcations"
        ")",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDOA_WR_CACHE_SEL",
        "This bit selects the cacheable attribute of VDOA AXI write transcation"
        "s",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR5.
static const field_t hw_iomuxc_gpr5[] =
{
    {
        "ARM_WFI",
        "ARM WFI event out indicating on WFI state of the cores (these are stat"
        "us, read only bits)",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_WFE",
        "ARM WFE event out indication on WFE state of the cores (these are stat"
        "us, read only bits)",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "L2_CLK_STOP",
        "L2 cache clock stop indication (this is a status, read only bit)",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR6.
static const field_t hw_iomuxc_gpr6[] =
{
    {
        "IPU1_ID00_WR_QOS",
        "IPU1 Write AXI ID=00 Quality of Service (QoS) priority  0xxx - 3 lsbs"
        " will be passed as configured  1xxx - 1111",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_ID01_WR_QOS",
        "IPU1 Write AXI ID=01 Quality of Service (QoS) priority  0xxx - 3 lsbs"
        " will be passed as configured  1xxx - 1111",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_ID10_WR_QOS",
        "IPU1 Write AXI ID=10 Quality of Service (QoS) priority  0xxx - 3 lsbs"
        " will be passed as configured  1xxx - 1111",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_ID11_WR_QOS",
        "IPU1 Write AXI ID=11 Quality of Service (QoS) priority  0xxx - 3 lsbs"
        " will be passed as configured  1xxx - 1111",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_ID00_RD_QOS",
        "IPU1 Read AXI ID=00 Quality of Service (QoS) priority  0xxx - 3 lsbs "
        "will be passed as configured  1xxx - 1111",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_ID01_RD_QOS",
        "IPU1 Read AXI ID=01 Quality of Service (QoS) priority  0xxx - 3 lsbs "
        "will be passed as configured  1xxx - 1111",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_ID10_RD_QOS",
        "IPU1 Read AXI ID=10 Quality of Service (QoS) priority  0xxx - 3 lsbs "
        "will be passed as configured  1xxx - 1111",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU1_ID11_RD_QOS",
        "IPU1 Read AXI ID=11 Quality of Service (QoS) priority  0xxx - 3 lsbs "
        "will be passed as configured  1xxx - 1111",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR7.
static const field_t hw_iomuxc_gpr7[] =
{
    {
        "IPU2_ID00_WR_QOS",
        "IPU2 Write AXI ID=00 Quality of Service (QoS) priority  0xxx - 3 lsbs"
        " will be passed as configured  1xxx - 1111",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_ID01_WR_QOS",
        "IPU2 Write AXI ID=01 Quality of Service (QoS) priority  0xxx - 3 lsbs"
        " will be passed as configured  1xxx - 1111",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_ID10_WR_QOS",
        "IPU2 Write AXI ID=10 Quality of Service (QoS) priority  0xxx - 3 lsbs"
        " will be passed as configured  1xxx - 1111",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_ID11_WR_QOS",
        "IPU2 Write AXI ID=11 Quality of Service (QoS) priority  0xxx - 3 lsbs"
        " will be passed as configured  1xxx - 1111",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_ID00_RD_QOS",
        "IPU2 Read AXI ID=00 Quality of Service (QoS) priority  0xxx - 3 lsbs "
        "will be passed as configured  1xxx - 1111",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_ID01_RD_QOS",
        "IPU2 Read AXI ID=01 Quality of Service (QoS) priority  0xxx - 3 lsbs "
        "will be passed as configured  1xxx - 1111",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_ID10_RD_QOS",
        "IPU2 Read AXI ID=10 Quality of Service (QoS) priority  0xxx - 3 lsbs "
        "will be passed as configured  1xxx - 1111",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU2_ID11_RD_QOS",
        "IPU2 Read AXI ID=11 Quality of Service (QoS) priority  0xxx - 3 lsbs "
        "will be passed as configured  1xxx - 1111",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR8.
static const field_t hw_iomuxc_gpr8[] =
{
    {
        "PCS_TX_DEEMPH_GEN1",
        "PCIe_PHY - This static value sets the Tx driver de-emphasis value in t"
        "he case where pipe0_tx_deemph is set to 1'b1 (the default setting) and"
        " the PHY is running at the Gen1 rate.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS_TX_DEEMPH_GEN2_3P5DB",
        "PCIe_PHY - This static value sets the Tx driver de-emphasis value in t"
        "he case where pipe0_tx_deemph is set to 1'b1 (the default setting) and"
        " the PHY is running at the Gen2 (3p5db) rate.",
        6, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS_TX_DEEMPH_GEN2_6DB",
        "PCIe_PHY - This static value sets the Tx driver de-emphasis value in t"
        "he case where pipe0_tx_deemph is set to 1'b0 and the PHY is running at"
        " the Gen2 (6db) rate.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS_TX_SWING_FULL",
        "PCIe_PHY - This static value sets the Tx driver SWING_FULL value.",
        18, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS_TX_SWING_LOW",
        "PCIe_PHY - This static value sets the launch amplitude of the transmit"
        "ter when pipe0_tx_swing is set to 1'b0 (default state).",
        25, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR9.
static const field_t hw_iomuxc_gpr9[] =
{
    {
        "TZASC1_BYP",
        "TZASC-1 BYPASS MUX control",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TZASC2_BYP",
        "TZASC-2 BYPASS MUX control",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR10.
static const field_t hw_iomuxc_gpr10[] =
{
    {
        "DCIC1_MUX_CTL",
        "DCIC-1 MUX control",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCIC2_MUX_CTL",
        "DCIC-2 MUX control",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_TZ_EN",
        "OCRAM TrustZone (TZ) enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_TZ_ADDR",
        "OCRAM TrustZone (TZ) start address.",
        5, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEC_ERR_RESP",
        "Security error response enable for all security gaskets (on both AHB a"
        "nd AXI busses)",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_CLK_EN",
        "ARM Debug clock enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_EN",
        "ARM non secure (non-invasive) debug enable",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_DCIC1_MUX_CTL",
        "Lock DCIC1_MUX_CTL field for changes.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_DCIC2_MUX_CTL",
        "Lock DCIC2_MUX_CTL field for changes.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_OCRAM_TZ_EN",
        "Lock OCRAM_TZ_EN field for changes.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_OCRAM_TZ_ADDR",
        "Lock OCRAM_TZ_ADDR field for changes.",
        21, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_SEC_ERR_RESP",
        "Lock SEC_ERR_RESP field for changes.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_DBG_CLK_EN",
        "Lock DBG_CLK_EN field for changes.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_DBG_EN",
        "Lock DBG_EN field for changes.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR11.
static const field_t hw_iomuxc_gpr11[] =
{
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR12.
static const field_t hw_iomuxc_gpr12[] =
{
    {
        "USDHC_DBG_MUX",
        "uSDHC debug bus IO mux control  '00' - uSDHC1 debug  '01' - uSDHC2 deb"
        "ug  '10' - uSDHC3 debug  '11' - uSDHC4 debug",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOS_LEVEL",
        "PCIe_PHY - Loss-of-Signal Detector Sensitivity Level Control Function:"
        " Sets the sensitivity level for the Loss-of-Signal detector.",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APPS_PM_XMT_PME",
        "PCIe_CTL - Wake Up.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_LTSSM_ENABLE",
        "PCIe_CTL - Driven low by the application after reset to hold the LTSSM"
        " in the Detect state until the application is ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_INIT_RST",
        "PCIe_CTL - Request from the application to send a Hot Reset to the dow"
        "nstream device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVICE_TYPE",
        "PCIe_CTL - Device/Port Type.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APPS_PM_XMT_TURNOFF",
        "PCIe_CTL - Request from the application to generate a PM_Turn_Off Mess"
        "age.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIA_STATUS_BUS_SELECT",
        "PCIe_CTL - used for debug to select what part of diag_status_bus will "
        "be reflected on the 32 bits of the iomux",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_CTL_7",
        "PCIe control of diagnostic bus select  (Drive 'cxpl_diag_ctrl' PCI con"
        "troller input)",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMP_APB_CLK_EN",
        "ARM platform APB clock enable",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMP_ATB_CLK_EN",
        "ARM platform ATB clock enable",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMP_AHB_CLK_EN",
        "ARM platform AHB clock enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMP_IPG_CLK_EN",
        "ARM platform IPG clock enable",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR13.
static const field_t hw_iomuxc_gpr13[] =
{
    {
        "SATA_PHY_1",
        "SATA PHY - Tx Edge rate control enables the SATA PHY to meet the edge "
        "rate requirements for all SATA variants",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SATA_PHY_2",
        "SATA PHY - Transmit level settings.",
        2, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SATA_PHY_3",
        "SATA PHY Tx -Transmit Boost Control, ratio of drive level of transmiss"
        "ion bit to non transmission bit.",
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SATA_PHY_4",
        "SATA PHY -Transmit Attenuation control, provides discrete driver atten"
        "uation factors (from full driver level).",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SATA_PHY_5",
        "SATA PHY - Spread Spectrum Enable.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SATA_SPEED",
        "Indicates SATA PHY speed mode",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SATA_PHY_6",
        "SATA PHY Rx - DPLL mode control, sets phase and frequency gain of rece"
        "iver DPLL  For bits encoding see below.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SATA_PHY_7",
        "SATA PHY Rx - Loss of signal detector level.",
        19, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SATA_PHY_8",
        "SATA _PHY Rx - Receiver Equalization control",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_STOP_REQ",
        "ENET stop request",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAN1_STOP_REQ",
        "CAN1 stop request",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAN2_STOP_REQ",
        "CAN2 stop request",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDMA_STOP_REQ",
        "SDMA stop request",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_TXC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_txc[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_TD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_td0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_TD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_td1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_TD2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_td2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_TD3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_td3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_RX_CTL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_rx_ctl[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_RD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_rd0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_TX_CTL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_tx_ctl[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_RD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_rd1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_RD2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_rd2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_RD3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_rd3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII_RXC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii_rxc[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A25.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a25[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_EB2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_eb2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D16.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d16[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D17.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d17[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D18.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d18[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D19.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d19[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D20.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d20[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D21.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d21[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D22.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d22[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D23.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d23[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_EB3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_eb3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D24.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d24[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D25.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d25[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D26.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d26[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D27.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d27[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D28.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d28[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D29.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d29[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D30.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d30[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_D31.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_d31[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A24.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a24[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A23.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a23[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A22.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a22[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A21.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a21[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A20.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a20[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A19.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a19[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A18.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a18[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A17.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a17[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_A16.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_a16[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_CS0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_cs0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_CS1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_cs1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_OE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_oe[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_RW.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_rw[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_LBA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_lba[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_EB0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_eb0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_EB1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_eb1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da5[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da6[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da7[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA8.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da8[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA9.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da9[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA10.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da10[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA11.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da11[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA12.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da12[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA13.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da13[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA14.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da14[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_DA15.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_da15[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_WAIT.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_wait[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EIM_BCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_eim_bclk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DI0_DISP_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_di0_disp_clk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DI0_PIN15.
static const field_t hw_iomuxc_sw_mux_ctl_pad_di0_pin15[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DI0_PIN2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_di0_pin2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DI0_PIN3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_di0_pin3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DI0_PIN4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_di0_pin4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat5[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat6[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat7[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT8.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat8[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT9.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat9[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT10.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat10[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT11.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat11[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT12.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat12[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT13.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat13[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT14.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat14[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT15.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat15[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT16.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat16[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT17.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat17[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT18.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat18[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT19.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat19[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT20.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat20[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT21.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat21[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT22.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat22[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_DISP0_DAT23.
static const field_t hw_iomuxc_sw_mux_ctl_pad_disp0_dat23[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_MDIO.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_mdio[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_REF_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_ref_clk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_RX_ER.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_rx_er[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_CRS_DV.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_crs_dv[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_RXD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_rxd1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_RXD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_rxd0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_TX_EN.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_tx_en[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_TXD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_txd1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_TXD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_txd0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET_MDC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet_mdc[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_9.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_9[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_6[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_5[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_7[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_8.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_8[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_16.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_16[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_17.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_17[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_18.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_18[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO_19.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio_19[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_PIXCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_pixclk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_MCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_mclk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DATA_EN.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_data_en[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_VSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_vsync[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat5[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat6[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat7[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT8.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat8[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT9.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat9[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT10.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat10[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT11.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat11[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT12.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat12[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT13.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat13[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT14.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat14[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT15.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat15[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT16.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat16[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT17.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat17[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT18.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat18[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI0_DAT19.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi0_dat19[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat7[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat6[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat5[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_cmd[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_clk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_RST.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_rst[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_CLE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_cle[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_ALE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_ale[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_WP_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_wp_b[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_RB0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_rb0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_CS0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_cs0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_CS1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_cs1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_CS2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_cs2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_CS3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_cs3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_cmd[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_clk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_D0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_d0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_D1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_d1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_D2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_d2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_D3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_d3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_D4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_d4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_D5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_d5[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_D6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_d6[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NANDF_D7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nandf_d7[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_dat0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_dat1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_dat2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_dat3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DAT4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_dat4[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DAT5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_dat5[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DAT6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_dat6[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DAT7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_dat7[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat1[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat0[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_cmd[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat2[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_clk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_clk[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_cmd[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat3[] =
{
    {
        "MUX_MODE",
        "MUX Mode Select Field.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Software Input On Field.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD2_DAT1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD2_DAT1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD2_DAT1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD2_DAT2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD2_DAT2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD2_DAT2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD2_DAT0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD2_DAT0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD2_DAT0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_TXC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_txc[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_TXC"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_TXC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_TXC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "TXC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_TD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_td0[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_TD0"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_TD0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_TD0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "TD0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_TD0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_TD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_td1[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_TD1"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_TD1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_TD1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "TD1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_TD1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_TD2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_td2[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_TD2"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_TD2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_TD2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "TD2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_TD2.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_TD3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_td3[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_TD3"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_TD3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_TD3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "TD3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_TD3.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_RX_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_rx_ctl[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_RX_"
        "CTL.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_RX_CTL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_RX_CTL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "RX_CTL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_RX_CTL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_RD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_rd0[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_RD0"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_RD0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_RD0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "RD0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_RD0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_TX_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_tx_ctl[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_TX_"
        "CTL.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_TX_CTL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_TX_CTL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "TX_CTL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_RD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_rd1[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_RD1"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_RD1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_RD1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "RD1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_RD1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_RD2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_rd2[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_RD2"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_RD2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_RD2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "RD2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_RD2.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_RD3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_rd3[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_RD3"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_RD3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_RD3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "RD3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_RD3.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII_RXC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii_rxc[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: RGMII_RXC"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: RGMII"
        "_RXC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: RGMII"
        "_RXC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: RGMII_"
        "RXC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: RG"
        "MII_RXC.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A25.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a25[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A25.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A25.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A25.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A2"
        "5.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "25.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "25.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A2"
        "5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_EB2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_eb2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_EB2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_EB2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_EB2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_EB"
        "2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_E"
        "B2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_E"
        "B2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_EB"
        "2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D16.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d16[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D16.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D16.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D16.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D1"
        "6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "16.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "16.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D1"
        "6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D17.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d17[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D17.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D17.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D17.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D1"
        "7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "17.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "17.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D1"
        "7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D18.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d18[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D18.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D18.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D18.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D1"
        "8.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "18.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "18.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D1"
        "8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D19.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d19[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D19.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D19.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D19.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D1"
        "9.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "19.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "19.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D1"
        "9.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D20.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d20[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D20.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D20.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D20.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "20.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "20.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D21.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d21[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D21.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D21.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D21.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "21.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "21.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D22.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d22[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D22.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D22.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D22.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "22.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "22.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D23.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d23[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D23.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D23.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D23.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "23.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "23.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_EB3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_eb3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_EB3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_EB3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_EB3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_EB"
        "3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_E"
        "B3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_E"
        "B3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_EB"
        "3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D24.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d24[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D24.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D24.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D24.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "24.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "24.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D25.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d25[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D25.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D25.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D25.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "5.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "25.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "25.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D26.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d26[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D26.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D26.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D26.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "26.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "26.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D27.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d27[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D27.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D27.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D27.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "27.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "27.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D28.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d28[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D28.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D28.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D28.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "8.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "28.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "28.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D29.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d29[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D29.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D29.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D29.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D2"
        "9.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "29.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "29.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D2"
        "9.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D30.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d30[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D30.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D30.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D30.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D3"
        "0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "30.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "30.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D3"
        "0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_D31.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_d31[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_D31.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_D31.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_D31.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_D3"
        "1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "31.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "31.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_D3"
        "1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A24.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a24[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A24.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A24.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A24.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A2"
        "4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "24.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "24.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A2"
        "4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A23.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a23[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A23.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A23.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A23.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A2"
        "3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "23.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "23.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A2"
        "3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A22.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a22[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A22.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A22.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A22.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A2"
        "2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "22.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "22.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A2"
        "2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A21.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a21[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A21.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A21.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A21.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A2"
        "1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "21.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "21.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A2"
        "1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A20.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a20[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A20.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A20.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A20.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A2"
        "0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "20.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "20.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A2"
        "0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A19.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a19[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A19.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A19.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A19.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A1"
        "9.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "19.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "19.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A1"
        "9.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A18.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a18[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A18.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A18.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A18.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A1"
        "8.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "18.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "18.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A1"
        "8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A17.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a17[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A17.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A17.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A17.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A1"
        "7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "17.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "17.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A1"
        "7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_A16.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_a16[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_A16.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_A16.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_A16.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_A1"
        "6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_A"
        "16.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_A"
        "16.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_A1"
        "6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_CS0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_cs0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_CS0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_CS0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_CS0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_CS"
        "0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_C"
        "S0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_C"
        "S0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_CS"
        "0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_CS1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_cs1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_CS1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_CS1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_CS1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_CS"
        "1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_C"
        "S1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_C"
        "S1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_CS"
        "1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_OE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_oe[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_OE.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_OE.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_OE.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_OE"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_O"
        "E.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_O"
        "E.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_OE"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_RW.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_rw[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_RW.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_RW.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_RW.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_RW"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_R"
        "W.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_R"
        "W.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_RW"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_LBA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_lba[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_LBA.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_LBA.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_LBA.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_LB"
        "A.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_L"
        "BA.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_L"
        "BA.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_LB"
        "A.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_EB0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_eb0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_EB0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_EB0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_EB0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_EB"
        "0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_E"
        "B0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_E"
        "B0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_EB"
        "0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_EB1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_eb1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_EB1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_EB1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_EB1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_EB"
        "1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_E"
        "B1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_E"
        "B1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_EB"
        "1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da5[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA5.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "5.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da6[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA6.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da7[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA7.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da8[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA8.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA8.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA8.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "8.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A8.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A8.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da9[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA9.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA9.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA9.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "9.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A9.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A9.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "9.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da10[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA10.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA10.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA10.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "10.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A10.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A10.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "10.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da11[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA11.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA11.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA11.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A11.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A11.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "11.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da12[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA12.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA12.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad EIM_DA12.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "12.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A12.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "12.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da13[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA13.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA13.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA13.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "13.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A13.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "13.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da14[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA14.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA14.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA14.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "14.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A14.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A14.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "14.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_DA15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_da15[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_DA15.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_DA15.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_DA15.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_DA"
        "15.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_D"
        "A15.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_D"
        "A15.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_DA"
        "15.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_WAIT.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_wait[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_WAIT.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_WAIT.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_WAIT.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_WA"
        "IT.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_W"
        "AIT.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_W"
        "AIT.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_WA"
        "IT.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EIM_BCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_eim_bclk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: EIM_BCLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: EIM_BCLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: EIM_BCLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: EIM_BC"
        "LK.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: EIM_B"
        "CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: EIM_B"
        "CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: EIM_BC"
        "LK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DI0_DISP_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_di0_disp_clk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DI0_DISP_CLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DI0_DISP_"
        "CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DI0_DISP_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DI0_DI"
        "SP_CLK.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DI0_D"
        "ISP_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DI0_D"
        "ISP_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DI0_DI"
        "SP_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DI0_PIN15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_di0_pin15[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DI0_PIN15.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DI0_PIN15"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DI0_PIN15.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DI0_PI"
        "N15.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DI0_P"
        "IN15.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DI0_P"
        "IN15.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DI0_PI"
        "N15.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DI0_PIN2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_di0_pin2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DI0_PIN2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DI0_PIN2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DI0_PIN2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DI0_PI"
        "N2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DI0_P"
        "IN2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DI0_P"
        "IN2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DI0_PI"
        "N2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DI0_PIN3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_di0_pin3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DI0_PIN3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DI0_PIN3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DI0_PIN3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DI0_PI"
        "N3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DI0_P"
        "IN3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DI0_P"
        "IN3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DI0_PI"
        "N3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DI0_PIN4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_di0_pin4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DI0_PIN4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DI0_PIN4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DI0_PIN4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DI0_PI"
        "N4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DI0_P"
        "IN4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DI0_P"
        "IN4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DI0_PI"
        "N4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat5[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT5.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT5.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat6[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT6.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat7[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT7.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat8[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT8.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "8.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT8.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT8.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT8.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT8.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat9[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT9.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "9.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT9.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT9.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT9.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT9.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT9.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat10[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT10.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "10.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT10.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT10.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT10.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT10.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT10.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat11[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT11.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "11.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT11.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT11.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad DISP0_"
        "DAT11.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT11.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat12[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT12.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "12.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT12.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT12.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT12.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT12.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat13[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT13.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "13.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT13.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT13.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT13.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT13.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat14[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT14.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "14.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT14.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT14.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT14.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT14.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT14.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat15[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT15.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "15.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT15.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT15.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT15.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT15.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT15.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT16.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat16[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT16.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "16.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT16.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT16.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT16.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT16.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT16.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT17.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat17[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT17.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "17.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT17.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT17.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT17.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT17.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT17.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT18.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat18[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT18.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "18.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT18.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT18.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT18.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT18.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT18.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT19.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat19[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT19.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "19.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT19.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT19.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT19.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT19.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT19.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT20.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat20[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT20.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "20.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT20.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT20.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT20.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT20.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT20.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT21.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat21[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT21.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "21.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT21.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT21.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT21.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT21.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT21.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT22.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat22[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT22.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "22.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT22.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT22.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT22.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT22.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT22.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DISP0_DAT23.
static const field_t hw_iomuxc_sw_pad_ctl_pad_disp0_dat23[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: DISP0_DAT23.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DISP0_DAT"
        "23.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: DISP0_DAT23.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: DISP0_"
        "DAT23.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DISP0"
        "_DAT23.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DISP0"
        "_DAT23.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DISP0_"
        "DAT23.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_MDIO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_mdio[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_MDIO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_MDIO"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: ENET_MDIO.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_M"
        "DIO.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "MDIO.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "MDIO.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_M"
        "DIO.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_REF_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_ref_clk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_REF_CLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_REF_"
        "CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: ENET_REF_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_R"
        "EF_CLK.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "REF_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "REF_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_R"
        "EF_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_RX_ER.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_rx_er[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_RX_ER.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_RX_E"
        "R.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: ENET_RX_ER.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_R"
        "X_ER.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "RX_ER.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "RX_ER.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_R"
        "X_ER.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_CRS_DV.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_crs_dv[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_CRS_DV.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_CRS_"
        "DV.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_C"
        "RS_DV.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "CRS_DV.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "CRS_DV.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_C"
        "RS_DV.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_RXD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_rxd1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_RXD1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_RXD1"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: ENET_RXD1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_R"
        "XD1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "RXD1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "RXD1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_R"
        "XD1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_RXD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_rxd0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_RXD0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_RXD0"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_R"
        "XD0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "RXD0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "RXD0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_R"
        "XD0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_TX_EN.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_tx_en[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_TX_EN.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_TX_E"
        "N.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: ENET_TX_EN.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_T"
        "X_EN.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "TX_EN.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "TX_EN.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_T"
        "X_EN.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_TXD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_txd1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_TXD1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_TXD1"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: ENET_TXD1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_T"
        "XD1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "TXD1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "TXD1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_T"
        "XD1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_TXD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_txd0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_TXD0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_TXD0"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: ENET_TXD0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_T"
        "XD0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "TXD0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "TXD0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_T"
        "XD0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET_MDC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet_mdc[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: ENET_MDC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: ENET_MDC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: ENET_MDC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: ENET_M"
        "DC.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: ENET_"
        "MDC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: ENET_"
        "MDC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: ENET_M"
        "DC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs5[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDQS5.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm5[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_DQM5"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM5.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM5.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm4[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_DQM4"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM4.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM4.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs4[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDQS4.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs3[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDQS3.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm3[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_DQM3"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM3.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM3.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs2[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDQS2.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm2[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_DQM2"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM2.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM2.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a0[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a1[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a2[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A2.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A2.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a3[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A3.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A3.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a4[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A4.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A4.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a5[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A5.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A5.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a6[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A6.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A6.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a7[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A7.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A7.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a8[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A8.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A8.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a9[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A9.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "9.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A9.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a10[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A10.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "10.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A10.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a11[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A11.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "11.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A11.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a12[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A12.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "12.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A12.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a13[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A13.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "13.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A13.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a14[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A14.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "14.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A14.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a15[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A15.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "15.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A15.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cas[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_CAS.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "CAS.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_C"
        "AS.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_CAS.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cs0[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "CS0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_C"
        "S0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_CS0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cs1[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "CS1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_C"
        "S1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_CS1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_ras[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_RAS.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "RAS.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_R"
        "AS.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_RAS.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_reset[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_RESE"
        "T.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "RESET.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "RESET.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "RESET.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_R"
        "ESET.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_RESET.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Select one out of next values for pad: DRAM_RESET.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba0[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDBA0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DBA0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDBA0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba1[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDBA1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DBA1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDBA1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdclk_0[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDCL"
        "K_0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDCLK_0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DCLK_0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDCLK_0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba2[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDBA2.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDBA2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDBA2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DBA2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDBA2.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdcke0[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDCKE0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDCKE0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDCKE0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DCKE0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDCKE0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdclk_1[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDCL"
        "K_1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDCLK_1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DCLK_1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDCLK_1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdcke1[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDCKE1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDCKE1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDCKE1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DCKE1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDCKE1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdodt0[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDOD"
        "T0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDODT0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDODT0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDODT0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DODT0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDODT0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdodt1[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDOD"
        "T1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDODT1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDODT1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDODT1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DODT1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDODT1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdwe[] =
{
    {
        "DSE",
        "Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDWE.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DWE.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDWE.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs0[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDQS0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm0[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_DQM0"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs1[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDQS1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm1[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_DQM1"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs6[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDQS6.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm6[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_DQM6"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM6.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM6.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs7[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDQS7.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm7[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: DRAM_DQM7"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM7.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM7.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "DDR Select Field  Read Only Field  Can be configured using Group Contr"
        "ol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_COL0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_COL0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_COL0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_ROW0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_ROW0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_ROW0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_COL1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_COL1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_COL1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_ROW1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_ROW1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_ROW1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_COL2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_COL2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_COL2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_ROW2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_ROW2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_ROW2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_COL3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_COL3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_COL3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_ROW3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_ROW3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_ROW3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_COL4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_COL4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_COL4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: KEY_ROW4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: KEY_ROW4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: KEY_ROW4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_0"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_0"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_1"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_1"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_9[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_9.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_9.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_9.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_9"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "9.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "9.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_9"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_3"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_3"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_6[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_6.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_6"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_6"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_2"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_2"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_4"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_4"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_5[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_5.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_5"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_5"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_7[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_7.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_7"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_7"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_8[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_8.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_8.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_8.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_8"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "8.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "8.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_8"
        ".",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_16.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_16[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_16.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_16.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_16.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_1"
        "6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "16.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "16.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_1"
        "6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_17.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_17[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_17.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_17.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_1"
        "7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "17.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "17.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_1"
        "7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_18.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_18[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_18.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_18.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_18.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_1"
        "8.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "18.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "18.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_1"
        "8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO_19.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio_19[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: GPIO_19.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: GPIO_19.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: GPIO_19.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: GPIO_1"
        "9.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: GPIO_"
        "19.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: GPIO_"
        "19.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: GPIO_1"
        "9.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_PIXCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_pixclk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_PIXCLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_PIXC"
        "LK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_PIXCLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_P"
        "IXCLK.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "PIXCLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "PIXCLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_P"
        "IXCLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_MCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_mclk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_MCLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_MCLK"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_MCLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_M"
        "CLK.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "MCLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "MCLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_M"
        "CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DATA_EN.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_data_en[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DATA_EN.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DATA"
        "_EN.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DATA_EN.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "ATA_EN.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DATA_EN.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DATA_EN.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "ATA_EN.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_VSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_vsync[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_VSYNC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_VSYN"
        "C.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_VSYNC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_V"
        "SYNC.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "VSYNC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "VSYNC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_V"
        "SYNC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT4"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat5[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT5.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT5"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT5.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat6[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT6.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT6"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat7[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT7.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT7"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat8[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT8.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT8"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT8.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT8.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT8.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT8.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat9[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT9.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT9"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT9.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT9.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT9.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT9.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT9.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat10[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT10.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT10.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT10.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT10.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT10.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT10.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat11[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT11.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT11.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT11.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT11.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT11.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat12[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT12.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT12.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT12.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT12.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT12.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat13[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT13.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT13.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT13.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT13.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT13.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat14[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT14.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT14.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT14.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT14.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT14.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT14.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat15[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT15.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT15.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT15.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT15.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT15.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT15.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT16.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat16[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT16.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT16.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT16.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT16.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT16.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT16.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT17.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat17[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT17.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT17.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT17.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT17.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT17.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT17.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT18.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat18[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT18.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "8.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT18.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT18.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT18.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT18.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT18.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI0_DAT19.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi0_dat19[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: CSI0_DAT19.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: CSI0_DAT1"
        "9.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: CSI0_DAT19.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: CSI0_D"
        "AT19.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: CSI0_"
        "DAT19.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: CSI0_"
        "DAT19.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: CSI0_D"
        "AT19.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tms[] =
{
    {
        "SRE",
        "Slew Rate Field  Read Only Field",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Read Only Field",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TMS.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: JTAG_T"
        "MS.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_mod[] =
{
    {
        "SRE",
        "Slew Rate Field  Read Only Field",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Read Only Field",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "MOD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: JTAG_M"
        "OD.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_trstb[] =
{
    {
        "SRE",
        "Slew Rate Field  Read Only Field",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Read Only Field",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TRSTB.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: JTAG_T"
        "RSTB.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tdi[] =
{
    {
        "SRE",
        "Slew Rate Field  Read Only Field",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Read Only Field",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TDI.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: JTAG_T"
        "DI.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tck[] =
{
    {
        "SRE",
        "Slew Rate Field  Read Only Field",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Read Only Field",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TCK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: JTAG_T"
        "CK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tdo[] =
{
    {
        "SRE",
        "Slew Rate Field  Read Only Field",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "Speed Field  Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Read Only Field",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TDO.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Read Only Field",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat7[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_DAT7.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_DAT7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_DAT7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat6[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_DAT6.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_DAT6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_DAT6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat5[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_DAT5.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_DAT5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_DAT5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T5.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_DAT4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_DAT4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_DAT4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_cmd[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_CMD.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_CMD.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_CMD.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_CM"
        "D.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_C"
        "MD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_C"
        "MD.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_CM"
        "D.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_clk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_CLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_CL"
        "K.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_C"
        "LK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_C"
        "LK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_CL"
        "K.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_DAT0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_DAT0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_DAT0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_DAT1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_DAT1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_DAT1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_DAT2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_DAT2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_DAT2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_DAT3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_DAT3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_DAT3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_RST.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_rst[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD3_RST.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD3_RST.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD3_RST.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD3_RS"
        "T.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD3_R"
        "ST.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD3_R"
        "ST.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD3_RS"
        "T.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_CLE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_cle[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_CLE.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_CLE"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_CLE.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "CLE.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_CLE.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_CLE.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "CLE.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_ALE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_ale[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_ALE.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_ALE"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_ALE.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "ALE.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_ALE.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_ALE.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "ALE.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_WP_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_wp_b[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_WP_B.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_WP_"
        "B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_WP_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "WP_B.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_WP_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_WP_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "WP_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_RB0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_rb0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_RB0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_RB0"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_RB0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "RB0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_RB0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_RB0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "RB0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_CS0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_cs0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_CS0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_CS0"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_CS0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "CS0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_CS0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_CS0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "CS0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_CS1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_cs1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_CS1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_CS1"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_CS1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "CS1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_CS1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_CS1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "CS1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_CS2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_cs2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_CS2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_CS2"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_CS2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "CS2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_CS2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_CS2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "CS2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_CS3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_cs3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_CS3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_CS3"
        ".",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_CS3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "CS3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_CS3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_CS3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "CS3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_cmd[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_CMD.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_CMD.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_CMD.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_CM"
        "D.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_C"
        "MD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_C"
        "MD.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_CM"
        "D.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_clk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_CLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_CL"
        "K.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_C"
        "LK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_C"
        "LK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_CL"
        "K.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_D0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_d0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_D0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_D0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_D0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "D0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_D0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_D0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "D0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_D1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_d1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_D1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_D1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_D1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "D1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_D1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_D1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "D1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_D2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_d2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_D2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_D2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_D2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "D2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_D2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_D2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "D2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_D3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_d3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_D3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_D3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_D3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "D3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_D3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_D3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "D3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_D4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_d4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_D4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_D4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_D4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "D4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_D4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_D4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "D4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_D5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_d5[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_D5.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_D5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_D5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "D5.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_D5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_D5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "D5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_D6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_d6[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_D6.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_D6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_D6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "D6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_D6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_D6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "D6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NANDF_D7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nandf_d7[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: NANDF_D7.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: NANDF_D7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: NANDF_D7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: NANDF_"
        "D7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: NANDF"
        "_D7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: NANDF"
        "_D7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: NANDF_"
        "D7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_dat0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_DAT0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_DAT0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_DAT0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_DA"
        "T0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_D"
        "AT0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_D"
        "AT0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_DA"
        "T0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_dat1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_DAT1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_DAT1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_DAT1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_DA"
        "T1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_D"
        "AT1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_D"
        "AT1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_DA"
        "T1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_dat2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_DAT2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_DAT2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_DAT2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_DA"
        "T2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_D"
        "AT2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_D"
        "AT2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_DA"
        "T2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_dat3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_DAT3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_DAT3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_DAT3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_DA"
        "T3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_D"
        "AT3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_D"
        "AT3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_DA"
        "T3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DAT4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_dat4[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_DAT4.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_DAT4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_DAT4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_DA"
        "T4.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_D"
        "AT4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_D"
        "AT4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_DA"
        "T4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DAT5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_dat5[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_DAT5.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_DAT5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_DAT5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_DA"
        "T5.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_D"
        "AT5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_D"
        "AT5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_DA"
        "T5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DAT6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_dat6[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_DAT6.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_DAT6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_DAT6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_DA"
        "T6.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_D"
        "AT6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_D"
        "AT6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_DA"
        "T6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DAT7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_dat7[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD4_DAT7.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD4_DAT7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD4_DAT7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD4_DA"
        "T7.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD4_D"
        "AT7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD4_D"
        "AT7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD4_DA"
        "T7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat1[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD1_DAT1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD1_DAT1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD1_DAT1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat0[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD1_DAT0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD1_DAT0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD1_DAT0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD1_DAT3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD1_DAT3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD1_DAT3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_cmd[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD1_CMD.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD1_CMD.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD1_CMD.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD1_CM"
        "D.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD1_C"
        "MD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD1_C"
        "MD.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD1_CM"
        "D.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat2[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD1_DAT2.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD1_DAT2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD1_DAT2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T2.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_clk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD1_CLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD1_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD1_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD1_CL"
        "K.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD1_C"
        "LK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD1_C"
        "LK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD1_CL"
        "K.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_clk[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD2_CLK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD2_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD2_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD2_CL"
        "K.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD2_C"
        "LK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD2_C"
        "LK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD2_CL"
        "K.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_cmd[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD2_CMD.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD2_CMD.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD2_CMD.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD2_CM"
        "D.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD2_C"
        "MD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD2_C"
        "MD.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD2_CM"
        "D.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat3[] =
{
    {
        "SRE",
        "Slew Rate Field  Select one out of next values for pad: SD2_DAT3.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for pad: SD2_DAT3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Speed Field  Select one out of next values for pad: SD2_DAT3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Pull Up / Down Config.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B7DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b7ds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: B7DS (P"
        "ads: DRAM_D56 DRAM_D57 DRAM_D58 DRAM_D59 DRAM_D60 DRAM_D61 DRAM_D62 DR"
        "AM_D63).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_ADDDS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_addds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: ADDDS ("
        "Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRA"
        "M_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM_A9 "
        "DRAM_SDBA0 DRAM_SDBA1).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrmode_ctl[] =
{
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for group: "
        "DDRMODE_CTL (Pads: DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3 DRAM_SD"
        "QS4 DRAM_SDQS5 DRAM_SDQS6 DRAM_SDQS7).",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_TERM_CTL0.
static const field_t hw_iomuxc_sw_pad_ctl_grp_term_ctl0[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: TER"
        "M_CTL0 (Pads: DRAM_D0 DRAM_D1 DRAM_D2 DRAM_D3 DRAM_D4 DRAM_D5 DRAM_D6 "
        "DRAM_D7).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRPKE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrpke[] =
{
    {
        "PKE",
        "Pull / Keep Enable Field  Select one out of next values for group: DDR"
        "PKE (Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A1"
        "4 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRA"
        "M_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM"
        "_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DR"
        "AM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 D"
        "RAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D32 DRAM_D33 "
        "DRAM_D34 DRAM_D35 DRAM_D36 DRAM_D37 DRAM_D38 DRAM_D39 DRAM_D4 DRAM_D40"
        " DRAM_D41 DRAM_D42 DRAM_D43 DRAM_D44 DRAM_D45 DRAM_D46 DRAM_D47 DRAM_D"
        "48 DRAM_D49 DRAM_D5 DRAM_D50 DRAM_D51 DRAM_D52 DRAM_D53 DRAM_D54 DRAM_"
        "D55 DRAM_D56 DRAM_D57 DRAM_D58 DRAM_D59 DRAM_D6 DRAM_D60 DRAM_D61 DRAM"
        "_D62 DRAM_D63 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DR"
        "AM_DQM3 DRAM_DQM4 DRAM_DQM5 DRAM_DQM6 DRAM_DQM7 DRAM_RAS DRAM_SDBA0 DR"
        "AM_SDBA1 DRAM_SDCLK_0 DRAM_SDCLK_1 DRAM_SDWE).",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_TERM_CTL1.
static const field_t hw_iomuxc_sw_pad_ctl_grp_term_ctl1[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: TER"
        "M_CTL1 (Pads: DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DR"
        "AM_D8 DRAM_D9).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_TERM_CTL2.
static const field_t hw_iomuxc_sw_pad_ctl_grp_term_ctl2[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: TER"
        "M_CTL2 (Pads: DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D20 DRAM_D21 DR"
        "AM_D22 DRAM_D23).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_TERM_CTL3.
static const field_t hw_iomuxc_sw_pad_ctl_grp_term_ctl3[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: TER"
        "M_CTL3 (Pads: DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DR"
        "AM_D30 DRAM_D31).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRPK.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrpk[] =
{
    {
        "PUE",
        "Pull / Keep Select Field  Select one out of next values for group: DDR"
        "PK (Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14"
        " DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM"
        "_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_"
        "D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRA"
        "M_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DR"
        "AM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D32 DRAM_D33 D"
        "RAM_D34 DRAM_D35 DRAM_D36 DRAM_D37 DRAM_D38 DRAM_D39 DRAM_D4 DRAM_D40 "
        "DRAM_D41 DRAM_D42 DRAM_D43 DRAM_D44 DRAM_D45 DRAM_D46 DRAM_D47 DRAM_D4"
        "8 DRAM_D49 DRAM_D5 DRAM_D50 DRAM_D51 DRAM_D52 DRAM_D53 DRAM_D54 DRAM_D"
        "55 DRAM_D56 DRAM_D57 DRAM_D58 DRAM_D59 DRAM_D6 DRAM_D60 DRAM_D61 DRAM_"
        "D62 DRAM_D63 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRA"
        "M_DQM3 DRAM_DQM4 DRAM_DQM5 DRAM_DQM6 DRAM_DQM7 DRAM_RAS DRAM_SDBA0 DRA"
        "M_SDBA1 DRAM_SDCLK_0 DRAM_SDCLK_1 DRAM_SDWE).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_TERM_CTL4.
static const field_t hw_iomuxc_sw_pad_ctl_grp_term_ctl4[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: TER"
        "M_CTL4 (Pads: DRAM_D32 DRAM_D33 DRAM_D34 DRAM_D35 DRAM_D36 DRAM_D37 DR"
        "AM_D38 DRAM_D39).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRHYS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrhys[] =
{
    {
        "HYS",
        "Hysteresis Enable Field  Select one out of next values for group: DDRH"
        "YS (Pads: DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14"
        " DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D2"
        "1 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_"
        "D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D32 DRAM_D33 DRAM_D34 DRAM_D35 DRAM"
        "_D36 DRAM_D37 DRAM_D38 DRAM_D39 DRAM_D4 DRAM_D40 DRAM_D41 DRAM_D42 DRA"
        "M_D43 DRAM_D44 DRAM_D45 DRAM_D46 DRAM_D47 DRAM_D48 DRAM_D49 DRAM_D5 DR"
        "AM_D50 DRAM_D51 DRAM_D52 DRAM_D53 DRAM_D54 DRAM_D55 DRAM_D56 DRAM_D57 "
        "DRAM_D58 DRAM_D59 DRAM_D6 DRAM_D60 DRAM_D61 DRAM_D62 DRAM_D63 DRAM_D7 "
        "DRAM_D8 DRAM_D9 DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3 DRAM_SDQS4"
        " DRAM_SDQS5 DRAM_SDQS6 DRAM_SDQS7).",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRMODE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrmode[] =
{
    {
        "DDR_INPUT",
        "DDR / CMOS Input Mode Field  Select one out of next values for group: "
        "DDRMODE (Pads: DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRA"
        "M_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DR"
        "AM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 "
        "DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D32 DRAM_D33 DRAM_D34 DRAM_D35"
        " DRAM_D36 DRAM_D37 DRAM_D38 DRAM_D39 DRAM_D4 DRAM_D40 DRAM_D41 DRAM_D4"
        "2 DRAM_D43 DRAM_D44 DRAM_D45 DRAM_D46 DRAM_D47 DRAM_D48 DRAM_D49 DRAM_"
        "D5 DRAM_D50 DRAM_D51 DRAM_D52 DRAM_D53 DRAM_D54 DRAM_D55 DRAM_D56 DRAM"
        "_D57 DRAM_D58 DRAM_D59 DRAM_D6 DRAM_D60 DRAM_D61 DRAM_D62 DRAM_D63 DRA"
        "M_D7 DRAM_D8 DRAM_D9).",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_TERM_CTL5.
static const field_t hw_iomuxc_sw_pad_ctl_grp_term_ctl5[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: TER"
        "M_CTL5 (Pads: DRAM_D40 DRAM_D41 DRAM_D42 DRAM_D43 DRAM_D44 DRAM_D45 DR"
        "AM_D46 DRAM_D47).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_TERM_CTL6.
static const field_t hw_iomuxc_sw_pad_ctl_grp_term_ctl6[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: TER"
        "M_CTL6 (Pads: DRAM_D48 DRAM_D49 DRAM_D50 DRAM_D51 DRAM_D52 DRAM_D53 DR"
        "AM_D54 DRAM_D55).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_TERM_CTL7.
static const field_t hw_iomuxc_sw_pad_ctl_grp_term_ctl7[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: TER"
        "M_CTL7 (Pads: DRAM_D56 DRAM_D57 DRAM_D58 DRAM_D59 DRAM_D60 DRAM_D61 DR"
        "AM_D62 DRAM_D63).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B0DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b0ds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: B0DS (P"
        "ads: DRAM_D0 DRAM_D1 DRAM_D2 DRAM_D3 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B1DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b1ds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: B1DS (P"
        "ads: DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D8 DRA"
        "M_D9).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_CTLDS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ctlds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: CTLDS ("
        "Pads: DRAM_CS0 DRAM_CS1 DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDWE).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddr_type_rgmii[] =
{
    {
        "DDR_SEL",
        "DDR Select Field  Select one out of next values for group: DDR_TYPE_RG"
        "MII (Pads: RGMII_RD0 RGMII_RD1 RGMII_RD2 RGMII_RD3 RGMII_RXC RGMII_RX_"
        "CTL RGMII_TD0 RGMII_TD1 RGMII_TD2 RGMII_TD3 RGMII_TXC RGMII_TX_CTL).",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B2DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b2ds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: B2DS (P"
        "ads: DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D20 DRAM_D21 DRAM_D22 DR"
        "AM_D23).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddr_type[] =
{
    {
        "DDR_SEL",
        "DDR Select Field  Select one out of next values for group: DDR_TYPE (P"
        "ads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM"
        "_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM_A9 D"
        "RAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 D"
        "RAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 "
        "DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D2"
        "7 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D32 DRAM_D33 DRAM_D"
        "34 DRAM_D35 DRAM_D36 DRAM_D37 DRAM_D38 DRAM_D39 DRAM_D4 DRAM_D40 DRAM_"
        "D41 DRAM_D42 DRAM_D43 DRAM_D44 DRAM_D45 DRAM_D46 DRAM_D47 DRAM_D48 DRA"
        "M_D49 DRAM_D5 DRAM_D50 DRAM_D51 DRAM_D52 DRAM_D53 DRAM_D54 DRAM_D55 DR"
        "AM_D56 DRAM_D57 DRAM_D58 DRAM_D59 DRAM_D6 DRAM_D60 DRAM_D61 DRAM_D62 D"
        "RAM_D63 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM"
        "3 DRAM_DQM4 DRAM_DQM5 DRAM_DQM6 DRAM_DQM7 DRAM_RAS DRAM_SDBA0 DRAM_SDB"
        "A1 DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDCLK_0 DRAM_SDCLK_1 DRAM_S"
        "DODT0 DRAM_SDODT1 DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3 DRAM_SDQ"
        "S4 DRAM_SDQS5 DRAM_SDQS6 DRAM_SDQS7 DRAM_SDWE).",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B3DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b3ds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: B3DS (P"
        "ads: DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D30 DR"
        "AM_D31).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B4DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b4ds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: B4DS (P"
        "ads: DRAM_D32 DRAM_D33 DRAM_D34 DRAM_D35 DRAM_D36 DRAM_D37 DRAM_D38 DR"
        "AM_D39).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B5DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b5ds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: B5DS (P"
        "ads: DRAM_D40 DRAM_D41 DRAM_D42 DRAM_D43 DRAM_D44 DRAM_D45 DRAM_D46 DR"
        "AM_D47).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B6DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b6ds[] =
{
    {
        "DSE",
        "Drive Strength Field  Select one out of next values for group: B6DS (P"
        "ads: DRAM_D48 DRAM_D49 DRAM_D50 DRAM_D51 DRAM_D52 DRAM_D53 DRAM_D54 DR"
        "AM_D55).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM.
static const field_t hw_iomuxc_sw_pad_ctl_grp_rgmii_term[] =
{
    {
        "ODT",
        "On Die Termination Field  Select one out of next values for group: RGM"
        "II_TERM (Pads: RGMII_RD0 RGMII_RD1 RGMII_RD2 RGMII_RD3 RGMII_RXC RGMII"
        "_RX_CTL).",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ASRC_ASRCK_CLOCK_6_SELECT_INPUT.
static const field_t hw_iomuxc_asrc_asrck_clock_6_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_da_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_db_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_da_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_db_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CAN1_IPP_IND_CANRX_SELECT_INPUT.
static const field_t hw_iomuxc_can1_ipp_ind_canrx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CAN2_IPP_IND_CANRX_SELECT_INPUT.
static const field_t hw_iomuxc_can2_ipp_ind_canrx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CCM_IPP_DI1_CLK_SELECT_INPUT.
static const field_t hw_iomuxc_ccm_ipp_di1_clk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT.
static const field_t hw_iomuxc_ccm_pmic_vfuncional_ready_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_2_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_3_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_ss_b_0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_ss_b_1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_ind_ss_b_0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi5_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi5_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi5_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_IND_SS_B_0_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi5_ipp_ind_ss_b_0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_IND_SS_B_1_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi5_ipp_ind_ss_b_1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT.
static const field_t hw_iomuxc_enet_ipg_clk_rmii_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET_IPP_IND_MAC0_MDIO_SELECT_INPUT.
static const field_t hw_iomuxc_enet_ipp_ind_mac0_mdio_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET_IPP_IND_MAC0_RXCLK_SELECT_INPUT.
static const field_t hw_iomuxc_enet_ipp_ind_mac0_rxclk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET_IPP_IND_MAC0_RXDATA_0_SELECT_INPUT.
static const field_t hw_iomuxc_enet_ipp_ind_mac0_rxdata_0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET_IPP_IND_MAC0_RXDATA_1_SELECT_INPUT.
static const field_t hw_iomuxc_enet_ipp_ind_mac0_rxdata_1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET_IPP_IND_MAC0_RXDATA_2_SELECT_INPUT.
static const field_t hw_iomuxc_enet_ipp_ind_mac0_rxdata_2_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET_IPP_IND_MAC0_RXDATA_3_SELECT_INPUT.
static const field_t hw_iomuxc_enet_ipp_ind_mac0_rxdata_3_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET_IPP_IND_MAC0_RXEN_SELECT_INPUT.
static const field_t hw_iomuxc_enet_ipp_ind_mac0_rxen_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_FSR_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_fsr_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_FST_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_fst_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_HCKR_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_hckr_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_HCKT_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_hckt_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SCKR_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sckr_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SCKT_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sckt_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO0_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO1_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO2_SDI3_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo2_sdi3_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO3_SDI2_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo3_sdi2_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO4_SDI1_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo4_sdi1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO5_SDI0_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo5_sdi0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_HDMI_TX_ICECIN_SELECT_INPUT.
static const field_t hw_iomuxc_hdmi_tx_icecin_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_HDMI_TX_II2C_MSTH13TDDC_SCLIN_SELECT_INPUT.
static const field_t hw_iomuxc_hdmi_tx_ii2c_msth13tddc_sclin_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_HDMI_TX_II2C_MSTH13TDDC_SDAIN_SELECT_INPUT.
static const field_t hw_iomuxc_hdmi_tx_ii2c_msth13tddc_sdain_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c1_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c1_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c2_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c2_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c3_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c3_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_10_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_10_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_11_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_11_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_12_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_12_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_13_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_13_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_14_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_14_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_15_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_15_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_16_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_16_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_17_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_17_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_18_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_18_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_19_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_19_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_DATA_EN_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_data_en_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_HSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_hsync_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_PIX_CLK_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_pix_clk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_IPU2_IPP_IND_SENS1_VSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_ipu2_ipp_ind_sens1_vsync_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_5_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_6_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_7_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_5_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_6_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_7_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_MLB_MLB_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_mlb_mlb_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_MLB_MLB_DATA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_mlb_mlb_data_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_MLB_MLB_SIG_IN_SELECT_INPUT.
static const field_t hw_iomuxc_mlb_mlb_sig_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT.
static const field_t hw_iomuxc_spdif_spdif_in1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT.
static const field_t hw_iomuxc_spdif_tx_clk2_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart1_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart1_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart2_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart2_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart3_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart3_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart4_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart4_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart5_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart5_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT.
static const field_t hw_iomuxc_usb_ipp_ind_otg_oc_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_IPP_IND_H1_OC_SELECT_INPUT.
static const field_t hw_iomuxc_usb_ipp_ind_h1_oc_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc1_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC module.
static const reg_t hw_iomuxc[] =
{
    {
        "GPR0",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_iomuxc_gpr0
    },
    {
        "GPR1",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_iomuxc_gpr1
    },
    {
        "GPR2",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_iomuxc_gpr2
    },
    {
        "GPR3",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_iomuxc_gpr3
    },
    {
        "GPR4",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_iomuxc_gpr4
    },
    {
        "GPR5",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_iomuxc_gpr5
    },
    {
        "GPR6",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_gpr6
    },
    {
        "GPR7",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_gpr7
    },
    {
        "GPR8",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc_gpr8
    },
    {
        "GPR9",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_gpr9
    },
    {
        "GPR10",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_iomuxc_gpr10
    },
    {
        "GPR11",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_iomuxc_gpr11
    },
    {
        "GPR12",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_iomuxc_gpr12
    },
    {
        "GPR13",
        "SATA_PHY_6    PHUG    FRUG    fast_startup    Frequency Tolerance (ppm"
        ")      000    1    1    None    780      001    2    2    None    780 "
        "     010    1    4    None    6,250      011    2    4    None    6,25"
        "0      1xx    Reserved",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_iomuxc_gpr13
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT1",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat1
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT2",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat2
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT0",
        "",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat0
    },
    {
        "SW_MUX_CTL_PAD_RGMII_TXC",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_txc
    },
    {
        "SW_MUX_CTL_PAD_RGMII_TD0",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_td0
    },
    {
        "SW_MUX_CTL_PAD_RGMII_TD1",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_td1
    },
    {
        "SW_MUX_CTL_PAD_RGMII_TD2",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_td2
    },
    {
        "SW_MUX_CTL_PAD_RGMII_TD3",
        "",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_td3
    },
    {
        "SW_MUX_CTL_PAD_RGMII_RX_CTL",
        "",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_rx_ctl
    },
    {
        "SW_MUX_CTL_PAD_RGMII_RD0",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_rd0
    },
    {
        "SW_MUX_CTL_PAD_RGMII_TX_CTL",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_tx_ctl
    },
    {
        "SW_MUX_CTL_PAD_RGMII_RD1",
        "",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_rd1
    },
    {
        "SW_MUX_CTL_PAD_RGMII_RD2",
        "",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_rd2
    },
    {
        "SW_MUX_CTL_PAD_RGMII_RD3",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_rd3
    },
    {
        "SW_MUX_CTL_PAD_RGMII_RXC",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii_rxc
    },
    {
        "SW_MUX_CTL_PAD_EIM_A25",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a25
    },
    {
        "SW_MUX_CTL_PAD_EIM_EB2",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_eb2
    },
    {
        "SW_MUX_CTL_PAD_EIM_D16",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d16
    },
    {
        "SW_MUX_CTL_PAD_EIM_D17",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d17
    },
    {
        "SW_MUX_CTL_PAD_EIM_D18",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d18
    },
    {
        "SW_MUX_CTL_PAD_EIM_D19",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d19
    },
    {
        "SW_MUX_CTL_PAD_EIM_D20",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d20
    },
    {
        "SW_MUX_CTL_PAD_EIM_D21",
        "",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d21
    },
    {
        "SW_MUX_CTL_PAD_EIM_D22",
        "",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d22
    },
    {
        "SW_MUX_CTL_PAD_EIM_D23",
        "",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d23
    },
    {
        "SW_MUX_CTL_PAD_EIM_EB3",
        "",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_eb3
    },
    {
        "SW_MUX_CTL_PAD_EIM_D24",
        "",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d24
    },
    {
        "SW_MUX_CTL_PAD_EIM_D25",
        "",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d25
    },
    {
        "SW_MUX_CTL_PAD_EIM_D26",
        "",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d26
    },
    {
        "SW_MUX_CTL_PAD_EIM_D27",
        "",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d27
    },
    {
        "SW_MUX_CTL_PAD_EIM_D28",
        "",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d28
    },
    {
        "SW_MUX_CTL_PAD_EIM_D29",
        "",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d29
    },
    {
        "SW_MUX_CTL_PAD_EIM_D30",
        "",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d30
    },
    {
        "SW_MUX_CTL_PAD_EIM_D31",
        "",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_d31
    },
    {
        "SW_MUX_CTL_PAD_EIM_A24",
        "",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a24
    },
    {
        "SW_MUX_CTL_PAD_EIM_A23",
        "",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a23
    },
    {
        "SW_MUX_CTL_PAD_EIM_A22",
        "",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a22
    },
    {
        "SW_MUX_CTL_PAD_EIM_A21",
        "",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a21
    },
    {
        "SW_MUX_CTL_PAD_EIM_A20",
        "",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a20
    },
    {
        "SW_MUX_CTL_PAD_EIM_A19",
        "",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a19
    },
    {
        "SW_MUX_CTL_PAD_EIM_A18",
        "",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a18
    },
    {
        "SW_MUX_CTL_PAD_EIM_A17",
        "",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a17
    },
    {
        "SW_MUX_CTL_PAD_EIM_A16",
        "",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_a16
    },
    {
        "SW_MUX_CTL_PAD_EIM_CS0",
        "",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_cs0
    },
    {
        "SW_MUX_CTL_PAD_EIM_CS1",
        "",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_cs1
    },
    {
        "SW_MUX_CTL_PAD_EIM_OE",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_oe
    },
    {
        "SW_MUX_CTL_PAD_EIM_RW",
        "",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_rw
    },
    {
        "SW_MUX_CTL_PAD_EIM_LBA",
        "",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_lba
    },
    {
        "SW_MUX_CTL_PAD_EIM_EB0",
        "",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_eb0
    },
    {
        "SW_MUX_CTL_PAD_EIM_EB1",
        "",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_eb1
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA0",
        "",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da0
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA1",
        "",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da1
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA2",
        "",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da2
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA3",
        "",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da3
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA4",
        "",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da4
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA5",
        "",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da5
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA6",
        "",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da6
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA7",
        "",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da7
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA8",
        "",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da8
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA9",
        "",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da9
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA10",
        "",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da10
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA11",
        "",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da11
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA12",
        "",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da12
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA13",
        "",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da13
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA14",
        "",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da14
    },
    {
        "SW_MUX_CTL_PAD_EIM_DA15",
        "",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_da15
    },
    {
        "SW_MUX_CTL_PAD_EIM_WAIT",
        "",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_wait
    },
    {
        "SW_MUX_CTL_PAD_EIM_BCLK",
        "",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_eim_bclk
    },
    {
        "SW_MUX_CTL_PAD_DI0_DISP_CLK",
        "",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_di0_disp_clk
    },
    {
        "SW_MUX_CTL_PAD_DI0_PIN15",
        "",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_di0_pin15
    },
    {
        "SW_MUX_CTL_PAD_DI0_PIN2",
        "",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_di0_pin2
    },
    {
        "SW_MUX_CTL_PAD_DI0_PIN3",
        "",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_di0_pin3
    },
    {
        "SW_MUX_CTL_PAD_DI0_PIN4",
        "",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_di0_pin4
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT0",
        "",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat0
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT1",
        "",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat1
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT2",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat2
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT3",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat3
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT4",
        "",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat4
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT5",
        "",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat5
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT6",
        "",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat6
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT7",
        "",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat7
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT8",
        "",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat8
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT9",
        "",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat9
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT10",
        "",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat10
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT11",
        "",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat11
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT12",
        "",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat12
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT13",
        "",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat13
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT14",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat14
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT15",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat15
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT16",
        "",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat16
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT17",
        "",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat17
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT18",
        "",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat18
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT19",
        "",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat19
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT20",
        "",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat20
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT21",
        "",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat21
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT22",
        "",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat22
    },
    {
        "SW_MUX_CTL_PAD_DISP0_DAT23",
        "",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_disp0_dat23
    },
    {
        "SW_MUX_CTL_PAD_ENET_MDIO",
        "",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_mdio
    },
    {
        "SW_MUX_CTL_PAD_ENET_REF_CLK",
        "",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_ref_clk
    },
    {
        "SW_MUX_CTL_PAD_ENET_RX_ER",
        "",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_rx_er
    },
    {
        "SW_MUX_CTL_PAD_ENET_CRS_DV",
        "",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_crs_dv
    },
    {
        "SW_MUX_CTL_PAD_ENET_RXD1",
        "",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_rxd1
    },
    {
        "SW_MUX_CTL_PAD_ENET_RXD0",
        "",
        4, // Width in bytes
        0x000001e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_rxd0
    },
    {
        "SW_MUX_CTL_PAD_ENET_TX_EN",
        "",
        4, // Width in bytes
        0x000001e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_tx_en
    },
    {
        "SW_MUX_CTL_PAD_ENET_TXD1",
        "",
        4, // Width in bytes
        0x000001ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_txd1
    },
    {
        "SW_MUX_CTL_PAD_ENET_TXD0",
        "",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_txd0
    },
    {
        "SW_MUX_CTL_PAD_ENET_MDC",
        "",
        4, // Width in bytes
        0x000001f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet_mdc
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL0",
        "",
        4, // Width in bytes
        0x000001f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col0
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW0",
        "",
        4, // Width in bytes
        0x000001fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row0
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL1",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col1
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW1",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row1
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL2",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col2
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW2",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row2
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL3",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col3
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW3",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row3
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL4",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col4
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW4",
        "",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row4
    },
    {
        "SW_MUX_CTL_PAD_GPIO_0",
        "",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_0
    },
    {
        "SW_MUX_CTL_PAD_GPIO_1",
        "",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_1
    },
    {
        "SW_MUX_CTL_PAD_GPIO_9",
        "",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_9
    },
    {
        "SW_MUX_CTL_PAD_GPIO_3",
        "",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_3
    },
    {
        "SW_MUX_CTL_PAD_GPIO_6",
        "",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_6
    },
    {
        "SW_MUX_CTL_PAD_GPIO_2",
        "",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_2
    },
    {
        "SW_MUX_CTL_PAD_GPIO_4",
        "",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_4
    },
    {
        "SW_MUX_CTL_PAD_GPIO_5",
        "",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_5
    },
    {
        "SW_MUX_CTL_PAD_GPIO_7",
        "",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_7
    },
    {
        "SW_MUX_CTL_PAD_GPIO_8",
        "",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_8
    },
    {
        "SW_MUX_CTL_PAD_GPIO_16",
        "",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_16
    },
    {
        "SW_MUX_CTL_PAD_GPIO_17",
        "",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_17
    },
    {
        "SW_MUX_CTL_PAD_GPIO_18",
        "",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_18
    },
    {
        "SW_MUX_CTL_PAD_GPIO_19",
        "",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio_19
    },
    {
        "SW_MUX_CTL_PAD_CSI0_PIXCLK",
        "",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_pixclk
    },
    {
        "SW_MUX_CTL_PAD_CSI0_MCLK",
        "",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_mclk
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DATA_EN",
        "",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_data_en
    },
    {
        "SW_MUX_CTL_PAD_CSI0_VSYNC",
        "",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_vsync
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT4",
        "",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat4
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT5",
        "",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat5
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT6",
        "",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat6
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT7",
        "",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat7
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT8",
        "",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat8
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT9",
        "",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat9
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT10",
        "",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat10
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT11",
        "",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat11
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT12",
        "",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat12
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT13",
        "",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat13
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT14",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat14
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT15",
        "",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat15
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT16",
        "",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat16
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT17",
        "",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat17
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT18",
        "",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat18
    },
    {
        "SW_MUX_CTL_PAD_CSI0_DAT19",
        "",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi0_dat19
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT7",
        "",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat7
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT6",
        "",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat6
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT5",
        "",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat5
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT4",
        "",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat4
    },
    {
        "SW_MUX_CTL_PAD_SD3_CMD",
        "",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD3_CLK",
        "",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_clk
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT0",
        "",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat0
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT1",
        "",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat1
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT2",
        "",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat2
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT3",
        "",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat3
    },
    {
        "SW_MUX_CTL_PAD_SD3_RST",
        "",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_rst
    },
    {
        "SW_MUX_CTL_PAD_NANDF_CLE",
        "",
        4, // Width in bytes
        0x000002d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_cle
    },
    {
        "SW_MUX_CTL_PAD_NANDF_ALE",
        "",
        4, // Width in bytes
        0x000002d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_ale
    },
    {
        "SW_MUX_CTL_PAD_NANDF_WP_B",
        "",
        4, // Width in bytes
        0x000002dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_wp_b
    },
    {
        "SW_MUX_CTL_PAD_NANDF_RB0",
        "",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_rb0
    },
    {
        "SW_MUX_CTL_PAD_NANDF_CS0",
        "",
        4, // Width in bytes
        0x000002e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_cs0
    },
    {
        "SW_MUX_CTL_PAD_NANDF_CS1",
        "",
        4, // Width in bytes
        0x000002e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_cs1
    },
    {
        "SW_MUX_CTL_PAD_NANDF_CS2",
        "",
        4, // Width in bytes
        0x000002ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_cs2
    },
    {
        "SW_MUX_CTL_PAD_NANDF_CS3",
        "",
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_cs3
    },
    {
        "SW_MUX_CTL_PAD_SD4_CMD",
        "",
        4, // Width in bytes
        0x000002f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD4_CLK",
        "",
        4, // Width in bytes
        0x000002f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_clk
    },
    {
        "SW_MUX_CTL_PAD_NANDF_D0",
        "",
        4, // Width in bytes
        0x000002fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_d0
    },
    {
        "SW_MUX_CTL_PAD_NANDF_D1",
        "",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_d1
    },
    {
        "SW_MUX_CTL_PAD_NANDF_D2",
        "",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_d2
    },
    {
        "SW_MUX_CTL_PAD_NANDF_D3",
        "",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_d3
    },
    {
        "SW_MUX_CTL_PAD_NANDF_D4",
        "",
        4, // Width in bytes
        0x0000030c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_d4
    },
    {
        "SW_MUX_CTL_PAD_NANDF_D5",
        "",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_d5
    },
    {
        "SW_MUX_CTL_PAD_NANDF_D6",
        "",
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_d6
    },
    {
        "SW_MUX_CTL_PAD_NANDF_D7",
        "",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nandf_d7
    },
    {
        "SW_MUX_CTL_PAD_SD4_DAT0",
        "",
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_dat0
    },
    {
        "SW_MUX_CTL_PAD_SD4_DAT1",
        "",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_dat1
    },
    {
        "SW_MUX_CTL_PAD_SD4_DAT2",
        "",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_dat2
    },
    {
        "SW_MUX_CTL_PAD_SD4_DAT3",
        "",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_dat3
    },
    {
        "SW_MUX_CTL_PAD_SD4_DAT4",
        "",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_dat4
    },
    {
        "SW_MUX_CTL_PAD_SD4_DAT5",
        "",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_dat5
    },
    {
        "SW_MUX_CTL_PAD_SD4_DAT6",
        "",
        4, // Width in bytes
        0x00000334, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_dat6
    },
    {
        "SW_MUX_CTL_PAD_SD4_DAT7",
        "",
        4, // Width in bytes
        0x00000338, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_dat7
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT1",
        "",
        4, // Width in bytes
        0x0000033c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat1
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT0",
        "",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat0
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT3",
        "",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat3
    },
    {
        "SW_MUX_CTL_PAD_SD1_CMD",
        "",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT2",
        "",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat2
    },
    {
        "SW_MUX_CTL_PAD_SD1_CLK",
        "",
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_clk
    },
    {
        "SW_MUX_CTL_PAD_SD2_CLK",
        "",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_clk
    },
    {
        "SW_MUX_CTL_PAD_SD2_CMD",
        "",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT3",
        "",
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat3
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT1",
        "",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat1
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT2",
        "",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat2
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT0",
        "",
        4, // Width in bytes
        0x00000368, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat0
    },
    {
        "SW_PAD_CTL_PAD_RGMII_TXC",
        "",
        4, // Width in bytes
        0x0000036c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_txc
    },
    {
        "SW_PAD_CTL_PAD_RGMII_TD0",
        "",
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_td0
    },
    {
        "SW_PAD_CTL_PAD_RGMII_TD1",
        "",
        4, // Width in bytes
        0x00000374, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_td1
    },
    {
        "SW_PAD_CTL_PAD_RGMII_TD2",
        "",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_td2
    },
    {
        "SW_PAD_CTL_PAD_RGMII_TD3",
        "",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_td3
    },
    {
        "SW_PAD_CTL_PAD_RGMII_RX_CTL",
        "",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_rx_ctl
    },
    {
        "SW_PAD_CTL_PAD_RGMII_RD0",
        "",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_rd0
    },
    {
        "SW_PAD_CTL_PAD_RGMII_TX_CTL",
        "",
        4, // Width in bytes
        0x00000388, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_tx_ctl
    },
    {
        "SW_PAD_CTL_PAD_RGMII_RD1",
        "",
        4, // Width in bytes
        0x0000038c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_rd1
    },
    {
        "SW_PAD_CTL_PAD_RGMII_RD2",
        "",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_rd2
    },
    {
        "SW_PAD_CTL_PAD_RGMII_RD3",
        "",
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_rd3
    },
    {
        "SW_PAD_CTL_PAD_RGMII_RXC",
        "",
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii_rxc
    },
    {
        "SW_PAD_CTL_PAD_EIM_A25",
        "",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a25
    },
    {
        "SW_PAD_CTL_PAD_EIM_EB2",
        "",
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_eb2
    },
    {
        "SW_PAD_CTL_PAD_EIM_D16",
        "",
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d16
    },
    {
        "SW_PAD_CTL_PAD_EIM_D17",
        "",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d17
    },
    {
        "SW_PAD_CTL_PAD_EIM_D18",
        "",
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d18
    },
    {
        "SW_PAD_CTL_PAD_EIM_D19",
        "",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d19
    },
    {
        "SW_PAD_CTL_PAD_EIM_D20",
        "",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d20
    },
    {
        "SW_PAD_CTL_PAD_EIM_D21",
        "",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d21
    },
    {
        "SW_PAD_CTL_PAD_EIM_D22",
        "",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d22
    },
    {
        "SW_PAD_CTL_PAD_EIM_D23",
        "",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d23
    },
    {
        "SW_PAD_CTL_PAD_EIM_EB3",
        "",
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_eb3
    },
    {
        "SW_PAD_CTL_PAD_EIM_D24",
        "",
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d24
    },
    {
        "SW_PAD_CTL_PAD_EIM_D25",
        "",
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d25
    },
    {
        "SW_PAD_CTL_PAD_EIM_D26",
        "",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d26
    },
    {
        "SW_PAD_CTL_PAD_EIM_D27",
        "",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d27
    },
    {
        "SW_PAD_CTL_PAD_EIM_D28",
        "",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d28
    },
    {
        "SW_PAD_CTL_PAD_EIM_D29",
        "",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d29
    },
    {
        "SW_PAD_CTL_PAD_EIM_D30",
        "",
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d30
    },
    {
        "SW_PAD_CTL_PAD_EIM_D31",
        "",
        4, // Width in bytes
        0x000003e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_d31
    },
    {
        "SW_PAD_CTL_PAD_EIM_A24",
        "",
        4, // Width in bytes
        0x000003e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a24
    },
    {
        "SW_PAD_CTL_PAD_EIM_A23",
        "",
        4, // Width in bytes
        0x000003ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a23
    },
    {
        "SW_PAD_CTL_PAD_EIM_A22",
        "",
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a22
    },
    {
        "SW_PAD_CTL_PAD_EIM_A21",
        "",
        4, // Width in bytes
        0x000003f4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a21
    },
    {
        "SW_PAD_CTL_PAD_EIM_A20",
        "",
        4, // Width in bytes
        0x000003f8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a20
    },
    {
        "SW_PAD_CTL_PAD_EIM_A19",
        "",
        4, // Width in bytes
        0x000003fc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a19
    },
    {
        "SW_PAD_CTL_PAD_EIM_A18",
        "",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a18
    },
    {
        "SW_PAD_CTL_PAD_EIM_A17",
        "",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a17
    },
    {
        "SW_PAD_CTL_PAD_EIM_A16",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_a16
    },
    {
        "SW_PAD_CTL_PAD_EIM_CS0",
        "",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_cs0
    },
    {
        "SW_PAD_CTL_PAD_EIM_CS1",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_cs1
    },
    {
        "SW_PAD_CTL_PAD_EIM_OE",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_oe
    },
    {
        "SW_PAD_CTL_PAD_EIM_RW",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_rw
    },
    {
        "SW_PAD_CTL_PAD_EIM_LBA",
        "",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_lba
    },
    {
        "SW_PAD_CTL_PAD_EIM_EB0",
        "",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_eb0
    },
    {
        "SW_PAD_CTL_PAD_EIM_EB1",
        "",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_eb1
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA0",
        "",
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da0
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA1",
        "",
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da1
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA2",
        "",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da2
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA3",
        "",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da3
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA4",
        "",
        4, // Width in bytes
        0x00000438, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da4
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA5",
        "",
        4, // Width in bytes
        0x0000043c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da5
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA6",
        "",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da6
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA7",
        "",
        4, // Width in bytes
        0x00000444, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da7
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA8",
        "",
        4, // Width in bytes
        0x00000448, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da8
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA9",
        "",
        4, // Width in bytes
        0x0000044c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da9
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA10",
        "",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da10
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA11",
        "",
        4, // Width in bytes
        0x00000454, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da11
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA12",
        "",
        4, // Width in bytes
        0x00000458, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da12
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA13",
        "",
        4, // Width in bytes
        0x0000045c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da13
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA14",
        "",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da14
    },
    {
        "SW_PAD_CTL_PAD_EIM_DA15",
        "",
        4, // Width in bytes
        0x00000464, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_da15
    },
    {
        "SW_PAD_CTL_PAD_EIM_WAIT",
        "",
        4, // Width in bytes
        0x00000468, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_wait
    },
    {
        "SW_PAD_CTL_PAD_EIM_BCLK",
        "",
        4, // Width in bytes
        0x0000046c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_eim_bclk
    },
    {
        "SW_PAD_CTL_PAD_DI0_DISP_CLK",
        "",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_di0_disp_clk
    },
    {
        "SW_PAD_CTL_PAD_DI0_PIN15",
        "",
        4, // Width in bytes
        0x00000474, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_di0_pin15
    },
    {
        "SW_PAD_CTL_PAD_DI0_PIN2",
        "",
        4, // Width in bytes
        0x00000478, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_di0_pin2
    },
    {
        "SW_PAD_CTL_PAD_DI0_PIN3",
        "",
        4, // Width in bytes
        0x0000047c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_di0_pin3
    },
    {
        "SW_PAD_CTL_PAD_DI0_PIN4",
        "",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_di0_pin4
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT0",
        "",
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat0
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT1",
        "",
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat1
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT2",
        "",
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat2
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT3",
        "",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat3
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT4",
        "",
        4, // Width in bytes
        0x00000494, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat4
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT5",
        "",
        4, // Width in bytes
        0x00000498, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat5
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT6",
        "",
        4, // Width in bytes
        0x0000049c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat6
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT7",
        "",
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat7
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT8",
        "",
        4, // Width in bytes
        0x000004a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat8
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT9",
        "",
        4, // Width in bytes
        0x000004a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat9
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT10",
        "",
        4, // Width in bytes
        0x000004ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat10
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT11",
        "",
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat11
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT12",
        "",
        4, // Width in bytes
        0x000004b4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat12
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT13",
        "",
        4, // Width in bytes
        0x000004b8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat13
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT14",
        "",
        4, // Width in bytes
        0x000004bc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat14
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT15",
        "",
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat15
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT16",
        "",
        4, // Width in bytes
        0x000004c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat16
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT17",
        "",
        4, // Width in bytes
        0x000004c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat17
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT18",
        "",
        4, // Width in bytes
        0x000004cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat18
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT19",
        "",
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat19
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT20",
        "",
        4, // Width in bytes
        0x000004d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat20
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT21",
        "",
        4, // Width in bytes
        0x000004d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat21
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT22",
        "",
        4, // Width in bytes
        0x000004dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat22
    },
    {
        "SW_PAD_CTL_PAD_DISP0_DAT23",
        "",
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_disp0_dat23
    },
    {
        "SW_PAD_CTL_PAD_ENET_MDIO",
        "",
        4, // Width in bytes
        0x000004e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_mdio
    },
    {
        "SW_PAD_CTL_PAD_ENET_REF_CLK",
        "",
        4, // Width in bytes
        0x000004e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_ref_clk
    },
    {
        "SW_PAD_CTL_PAD_ENET_RX_ER",
        "",
        4, // Width in bytes
        0x000004ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_rx_er
    },
    {
        "SW_PAD_CTL_PAD_ENET_CRS_DV",
        "",
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_crs_dv
    },
    {
        "SW_PAD_CTL_PAD_ENET_RXD1",
        "",
        4, // Width in bytes
        0x000004f4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_rxd1
    },
    {
        "SW_PAD_CTL_PAD_ENET_RXD0",
        "",
        4, // Width in bytes
        0x000004f8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_rxd0
    },
    {
        "SW_PAD_CTL_PAD_ENET_TX_EN",
        "",
        4, // Width in bytes
        0x000004fc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_tx_en
    },
    {
        "SW_PAD_CTL_PAD_ENET_TXD1",
        "",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_txd1
    },
    {
        "SW_PAD_CTL_PAD_ENET_TXD0",
        "",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_txd0
    },
    {
        "SW_PAD_CTL_PAD_ENET_MDC",
        "",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet_mdc
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS5",
        "",
        4, // Width in bytes
        0x0000050c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs5
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM5",
        "",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm5
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM4",
        "",
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm4
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS4",
        "",
        4, // Width in bytes
        0x00000518, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs4
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS3",
        "",
        4, // Width in bytes
        0x0000051c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs3
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM3",
        "",
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm3
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS2",
        "",
        4, // Width in bytes
        0x00000524, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM2",
        "",
        4, // Width in bytes
        0x00000528, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A0",
        "",
        4, // Width in bytes
        0x0000052c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A1",
        "",
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A2",
        "",
        4, // Width in bytes
        0x00000534, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A3",
        "",
        4, // Width in bytes
        0x00000538, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a3
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A4",
        "",
        4, // Width in bytes
        0x0000053c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a4
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A5",
        "",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a5
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A6",
        "",
        4, // Width in bytes
        0x00000544, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a6
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A7",
        "",
        4, // Width in bytes
        0x00000548, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a7
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A8",
        "",
        4, // Width in bytes
        0x0000054c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a8
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A9",
        "",
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a9
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A10",
        "",
        4, // Width in bytes
        0x00000554, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a10
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A11",
        "",
        4, // Width in bytes
        0x00000558, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a11
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A12",
        "",
        4, // Width in bytes
        0x0000055c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a12
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A13",
        "",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a13
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A14",
        "",
        4, // Width in bytes
        0x00000564, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a14
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A15",
        "",
        4, // Width in bytes
        0x00000568, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a15
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CAS",
        "",
        4, // Width in bytes
        0x0000056c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cas
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CS0",
        "",
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cs0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CS1",
        "",
        4, // Width in bytes
        0x00000574, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cs1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_RAS",
        "",
        4, // Width in bytes
        0x00000578, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_ras
    },
    {
        "SW_PAD_CTL_PAD_DRAM_RESET",
        "",
        4, // Width in bytes
        0x0000057c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_reset
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA0",
        "",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA1",
        "",
        4, // Width in bytes
        0x00000584, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCLK_0",
        "",
        4, // Width in bytes
        0x00000588, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdclk_0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA2",
        "",
        4, // Width in bytes
        0x0000058c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCKE0",
        "",
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdcke0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCLK_1",
        "",
        4, // Width in bytes
        0x00000594, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdclk_1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCKE1",
        "",
        4, // Width in bytes
        0x00000598, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdcke1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDODT0",
        "The pad settings for SDCLK_0_B and SDCLK_1_B are identical to SDCLK_0 "
        "and SDCLK_1 respectively.",
        4, // Width in bytes
        0x0000059c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdodt0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDODT1",
        "",
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdodt1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDWE",
        "",
        4, // Width in bytes
        0x000005a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdwe
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS0",
        "",
        4, // Width in bytes
        0x000005a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM0",
        "",
        4, // Width in bytes
        0x000005ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS1",
        "",
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM1",
        "",
        4, // Width in bytes
        0x000005b4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS6",
        "",
        4, // Width in bytes
        0x000005b8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs6
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM6",
        "",
        4, // Width in bytes
        0x000005bc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm6
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS7",
        "",
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs7
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM7",
        "",
        4, // Width in bytes
        0x000005c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm7
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL0",
        "",
        4, // Width in bytes
        0x000005c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col0
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW0",
        "",
        4, // Width in bytes
        0x000005cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row0
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL1",
        "",
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col1
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW1",
        "",
        4, // Width in bytes
        0x000005d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row1
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL2",
        "",
        4, // Width in bytes
        0x000005d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col2
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW2",
        "",
        4, // Width in bytes
        0x000005dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row2
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL3",
        "",
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col3
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW3",
        "",
        4, // Width in bytes
        0x000005e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row3
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL4",
        "",
        4, // Width in bytes
        0x000005e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col4
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW4",
        "",
        4, // Width in bytes
        0x000005ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row4
    },
    {
        "SW_PAD_CTL_PAD_GPIO_0",
        "",
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_0
    },
    {
        "SW_PAD_CTL_PAD_GPIO_1",
        "",
        4, // Width in bytes
        0x000005f4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_1
    },
    {
        "SW_PAD_CTL_PAD_GPIO_9",
        "",
        4, // Width in bytes
        0x000005f8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_9
    },
    {
        "SW_PAD_CTL_PAD_GPIO_3",
        "",
        4, // Width in bytes
        0x000005fc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_3
    },
    {
        "SW_PAD_CTL_PAD_GPIO_6",
        "",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_6
    },
    {
        "SW_PAD_CTL_PAD_GPIO_2",
        "",
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_2
    },
    {
        "SW_PAD_CTL_PAD_GPIO_4",
        "",
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_4
    },
    {
        "SW_PAD_CTL_PAD_GPIO_5",
        "",
        4, // Width in bytes
        0x0000060c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_5
    },
    {
        "SW_PAD_CTL_PAD_GPIO_7",
        "",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_7
    },
    {
        "SW_PAD_CTL_PAD_GPIO_8",
        "",
        4, // Width in bytes
        0x00000614, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_8
    },
    {
        "SW_PAD_CTL_PAD_GPIO_16",
        "",
        4, // Width in bytes
        0x00000618, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_16
    },
    {
        "SW_PAD_CTL_PAD_GPIO_17",
        "",
        4, // Width in bytes
        0x0000061c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_17
    },
    {
        "SW_PAD_CTL_PAD_GPIO_18",
        "",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_18
    },
    {
        "SW_PAD_CTL_PAD_GPIO_19",
        "",
        4, // Width in bytes
        0x00000624, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio_19
    },
    {
        "SW_PAD_CTL_PAD_CSI0_PIXCLK",
        "",
        4, // Width in bytes
        0x00000628, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_pixclk
    },
    {
        "SW_PAD_CTL_PAD_CSI0_MCLK",
        "",
        4, // Width in bytes
        0x0000062c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_mclk
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DATA_EN",
        "",
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_data_en
    },
    {
        "SW_PAD_CTL_PAD_CSI0_VSYNC",
        "",
        4, // Width in bytes
        0x00000634, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_vsync
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT4",
        "",
        4, // Width in bytes
        0x00000638, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat4
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT5",
        "",
        4, // Width in bytes
        0x0000063c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat5
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT6",
        "",
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat6
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT7",
        "",
        4, // Width in bytes
        0x00000644, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat7
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT8",
        "",
        4, // Width in bytes
        0x00000648, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat8
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT9",
        "",
        4, // Width in bytes
        0x0000064c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat9
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT10",
        "",
        4, // Width in bytes
        0x00000650, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat10
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT11",
        "",
        4, // Width in bytes
        0x00000654, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat11
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT12",
        "",
        4, // Width in bytes
        0x00000658, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat12
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT13",
        "",
        4, // Width in bytes
        0x0000065c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat13
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT14",
        "",
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat14
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT15",
        "",
        4, // Width in bytes
        0x00000664, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat15
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT16",
        "",
        4, // Width in bytes
        0x00000668, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat16
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT17",
        "",
        4, // Width in bytes
        0x0000066c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat17
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT18",
        "",
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat18
    },
    {
        "SW_PAD_CTL_PAD_CSI0_DAT19",
        "",
        4, // Width in bytes
        0x00000674, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi0_dat19
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TMS",
        "",
        4, // Width in bytes
        0x00000678, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tms
    },
    {
        "SW_PAD_CTL_PAD_JTAG_MOD",
        "",
        4, // Width in bytes
        0x0000067c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_mod
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TRSTB",
        "",
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_trstb
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TDI",
        "",
        4, // Width in bytes
        0x00000684, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tdi
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TCK",
        "",
        4, // Width in bytes
        0x00000688, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tck
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TDO",
        "",
        4, // Width in bytes
        0x0000068c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tdo
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT7",
        "",
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat7
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT6",
        "",
        4, // Width in bytes
        0x00000694, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat6
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT5",
        "",
        4, // Width in bytes
        0x00000698, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat5
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT4",
        "",
        4, // Width in bytes
        0x0000069c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat4
    },
    {
        "SW_PAD_CTL_PAD_SD3_CMD",
        "",
        4, // Width in bytes
        0x000006a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD3_CLK",
        "",
        4, // Width in bytes
        0x000006a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_clk
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT0",
        "",
        4, // Width in bytes
        0x000006a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat0
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT1",
        "",
        4, // Width in bytes
        0x000006ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat1
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT2",
        "",
        4, // Width in bytes
        0x000006b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat2
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT3",
        "",
        4, // Width in bytes
        0x000006b4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat3
    },
    {
        "SW_PAD_CTL_PAD_SD3_RST",
        "",
        4, // Width in bytes
        0x000006b8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_rst
    },
    {
        "SW_PAD_CTL_PAD_NANDF_CLE",
        "",
        4, // Width in bytes
        0x000006bc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_cle
    },
    {
        "SW_PAD_CTL_PAD_NANDF_ALE",
        "",
        4, // Width in bytes
        0x000006c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_ale
    },
    {
        "SW_PAD_CTL_PAD_NANDF_WP_B",
        "",
        4, // Width in bytes
        0x000006c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_wp_b
    },
    {
        "SW_PAD_CTL_PAD_NANDF_RB0",
        "",
        4, // Width in bytes
        0x000006c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_rb0
    },
    {
        "SW_PAD_CTL_PAD_NANDF_CS0",
        "",
        4, // Width in bytes
        0x000006cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_cs0
    },
    {
        "SW_PAD_CTL_PAD_NANDF_CS1",
        "",
        4, // Width in bytes
        0x000006d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_cs1
    },
    {
        "SW_PAD_CTL_PAD_NANDF_CS2",
        "",
        4, // Width in bytes
        0x000006d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_cs2
    },
    {
        "SW_PAD_CTL_PAD_NANDF_CS3",
        "",
        4, // Width in bytes
        0x000006d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_cs3
    },
    {
        "SW_PAD_CTL_PAD_SD4_CMD",
        "",
        4, // Width in bytes
        0x000006dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD4_CLK",
        "",
        4, // Width in bytes
        0x000006e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_clk
    },
    {
        "SW_PAD_CTL_PAD_NANDF_D0",
        "",
        4, // Width in bytes
        0x000006e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_d0
    },
    {
        "SW_PAD_CTL_PAD_NANDF_D1",
        "",
        4, // Width in bytes
        0x000006e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_d1
    },
    {
        "SW_PAD_CTL_PAD_NANDF_D2",
        "",
        4, // Width in bytes
        0x000006ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_d2
    },
    {
        "SW_PAD_CTL_PAD_NANDF_D3",
        "",
        4, // Width in bytes
        0x000006f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_d3
    },
    {
        "SW_PAD_CTL_PAD_NANDF_D4",
        "",
        4, // Width in bytes
        0x000006f4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_d4
    },
    {
        "SW_PAD_CTL_PAD_NANDF_D5",
        "",
        4, // Width in bytes
        0x000006f8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_d5
    },
    {
        "SW_PAD_CTL_PAD_NANDF_D6",
        "",
        4, // Width in bytes
        0x000006fc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_d6
    },
    {
        "SW_PAD_CTL_PAD_NANDF_D7",
        "",
        4, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nandf_d7
    },
    {
        "SW_PAD_CTL_PAD_SD4_DAT0",
        "",
        4, // Width in bytes
        0x00000704, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_dat0
    },
    {
        "SW_PAD_CTL_PAD_SD4_DAT1",
        "",
        4, // Width in bytes
        0x00000708, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_dat1
    },
    {
        "SW_PAD_CTL_PAD_SD4_DAT2",
        "",
        4, // Width in bytes
        0x0000070c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_dat2
    },
    {
        "SW_PAD_CTL_PAD_SD4_DAT3",
        "",
        4, // Width in bytes
        0x00000710, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_dat3
    },
    {
        "SW_PAD_CTL_PAD_SD4_DAT4",
        "",
        4, // Width in bytes
        0x00000714, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_dat4
    },
    {
        "SW_PAD_CTL_PAD_SD4_DAT5",
        "",
        4, // Width in bytes
        0x00000718, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_dat5
    },
    {
        "SW_PAD_CTL_PAD_SD4_DAT6",
        "",
        4, // Width in bytes
        0x0000071c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_dat6
    },
    {
        "SW_PAD_CTL_PAD_SD4_DAT7",
        "",
        4, // Width in bytes
        0x00000720, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_dat7
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT1",
        "",
        4, // Width in bytes
        0x00000724, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat1
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT0",
        "",
        4, // Width in bytes
        0x00000728, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat0
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT3",
        "",
        4, // Width in bytes
        0x0000072c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat3
    },
    {
        "SW_PAD_CTL_PAD_SD1_CMD",
        "",
        4, // Width in bytes
        0x00000730, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT2",
        "",
        4, // Width in bytes
        0x00000734, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat2
    },
    {
        "SW_PAD_CTL_PAD_SD1_CLK",
        "",
        4, // Width in bytes
        0x00000738, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_clk
    },
    {
        "SW_PAD_CTL_PAD_SD2_CLK",
        "",
        4, // Width in bytes
        0x0000073c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_clk
    },
    {
        "SW_PAD_CTL_PAD_SD2_CMD",
        "",
        4, // Width in bytes
        0x00000740, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT3",
        "",
        4, // Width in bytes
        0x00000744, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat3
    },
    {
        "SW_PAD_CTL_GRP_B7DS",
        "",
        4, // Width in bytes
        0x00000748, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b7ds
    },
    {
        "SW_PAD_CTL_GRP_ADDDS",
        "",
        4, // Width in bytes
        0x0000074c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_addds
    },
    {
        "SW_PAD_CTL_GRP_DDRMODE_CTL",
        "",
        4, // Width in bytes
        0x00000750, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrmode_ctl
    },
    {
        "SW_PAD_CTL_GRP_TERM_CTL0",
        "",
        4, // Width in bytes
        0x00000754, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_term_ctl0
    },
    {
        "SW_PAD_CTL_GRP_DDRPKE",
        "",
        4, // Width in bytes
        0x00000758, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrpke
    },
    {
        "SW_PAD_CTL_GRP_TERM_CTL1",
        "",
        4, // Width in bytes
        0x0000075c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_term_ctl1
    },
    {
        "SW_PAD_CTL_GRP_TERM_CTL2",
        "",
        4, // Width in bytes
        0x00000760, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_term_ctl2
    },
    {
        "SW_PAD_CTL_GRP_TERM_CTL3",
        "",
        4, // Width in bytes
        0x00000764, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_term_ctl3
    },
    {
        "SW_PAD_CTL_GRP_DDRPK",
        "",
        4, // Width in bytes
        0x00000768, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrpk
    },
    {
        "SW_PAD_CTL_GRP_TERM_CTL4",
        "",
        4, // Width in bytes
        0x0000076c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_term_ctl4
    },
    {
        "SW_PAD_CTL_GRP_DDRHYS",
        "",
        4, // Width in bytes
        0x00000770, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrhys
    },
    {
        "SW_PAD_CTL_GRP_DDRMODE",
        "",
        4, // Width in bytes
        0x00000774, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrmode
    },
    {
        "SW_PAD_CTL_GRP_TERM_CTL5",
        "",
        4, // Width in bytes
        0x00000778, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_term_ctl5
    },
    {
        "SW_PAD_CTL_GRP_TERM_CTL6",
        "",
        4, // Width in bytes
        0x0000077c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_term_ctl6
    },
    {
        "SW_PAD_CTL_GRP_TERM_CTL7",
        "",
        4, // Width in bytes
        0x00000780, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_term_ctl7
    },
    {
        "SW_PAD_CTL_GRP_B0DS",
        "",
        4, // Width in bytes
        0x00000784, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b0ds
    },
    {
        "SW_PAD_CTL_GRP_B1DS",
        "",
        4, // Width in bytes
        0x00000788, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b1ds
    },
    {
        "SW_PAD_CTL_GRP_CTLDS",
        "",
        4, // Width in bytes
        0x0000078c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ctlds
    },
    {
        "SW_PAD_CTL_GRP_DDR_TYPE_RGMII",
        "",
        4, // Width in bytes
        0x00000790, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddr_type_rgmii
    },
    {
        "SW_PAD_CTL_GRP_B2DS",
        "",
        4, // Width in bytes
        0x00000794, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b2ds
    },
    {
        "SW_PAD_CTL_GRP_DDR_TYPE",
        "",
        4, // Width in bytes
        0x00000798, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddr_type
    },
    {
        "SW_PAD_CTL_GRP_B3DS",
        "",
        4, // Width in bytes
        0x0000079c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b3ds
    },
    {
        "SW_PAD_CTL_GRP_B4DS",
        "",
        4, // Width in bytes
        0x000007a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b4ds
    },
    {
        "SW_PAD_CTL_GRP_B5DS",
        "",
        4, // Width in bytes
        0x000007a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b5ds
    },
    {
        "SW_PAD_CTL_GRP_B6DS",
        "",
        4, // Width in bytes
        0x000007a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b6ds
    },
    {
        "SW_PAD_CTL_GRP_RGMII_TERM",
        "",
        4, // Width in bytes
        0x000007ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_rgmii_term
    },
    {
        "ASRC_ASRCK_CLOCK_6_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_asrc_asrck_clock_6_select_input
    },
    {
        "AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_da_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_db_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_txfs_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_da_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_db_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_txfs_amx_select_input
    },
    {
        "CAN1_IPP_IND_CANRX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_can1_ipp_ind_canrx_select_input
    },
    {
        "CAN2_IPP_IND_CANRX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_can2_ipp_ind_canrx_select_input
    },
    {
        "CCM_IPP_DI1_CLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ccm_ipp_di1_clk_select_input
    },
    {
        "CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ccm_pmic_vfuncional_ready_select_input
    },
    {
        "ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI1_IPP_IND_MISO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_miso_select_input
    },
    {
        "ECSPI1_IPP_IND_MOSI_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_mosi_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_0_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_1_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_2_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_3_select_input
    },
    {
        "ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI2_IPP_IND_MISO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_miso_select_input
    },
    {
        "ECSPI2_IPP_IND_MOSI_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_mosi_select_input
    },
    {
        "ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_ss_b_0_select_input
    },
    {
        "ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_ss_b_1_select_input
    },
    {
        "ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_ss_b_0_select_input
    },
    {
        "ECSPI5_IPP_CSPI_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000828, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI5_IPP_IND_MISO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000082c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_ind_miso_select_input
    },
    {
        "ECSPI5_IPP_IND_MOSI_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_ind_mosi_select_input
    },
    {
        "ECSPI5_IPP_IND_SS_B_0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000834, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_ind_ss_b_0_select_input
    },
    {
        "ECSPI5_IPP_IND_SS_B_1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000838, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_ind_ss_b_1_select_input
    },
    {
        "ENET_IPG_CLK_RMII_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet_ipg_clk_rmii_select_input
    },
    {
        "ENET_IPP_IND_MAC0_MDIO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet_ipp_ind_mac0_mdio_select_input
    },
    {
        "ENET_IPP_IND_MAC0_RXCLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet_ipp_ind_mac0_rxclk_select_input
    },
    {
        "ENET_IPP_IND_MAC0_RXDATA_0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet_ipp_ind_mac0_rxdata_0_select_input
    },
    {
        "ENET_IPP_IND_MAC0_RXDATA_1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet_ipp_ind_mac0_rxdata_1_select_input
    },
    {
        "ENET_IPP_IND_MAC0_RXDATA_2_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet_ipp_ind_mac0_rxdata_2_select_input
    },
    {
        "ENET_IPP_IND_MAC0_RXDATA_3_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet_ipp_ind_mac0_rxdata_3_select_input
    },
    {
        "ENET_IPP_IND_MAC0_RXEN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet_ipp_ind_mac0_rxen_select_input
    },
    {
        "ESAI_IPP_IND_FSR_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_fsr_select_input
    },
    {
        "ESAI_IPP_IND_FST_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_fst_select_input
    },
    {
        "ESAI_IPP_IND_HCKR_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_hckr_select_input
    },
    {
        "ESAI_IPP_IND_HCKT_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_hckt_select_input
    },
    {
        "ESAI_IPP_IND_SCKR_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000086c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sckr_select_input
    },
    {
        "ESAI_IPP_IND_SCKT_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sckt_select_input
    },
    {
        "ESAI_IPP_IND_SDO0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000874, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo0_select_input
    },
    {
        "ESAI_IPP_IND_SDO1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000878, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo1_select_input
    },
    {
        "ESAI_IPP_IND_SDO2_SDI3_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000087c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo2_sdi3_select_input
    },
    {
        "ESAI_IPP_IND_SDO3_SDI2_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo3_sdi2_select_input
    },
    {
        "ESAI_IPP_IND_SDO4_SDI1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000884, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo4_sdi1_select_input
    },
    {
        "ESAI_IPP_IND_SDO5_SDI0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000888, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo5_sdi0_select_input
    },
    {
        "HDMI_TX_ICECIN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000088c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_hdmi_tx_icecin_select_input
    },
    {
        "HDMI_TX_II2C_MSTH13TDDC_SCLIN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_hdmi_tx_ii2c_msth13tddc_sclin_select_input
    },
    {
        "HDMI_TX_II2C_MSTH13TDDC_SDAIN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000894, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_hdmi_tx_ii2c_msth13tddc_sdain_select_input
    },
    {
        "I2C1_IPP_SCL_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000898, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c1_ipp_scl_in_select_input
    },
    {
        "I2C1_IPP_SDA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000089c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c1_ipp_sda_in_select_input
    },
    {
        "I2C2_IPP_SCL_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c2_ipp_scl_in_select_input
    },
    {
        "I2C2_IPP_SDA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c2_ipp_sda_in_select_input
    },
    {
        "I2C3_IPP_SCL_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c3_ipp_scl_in_select_input
    },
    {
        "I2C3_IPP_SDA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c3_ipp_sda_in_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_10_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_10_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_11_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_11_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_12_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_12_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_13_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_13_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_14_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_14_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_15_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_15_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_16_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_16_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_17_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_17_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_18_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_18_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_19_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_19_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_DATA_EN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_data_en_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_HSYNC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_hsync_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_PIX_CLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_pix_clk_select_input
    },
    {
        "IPU2_IPP_IND_SENS1_VSYNC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ipu2_ipp_ind_sens1_vsync_select_input
    },
    {
        "KPP_IPP_IND_COL_5_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_5_select_input
    },
    {
        "KPP_IPP_IND_COL_6_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_6_select_input
    },
    {
        "KPP_IPP_IND_COL_7_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_7_select_input
    },
    {
        "KPP_IPP_IND_ROW_5_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_5_select_input
    },
    {
        "KPP_IPP_IND_ROW_6_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_6_select_input
    },
    {
        "KPP_IPP_IND_ROW_7_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000008fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_7_select_input
    },
    {
        "MLB_MLB_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000900, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_mlb_mlb_clk_in_select_input
    },
    {
        "MLB_MLB_DATA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000904, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_mlb_mlb_data_in_select_input
    },
    {
        "MLB_MLB_SIG_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000908, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_mlb_mlb_sig_in_select_input
    },
    {
        "SPDIF_SPDIF_IN1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000914, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_spdif_spdif_in1_select_input
    },
    {
        "SPDIF_TX_CLK2_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000918, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_spdif_tx_clk2_select_input
    },
    {
        "UART1_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000091c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart1_ipp_uart_rts_b_select_input
    },
    {
        "UART1_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000920, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart1_ipp_uart_rxd_mux_select_input
    },
    {
        "UART2_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000924, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart2_ipp_uart_rts_b_select_input
    },
    {
        "UART2_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000928, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart2_ipp_uart_rxd_mux_select_input
    },
    {
        "UART3_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000092c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart3_ipp_uart_rts_b_select_input
    },
    {
        "UART3_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000930, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart3_ipp_uart_rxd_mux_select_input
    },
    {
        "UART4_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000934, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart4_ipp_uart_rts_b_select_input
    },
    {
        "UART4_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000938, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart4_ipp_uart_rxd_mux_select_input
    },
    {
        "UART5_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000093c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart5_ipp_uart_rts_b_select_input
    },
    {
        "UART5_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000940, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart5_ipp_uart_rxd_mux_select_input
    },
    {
        "USB_IPP_IND_OTG_OC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000944, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_ipp_ind_otg_oc_select_input
    },
    {
        "USB_IPP_IND_H1_OC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000948, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_ipp_ind_h1_oc_select_input
    },
    {
        "USDHC1_IPP_WP_ON_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000094c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc1_ipp_wp_on_select_input
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IPU
#endif

// Bitfields in register IPU_CONF.
static const field_t hw_ipu_conf[] =
{
    {
        "CSI0_EN",
        "Camera Sensor Interface 0 Enable bit",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_EN",
        "Camera Sensor Interface 1 Enable bit",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_EN",
        "Image Conversion Sub-Block Enable bit",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRT_EN",
        "Image Rotation Sub-Block Enable bit",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_EN",
        "Display processor Sub-block Enable bit",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_EN",
        "Display interface Sub-block 0 Enable bit",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_EN",
        "Display Interface Sub-block 1 Enable bit",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC_EN",
        "Sensor's Multi FIFO Controller Sub-block (SMFC) Enable bit",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_EN",
        "Display Controller sub-block (DC) Enable bit",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_EN",
        "Display's Multi FIFO Controller sub-block (DMFC) Enable bit",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SISG_EN",
        "Still Image Synchronization Generator (SISG) Enable bit",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_EN",
        "VDI enable bit.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_DIAGBUS_MODE",
        "IPU diagnostic bus mode.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_DIAGBUS_ON",
        "IPU Diagnostics bus on  This bit is connected to the IPU's output.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_DISABLE",
        "Image DMA controller (IDMAC) disable bit.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_DMFC_SEL",
        "IC to DMFC select  Selects the DMAIC_1 (channel 21) channel's connecti"
        "vity between the IC and the DMFC",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_DMFC_SYNC",
        "IC to DMFC Sync flow  This bit defines if the direct flow between IC t"
        "o DMFC is synchronous or asynchronous",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_DMFC_SYNC",
        "This bit enables the direct path VDI C -> IC_VF -> DMFC for sync flow.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_DATA_SOURCE",
        "CSI0 data Source  This bit selects what is the data source for the CSI"
        "0.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_DATA_SOURCE",
        "CSI1 data Source  This bit selects what is the data source for the CSI"
        "1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_INPUT",
        "IC Input select bit.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SEL",
        "CSI select bit; This bit selects manually between the 2 CSI's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SISG_CTRL0.
static const field_t hw_ipu_sisg_ctrl0[] =
{
    {
        "VSYNC_RST_CNT",
        "VSYNC Resets counters  Defines if the counters are stooped following V"
        "SYNC or when the counters reach a pre defined value (VAL_STOP_SISG_COU"
        "NTER)",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NO_VSYNC_2_STRT_CNT",
        "VSYCs to Start Counter  This bits define how many VSYNCs signals will "
        "be counter before activating the SISG counters.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VAL_STOP_SISG_COUNTER",
        "SISG Stop Counters value.",
        4, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_ACTV_TRIG",
        "Reserved, should be cleared.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXT_ACTV",
        "External Active  Define if an external active trigger will start the c"
        "ounters.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SISG_CTRL1.
static const field_t hw_ipu_sisg_ctrl1[] =
{
    {
        "SISG_STROBE_CNT",
        "SISG Strobe Count  The SISG can repeat the sequence for up to 32 cycle"
        "s; this is used for generating a train of pulses.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SISG_OUT_POL",
        "SISG_OUT_POL  This bits defines the polarity of the SISG output signal"
        "s",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SISG_SET_I.
static const field_t hw_ipu_sisg_set_i[] =
{
    {
        "SISG_SET",
        "SISG SET <i> value  These bits define the set value of the SISG counte"
        "r #<i>",
        0, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SISG_CLR_I.
static const field_t hw_ipu_sisg_clr_i[] =
{
    {
        "SISG_CLEAR",
        "SISG CLR <i> value  These bits define the clear value of the SISG coun"
        "ter #<i>",
        0, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_1.
static const field_t hw_ipu_int_ctrl_1[] =
{
    {
        "IDMAC_EOF_EN_0",
        "Enable End of Frame of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_1",
        "Enable End of Frame of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_2",
        "Enable End of Frame of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_3",
        "Enable End of Frame of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_5",
        "Enable End of Frame of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_8",
        "Enable End of Frame of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_9",
        "Enable End of Frame of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_10",
        "Enable End of Frame of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_11",
        "Enable End of Frame of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_12",
        "Enable End of Frame of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_13",
        "Enable End of Frame of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_14",
        "Enable End of Frame of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_15",
        "Enable End of Frame of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_17",
        "Enable End of Frame of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_18",
        "Enable End of Frame of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_19",
        "Enable End of Frame of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_20",
        "Enable End of Frame of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_21",
        "Enable End of Frame of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_22",
        "Enable End of Frame of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_23",
        "Enable End of Frame of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_24",
        "Enable End of Frame of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_25",
        "Enable End of Frame of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_26",
        "Enable End of Frame of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_27",
        "Enable End of Frame of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_28",
        "Enable End of Frame of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_29",
        "Enable End of Frame of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_31",
        "Enable End of Frame of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_2.
static const field_t hw_ipu_int_ctrl_2[] =
{
    {
        "IDMAC_EOF_EN_33",
        "Enable End of Frame of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_40",
        "Enable End of Frame of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_41",
        "Enable End of Frame of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_42",
        "Enable End of Frame of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_43",
        "Enable End of Frame of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_44",
        "Enable End of Frame of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_45",
        "Enable End of Frame of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_46",
        "Enable End of Frame of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_47",
        "Enable End of Frame of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_48",
        "Enable End of Frame of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_49",
        "Enable End of Frame of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_50",
        "Enable End of Frame of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_51",
        "Enable End of Frame of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_EN_52",
        "Enable End of Frame of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_3.
static const field_t hw_ipu_int_ctrl_3[] =
{
    {
        "IDMAC_NFACK_EN_0",
        "Enable New Frame Ack of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_1",
        "Enable New Frame Ack of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_2",
        "Enable New Frame Ack of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_3",
        "Enable New Frame Ack of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_5",
        "Enable New Frame Ack of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_8",
        "Enable New Frame Ack of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_9",
        "Enable New Frame Ack of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_10",
        "Enable New Frame Ack of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_11",
        "Enable New Frame Ack of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_12",
        "Enable New Frame Ack of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_13",
        "Enable New Frame Ack of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_14",
        "Enable New Frame Ack of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_15",
        "Enable New Frame Ack of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_17",
        "Enable New Frame Ack of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_18",
        "Enable New Frame Ack of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_19",
        "Enable New Frame Ack of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_20",
        "Enable New Frame Ack of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_21",
        "Enable New Frame Ack of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_22",
        "Enable New Frame Ack of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_23",
        "Enable New Frame Ack of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_24",
        "Enable New Frame Ack of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_25",
        "Enable New Frame Ack of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_26",
        "Enable New Frame Ack of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_27",
        "Enable New Frame Ack of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_28",
        "Enable New Frame Ack of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_29",
        "Enable New Frame Ack of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_31",
        "Enable New Frame Ack of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_4.
static const field_t hw_ipu_int_ctrl_4[] =
{
    {
        "IDMAC_NFACK_EN_33",
        "Enable New Frame Ack of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_40",
        "Enable New Frame Ack of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_41",
        "Enable New Frame Ack of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_42",
        "Enable New Frame Ack of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_43",
        "Enable New Frame Ack of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_44",
        "Enable New Frame Ack of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_45",
        "Enable New Frame Ack of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_46",
        "Enable New Frame Ack of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_47",
        "Enable New Frame Ack of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_48",
        "Enable New Frame Ack of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_49",
        "Enable New Frame Ack of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_50",
        "Enable New Frame Ack of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_51",
        "Enable New Frame Ack of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_EN_52",
        "Enable New Frame Ack of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_5.
static const field_t hw_ipu_int_ctrl_5[] =
{
    {
        "IDMAC_NFB4EOF_EN_0",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_1",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_2",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_3",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_5",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_8",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_9",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_10",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_11",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_12",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_13",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_14",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_15",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_17",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_18",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_19",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_20",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_21",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_22",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_23",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_24",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_25",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_26",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_27",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_28",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_29",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_31",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_6.
static const field_t hw_ipu_int_ctrl_6[] =
{
    {
        "IDMAC_NFB4EOF_EN_33",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_40",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_41",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_42",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_43",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_44",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_45",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_46",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_47",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_48",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_49",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_50",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_51",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_EN_52",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_7.
static const field_t hw_ipu_int_ctrl_7[] =
{
    {
        "IDMAC_EOS_EN_19",
        "End of Scroll indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_23",
        "End of Scroll indication of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_24",
        "End of Scroll indication of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_25",
        "End of Scroll indication of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_26",
        "End of Scroll indication of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_27",
        "End of Scroll indication of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_28",
        "End of Scroll indication of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_29",
        "End of Scroll indication of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_31",
        "End of Scroll indication of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_8.
static const field_t hw_ipu_int_ctrl_8[] =
{
    {
        "IDMAC_EOS_EN_33",
        "End of Scroll of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_41",
        "End of Scroll of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_42",
        "End of Scroll of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_43",
        "End of Scroll of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_44",
        "End of Scroll of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_51",
        "End of Scroll of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_52",
        "End of Scroll of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_9.
static const field_t hw_ipu_int_ctrl_9[] =
{
    {
        "VDI_FIFO1_OVF_EN",
        "FIFO1 overflow Interrupt1 Enable  The VDI C generates FIFO1 overflow i"
        "nterrupt1 when the write pointer of FIFO1 overruns read pointer.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_BAYER_BUF_OVF_EN",
        "This bit enables an interrupt that is a result of the IC Buffer overfl"
        "ow for bayer coming from the IC.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_ENC_BUF_OVF_EN",
        "This bit enables an interrupt that is a result of the IC Buffer overfl"
        "ow for encoding coming from the IC.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_VF_BUF_OVF_EN",
        "This bit enables an interrupt that is a result of the IC Buffer overfl"
        "ow for view finder coming from the IC.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_PUPE_EN",
        "CSI0_PUPE_EN - CSI0 parameters update error interrupt enable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_PUPE_EN",
        "CSI1_PUPE_EN - CSI1 parameters update error interrupt enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_10.
static const field_t hw_ipu_int_ctrl_10[] =
{
    {
        "SMFC0_FRM_LOST_EN",
        "Frame Lost of SMFC channel 0 interrupt enable bit  This bit enables an"
        " interrupt that is a result of a Frame Lost of SMFC channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC1_FRM_LOST_EN",
        "Frame Lost of SMFC channel 1 interrupt enable bit  This bit enables an"
        " interrupt that is a result of a Frame Lost of SMFC channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC2_FRM_LOST_EN",
        "Frame Lost of SMFC channel 2 interrupt enable bit  This bit enables an"
        " interrupt that is a result of a Frame Lost of SMFC channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC3_FRM_LOST_EN",
        "Frame Lost of SMFC channel 3 interrupt enable bit  This bit enables an"
        " interrupt that is a result of a Frame Lost of SMFC channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_TEARING_ERR_1_EN",
        "Tearing Error #1 enable  This bit enables the interrupt that is a resu"
        "lt of tearing error while the anti tearing mechanism is activated for "
        "DC channel 1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_TEARING_ERR_2_EN",
        "Tearing Error #2 enable  This bit enables the interrupt that is a resu"
        "lt of tearing error while the anti tearing mechanism is activated for "
        "DC channel 2",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_TEARING_ERR_6_EN",
        "Tearing Error #6 enable  This bit enables the interrupt that is a resu"
        "lt of tearing error while the anti tearing mechanism is activated for "
        "DC channel 6",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SYNC_DISP_ERR_EN",
        "DI0 Synchronous display error enable  This bit enables the interrupt t"
        "hat is a result of an error during access to a synchronous display via"
        " DI0",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SYNC_DISP_ERR_EN",
        "DI1 Synchronous display error enable  This bit enables the interrupt t"
        "hat is a result of an error during access to a synchronous display via"
        " DI1",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_TIME_OUT_ERR_EN",
        "DI0 time outwore interrupt enable  This bit enables the interrupt that"
        " is a result of a time out error during a read access via DI0",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_TIME_OUT_ERR_EN",
        "DI1 time out error interrupt enable  This bit enables the interrupt th"
        "at is a result of a time out error during a read access via DI1",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_VF_FRM_LOST_ERR_EN",
        "This bit enables an interrupt that is a result of IC's view finder fra"
        "me lost.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_ENC_FRM_LOST_ERR_EN",
        "This bit enables an interrupt that is a result of IC's encoding frame "
        "lost.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_BAYER_FRM_LOST_ERR_EN",
        "This bit enables an interrupt that is a result of IC's Bayer frame los"
        "t.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_PRIVILEGED_ACC_ERR_EN",
        "Non Privileged Access Error interrupt enable.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXIW_ERR_EN",
        "This bit enables an interrupt that is a result of AXI write access res"
        "ulted with error response.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXIR_ERR_EN",
        "This bit enables an interrupt that is a result of AXI read access resu"
        "lted with error response.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_11.
static const field_t hw_ipu_int_ctrl_11[] =
{
    {
        "IDMAC_EOBND_EN_0",
        "end-of-band indication of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_1",
        "end-of-band indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_2",
        "end-of-band indication of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_3",
        "end-of-band indication of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_5",
        "end-of-band indication of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_11",
        "end-of-band indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_12",
        "end-of-band indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_20",
        "end-of-band indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_21",
        "end-of-band indication of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_22",
        "end-of-band indication of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_25",
        "end-of-band indication of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_26",
        "end-of-band indication of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_12.
static const field_t hw_ipu_int_ctrl_12[] =
{
    {
        "IDMAC_EOBND_EN_45",
        "end-of-band indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_46",
        "end-of-band indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_47",
        "end-of-band indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_48",
        "end-of-band indication of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_49",
        "end-of-band indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_50",
        "end-of-band indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_13.
static const field_t hw_ipu_int_ctrl_13[] =
{
    {
        "IDMAC_TH_EN_0",
        "Threshold crossing indication of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_1",
        "Threshold crossing indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_2",
        "Threshold crossing indication of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_3",
        "Threshold crossing indication of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_5",
        "Threshold crossing indication of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_8",
        "Threshold crossing indication of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_9",
        "Threshold crossing indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_10",
        "Threshold crossing indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_11",
        "Threshold crossing indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_12",
        "Threshold crossing indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_13",
        "Threshold crossing indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_14",
        "Threshold crossing indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_15",
        "Threshold crossing indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_17",
        "Threshold crossing indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_18",
        "Threshold crossing indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_19",
        "Threshold crossing indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_20",
        "Threshold crossing indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_21",
        "Threshold crossing indication of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_22",
        "Threshold crossing indication of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_23",
        "Threshold crossing indication of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_24",
        "Threshold crossing indication of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_25",
        "Threshold crossing indication of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_26",
        "Threshold crossing indication of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_27",
        "Threshold crossing indication of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_28",
        "Threshold crossing indication of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_29",
        "Threshold crossing indication of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_31",
        "Threshold crossing indication of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_14.
static const field_t hw_ipu_int_ctrl_14[] =
{
    {
        "IDMAC_TH_EN_33",
        "Threshold crossing indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_40",
        "Threshold crossing indication of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_41",
        "Threshold crossing indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_42",
        "Threshold crossing indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_43",
        "Threshold crossing indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_44",
        "Threshold crossing indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_45",
        "Threshold crossing indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_46",
        "Threshold crossing indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_47",
        "Threshold crossing indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_48",
        "Threshold crossing indication of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_49",
        "Threshold crossing indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_50",
        "Threshold crossing indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_51",
        "Threshold crossing indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_EN_52",
        "Threshold crossing indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_CTRL_15.
static const field_t hw_ipu_int_ctrl_15[] =
{
    {
        "SNOOPING1_INT_EN",
        "IPU snooping 1 interrupt enable bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNOOPING2_INT_EN",
        "IPU snooping 2 interrupt enable bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_SF_START_EN",
        "DP Sync Flow Start enable bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_SF_END_EN",
        "DP Sync Flow End enable bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASF_START_EN",
        "DP Async Flow Start enable bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASF_END_EN",
        "DP Async Flow End enable bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_SF_BRAKE_EN",
        "DP Sync Flow Brake enable bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASF_BRAKE_EN",
        "DP Async Flow Brake enable bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_0_EN",
        "This bit enables they'd Frame Complete on channel #0 interrupt",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_1_EN",
        "This bit enables they'd Frame Complete on channel #1 interrupt",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_2_EN",
        "This bit enables the DC Frame Complete on channel #2 interrupt",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_3_EN",
        "This bit enables the DC Frame Complete on channel #3 interrupt",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_4_EN",
        "This bit enables the DC Frame Complete on channel #4 interrupt",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_6_EN",
        "This bit enables the DC Frame Complete on channel #6 interrupt",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI_VSYNC_PRE_0_EN",
        "This bit enables the DI0 interrupt indicating of a VSYNC signal assert"
        "ed 2 rows before the VSYNC sent to the display",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI_VSYNC_PRE_1_EN",
        "This bit enables the DI1 interrupt indicating of a VSYNC signal assert"
        "ed 2 rows before the VSYNC sent to the display",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_DP_START_EN",
        "This bit enables the interrupt asserted anytime the DP start a new syn"
        "c or async flow or when an async flow is interrupted by a sync flow",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_ASYNC_STOP_EN",
        "This bit enables the interrupt asserted anytime the DP stops an async "
        "flow and moves to a sync flow",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_0_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #0 of DI0",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_1_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #1 of DI0",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_2_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #2 of DI0",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_3_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #3 of DI0",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_4_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #4 of DI0",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_5_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #5 of DI0",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_6_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #6 of DI0",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_7_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #7 of DI0",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_8_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #8 of DI0",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_9_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #9 of DI0",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_10_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #10 of DI0",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DISP_CLK_EN_PRE_EN",
        "DI1_DISP_CLK_EN_PRE_EN",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_EN_PRE_3_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #3 of DI1",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_EN_PRE_8_EN",
        "This bit enables the interrupt that is a result of a trigger generated"
        " by counter #8 of DI1",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_1.
static const field_t hw_ipu_sdma_event_1[] =
{
    {
        "IDMAC_EOF_SDMA_EN_0",
        "Enable End of Frame of Channel SDMA event.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_1",
        "Enable End of Frame of Channel SDMA event.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_2",
        "Enable End of Frame of Channel SDMA event.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_3",
        "Enable End of Frame of Channel SDMA event.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_5",
        "Enable End of Frame of Channel SDMA event.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_8",
        "Enable End of Frame of Channel SDMA event.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_9",
        "Enable End of Frame of Channel SDMA event.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_10",
        "Enable End of Frame of Channel SDMA event.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_11",
        "Enable End of Frame of Channel SDMA event.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_12",
        "Enable End of Frame of Channel SDMA event.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_13",
        "Enable End of Frame of Channel SDMA event.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_14",
        "Enable End of Frame of Channel SDMA event.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_15",
        "Enable End of Frame of Channel SDMA event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_17",
        "Enable End of Frame of Channel SDMA event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_18",
        "Enable End of Frame of Channel SDMA event.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_19",
        "Enable End of Frame of Channel SDMA event.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_20",
        "Enable End of Frame of Channel SDMA event.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_21",
        "Enable End of Frame of Channel SDMA event.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_22",
        "Enable End of Frame of Channel SDMA event.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_23",
        "Enable End of Frame of Channel SDMA event.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_24",
        "Enable End of Frame of Channel SDMA event.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_25",
        "Enable End of Frame of Channel SDMA event.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_26",
        "Enable End of Frame of Channel SDMA event.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_27",
        "Enable End of Frame of Channel SDMA event.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_28",
        "Enable End of Frame of Channel SDMA event.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_29",
        "Enable End of Frame of Channel SDMA event.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_31",
        "Enable End of Frame of Channel SDMA event.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_2.
static const field_t hw_ipu_sdma_event_2[] =
{
    {
        "IDMAC_EOF_SDMA_EN_33",
        "Enable End of Frame of Channel SDMA event.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_40",
        "Enable End of Frame of Channel SDMA event.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_41",
        "Enable End of Frame of Channel SDMA event.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_42",
        "Enable End of Frame of Channel SDMA event.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_43",
        "Enable End of Frame of Channel SDMA event.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_44",
        "Enable End of Frame of Channel SDMA event.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_45",
        "Enable End of Frame of Channel SDMA event.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_46",
        "Enable End of Frame of Channel SDMA event.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_47",
        "Enable End of Frame of Channel SDMA event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_48",
        "Enable End of Frame of Channel SDMA event.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_49",
        "Enable End of Frame of Channel SDMA event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_50",
        "Enable End of Frame of Channel SDMA event.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_51",
        "Enable End of Frame of Channel SDMA event.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_SDMA_EN_52",
        "Enable End of Frame of Channel SDMA event.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_3.
static const field_t hw_ipu_sdma_event_3[] =
{
    {
        "IDMAC_NFACK_SDMA_EN_0",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_1",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_2",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_3",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_5",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_8",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_9",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_10",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_11",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_12",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_13",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_14",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_15",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_17",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_18",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_19",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_20",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_21",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_22",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_23",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_24",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_25",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_26",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_27",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_28",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_29",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_31",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_4.
static const field_t hw_ipu_sdma_event_4[] =
{
    {
        "IDMAC_NFACK_SDMA_EN_33",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_40",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_41",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_42",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_43",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_44",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_45",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_46",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_47",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_48",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_49",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_50",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_51",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_SDMA_EN_52",
        "Enable New Frame Acknowledge of Channel SDMA event.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_7.
static const field_t hw_ipu_sdma_event_7[] =
{
    {
        "IDMAC_EOS_SDMA_EN_19",
        "Enable End of Scroll of Channel SDMA event.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_23",
        "Enable End of Scroll of Channel SDMA event.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_24",
        "Enable End of Scroll of Channel SDMA event.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_25",
        "Enable End of Scroll of Channel SDMA event.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_26",
        "Enable End of Scroll of Channel SDMA event.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_27",
        "Enable End of Scroll of Channel SDMA event.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_28",
        "Enable End of Scroll of Channel SDMA event.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_29",
        "Enable End of Scroll of Channel SDMA event.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_31",
        "Enable End of Scroll of Channel SDMA event.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_8.
static const field_t hw_ipu_sdma_event_8[] =
{
    {
        "IDMAC_EOS_SDMA_EN_33",
        "Enable End of Scroll of Channel SDMA event.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_41",
        "Enable End of Scroll of Channel SDMA event.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_42",
        "Enable End of Scroll of Channel SDMA event.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_43",
        "Enable End of Scroll of Channel SDMA event.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_44",
        "Enable End of Scroll of Channel SDMA event.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_51",
        "Enable End of Scroll of Channel SDMA event.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_SDMA_EN_52",
        "Enable End of Scroll of Channel SDMA event.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_11.
static const field_t hw_ipu_sdma_event_11[] =
{
    {
        "IDMAC_EOBND_SDMA_EN_0",
        "Enable End of Band of Channel SDMA event.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_1",
        "Enable End of Band of Channel SDMA event.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_2",
        "Enable End of Band of Channel SDMA event.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_3",
        "Enable End of Band of Channel SDMA event.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_5",
        "Enable End of Band of Channel SDMA event.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_11",
        "Enable End of Band of Channel SDMA event.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_12",
        "Enable End of Band of Channel SDMA event.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_20",
        "Enable End of Band of Channel SDMA event.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_21",
        "Enable End of Band of Channel SDMA event.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_22",
        "Enable End of Band of Channel SDMA event.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_25",
        "Enable End of Band of Channel SDMA event.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_26",
        "Enable End of Band of Channel SDMA event.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_12.
static const field_t hw_ipu_sdma_event_12[] =
{
    {
        "IDMAC_EOBND_SDMA_EN_45",
        "Enable End of Band of Channel SDMA event.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_46",
        "Enable End of Band of Channel SDMA event.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_47",
        "Enable End of Band of Channel SDMA event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_48",
        "Enable End of Band of Channel SDMA event.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_49",
        "Enable End of Band of Channel SDMA event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_SDMA_EN_50",
        "Enable End of Band of Channel SDMA event.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_13.
static const field_t hw_ipu_sdma_event_13[] =
{
    {
        "IDMAC_TH_SDMA_EN_0",
        "Enable Threshold of Channel SDMA event.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_1",
        "Enable Threshold of Channel SDMA event.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_2",
        "Enable Threshold of Channel SDMA event.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_3",
        "Enable Threshold of Channel SDMA event.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_5",
        "Enable Threshold of Channel SDMA event.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_8",
        "Enable Threshold of Channel SDMA event.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_9",
        "Enable Threshold of Channel SDMA event.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_10",
        "Enable Threshold of Channel SDMA event.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_11",
        "Enable Threshold of Channel SDMA event.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_12",
        "Enable Threshold of Channel SDMA event.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_13",
        "Enable Threshold of Channel SDMA event.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_14",
        "Enable Threshold of Channel SDMA event.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_15",
        "Enable Threshold of Channel SDMA event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_17",
        "Enable Threshold of Channel SDMA event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_18",
        "Enable Threshold of Channel SDMA event.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_19",
        "Enable Threshold of Channel SDMA event.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_20",
        "Enable Threshold of Channel SDMA event.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_21",
        "Enable Threshold of Channel SDMA event.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_22",
        "Enable Threshold of Channel SDMA event.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_23",
        "Enable Threshold of Channel SDMA event.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_24",
        "Enable Threshold of Channel SDMA event.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_25",
        "Enable Threshold of Channel SDMA event.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_26",
        "Enable Threshold of Channel SDMA event.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_27",
        "Enable Threshold of Channel SDMA event.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_28",
        "Enable Threshold of Channel SDMA event.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_29",
        "Enable Threshold of Channel SDMA event.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_31",
        "Enable Threshold of Channel SDMA event.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SDMA_EVENT_14.
static const field_t hw_ipu_sdma_event_14[] =
{
    {
        "IDMAC_TH_SDMA_EN_33",
        "Threshold of Channel SDMA event.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_40",
        "Threshold of Channel SDMA event.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_41",
        "Threshold of Channel SDMA event.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_42",
        "Threshold of Channel SDMA event.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_43",
        "Threshold of Channel SDMA event.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_44",
        "Threshold of Channel SDMA event.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_45",
        "Threshold of Channel SDMA event.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_46",
        "Threshold of Channel SDMA event.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_47",
        "Threshold of Channel SDMA event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_48",
        "Threshold of Channel SDMA event.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_49",
        "Threshold of Channel SDMA event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_50",
        "Threshold of Channel SDMA event.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_51",
        "Threshold of Channel SDMA event.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_SDMA_EN_52",
        "Threshold of Channel SDMA event.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SRM_PRI1.
static const field_t hw_ipu_srm_pri1[] =
{
    {
        "CSI1_SRM_PRI",
        "CSI1 SRM priority  This bits define the priority of the CSI0 module",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SRM_MODE",
        "CSI1 SRM Mode  This field controls the SRM logic that handles the CSI1"
        " registers",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SRM_PRI",
        "CSI0 SRM priority  This bits define the priority of the CSI1 block",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SRM_MODE",
        "CSI0 SRM Mode  This field controls the SRM logic that handles the CSI0"
        " registers",
        11, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SRM_PRI2.
static const field_t hw_ipu_srm_pri2[] =
{
    {
        "DP_SRM_PRI",
        "DP SRM priority  This bits define the priority of the DP module",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_S_SRM_MODE",
        "DP sync flow SRM Mode  This field controls the SRM logic that handles "
        "the DP sync flow registers",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_A0_SRM_MODE",
        "DP Async flow #0 SRM Mode  This field controls the SRM logic that hand"
        "les the DP Async flow #0 registers",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_A1_SRM_MODE",
        "DP Async flow #1 SRM Mode  This field controls the SRM logic that hand"
        "les the DP Async flow #1 registers",
        7, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_SRM_PRI",
        "DC SRM priority  This bits define the priority of the DC module",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_2_SRM_MODE",
        "DC Group #2 SRM Mode  This field controls the SRM logic that handles t"
        "he DC Group #2 registers",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_6_SRM_MODE",
        "DC Group #6 SRM Mode  This field controls the SRM logic that handles t"
        "he DC Group #6 registers",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SRM_PRI",
        "DI0 SRM priority  This bits define the priority of the DI0 module",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SRM_MCU_USE",
        "DI0 SRM is used by ARM platform  This bit indicates that the registers"
        " of the DI0 are currently being updated by the ARM platform.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SRM_PRI",
        "DI1 SRM priority  This bits define the priority of the DI1 module",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SRM_MODE",
        "DCI1 SRM Mode  This field controls the SRM logic that handles the DI1 "
        "registers",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_FS_PROC_FLOW1.
static const field_t hw_ipu_fs_proc_flow1[] =
{
    {
        "PRPENC_ROT_SRC_SEL",
        "Source select for the encoding task of the IRT",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_ROT_SRC_SEL",
        "Source select for the view finder task of the IRT  0000 ARM platform",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_SRC_SEL",
        "Source select for the pre processing task of the IC",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_ROT_SRC_SEL",
        "Source select for the pre processing task of the IRT (CH 50)",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI1_SRC_SEL",
        "Source select for the VDIC plane #1 (IDMAC's CH26)  This field is rele"
        "vant only if the VDIC works in combining mode (VDI_CMB_EN bit is set)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI3_SRC_SEL",
        "Source select for the VDIC plane #3 (IDMAC's CH 25)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRP_SRC_SEL",
        "Source select for the Pre Processing Task  0000 ARM platform",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_SRC_SEL",
        "Source select for the VDI C  This field is relevant if the VDIC works "
        "in de-interlacing mode (when VDI_CMB_EN bit is clear)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENC_IN_VALID",
        "Encoding Input valid.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VF_IN_VALID",
        "View-finder Input valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_FS_PROC_FLOW2.
static const field_t hw_ipu_fs_proc_flow2[] =
{
    {
        "PRP_ENC_DEST_SEL",
        "Destination select for Encoding task",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_DEST_SEL",
        "Destination select for View finder task",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_ROT_DEST_SEL",
        "Destination select for Rotation task coming from the View finder input",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_DEST_SEL",
        "Destination select for post processing task",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_ROT_DEST_SEL",
        "Destination select for Rotation task coming from the Post Processing i"
        "nput",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPENC_ROT_DEST_SEL",
        "Destination select for Rotation task coming from the Encoding input",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRP_DEST_SEL",
        "Pre processing destination select (for channel DMAIC_7)",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_FS_PROC_FLOW3.
static const field_t hw_ipu_fs_proc_flow3[] =
{
    {
        "SMFC0_DEST_SEL",
        "Destination select for SMFC0",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC1_DEST_SEL",
        "Destination select for SMFC1",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC2_DEST_SEL",
        "Destination select for SMFC2",
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC3_DEST_SEL",
        "Destination select for SMFC3",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDOA_DEST_SEL",
        "Destination select for VDOA",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXT_SRC1_DEST_SEL",
        "Destination select for External Source 1",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXT_SRC2_DEST_SEL",
        "Destination select for External Source 2",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_FS_DISP_FLOW1.
static const field_t hw_ipu_fs_disp_flow1[] =
{
    {
        "DP_SYNC0_SRC_SEL",
        "Source select for DS2 - MG (graphics) plane (ch23)",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_SYNC1_SRC_SEL",
        "Source select for DS1/DS2 - Vx (video) plane (ch27)",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASYNC0_SRC_SEL",
        "Source select for DS2 - MG (graphics) plane (ch29)",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASYNC1_SRC_SEL",
        "Source select for DS1/DS2 - Vx (video) plane (ch24)",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC2_SRC_SEL",
        "Source select for DS3 (ch41)",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC1_SRC_SEL",
        "Source select for DS1/DS2 - MG (graphics) plane (ch28)",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_FS_DISP_FLOW2.
static const field_t hw_ipu_fs_disp_flow2[] =
{
    {
        "DP_ASYNC0_ALT_SRC_SEL",
        "Source select for alternate DS2 - MG (graphics) plane (ch29)",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASYNC1_ALT_SRC_SEL",
        "Source select for alternate DS1/DS2 - Vx (video) plane (ch24)",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC2_ALT_SRC_SEL",
        "Source select for Alternate DS3 (ch41)",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SKIP.
static const field_t hw_ipu_skip[] =
{
    {
        "CSI_MAX_RATIO_SKIP_IC_ENC",
        "CSI Maximum Ratio Skip for IC (encoding task)  These bits define the n"
        "umber of frames in a skipping set.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SKIP_IC_ENC",
        "CSI SKIP IC_ENC  These 5 bits define the skipping pattern of the frame"
        "s send to the IC for encoding task from one of the CSIs as defined on "
        "the CSI_SEL and IC_INPUT bits Skipping is done for a set of frames.",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_MAX_RATIO_SKIP_IC_VF",
        "CSI Maximum Ratio Skip for IC (view finder task)  These bits define th"
        "e number of frames in a skipping set.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SKIP_IC_VF",
        "CSI SKIP IC_VF  These 5 bits define the skipping pattern of the frames"
        " send to the IC for view finder task from one of the CSIs as defined o"
        "n the CSI_SEL and IC_INPUT bits Skipping is done for a set of frames.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_MAX_RATIO_SKIP",
        "Maximum Ratio Skip for VDI C  These bits define the number of frames i"
        "n a skipping set.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_SKIP",
        "VDI_SKIP  These 12 bits define the skipping pattern of the frames send"
        " from the VDI C .",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DISP_ALT_CONF.
static const field_t hw_ipu_disp_alt_conf[] =
{
    { 0 } // Terminator
};

// Bitfields in register IPU_DISP_GEN.
static const field_t hw_ipu_disp_gen[] =
{
    {
        "DI0_DUAL_MODE",
        "DI0 dual mode control",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DUAL_MODE",
        "DI1 dual mode control",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC2_DOUBLE_FLOW",
        "DC2 Double Flow.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASYNC_DOUBLE_FLOW",
        "DP Async Double Flow.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_FG_EN_ASYNC0",
        "FG_EN - partial plane Enable for async flow 0.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_FG_EN_ASYNC1",
        "FG_EN - partial plane Enable for async flow 1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_PIPE_CLR",
        "DP Pipe Clear  This bit clears the internal pipe of the DP.",
        6, // LSB
        6, // MSB
        false, // Readable
        true // Writable
    },
    {
        "MCU_DI_ID_8",
        "MCU_DI_ID_8 - DI ID via DC channel 8.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_DI_ID_9",
        "MCU_DI_ID_9 - DI ID via DC channel 9.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_T",
        "The address space for accesses through the AHB-lite slave port is MB a"
        "nd it is split internally (with 32MB resolution) according to bits [28"
        ":25] of the address.",
        18, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_MAX_BURST_STOP",
        "ARM platform Maximal burst  This bit limit the maximal unspecified len"
        "gth burst.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_VSYNC_DEST",
        "CSI_VSYNC destination  This bit defines the destination of the VSYNC c"
        "oming from the CSI's",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_COUNTER_RELEASE",
        "DI1 Counter release  By default the DI0 counters responsible for wavef"
        "orm generation for sync flow are frozen.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_COUNTER_RELEASE",
        "DI1 Counter release  By default the DI0 counters responsible for wavef"
        "orm generation for sync flow are frozen.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DISP_ALT1.
static const field_t hw_ipu_disp_alt1[] =
{
    {
        "RUN_VALUE_M1_ALT_0",
        "Counter pre defined value  This fields defines the counter pre defines"
        " value.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNT_CLR_SEL_ALT_0",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNT_AUTO_RELOAD_ALT_0",
        "Counter auto reload mode",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STEP_REPEAT_ALT_0",
        "This fields defines the amount of repetitions that will be performed b"
        "y the counter",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL_ALT_0",
        "Select alternative parameters instead of DI Sync Wave Gen counter#.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DISP_ALT2.
static const field_t hw_ipu_disp_alt2[] =
{
    {
        "OFFSET_VALUE_ALT_0",
        "Counter offset value  The counter can start counting after a pre defin"
        "ed delay  This field defines the amount of cycles that the counter wil"
        "l be delayed by",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET_RESOLUTION_ALT_0",
        "Counter offset Resolution  This field defines the trigger causing the "
        "offset counter to increment  The counter offset resolution should be d"
        "efined in the same way as in original DI's counter#",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN_RESOLUTION_ALT_0",
        "Counter Run Resolution  This field defines the trigger causing the cou"
        "nter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DISP_ALT3.
static const field_t hw_ipu_disp_alt3[] =
{
    {
        "RUN_VALUE_M1_ALT_1",
        "Counter pre defined value  This fields defines the counter pre defines"
        " value.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNT_CLR_SEL_ALT_1",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNT_AUTO_RELOAD_ALT_1",
        "Counter auto reload mode",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STEP_REPEAT_ALT_1",
        "This fields defines the amount of repetitions that will be performed b"
        "y the counter",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL_ALT_1",
        "Select alternative parameters instead of DI Sync Wave Gen counter#.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DISP_ALT4.
static const field_t hw_ipu_disp_alt4[] =
{
    {
        "OFFSET_VALUE_ALT_1",
        "Counter offset value  The counter can start counting after a pre defin"
        "ed delay  This field defines the amount of cycles that the counter wil"
        "l be delayed by",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET_RESOLUTION_ALT_1",
        "Counter offset Resolution  This field defines the trigger causing the "
        "offset counter to increment  The counter offset resolution should be d"
        "efined in the same way as in original DI's counter#",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN_RESOLUTION_ALT_1",
        "Counter Run Resolution  This field defines the trigger causing the cou"
        "nter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SNOOP.
static const field_t hw_ipu_snoop[] =
{
    {
        "AUTOREF_PER",
        "Autorefresh period minus 1.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNOOP2_SYNC_BYP",
        "This bits control the bypass of the synchronizer on emi_snooping2 sign"
        "al.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_MEM_RST.
static const field_t hw_ipu_mem_rst[] =
{
    {
        "RST_MEM_EN",
        "Reset Memory Enable  Each bit on this field enables the memory reset m"
        "echanism for a specific memory.",
        0, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST_MEM_START",
        "Memory Reset Start  Writing one to this bit activate the memory reset "
        "mechanism.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_PM.
static const field_t hw_ipu_pm[] =
{
    {
        "DI0_CLK_PERIOD_0",
        "DI0_CLK period option 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CLK_PERIOD_1",
        "DI0_CLK period option 1.",
        7, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SRM_CLOCK_CHANGE_MODE",
        "SRM clock change mode  When the clock is going to be changed to any ne"
        "w ratio other then 1:1, 1:2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLCOK_MODE_STAT",
        "Clock mode status  This is a read only bit indicating what is the curr"
        "ent clock mode",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI1_CLK_PERIOD_0",
        "DI1_CLK period option 0.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CLK_PERIOD_1",
        "DI1_CLK period option 1.",
        23, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SRM_CLOCK_CHANGE_MODE",
        "SRM clock change mode  When the clock is going to be changed to any ne"
        "w ratio other then 1:1, 1:2.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPSR_MODE",
        "LPSR Mode  This bit indicates that the next attempt for entering low p"
        "ower mode is an attempt to move to LPST mode.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_GPR.
static const field_t hw_ipu_gpr[] =
{
    {
        "IPU_GPN",
        "IPU General Purpose bit.",
        0, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VF_TSTAT_CLR",
        "Reset viewfinder state machine.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_CH_BUF2_RDY0_CLR",
        "This bit defines the IPU_CH_BUF2_RDY0 properties.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_CH_BUF2_RDY1_CLR",
        "This bit defines the IPU_CH_BUF2_RDY1 properties.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_DI0_CLK_CHANGE_ACK_DIS",
        "Disable DI0's clock change mechanism.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_DI1_CLK_CHANGE_ACK_DIS",
        "Disable DI1's clock change mechanism.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_ALT_CH_BUF0_RDY0_CLR",
        "This bit defines the IPU_ALT_CH_BUF0_RDY0 properties.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_ALT_CH_BUF0_RDY1_CLR",
        "This bit defines the IPU_ALT_CH_BUF0_RDY1 properties.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_ALT_CH_BUF1_RDY0_CLR",
        "This bit defines the IPU_ALT_CH_BUF1_RDY0 properties.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_ALT_CH_BUF1_RDY1_CLR",
        "This bit defines the IPU_ALT_CH_BUF1_RDY1 properties.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_CH_BUF0_RDY0_CLR",
        "This bit defines the IPU_CH_BUF0_RDY0 properties.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_CH_BUF0_RDY1_CLR",
        "This bit defines the IPU_CH_BUF0_RDY1 properties.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_CH_BUF1_RDY0_CLR",
        "This bit defines the IPU_CH_BUF1_RDY0 properties.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPU_CH_BUF1_RDY1_CLR",
        "This bit defines the IPU_CH_BUF1_RDY1 properties.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CH_DB_MODE_SEL0.
static const field_t hw_ipu_ch_db_mode_sel0[] =
{
    {
        "DMA_CH_DB_MODE_SEL_0",
        "Double Buffer Mode Select.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_1",
        "Double Buffer Mode Select.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_2",
        "Double Buffer Mode Select.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_3",
        "Double Buffer Mode Select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_5",
        "Double Buffer Mode Select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_8",
        "Double Buffer Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_9",
        "Double Buffer Mode Select.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_10",
        "Double Buffer Mode Select.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_11",
        "Double Buffer Mode Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_12",
        "Double Buffer Mode Select.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_13",
        "Double Buffer Mode Select.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_14",
        "Double Buffer Mode Select.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_15",
        "Double Buffer Mode Select.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_17",
        "Double Buffer Mode Select.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_18",
        "Double Buffer Mode Select.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_19",
        "Double Buffer Mode Select.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_20",
        "Double Buffer Mode Select.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_21",
        "Double Buffer Mode Select.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_22",
        "Double Buffer Mode Select.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_23",
        "Double Buffer Mode Select.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_24",
        "Double Buffer Mode Select.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_25",
        "Double Buffer Mode Select.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_26",
        "Double Buffer Mode Select.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_27",
        "Double Buffer Mode Select.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_28",
        "Double Buffer Mode Select.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_29",
        "Double Buffer Mode Select.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_31",
        "Double Buffer Mode Select.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CH_DB_MODE_SEL1.
static const field_t hw_ipu_ch_db_mode_sel1[] =
{
    {
        "DMA_CH_DB_MODE_SEL_33",
        "Double Buffer Mode Select.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_40",
        "Double Buffer Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_41",
        "Double Buffer Mode Select.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_42",
        "Double Buffer Mode Select.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_43",
        "Double Buffer Mode Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_44",
        "Double Buffer Mode Select.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_45",
        "Double Buffer Mode Select.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_46",
        "Double Buffer Mode Select.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_47",
        "Double Buffer Mode Select.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_48",
        "Double Buffer Mode Select.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_49",
        "Double Buffer Mode Select.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_50",
        "Double Buffer Mode Select.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_51",
        "Double Buffer Mode Select.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_DB_MODE_SEL_52",
        "Double Buffer Mode Select.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CH_DB_MODE_SEL0.
static const field_t hw_ipu_alt_ch_db_mode_sel0[] =
{
    {
        "DMA_CH_ALT_DB_MODE_SEL_4",
        "Double Buffer Mode Select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_DB_MODE_SEL_5",
        "Double Buffer Mode Select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_DB_MODE_SEL_6",
        "Double Buffer Mode Select.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_DB_MODE_SEL_7",
        "Double Buffer Mode Select.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_DB_MODE_SEL_24",
        "Double Buffer Mode Select.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_DB_MODE_SEL_29",
        "Double Buffer Mode Select.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CH_DB_MODE_SEL1.
static const field_t hw_ipu_alt_ch_db_mode_sel1[] =
{
    {
        "DMA_CH_ALT_DB_MODE_SEL_33",
        "Double Buffer Mode Select.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_DB_MODE_SEL_41",
        "Double Buffer Mode Select.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_DB_MODE_SEL_52",
        "Double Buffer Mode Select.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CH_TRB_MODE_SEL0.
static const field_t hw_ipu_alt_ch_trb_mode_sel0[] =
{
    {
        "DMA_CH_TRB_MODE_SEL_8",
        "Triple Buffer Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_TRB_MODE_SEL_9",
        "Triple Buffer Mode Select.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_TRB_MODE_SEL_10",
        "Triple Buffer Mode Select.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_TRB_MODE_SEL_13",
        "Triple Buffer Mode Select.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_TRB_MODE_SEL_21",
        "Triple Buffer Mode Select.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_TRB_MODE_SEL_23",
        "Triple Buffer Mode Select.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_TRB_MODE_SEL_27",
        "Triple Buffer Mode Select.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_TRB_MODE_SEL_28",
        "Triple Buffer Mode Select.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CH_TRB_MODE_SEL1.
static const field_t hw_ipu_alt_ch_trb_mode_sel1[] =
{
    {
        "DMA_CH_TRB_MODE_SEL_N",
        "Triple Buffer Mode Select.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_1.
static const field_t hw_ipu_int_stat_1[] =
{
    {
        "IDMAC_EOF_0",
        "End of Frame of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_1",
        "End of Frame of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_2",
        "End of Frame of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_3",
        "End of Frame of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_5",
        "End of Frame of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_8",
        "End of Frame of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_9",
        "End of Frame of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_10",
        "End of Frame of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_11",
        "End of Frame of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_12",
        "End of Frame of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_13",
        "End of Frame of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_14",
        "End of Frame of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_15",
        "End of Frame of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_17",
        "End of Frame of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_18",
        "End of Frame of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_19",
        "End of Frame of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_20",
        "End of Frame of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_21",
        "End of Frame of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_22",
        "End of Frame of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_23",
        "End of Frame of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_24",
        "End of Frame of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_25",
        "End of Frame of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_26",
        "End of Frame of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_27",
        "End of Frame of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_28",
        "End of Frame of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_29",
        "End of Frame of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_31",
        "End of Frame of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_2.
static const field_t hw_ipu_int_stat_2[] =
{
    {
        "IDMAC_EOF_33",
        "End of Frame of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_40",
        "End of Frame of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_41",
        "End of Frame of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_42",
        "End of Frame of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_43",
        "End of Frame of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_44",
        "End of Frame of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_45",
        "End of Frame of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_46",
        "End of Frame of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_47",
        "End of Frame of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_48",
        "End of Frame of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_49",
        "End of Frame of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_50",
        "End of Frame of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_51",
        "End of Frame of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOF_52",
        "End of Frame of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_3.
static const field_t hw_ipu_int_stat_3[] =
{
    {
        "IDMAC_NFACK_0",
        "Enable New Frame Ack of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_1",
        "Enable New Frame Ack of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_2",
        "Enable New Frame Ack of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_3",
        "Enable New Frame Ack of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_5",
        "Enable New Frame Ack of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_8",
        "Enable New Frame Ack of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_9",
        "Enable New Frame Ack of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_10",
        "Enable New Frame Ack of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_11",
        "Enable New Frame Ack of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_12",
        "Enable New Frame Ack of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_13",
        "Enable New Frame Ack of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_14",
        "Enable New Frame Ack of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_15",
        "Enable New Frame Ack of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_17",
        "Enable New Frame Ack of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_18",
        "Enable New Frame Ack of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_19",
        "Enable New Frame Ack of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_20",
        "Enable New Frame Ack of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_21",
        "Enable New Frame Ack of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_22",
        "Enable New Frame Ack of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_23",
        "Enable New Frame Ack of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_24",
        "Enable New Frame Ack of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_25",
        "Enable New Frame Ack of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_26",
        "Enable New Frame Ack of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_27",
        "Enable New Frame Ack of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_28",
        "Enable New Frame Ack of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_29",
        "Enable New Frame Ack of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_31",
        "Enable New Frame Ack of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_4.
static const field_t hw_ipu_int_stat_4[] =
{
    {
        "IDMAC_NFACK_33",
        "Enable New Frame Ack of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_40",
        "Enable New Frame Ack of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_41",
        "Enable New Frame Ack of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_42",
        "Enable New Frame Ack of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_43",
        "Enable New Frame Ack of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_44",
        "Enable New Frame Ack of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_45",
        "Enable New Frame Ack of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_46",
        "Enable New Frame Ack of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_47",
        "Enable New Frame Ack of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_48",
        "Enable New Frame Ack of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_49",
        "Enable New Frame Ack of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_50",
        "Enable New Frame Ack of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_51",
        "Enable New Frame Ack of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFACK_52",
        "Enable New Frame Ack of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_5.
static const field_t hw_ipu_int_stat_5[] =
{
    {
        "IDMAC_NFB4EOF_ERR_0",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_1",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_2",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_3",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_5",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_8",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_9",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_10",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_11",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_12",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_13",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_14",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_15",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_17",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_18",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_19",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_20",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_21",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_22",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_23",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_24",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_25",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_26",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_27",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_28",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_29",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_31",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_6.
static const field_t hw_ipu_int_stat_6[] =
{
    {
        "IDMAC_NFB4EOF_ERR_33",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_40",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_41",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_42",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_43",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_44",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_45",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_46",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_47",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_48",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_49",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_50",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_51",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_NFB4EOF_ERR_52",
        "New Frame before end-of-frame error indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_7.
static const field_t hw_ipu_int_stat_7[] =
{
    {
        "IDMAC_EOS_EN_19",
        "End of Scroll indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_23",
        "End of Scroll indication of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_24",
        "End of Scroll indication of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_25",
        "End of Scroll indication of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_26",
        "End of Scroll indication of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_27",
        "End of Scroll indication of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_28",
        "End of Scroll indication of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_29",
        "End of Scroll indication of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_31",
        "End of Scroll indication of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_8.
static const field_t hw_ipu_int_stat_8[] =
{
    {
        "IDMAC_EOS_EN_33",
        "End of Scroll indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_41",
        "End of Scroll indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_42",
        "End of Scroll indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_43",
        "End of Scroll indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_44",
        "End of Scroll indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_51",
        "End of Scroll indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOS_EN_52",
        "End of Scroll indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_9.
static const field_t hw_ipu_int_stat_9[] =
{
    {
        "VDI_FIFO1_OVF",
        "FIFO1 overflow Interrupt1  The VDI C generate FIFO1 overflow interrupt"
        "1 when write pointer of FIFO1 overrun read pointer.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_BAYER_BUF_OVF",
        "This bit indicates on an interrupt that is a result of the IC Buffer o"
        "verflow for Bayer coming from the IC.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_ENC_BUF_OVF",
        "This bit indicates on an interrupt that is a result of the IC Buffer o"
        "verflow for encoding coming from the IC.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_VF_BUF_OVF",
        "This bit indicates on an interrupt that is a result of the IC Buffer o"
        "verflow for view finder coming from the IC.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_PUPE",
        "CSI0_PUPE - CSI0 parameters update error interrupt.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_PUPE",
        "CSI1_PUPE - CSI1 parameters update error interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_10.
static const field_t hw_ipu_int_stat_10[] =
{
    {
        "SMFC0_FRM_LOST",
        "Frame Lost of SMFC channel 0 interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC1_FRM_LOST",
        "Frame Lost of SMFC channel 1 interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC2_FRM_LOST",
        "Frame Lost of SMFC channel 2 interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMFC3_FRM_LOST",
        "Frame Lost of SMFC channel 3 interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_TEARING_ERR_1",
        "Tearing Error #1 interrupt  This bit indicates on the interrupt that i"
        "s a result of tearing error while the anti tearing mechanism is activa"
        "ted for DC channel 1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_TEARING_ERR_2",
        "Tearing Error #2 interrupt  This bit indicates on the interrupt that i"
        "s a result of tearing error while the anti tearing mechanism is activa"
        "ted for DC channel 2",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_TEARING_ERR_6",
        "Tearing Error #6 interrupt  This bit indicates on the interrupt that i"
        "s a result of tearing error while the anti tearing mechanism is activa"
        "ted for DC channel 6",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SYNC_DISP_ERR",
        "DI0 Synchronous display error interrupt  This bit indicates on the int"
        "errupt that is a result of an error during access to a synchronous dis"
        "play via DI0",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SYNC_DISP_ERR",
        "DI1 Synchronous display error interrupt  This bit indicates on the int"
        "errupt that is a result of an error during access to a synchronous dis"
        "play via DI1",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_TIME_OUT_ERR",
        "DI0 time out error interrupt  This bit indicates on the interrupt that"
        " is a result of a time out error during a read access via DI0",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_TIME_OUT_ERR",
        "DI1 time out error interrupt  This bit indicates on the interrupt that"
        " is a result of a time out error during a read access via DI1",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_VF_FRM_LOST_ERR",
        "This bit indicates on an interrupt that is a result of IC's view finde"
        "r frame lost.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_ENC_FRM_LOST_ERR",
        "This bit indicates on an interrupt that is a result of IC's encoding f"
        "rame lost.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_BAYER_FRM_LOST_ERR",
        "This bit indicates on an interrupt that is a result of IC's Bayer fram"
        "e lost.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_PRIVILEGED_ACC_ERR",
        "Non Privileged Access Error interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXIW_ERR",
        "This bit indicates on an interrupt that is a result of AXI write acces"
        "s resulted with error response.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXIR_ERR",
        "This bit indicates on an interrupt that is a result of AXI read access"
        " resulted with error response.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_11.
static const field_t hw_ipu_int_stat_11[] =
{
    {
        "IDMAC_EOBND_EN_0",
        "end-of-band indication of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_1",
        "end-of-band indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_2",
        "end-of-band indication of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_3",
        "end-of-band indication of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_5",
        "end-of-band indication of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_11",
        "end-of-band indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_12",
        "end-of-band indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_20",
        "end-of-band indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_21",
        "end-of-band indication of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_22",
        "end-of-band indication of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_25",
        "end-of-band indication of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_26",
        "end-of-band indication of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_12.
static const field_t hw_ipu_int_stat_12[] =
{
    {
        "IDMAC_EOBND_EN_45",
        "end-of-band indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_46",
        "end-of-band indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_47",
        "end-of-band indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_48",
        "end-of-band indication of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_49",
        "end-of-band indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_EOBND_EN_50",
        "end-of-band indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_13.
static const field_t hw_ipu_int_stat_13[] =
{
    {
        "IDMAC_TH_0",
        "Threshold crossing indication of Channel interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_1",
        "Threshold crossing indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_2",
        "Threshold crossing indication of Channel interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_3",
        "Threshold crossing indication of Channel interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_5",
        "Threshold crossing indication of Channel interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_8",
        "Threshold crossing indication of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_9",
        "Threshold crossing indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_10",
        "Threshold crossing indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_11",
        "Threshold crossing indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_12",
        "Threshold crossing indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_13",
        "Threshold crossing indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_14",
        "Threshold crossing indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_15",
        "Threshold crossing indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_17",
        "Threshold crossing indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_18",
        "Threshold crossing indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_19",
        "Threshold crossing indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_20",
        "Threshold crossing indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_21",
        "Threshold crossing indication of Channel interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_22",
        "Threshold crossing indication of Channel interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_23",
        "Threshold crossing indication of Channel interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_24",
        "Threshold crossing indication of Channel interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_25",
        "Threshold crossing indication of Channel interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_26",
        "Threshold crossing indication of Channel interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_27",
        "Threshold crossing indication of Channel interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_28",
        "Threshold crossing indication of Channel interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_29",
        "Threshold crossing indication of Channel interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_31",
        "Threshold crossing indication of Channel interrupt.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_14.
static const field_t hw_ipu_int_stat_14[] =
{
    {
        "IDMAC_TH_33",
        "Threshold crossing indication of Channel interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_40",
        "Threshold crossing indication of Channel interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_41",
        "Threshold crossing indication of Channel interrupt.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_42",
        "Threshold crossing indication of Channel interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_43",
        "Threshold crossing indication of Channel interrupt.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_44",
        "Threshold crossing indication of Channel interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_45",
        "Threshold crossing indication of Channel interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_46",
        "Threshold crossing indication of Channel interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_47",
        "Threshold crossing indication of Channel interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_48",
        "Threshold crossing indication of Channel interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_49",
        "Threshold crossing indication of Channel interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_50",
        "Threshold crossing indication of Channel interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_51",
        "Threshold crossing indication of Channel interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_TH_52",
        "Threshold crossing indication of Channel interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_INT_STAT_15.
static const field_t hw_ipu_int_stat_15[] =
{
    {
        "SNOOPING1_INT",
        "IPU snooping 1 event indication interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNOOPING2_INT",
        "IPU snooping 2 event indication interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_SF_START",
        "DP Sync Flow Start indication interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_SF_END",
        "DP Sync Flow End indication interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASF_START",
        "DP Async Flow Start indication interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASF_END",
        "DP Async Flow End indication interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_SF_BRAKE",
        "DP Sync Flow Brake indication interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_ASF_BRAKE",
        "DP Async Flow Brake indication interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_0",
        "DC Frame Complete on channel #0 interrupt indication",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_1",
        "DC Frame Complete on channel #1 interrupt indication",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_2",
        "DC Frame Complete on channel #2 interrupt indication",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_3",
        "DC Frame Complete on channel #3 interrupt indication",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_4",
        "DC Frame Complete on channel #4 interrupt indication",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_FC_6",
        "DC Frame Complete on channel #6 interrupt indication",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI_VSYNC_PRE_0",
        "DI0 interrupt indicating of a VSYNC signal asserted 2 rows before the "
        "VSYNC sent to the display",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI_VSYNC_PRE_1",
        "DI1 interrupt indicating of a VSYNC signal asserted 2 rows before the "
        "VSYNC sent to the display",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_DP_START",
        "This bit indicates on an interrupt asserted anytime the DP start a new"
        " sync or async flow or when an async flow is interrupted by a sync flo"
        "w",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_ASYNC_STOP",
        "This bit indicates on an interrupt asserted anytime the DP stops an as"
        "ync flow and moves to a sync flow",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_0",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #0 of DI0",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_1",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #1 of DI0",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_2",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #2 of DI0",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_3",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #3 of DI0",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_4",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #4 of DI0",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_5",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #5 of DI0",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_6",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #6 of DI0",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_7",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #7 of DI0",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_8",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #8 of DI0",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_9",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #9 of DI0",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_EN_PRE_10",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #10 of DI0",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DISP_CLK_EN_PRE",
        "DI1_DISP_CLK_EN_PRE",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_EN_PRE_3",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #3 of DI1",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_EN_PRE_8",
        "This bit indicates on the interrupt that is a result of a trigger gene"
        "rated by counter #8 of DI1",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CUR_BUF_0.
static const field_t hw_ipu_cur_buf_0[] =
{
    {
        "DMA_CH_CUR_BUF_0",
        "Current Buffer.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_1",
        "Current Buffer.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_2",
        "Current Buffer.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_3",
        "Current Buffer.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_5",
        "Current Buffer.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_8",
        "Current Buffer.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_9",
        "Current Buffer.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_10",
        "Current Buffer.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_11",
        "Current Buffer.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_12",
        "Current Buffer.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_13",
        "Current Buffer.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_14",
        "Current Buffer.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_15",
        "Current Buffer.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_17",
        "Current Buffer.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_18",
        "Current Buffer.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_19",
        "Current Buffer.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_20",
        "Current Buffer.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_21",
        "Current Buffer.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_22",
        "Current Buffer.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_23",
        "Current Buffer.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_24",
        "Current Buffer.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_25",
        "Current Buffer.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_26",
        "Current Buffer.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_27",
        "Current Buffer.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_28",
        "Current Buffer.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_29",
        "Current Buffer.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_31",
        "Current Buffer.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CUR_BUF_1.
static const field_t hw_ipu_cur_buf_1[] =
{
    {
        "DMA_CH_CUR_BUF_33",
        "Current Buffer.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_40",
        "Current Buffer.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_41",
        "Current Buffer.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_42",
        "Current Buffer.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_43",
        "Current Buffer.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_44",
        "Current Buffer.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_45",
        "Current Buffer.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_46",
        "Current Buffer.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_47",
        "Current Buffer.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_48",
        "Current Buffer.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_49",
        "Current Buffer.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_50",
        "Current Buffer.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_51",
        "Current Buffer.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_CUR_BUF_52",
        "Current Buffer.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CUR_0.
static const field_t hw_ipu_alt_cur_0[] =
{
    {
        "DMA_CH_ALT_CUR_BUF_24",
        "Current Buffer.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_ALT_CUR_BUF_29",
        "Current Buffer.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CUR_1.
static const field_t hw_ipu_alt_cur_1[] =
{
    {
        "DMA_CH_ALT_CUR_BUF_N1",
        "Current Buffer.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_ALT_CUR_BUF_N",
        "Current Buffer.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_ALT_CUR_BUF_52",
        "Current Buffer.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SRM_STAT.
static const field_t hw_ipu_srm_stat[] =
{
    {
        "DP_S_SRM_STAT",
        "DP SYNC FLOW SRM STAT  This bit indicates that the SRM is currently up"
        "dating the DP sync flow registers",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_A0_SRM_STAT",
        "DP ASYNC0 FLOW SRM STAT  This bit indicates that the SRM is currently "
        "updating the DP async flow 0 registers",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_A1_SRM_STAT",
        "DP ASYNC1 FLOW SRM STAT  This bit indicates that the SRM is currently "
        "updating the DP async flow 1 registers",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_2_SRM_STAT",
        "DC group #2 SRM STAT  This bit indicates that the SRM is currently upd"
        "ating the DC group #2 registers",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_6_SRM_STAT",
        "DC group #6 SRM STAT  This bit indicates that the SRM is currently upd"
        "ating the DC group #6 registers",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSI0_SRM_STAT",
        "CSI1_SRM_STAT",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSI1_SRM_STAT",
        "CSI1_SRM_STAT",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI0_SRM_STAT",
        "DI0 SRM STAT  This bit indicates that the SRM is currently updating th"
        "e DI0 registers",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI1_SRM_STAT",
        "DI1 SRM STAT  This bit indicates that the SRM is currently updating th"
        "e DI1 registers",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_PROC_TASKS_STAT.
static const field_t hw_ipu_proc_tasks_stat[] =
{
    {
        "ENC_TSTAT",
        "Status of the encoding task",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VF_TSTAT",
        "Status of the viewfinder task",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PP_TSTAT",
        "Status of the post processing task",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENC_ROT_TSTAT",
        "Status of the rotation for encoding task",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VF_ROT_TSTAT",
        "Status of the rotation for viewfinder task",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PP_ROT_TSTAT",
        "Status of the rotation for post processing task",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEM2PRP_TSTAT",
        "Status of the pre processing tasks (viewfinder and encoding) when the "
        "source is coming from the memory.",
        12, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DISP_TASKS_STAT.
static const field_t hw_ipu_disp_tasks_stat[] =
{
    {
        "DP_ASYNC_STAT",
        "Status of the Asynchronous flow through the DP",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_ASYNC_CUR_FLOW",
        "Current asynchronous flow via the DP",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_ASYNC1_STAT",
        "Status of the Asynchronous flow #1 through the DC (ch 28)",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_ASYNCH2_STAT",
        "Status of the Asynchronous flow #2 through the DC",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_ASYNC2_CUR_FLOW",
        "Current asynchronous #2 flow via the DC",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_TRIPLE_CUR_BUF_0.
static const field_t hw_ipu_triple_cur_buf_0[] =
{
    {
        "DMA_CH_TRIPLE_CUR_BUF_8",
        "Current Buffer for triple buffer mode.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_TRIPLE_CUR_BUF_9",
        "Current Buffer for triple buffer mode.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_TRIPLE_CUR_BUF_10",
        "Current Buffer for triple buffer mode.",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_TRIPLE_CUR_BUF_13",
        "Current Buffer for triple buffer mode.",
        26, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_TRIPLE_CUR_BUF_1.
static const field_t hw_ipu_triple_cur_buf_1[] =
{
    {
        "DMA_CH_TRIPLE_CUR_BUF_21",
        "Current Buffer for triple buffer mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_TRIPLE_CUR_BUF_23",
        "Current Buffer for triple buffer mode.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_TRIPLE_CUR_BUF_27",
        "Current Buffer for triple buffer mode.",
        22, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_TRIPLE_CUR_BUF_28",
        "Current Buffer for triple buffer mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_TRIPLE_CUR_BUF_2.
static const field_t hw_ipu_triple_cur_buf_2[] =
{
    {
        "DMA_CH_TRIPLE_CUR_BUF_N",
        "Current Buffer for triple buffer mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_TRIPLE_CUR_BUF_3.
static const field_t hw_ipu_triple_cur_buf_3[] =
{
    {
        "DMA_CH_TRIPLE_CUR_BUF_N",
        "Current Buffer for triple buffer mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CH_BUF0_RDY0.
static const field_t hw_ipu_ch_buf0_rdy0[] =
{
    {
        "DMA_CH_BUF0_RDY_0",
        "Buffer 0 is ready.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_1",
        "Buffer 0 is ready.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_2",
        "Buffer 0 is ready.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_3",
        "Buffer 0 is ready.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_4",
        "Buffer 0 is ready.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_5",
        "Buffer 0 is ready.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_6",
        "Buffer 0 is ready.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_7",
        "Buffer 0 is ready.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_8",
        "Buffer 0 is ready.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_9",
        "Buffer 0 is ready.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_10",
        "Buffer 0 is ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_11",
        "Buffer 0 is ready.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_12",
        "Buffer 0 is ready.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_13",
        "Buffer 0 is ready.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_14",
        "Buffer 0 is ready.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_15",
        "Buffer 0 is ready.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_17",
        "Buffer 0 is ready.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_18",
        "Buffer 0 is ready.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_20",
        "Buffer 0 is ready.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_21",
        "Buffer 0 is ready.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_22",
        "Buffer 0 is ready.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_23",
        "Buffer 0 is ready.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_24",
        "Buffer 0 is ready.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_27",
        "Buffer 0 is ready.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_28",
        "Buffer 0 is ready.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_29",
        "Buffer 0 is ready.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_31",
        "Buffer 0 is ready.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CH_BUF0_RDY1.
static const field_t hw_ipu_ch_buf0_rdy1[] =
{
    {
        "DMA_CH_BUF0_RDY_33",
        "Buffer 0 is ready.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_40",
        "Buffer 0 is ready.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_41",
        "Buffer 0 is ready.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_42",
        "Buffer 0 is ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_43",
        "Buffer 0 is ready.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_44",
        "Buffer 0 is ready.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_45",
        "Buffer 0 is ready.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_46",
        "Buffer 0 is ready.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_47",
        "Buffer 0 is ready.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_48",
        "Buffer 0 is ready.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_49",
        "Buffer 0 is ready.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_50",
        "Buffer 0 is ready.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_51",
        "Buffer 0 is ready.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_52",
        "Buffer 0 is ready.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CH_BUF1_RDY0.
static const field_t hw_ipu_ch_buf1_rdy0[] =
{
    {
        "DMA_CH_BUF1_RDY_0",
        "Buffer 1 is ready.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_1",
        "Buffer 1 is ready.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_2",
        "Buffer 1 is ready.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_3",
        "Buffer 1 is ready.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_5",
        "Buffer 1 is ready.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_8",
        "Buffer 1 is ready.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_9",
        "Buffer 1 is ready.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_10",
        "Buffer 1 is ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY",
        "Buffer 1 is ready.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_12",
        "Buffer 1 is ready.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_13",
        "Buffer 1 is ready.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_14",
        "Buffer 1 is ready.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_15",
        "Buffer 1 is ready.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_17",
        "Buffer 1 is ready.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_18",
        "Buffer 1 is ready.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_19",
        "Buffer 1 is ready.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_20",
        "Buffer 1 is ready.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_21",
        "Buffer 1 is ready.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_22",
        "Buffer 1 is ready.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_23",
        "Buffer 1 is ready.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_24",
        "Buffer 1 is ready.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_25",
        "Buffer 1 is ready.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_26",
        "Buffer 1 is ready.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_27",
        "Buffer 1 is ready.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_28",
        "Buffer 1 is ready.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_29",
        "Buffer 1 is ready.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF1_RDY_31",
        "Buffer 1 is ready.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CH_BUF1_RDY1.
static const field_t hw_ipu_ch_buf1_rdy1[] =
{
    {
        "DMA_CH_BUF0_RDY_33",
        "Buffer 1 is ready.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_40",
        "Buffer 1 is ready.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_41",
        "Buffer 1 is ready.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_42",
        "Buffer 1 is ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_43",
        "Buffer 1 is ready.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_44",
        "Buffer 1 is ready.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_45",
        "Buffer 1 is ready.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_46",
        "Buffer 1 is ready.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_47",
        "Buffer 1 is ready.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_48",
        "Buffer 1 is ready.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_49",
        "Buffer 1 is ready.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_50",
        "Buffer 1 is ready.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_51",
        "Buffer 1 is ready.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF0_RDY_52",
        "Buffer 1 is ready.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CH_BUF0_RDY0.
static const field_t hw_ipu_alt_ch_buf0_rdy0[] =
{
    {
        "DMA_CH_ALT_BUF0_RDY_24",
        "Buffer 0 is ready.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_BUF0_RDY_29",
        "Buffer 0 is ready.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CH_BUF0_RDY1.
static const field_t hw_ipu_alt_ch_buf0_rdy1[] =
{
    {
        "DMA_CH_ALT_BUF0_RDY_33",
        "Buffer 0 is ready.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_BUF0_RDY_41",
        "Buffer 0 is ready.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_BUF0_RDY_52",
        "Buffer 0 is ready.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CH_BUF1_RDY0.
static const field_t hw_ipu_alt_ch_buf1_rdy0[] =
{
    {
        "DMA_CH_ALT_BUF1_RDY_24",
        "Buffer 1 is ready.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_BUF1_RDY_29",
        "Buffer 1 is ready.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_ALT_CH_BUF1_RDY1.
static const field_t hw_ipu_alt_ch_buf1_rdy1[] =
{
    {
        "DMA_CH_ALT_BUF1_RDY_33",
        "Buffer 1 is ready.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_BUF1_RDY_41",
        "Buffer 1 is ready.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_BUF1_RDY_52",
        "Buffer 1 is ready.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CH_BUF2_RDY0.
static const field_t hw_ipu_ch_buf2_rdy0[] =
{
    {
        "DMA_CH_BUF2_RDY_0",
        "Buffer 2 is ready.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF2_RDY_2",
        "Buffer 2 is ready.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF2_RDY_8",
        "Buffer 2 is ready.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF2_RDY_9",
        "Buffer 2 is ready.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF2_RDY_10",
        "Buffer 2 is ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF2_RDY_13",
        "Buffer 2 is ready.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF2_RDY_21",
        "Buffer 2 is ready.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF2_RDY_23",
        "Buffer 2 is ready.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_ALT_BUF1_RDY_27",
        "buffer 2 is ready.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CH_BUF2_RDY_28",
        "Buffer 2 is ready.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CH_BUF2_RDY1.
static const field_t hw_ipu_ch_buf2_rdy1[] =
{
    {
        "DMA_CH_BUF2_RDY",
        "Buffer 2 is ready.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_CONF.
static const field_t hw_ipu_idmac_conf[] =
{
    {
        "MAX_REQ_READ",
        "Maximum Read Requests.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIDPT",
        "Write Interleaving Depth  These 2 bits define the Write Interleaving D"
        "epth of the AXI port.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDI",
        "Read Data Interleaving.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "P_ENDIAN",
        "Pixel Endianness.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USED_BUFS_MAX_W",
        "Limit the number of pending non real time write requests.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USED_BUFS_EN_W",
        "Enables the limit on the number of pending non real time write request"
        "s.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USED_BUFS_MAX_R",
        "Limit the number of pending non real time read requests.",
        21, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USED_BUFS_EN_R",
        "Enables the limit on the number of pending non real time read requests"
        ".",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_CH_EN_1.
static const field_t hw_ipu_idmac_ch_en_1[] =
{
    {
        "IDMAC_CH_EN_0",
        "IDMAC Channel enable bit [i]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_1",
        "IDMAC Channel enable bit [i]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_2",
        "IDMAC Channel enable bit [i]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_3",
        "IDMAC Channel enable bit [i]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_5",
        "IDMAC Channel enable bit [i]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_8",
        "IDMAC Channel enable bit [i]",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_9",
        "IDMAC Channel enable bit [i]",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_10",
        "IDMAC Channel enable bit [i]",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_11",
        "IDMAC Channel enable bit [i]",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_12",
        "IDMAC Channel enable bit [i]",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_13",
        "IDMAC Channel enable bit [i]",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_14",
        "IDMAC Channel enable bit [i]",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_15",
        "IDMAC Channel enable bit [i]",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_17",
        "IDMAC Channel enable bit [i]",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_18",
        "IDMAC Channel enable bit [i]",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_19",
        "IDMAC Channel enable bit [i]",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_20",
        "IDMAC Channel enable bit [i]",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_21",
        "IDMAC Channel enable bit [i]",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_22",
        "IDMAC Channel enable bit [i]",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_23",
        "IDMAC Channel enable bit [i]",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_24",
        "IDMAC Channel enable bit [i]",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_25",
        "IDMAC Channel enable bit [i]",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_26",
        "IDMAC Channel enable bit [i]",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_27",
        "IDMAC Channel enable bit [i]",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_28",
        "IDMAC Channel enable bit [i]",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_29",
        "IDMAC Channel enable bit [i]",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_31",
        "IDMAC Channel enable bit [i]",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_ALT_SEP_ALPHA.
static const field_t hw_ipu_idmac_alt_sep_alpha[] =
{
    {
        "IDMAC_ALT_SEP_AL_23",
        "IDMAC Alternate Separate alpha indication bit [i]  A sub block may nee"
        "d to read data from the system's memory where the pixel data and the a"
        "lpha transparency data are located in separate buffers.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_ALT_SEP_AL_24",
        "IDMAC Alternate Separate alpha indication bit [i]  A sub block may nee"
        "d to read data from the system's memory where the pixel data and the a"
        "lpha transparency data are located in separate buffers.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_ALT_SEP_AL_29",
        "IDMAC Alternate Separate alpha indication bit [i]  A sub block may nee"
        "d to read data from the system's memory where the pixel data and the a"
        "lpha transparency data are located in separate buffers.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_CH_PRI_1.
static const field_t hw_ipu_idmac_ch_pri_1[] =
{
    {
        "IDMAC_CH_PRI_0",
        "IDMAC Channel enable bit [i]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_1",
        "IDMAC Channel enable bit [i]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_2",
        "IDMAC Channel enable bit [i]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_3",
        "IDMAC Channel enable bit [i]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_5",
        "IDMAC Channel enable bit [i]",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_8",
        "IDMAC Channel enable bit [i]",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_9",
        "IDMAC Channel enable bit [i]",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_10",
        "IDMAC Channel enable bit [i]",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_11",
        "IDMAC Channel enable bit [i]",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_12",
        "IDMAC Channel enable bit [i]",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_13",
        "IDMAC Channel enable bit [i]",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_14",
        "IDMAC Channel enable bit [i]",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_15",
        "IDMAC Channel enable bit [i]",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_20",
        "IDMAC Channel enable bit [i]",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_21",
        "IDMAC Channel enable bit [i]",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_22",
        "IDMAC Channel enable bit [i]",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_23",
        "IDMAC Channel enable bit [i]",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_24",
        "IDMAC Channel enable bit [i]",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_25",
        "IDMAC Channel enable bit [i]",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_26",
        "IDMAC Channel enable bit [i]",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_27",
        "IDMAC Channel enable bit [i]",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_28",
        "IDMAC Channel enable bit [i]",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_29",
        "IDMAC Channel enable bit [i]",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_CH_PRI_2.
static const field_t hw_ipu_idmac_ch_pri_2[] =
{
    {
        "IDMAC_CH_PRI_8",
        "IDMAC Channel enable bit [i]",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_9",
        "IDMAC Channel enable bit [i]",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_10",
        "IDMAC Channel enable bit [i]",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_11",
        "IDMAC Channel enable bit [i]",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_12",
        "IDMAC Channel enable bit [i]",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_13",
        "IDMAC Channel enable bit [i]",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_14",
        "IDMAC Channel enable bit [i]",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_15",
        "IDMAC Channel enable bit [i]",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_16",
        "IDMAC Channel enable bit [i]",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_17",
        "IDMAC Channel enable bit [i]",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_PRI_18",
        "IDMAC Channel enable bit [i]",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_WM_EN_2.
static const field_t hw_ipu_idmac_wm_en_2[] =
{
    {
        "IDMAC_WM_EN__40",
        "IDMAC Watermark enable bit [i]",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__41",
        "IDMAC Watermark enable bit [i]",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__42",
        "IDMAC Watermark enable bit [i]",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__43",
        "IDMAC Watermark enable bit [i]",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__44",
        "IDMAC Watermark enable bit [i]",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_LOCK_EN_1.
static const field_t hw_ipu_idmac_lock_en_1[] =
{
    {
        "IDMAC_LOCK_EN_5",
        "IDMAC lock bits for channel [i]",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_11",
        "IDMAC lock bits for channel [i]",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_12",
        "IDMAC lock bits for channel [i]",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_14",
        "IDMAC lock bits for channel [i]",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_15",
        "IDMAC lock bits for channel [i]",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_20",
        "IDMAC lock bits for channel [i]",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_21",
        "IDMAC lock bits for channel [i]",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_22",
        "IDMAC lock bits for channel [i]",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_23",
        "IDMAC lock bits for channel [i]",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_27",
        "IDMAC lock bits for channel [i]",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_EN_28",
        "IDMAC lock bits for channel [i]",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_CH_BUSY_1.
static const field_t hw_ipu_idmac_ch_busy_1[] =
{
    {
        "IDMAC_CH_BUSY_0",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_1",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_2",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_3",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_5",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_8",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_9",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_10",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_11",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_12",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_13",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_14",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_15",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_17",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_18",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_20",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_21",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_22",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_23",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_24",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_25",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_26",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_27",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_28",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_29",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_CH_BUSY_2.
static const field_t hw_ipu_idmac_ch_busy_2[] =
{
    {
        "IDMAC_CH_BUSY_33",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_40",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_41",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_42",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_43",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_44",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_45",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_46",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_47",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_48",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_49",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_50",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_51",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDMAC_CH_BUSY_52",
        "IDMAC Channel busy bit [i]  This bit indicates if the channel is curre"
        "ntly served by the IDMAC.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_SEP_ALPHA.
static const field_t hw_ipu_idmac_sep_alpha[] =
{
    {
        "IDMAC_SEP_AL_14",
        "IDMAC Separate alpha indication bit [i]  A sub block may need to read "
        "data from the system's memory where the pixel data and the alpha trans"
        "parency data are located in separate buffers.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SEP_AL_15",
        "IDMAC Separate alpha indication bit [i]  A sub block may need to read "
        "data from the system's memory where the pixel data and the alpha trans"
        "parency data are located in separate buffers.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SEP_AL_23",
        "IDMAC Separate alpha indication bit [i]  A sub block may need to read "
        "data from the system's memory where the pixel data and the alpha trans"
        "parency data are located in separate buffers.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SEP_AL_24",
        "IDMAC Separate alpha indication bit [i]  A sub block may need to read "
        "data from the system's memory where the pixel data and the alpha trans"
        "parency data are located in separate buffers.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SEP_AL_25",
        "IDMAC Separate alpha indication bit [i]  A sub block may need to read "
        "data from the system's memory where the pixel data and the alpha trans"
        "parency data are located in separate buffers.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SEP_AL_27",
        "IDMAC Separate alpha indication bit [i]  A sub block may need to read "
        "data from the system's memory where the pixel data and the alpha trans"
        "parency data are located in separate buffers.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SEP_AL_29",
        "IDMAC Separate alpha indication bit [i]  A sub block may need to read "
        "data from the system's memory where the pixel data and the alpha trans"
        "parency data are located in separate buffers.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_WM_EN_1.
static const field_t hw_ipu_idmac_wm_en_1[] =
{
    {
        "IDMAC_WM_EN__0",
        "IDMAC Watermark enable bit [i]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__1",
        "IDMAC Watermark enable bit [i]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__2",
        "IDMAC Watermark enable bit [i]",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__3",
        "IDMAC Watermark enable bit [i]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__8",
        "IDMAC Watermark enable bit [i]",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__10",
        "IDMAC Watermark enable bit [i]",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__12",
        "IDMAC Watermark enable bit [i]",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__13",
        "IDMAC Watermark enable bit [i]",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__14",
        "IDMAC Watermark enable bit [i]",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__23",
        "IDMAC Watermark enable bit [i]",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__24",
        "IDMAC Watermark enable bit [i]",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__25",
        "IDMAC Watermark enable bit [i]",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__26",
        "IDMAC Watermark enable bit [i]",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__27",
        "IDMAC Watermark enable bit [i]",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__28",
        "IDMAC Watermark enable bit [i]",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_WM_EN__29",
        "IDMAC Watermark enable bit [i]",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_SC_CORD_1.
static const field_t hw_ipu_idmac_sc_cord_1[] =
{
    {
        "SY1",
        "Scroll Y coordination (2nd set)  This field indicates the Y coordinate"
        " of the scroll.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SX1",
        "Scroll X coordination (2nd set)  This field indicates the X coordinate"
        " of the scroll.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_CH_EN_2.
static const field_t hw_ipu_idmac_ch_en_2[] =
{
    {
        "IDMAC_CH_EN_33",
        "IDMAC Channel enable bit [i]",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_40",
        "IDMAC Channel enable bit [i]",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_41",
        "IDMAC Channel enable bit [i]",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_42",
        "IDMAC Channel enable bit [i]",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_43",
        "IDMAC Channel enable bit [i]",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_44",
        "IDMAC Channel enable bit [i]",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_45",
        "IDMAC Channel enable bit [i]",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_46",
        "IDMAC Channel enable bit [i]",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_47",
        "IDMAC Channel enable bit [i]",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_48",
        "IDMAC Channel enable bit [i]",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_49",
        "IDMAC Channel enable bit [i]",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_50",
        "IDMAC Channel enable bit [i]",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_51",
        "IDMAC Channel enable bit [i]",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_CH_EN_52",
        "IDMAC Channel enable bit [i]",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_LOCK_EN_2.
static const field_t hw_ipu_idmac_lock_en_2[] =
{
    {
        "IDMAC_LOCK_45",
        "IDMAC lock bits for channel [i]",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_46",
        "IDMAC lock bits for channel [i]",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_47",
        "IDMAC lock bits for channel [i]",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_48",
        "IDMAC lock bits for channel [i]",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_49",
        "IDMAC lock bits for channel [i]",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_LOCK_50",
        "IDMAC lock bits for channel [i]",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_SUB_ADDR_2.
static const field_t hw_ipu_idmac_sub_addr_2[] =
{
    {
        "IDMAC_SUB_ADDR_41",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR_51",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR_52",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_SUB_ADDR_3.
static const field_t hw_ipu_idmac_sub_addr_3[] =
{
    {
        "IDMAC_SUB_ADDR_9",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR_10",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR_13",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR_27",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_BNDM_EN_1.
static const field_t hw_ipu_idmac_bndm_en_1[] =
{
    {
        "IDMAC_BNDM_EN_0",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_1",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_2",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_3",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_5",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_11",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_12",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_20",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_21",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_22",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_25",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_26",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_DEBUG_CNT.
static const field_t hw_ipu_dp_debug_cnt[] =
{
    {
        "BRAKE_STATUS_EN_0",
        "This bit enables the break/status unit #0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRAKE_CNT_0",
        "The async flow can be broken multiple times.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRAKE_STATUS_EN_1",
        "This bit enables the break/status unit #1",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRAKE_CNT_1",
        "The async flow can be broken multiple times.",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_DEBUG_STAT.
static const field_t hw_ipu_dp_debug_stat[] =
{
    {
        "V_CNT_OLD_0",
        "The exact row where the async flow has been broken (This filed is rele"
        "vant for debug unit #0)",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FG_ACTIVE_0",
        "Displaying the partial frame has been started for async flow (This fil"
        "ed is relevant for debug unit #0)",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMBYP_EN_OLD_0",
        "the async flow has been broken in the middle of combining (This filed "
        "is relevant for debug unit #0)",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CYP_EN_OLD_0",
        "The async flow has been broken in the middle of a cursor (This filed i"
        "s relevant for debug unit #0)",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "V_CNT_OLD_1",
        "The exact row where the async flow has been broken (This filed is rele"
        "vant for debug unit #0)",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FG_ACTIVE_1",
        "Displaying the partial frame has been started (This filed is relevant "
        "for debug unit #1)",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMBYP_EN_OLD_1",
        "the async1 flow has been broken in the middle of combining (This filed"
        " is relevant for debug unit #1)",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CYP_EN_OLD_1",
        "The async flow has been broken in the middle of a cursor (This filed i"
        "s relevant for debug unit #1)",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_CONF.
static const field_t hw_ipu_ic_conf[] =
{
    {
        "PRPENC_EN",
        "Preprocessing Task for encoding enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPENC_CSC1",
        "Preprocessing Task for encoding color conversion enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPENC_ROT_EN",
        "Preprocessing Rotation Task for encoding enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_EN",
        "Preprocessing Task for View-Finder enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_CSC1",
        "Pre-processing task for view-finder first color conversion enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_CSC2",
        "Reserved",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_CMB",
        "Preprocessing Task for View-Finder combining enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_ROT_EN",
        "Preprocessing Rotation Task for viewfinder enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_EN",
        "Post-Processing Task enable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_CSC1",
        "Post-Processing Task color conversion YUV-->RGB enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_CSC2",
        "Post-Processing Task color conversion RGB-->YUV enable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_CMB",
        "Post-Processing Task combining enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_ROT_EN",
        "Post-Processing Rotation Task enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_GLB_LOC_A",
        "Global Alpha.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_KEY_COLOR_EN",
        "Key Color enable.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWS_EN",
        "Raw sensor enable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_MEM_WR_EN",
        "CSI direct memory write enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_PRP_ENC_RSC.
static const field_t hw_ipu_ic_prp_enc_rsc[] =
{
    {
        "PRPENC_RS_R_H",
        "Preprocessing task for encoding Resizing horizontal Ratio.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPENC_DS_R_H",
        "Preprocessing task for encoding Downsizing horizontal Ratio.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPENC_RS_R_V",
        "Preprocessing task for encoding Resizing vertical Ratio.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPENC_DS_R_V",
        "Preprocessing task for encoding Downsizing vertical Ratio.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_PRP_VF_RSC.
static const field_t hw_ipu_ic_prp_vf_rsc[] =
{
    {
        "PRPVF_RS_R_H",
        "Preprocessing task for view-finding resizing horizontal ratio.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_DS_R_H",
        "Preprocessing task for encoding Downsizing horizontal Ratio.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_RS_R_V",
        "Preprocessing task for encoding Resizing vertical Ratio.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRPVF_DS_R_V",
        "Preprocessing task for encoding Downsizing vertical Ratio.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_PP_RSC.
static const field_t hw_ipu_ic_pp_rsc[] =
{
    {
        "PP_RS_R_H",
        "Post-Processing task Resizing horizontal Ratio.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_DS_R_H",
        "Post-Processing task Downsizing horizontal Ratio.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_RS_R_V",
        "Post-Processing task Resizing vertical Ratio.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP_DS_R_V",
        "Post-Processing task Downsizing vertical Ratio.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_CMBP_1.
static const field_t hw_ipu_ic_cmbp_1[] =
{
    {
        "IC_PRPVF_ALPHA_V",
        "Preprocessing task for viewfinder Global Alpha.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_PP_ALPHA_V",
        "Post-Processing task Global Alpha.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_CMBP_2.
static const field_t hw_ipu_ic_cmbp_2[] =
{
    {
        "IC_KEY_COLOR_B",
        "Key Color Blue.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_KEY_COLOR_G",
        "Key Color Green.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IC_KEY_COLOR_R",
        "Key Color Red.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_IDMAC_1.
static const field_t hw_ipu_ic_idmac_1[] =
{
    {
        "CB0_BURST_16",
        "This bit defines the number of active cycles within a burst (burst siz"
        "e) coming from the IDMAC for IC's CB0  For pixel data the number of pi"
        "xels should match the NPB[6:2] value on the IDMAC's CPMEM",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB1_BURST_16",
        "This bit defines the number of active cycles within a burst (burst siz"
        "e) coming from the IDMAC for IC's CB1  For pixel data the number of pi"
        "xels should match the NPB[6:2] value on the IDMAC's CPMEM",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB2_BURST_16",
        "This bit defines the number of active cycles within a burst (burst siz"
        "e) coming from the IDMAC for IC's CB2  For pixel data the number of pi"
        "xels should match the NPB[6:2] value on the IDMAC's CPMEM",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB3_BURST_16",
        "This bit defines the number of active cycles within a burst (burst siz"
        "e) coming from the IDMAC for IC's CB3  For pixel data the number of pi"
        "xels should match the NPB[6:2] value on the IDMAC's CPMEM",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB4_BURST_16",
        "This bit defines the number of active cycles within a burst (burst siz"
        "e) coming from the IDMAC for IC's CB4  For pixel data the number of pi"
        "xels should match the NPB[6:2] value on the IDMAC's CPMEM",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB5_BURST_16",
        "This bit defines the number of active cycles within a burst (burst siz"
        "e) coming from the IDMAC for IC's CB5  For pixel data the number of pi"
        "xels should match the NPB[6:2] value on the IDMAC's CPMEM",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB6_BURST_16",
        "This bit defines the number of active cycles within a burst (burst siz"
        "e) coming from the IDMAC for IC's CB6  For pixel data the number of pi"
        "xels should match the NPB[6:2] value on the IDMAC's CPMEM",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB7_BURST_16",
        "This bit defines the number of active cycles within a burst (burst siz"
        "e) coming from the IDMAC for IC's CB7  For pixel data the number of pi"
        "xels should match the NPB[6:2] value on the IDMAC's CPMEM",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T1_ROT",
        "Rotation for Encoding (ENC) task  The value of this field must be iden"
        "tical to the corresponding channel's ROT parameters in the IDMAC's CPM"
        "EM",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T1_FLIP_LR",
        "LEFT/RIGHT flip for Encoding (ENC) task; this bit affect the flipping "
        "done on the rotation unit  The value of this field must be identical t"
        "o the corresponding channel's HF parameter in the IDMAC's CPMEM",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T1_FLIP_UD",
        "UP/DOWN flip for Encoding (ENC) task  The value of this field must be "
        "identical to the corresponding channel's VF parameters in the IDMAC's "
        "CPMEM",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T2_ROT",
        "Rotation for View Finder (VF) task  The value of this field must be id"
        "entical to the corresponding channel's ROT parameters in the IDMAC's C"
        "PMEM",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T2_FLIP_LR",
        "LEFT/RIGHT flip for View Finder (VF) task; this bit affect the flippin"
        "g done on the rotation unit  The value of this field must be identical"
        " to the corresponding channel's HF parameter in the IDMAC's CPMEM",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T2_FLIP_UD",
        "UP/DOWN flip for View Finder (VF) task  The value of this field must b"
        "e identical to the corresponding channel's VF parameters in the IDMAC'"
        "s CPMEM",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T3_ROT",
        "Rotation for Post Processing (PP) task  The value of this field must b"
        "e identical to the corresponding channel's ROT parameters in the IDMAC"
        "'s CPMEM",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T3_FLIP_LR",
        "LEFT/RIGHT flip for Post Processing (PP) task; this bit affect the fli"
        "pping done on the rotation unit  The value of this field must be ident"
        "ical to the corresponding channel's HF parameter in the IDMAC's CPMEM",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T3_FLIP_UD",
        "UP/DOWN flip for Post Processing (PP) task  The value of this field mu"
        "st be identical to the corresponding channel's VF parameters in the ID"
        "MAC's CPMEM",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T1_FLIP_RS",
        "LEFT/RIGHT flip for Encoding (ENC) task; this bit affect the flipping "
        "done on the resizing unit.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T2_FLIP_RS",
        "LEFT/RIGHT flip for View Finder (VF) task; this bit affect the flippin"
        "g done on the resizing unit.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T3_FLIP_RS",
        "LEFT/RIGHT flip for Post Processing (PP) task; his bit affect the flip"
        "ping done on the resizing unit.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALT_CB6_BURST_16",
        "Reserved",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALT_CB7_BURST_16",
        "Reserved",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_IDMAC_2.
static const field_t hw_ipu_ic_idmac_2[] =
{
    {
        "T1_FR_HEIGHT",
        "Frame Height for Encoding (ENC) task  The value of this field must be "
        "identical to corresponding FH channel's parameters in the IDMAC's CPME"
        "M.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T2_FR_HEIGHT",
        "Frame Height for View Finder (VF) task  The value of this field must b"
        "e identical to the corresponding FH channel's parameters in the IDMAC'"
        "s CPMEM.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T3_FR_HEIGHT",
        "Frame Height for Post Processing (PP) task  The value of this field mu"
        "st be identical to the corresponding FH channel's parameters in the ID"
        "MAC's CPMEM.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_IDMAC_3.
static const field_t hw_ipu_ic_idmac_3[] =
{
    {
        "T1_FR_WIDTH",
        "Frame Width for Encoding (ENC) task  The value of this field must be i"
        "dentical to corresponding FW channel's parameters in the IDMAC's CPMEM"
        ".",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T2_FR_WIDTH",
        "Frame Width for View Finder (VF) task  The value of this field must be"
        " identical to the corresponding FW channel's parameters in the IDMAC's"
        " CPMEM.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "T3_FR_WIDTH",
        "Frame Width for Post Processing (PP) task  The value of this field mus"
        "t be identical to the corresponding FW channel's parameters in the IDM"
        "AC's CPMEM.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IC_IDMAC_4.
static const field_t hw_ipu_ic_idmac_4[] =
{
    {
        "MPM_RW_BRDG_MAX_RQ",
        "MPM memory Bridge Max Requests between MPM's read and writes",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPM_DMFC_BRDG_MAX_RQ",
        "MPM memory Bridge Max Requests for the IC DMFC interface",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBM_BRDG_MAX_RQ",
        "IBM memory Bridge Max Requests",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RM_BRDG_MAX_RQ",
        "RM memory Bridge Max Requests",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_SENS_CONF.
static const field_t hw_ipu_csi0_sens_conf[] =
{
    {
        "CSI0_VSYNC_POL",
        "Invert IPP_IND_SENSB_VSYNC input.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_HSYNC_POL",
        "Invert IPP_IND_SENSB_HSYNC input.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_DATA_POL",
        "Invert data input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SENS_PIX_CLK_POL",
        "Invert Pixel clock input.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SENS_PRTCL",
        "Sensor Protocol.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_PACK_TIGHT",
        "CSI0 Pack Tight  When the data format is YUV or RGB and the component'"
        "s width is 9-16 bits, it can be sent to the memory in 2 different ways"
        ".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SENS_DATA_FORMAT",
        "Data format from the sensor.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_DATA_WIDTH",
        "Data width.",
        11, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_EXT_VSYNC",
        "External VSYNC enable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_DIV_RATIO",
        "DIV Ratio Clock division ratio minus 1.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_DATA_DEST",
        "These bits enable the destination of the data coming from the CSI.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_JPEG8_EN",
        "JPEG8 enable bit",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_JPEG_MODE",
        "JPEG Mode - this bit defines the mode of the control signals when work"
        "ing in JPEG mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_FORCE_EOF",
        "Force End of frame  This is a self clear bit allowing the user to forc"
        "e an End-of-frame event; This bit can be used in cases where the frame"
        " sent by the sensor was not completed.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_DATA_EN_POL",
        "Invert IPP_IND_SENSB_DATA_EN input.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_SENS_FRM_SIZE.
static const field_t hw_ipu_csi0_sens_frm_size[] =
{
    {
        "CSI0_SENS_FRM_WIDTH",
        "Sensor frame width minus 1.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SENS_FRM_HEIGHT",
        "Sensor frame height minus 1.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_ACT_FRM_SIZE.
static const field_t hw_ipu_csi0_act_frm_size[] =
{
    {
        "CSI0_ACT_FRM_WIDTH",
        "Actual frame width minus 1.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_ACT_FRM_HEIGHT",
        "Actual frame height minus 1.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_OUT_FRM_CTRL.
static const field_t hw_ipu_csi0_out_frm_ctrl[] =
{
    {
        "CSI0_VSC",
        "Vertical skip.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_HSC",
        "Horizontal skip.",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_VERT_DWNS",
        "Enable vertical downsizing (decimation) by 2.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_HORZ_DWNS",
        "Enable horizontal downsizing (decimation) by 2.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_TST_CTRL.
static const field_t hw_ipu_csi0_tst_ctrl[] =
{
    {
        "PG_R_VALUE",
        "Pattern generator R value.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PG_G_VALUE",
        "Pattern generator G value.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PG_B_VALUE",
        "Pattern generator B value.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_GEN_MODE",
        "Test generator mode.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_CCIR_CODE_1.
static const field_t hw_ipu_csi0_ccir_code_1[] =
{
    {
        "CSI0_END_FLD0_BLNK_1ST",
        "End of field 0 first blanking line command (interlaces mode).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_STRT_FLD0_BLNK_1ST",
        "Start of field 0 first blanking line command (interlaces mode).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_END_FLD0_BLNK_2ND",
        "End of field 0 second blanking line command (interlaces mode).",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_STRT_FLD0_BLNK_2ND",
        "Start of field 0 second blanking line command (interlaces mode).",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_END_FLD0_ACTV",
        "End of field 0 active line command (interlaces mode).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_STRT_FLD0_ACTV",
        "Start of field 0 active line command (interlaces mode).",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CCIR_ERR_DET_EN",
        "Enable error detection and correction for CCIR interlaced mode with pr"
        "otection bit.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_CCIR_CODE_2.
static const field_t hw_ipu_csi0_ccir_code_2[] =
{
    {
        "CSI0_END_FLD1_BLNK_1ST",
        "End of field 1 first blanking line command (interlaces mode).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_STRT_FLD1_BLNK_1ST",
        "Start of field 1 first blanking line command (interlaces mode).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_END_FLD1_BLNK_2ND",
        "End of field 1 second blanking line command (interlaces mode).",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_STRT_FLD1_BLNK_2ND",
        "Start of field 1 second blanking line command (interlaces mode).",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_END_FLD1_ACTV",
        "End of field 1 active line command (interlaces mode).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_STRT_FLD1_ACTV",
        "Start of field 1 active line command (interlaces mode).",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_CCIR_CODE_3.
static const field_t hw_ipu_csi0_ccir_code_3[] =
{
    {
        "CSI0_CCIR_PRECOM",
        "CCIR pre command.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_DI.
static const field_t hw_ipu_csi0_di[] =
{
    {
        "CSI0_MIPI_DI0",
        "CSI0_MIPI_DI0   This field holds the Data Identifier #0 handled by the"
        " CSI; This is the main stream.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_MIPI_DI1",
        "CSI0_MIPI_DI1   This field holds the Data Identifier #1 handled by the"
        " CSI",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_MIPI_DI2",
        "CSI0_MIPI_DI2   This field holds the Data Identifier #2 handled by the"
        " CSI.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_MIPI_DI3",
        "CSI0_MIPI_DI3   This field holds the Data Identifier #3 handled by the"
        " CSI.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_SKIP.
static const field_t hw_ipu_csi0_skip[] =
{
    {
        "CSI0_MAX_RATIO_SKIP_SMFC",
        "CSI0 Maximum Ratio Skip for SMFC  These bits define the number of fram"
        "es in a skipping set.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SKIP_SMFC",
        "CSI0 SKIP SMFC  These 5 bits define the skipping pattern of the frames"
        " send to the SMFC.",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_ID_2_SKIP",
        "CSI0 to SMFC Skipping ID.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_MAX_RATIO_SKIP_ISP",
        "Reserved",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SKIP_ISP",
        "Reserved",
        19, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_CTRL.
static const field_t hw_ipu_csio_cpd_ctrl[] =
{
    {
        "CSI0_GREEN_P_BEGIN",
        "Color of first component in the frame.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_RED_ROW_BEGIN",
        "Color of first row in the frame.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD",
        "CSI0_CPD  These bits enable the compander in the path to different des"
        "tination.",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_RC_I.
static const field_t hw_ipu_csio_cpd_rc_i[] =
{
    {
        "CSI0_CPD_RC1",
        "CONSTANT <2*i> parameter of Compander, Red component.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_RC",
        "CONSTANT <2*i+1> parameter of Compander, Red component.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_RS_I.
static const field_t hw_ipu_csio_cpd_rs_i[] =
{
    {
        "CSI0_CPD_RS3",
        "Reserved",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_RS2",
        "Reserved",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_RS1",
        "Reserved",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_RS",
        "Reserved",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_GRC_I.
static const field_t hw_ipu_csio_cpd_grc_i[] =
{
    {
        "CSI0_CPD_GRC1",
        "Reserved",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_GRC",
        "Reserved",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_GRS_I.
static const field_t hw_ipu_csio_cpd_grs_i[] =
{
    {
        "CSI0_CPD_GRS3",
        "Reserved",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_GRS2",
        "Reserved",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_GRS1",
        "Reserved",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_GRS",
        "Reserved",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_GBC_I.
static const field_t hw_ipu_csio_cpd_gbc_i[] =
{
    {
        "CSI0_CPD_GBC1",
        "Reserved",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_GBC",
        "Reserved",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_GBS_I.
static const field_t hw_ipu_csio_cpd_gbs_i[] =
{
    {
        "CSI0_CPD_GBS3",
        "Reserved",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_GBS2",
        "Reserved",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_GBS1",
        "Reserved",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_GBS",
        "Reserved",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_BC_I.
static const field_t hw_ipu_csio_cpd_bc_i[] =
{
    {
        "CSI0_CPD_BC1",
        "Reserved",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_BC",
        "Reserved",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSIO_CPD_BS_I.
static const field_t hw_ipu_csio_cpd_bs_i[] =
{
    {
        "CSI0_CPD_BS3",
        "Reserved  l",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_BS2",
        "Reserved",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_BS1",
        "Reserved",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_BS",
        "Reserved",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_CPD_OFFSET1.
static const field_t hw_ipu_csi0_cpd_offset1[] =
{
    {
        "CSI0_GR_OFFSET",
        "Reserved",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_GB_OFFSET",
        "Reserved",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_CPD_B_OFFSET",
        "Reserved",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI0_CPD_OFFSET2.
static const field_t hw_ipu_csi0_cpd_offset2[] =
{
    {
        "CSI0_CPD_R_OFFSET",
        "CSI0 Red component offset  The value is between -512 to 511.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_SENS_CONF.
static const field_t hw_ipu_csi1_sens_conf[] =
{
    {
        "CSI1_VSYNC_POL",
        "Invert IPP_IND_SENSB_VSYNC input.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_HSYNC_POL",
        "Invert IPP_IND_SENSB_HSYNC input.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_DATA_POL",
        "Invert data input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SENS_PIX_CLK_POL",
        "Invert Pixel clock input.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SENS_PRTCL",
        "Sensor Protocol.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_PACK_TIGHT",
        "CSI1 Pack Tight   When the data format is YUV or RGB and the component"
        "'s width is 9-16 bits, it can be sent to the memory in 2 different way"
        "s",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SENS_DATA_FORMAT",
        "Data format from the sensor.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_DATA_WIDTH",
        "Data width.",
        11, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_EXT_VSYNC",
        "External VSYNC enable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_DIV_RATIO",
        "DIV Ratio Clock division ratio minus 1.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_DATA_DEST",
        "These bits enable the destination of the data coming from the CSI.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_JPEG8_EN",
        "JPEG8 enable bit",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_JPEG_MODE",
        "JPEG Mode - this bit defines the mode of the control signals when work"
        "ing in JPEG mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_FORCE_EOF",
        "Force End of frame  This is a self clear bit allowing the user to forc"
        "e an End-of-frame event; This bit can be used in cases where the frame"
        " sent by the sensor was not completed.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_DATA_EN_POL",
        "Invert IPP_IND_SENSB_DATA_EN input.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_SENS_FRM_SIZE.
static const field_t hw_ipu_csi1_sens_frm_size[] =
{
    {
        "CSI1_SENS_FRM_WIDTH",
        "Sensor frame width minus 1.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SENS_FRM_HEIGHT",
        "Sensor frame height minus 1.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_ACT_FRM_SIZE.
static const field_t hw_ipu_csi1_act_frm_size[] =
{
    {
        "CSI1_ACT_FRM_WIDTH",
        "Actual frame width minus 1.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_ACT_FRM_HEIGHT",
        "Actual frame height minus 1.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_OUT_FRM_CTRL.
static const field_t hw_ipu_csi1_out_frm_ctrl[] =
{
    {
        "CSI1_VSC",
        "Vertical skip.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_HSC",
        "Horizontal skip.",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_VERT_DWNS",
        "Enable vertical downsizing (decimation) by 2.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_HORZ_DWNS",
        "Enable horizontal downsizing (decimation) by 2.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_TST_CTRL.
static const field_t hw_ipu_csi1_tst_ctrl[] =
{
    {
        "PG_R_VALUE",
        "Pattern generator R value.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PG_G_VALUE",
        "Pattern generator G value.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PG_B_VALUE",
        "Pattern generator B value.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_GEN_MODE",
        "Test generator mode.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CCIR_CODE_1.
static const field_t hw_ipu_csi1_ccir_code_1[] =
{
    {
        "CSI1_END_FLD0_BLNK_1ST",
        "End of field 0 first blanking line command (interlaces mode).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_STRT_FLD0_BLNK_1ST",
        "Start of field 0 first blanking line command (interlaces mode).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_END_FLD0_BLNK_2ND",
        "End of field 0 second blanking line command (interlaces mode).",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_STRT_FLD0_BLNK_2ND",
        "Start of field 0 second blanking line command (interlaces mode).",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_END_FLD0_ACTV",
        "End of field 0 active line command (interlaces mode).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_STRT_FLD0_ACTV",
        "Start of field 0 active line command (interlaces mode).",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CCIR_ERR_DET_EN",
        "Enable error detection and correction for CCIR interlaced mode with pr"
        "otection bit.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CCIR_CODE_2.
static const field_t hw_ipu_csi1_ccir_code_2[] =
{
    {
        "CSI1_END_FLD1_BLNK_1ST",
        "End of field 1 first blanking line command (interlaces mode).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_STRT_FLD1_BLNK_1ST",
        "Start of field 1 first blanking line command (interlaces mode).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_END_FLD1_BLNK_2ND",
        "End of field 1 second blanking line command (interlaces mode).",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_STRT_FLD1_BLNK_2ND",
        "Start of field 1 second blanking line command (interlaces mode).",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_END_FLD1_ACTV",
        "End of field 1 active line command (interlaces mode).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_STRT_FLD1_ACTV",
        "Start of field 1 active line command (interlaces mode).",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CCIR_CODE_3.
static const field_t hw_ipu_csi1_ccir_code_3[] =
{
    {
        "CSI1_CCIR_PRECOM",
        "CCIR pre command.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_DI.
static const field_t hw_ipu_csi1_di[] =
{
    {
        "CSI1_MIPI_DI0",
        "CSI1_MIPI_DI0  This field holds the Data Identifier #0 handled by the "
        "CSI; This is the main stream.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_MIPI_DI1",
        "CSI1_MIPI_DI1  This field holds the Data Identifier #1 handled by the "
        "CSI",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_MIPI_DI2",
        "CSI1_MIPI_DI2  This field holds the Data Identifier #2 handled by the "
        "CSI.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_MIPI_DI3",
        "CSI1_MIPI_DI3   This field holds the Data Identifier #3 handled by the"
        " CSI.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_SKIP.
static const field_t hw_ipu_csi1_skip[] =
{
    {
        "CSI1_MAX_RATIO_SKIP_SMFC",
        "CSI1 Maximum Ratio Skip for SMFC  These bits define the number of fram"
        "es in a skipping set.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SKIP_SMFC",
        "CSI1 SKIP SMFC  These 5 bits define the skipping pattern of the frames"
        " send to the SMFC.",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_ID_2_SKIP",
        "CSI1 to SMFC Skipping ID.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_MAX_RATIO_SKIP_ISP",
        "Reserved",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SKIP_ISP",
        "Reserved",
        19, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_CTRL.
static const field_t hw_ipu_csi1_cpd_ctrl[] =
{
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_RC_I.
static const field_t hw_ipu_csi1_cpd_rc_i[] =
{
    {
        "CSI1_CPD_RC1",
        "CONSTANT <2*i> parameter of Compander, Red component.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_RC",
        "CONSTANT <2*i+1> parameter of Compander, Red component.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_RS_I.
static const field_t hw_ipu_csi1_cpd_rs_i[] =
{
    {
        "CSI1_CPD_RS3",
        "SLOPE<4*i> parameter of Compander, Red component.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_RS2",
        "SLOPE<4*i+1> parameter of Compander, Red component.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_RS1",
        "SLOPE<4*i+2> parameter of Compander, Red component.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_RS",
        "SLOPE<4*i+3> parameter of Compander, Red component.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_GRC_I.
static const field_t hw_ipu_csi1_cpd_grc_i[] =
{
    {
        "CSI1_CPD_GRC1",
        "CONSTANT<2*i> parameter of Compander, GR component.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GRC",
        "CONST<2*i+1> parameter of Compander, GR component.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_GRS_I.
static const field_t hw_ipu_csi1_cpd_grs_i[] =
{
    {
        "CSI1_CPD_GRS3",
        "SLOPE<4*i> parameter of Compander, GR component.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GRS2",
        "SLOPE<4*i+1> parameter of Compander, GR component.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GRS1",
        "SLOPE<4*i+2> parameter of Compander, GR component.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GRS",
        "SLOPE<4*i+3> parameter of Compander, GR component.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_GBC_I.
static const field_t hw_ipu_csi1_cpd_gbc_i[] =
{
    {
        "CSI1_CPD_GBC1",
        "CONSTANTi parameter of Compander, GB component.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GBC",
        "CONSTi+1 parameter of Compander, GB component.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_GBS_I.
static const field_t hw_ipu_csi1_cpd_gbs_i[] =
{
    {
        "CSI1_CPD_GBS3",
        "SLOPE<4*i> parameter of Compander, GB component.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GBS2",
        "SLOPE<4*i+1> parameter of Compander, GB component.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GBS1",
        "SLOPE<4*i+2> parameter of Compander, GB component.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GBS",
        "SLOPE<4*i+3> parameter of Compander, GB component.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_BC_I.
static const field_t hw_ipu_csi1_cpd_bc_i[] =
{
    {
        "CSI1_CPD_BC1",
        "CONSTANT<2*i> parameter of Compander, Blue component.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_BC",
        "CONSTANT<2*i+1> parameter of Compander, Blue component.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_BS_I.
static const field_t hw_ipu_csi1_cpd_bs_i[] =
{
    {
        "CSI1_CPD_BS3",
        "SLOPE<4*i> parameter of Compander, Blue component.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_BS2",
        "SLOPE<4*i+1> parameter of Compander, Blue component.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_BS1",
        "SLOPE<4*i+2> parameter of Compander, Blue component.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_BS",
        "SLOPE<4*i+3> parameter of Compander, Blue component.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_OFFSET1.
static const field_t hw_ipu_csi1_cpd_offset1[] =
{
    {
        "CSI1_CPD_GR_OFFSET",
        "CSI1 Green Red component offset  The value is between -512 to 511.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_GB_OFFSET",
        "CSI1 Green Blue component offset  The value is between -512 to 511.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_CPD_B_OFFSET",
        "CSI1 Blue component offset  The value is between -512 to 511.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_CSI1_CPD_OFFSET2.
static const field_t hw_ipu_csi1_cpd_offset2[] =
{
    {
        "CSI1_CPD_R_OFFSET",
        "CSI1 Red component offset  The value is between -512 to 511.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_GENERAL.
static const field_t hw_ipu_di0_general[] =
{
    {
        "DI0_POLARITY",
        "DI0 output pin's polarity  This bits define the polarity of each of th"
        "e DI's outputs.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_POLARITY_CS0",
        "DI0 Chip Select's 0 polarity  This bits define the polarity of the DI'"
        "s CS0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_POLARITY_CS1",
        "DI0 Chip Select's 1 polarity  This bits define the polarity of the DI'"
        "s CS1.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_ERM_VSYNC_SEL",
        "DI0 error recovery block's VSYNC source select  The error recovery blo"
        "ck detect a case where the DI's VSYNC is asserted before the EOF.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_ERR_TREATMENT",
        "In case of synchronous flow error there are 2 ways to handle the displ"
        "ay",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SYNC_COUNT_SEL",
        "For synchronous flow error: selects synchronous flow synchronization c"
        "ounter in DI:",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_POLARITY_DISP_CLK",
        "DI0 Output Clock's polarity  This bits define the polarity of the DI0'"
        "s clock.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_WATCHDOG_MODE",
        "DI0 watchdog mode  In case of a display error where the DI clock is st"
        "opped (defined at di0_err_treatment).",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CLK_EXT",
        "DI0 External Clock.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_VSYNC_EXT",
        "DI0 External VSYNC.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_MASK_SEL",
        "DI0 Mask select.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DISP_CLOCK_INIT",
        "Display clock's initial mode  For synchronization error conditions the"
        " display clock can be stopped on the next VSYNC",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CLOCK_STOP_MODE",
        "DI clock stop mode  When performing a clock change.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DISP_Y_SEL",
        "DI0 Display Vertical coordinate (Y) select.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PIN8_PIN15_SEL",
        "This bit routes PIN8 over PIN15",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_BS_CLKGEN0.
static const field_t hw_ipu_di0_bs_clkgen0[] =
{
    {
        "DI0_DISP_CLK_PERIOD",
        "DI0 Display Clock Period  This field defines the Display interface clo"
        "ck period for display write access.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DISP_CLK_OFFSET",
        "DI0 Display Clock Offset  The DI has the ability to delay the display'"
        "s clock  This field defines the amount of IPU's clock cycles added as "
        "delay on this clock.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_BS_CLKGEN1.
static const field_t hw_ipu_di0_bs_clkgen1[] =
{
    {
        "DI0_DISP_CLK_UP",
        "DI0 display clock rising edge position  This parameter contains an int"
        "eger part (bits 8:1) and a fractional part (bit 0).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DISP_CLK_DOWN",
        "DI0 display clock falling edge position  This parameter contains an in"
        "teger part (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_1.
static const field_t hw_ipu_di0_sw_gen0_1[] =
{
    {
        "DI0_OFFSET_RESOLUTION_1",
        "DI0 counter #1 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_1",
        "DI0 counter #1 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_1",
        "DI0 counter #1 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_1",
        "DI0 counter #1 pre defined value  This fields defines the counter #1 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_2.
static const field_t hw_ipu_di0_sw_gen0_2[] =
{
    {
        "DI0_OFFSET_RESOLUTION_2",
        "DI0 counter #2 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_2",
        "DI0 counter #2 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_2",
        "DI0 counter #2 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_2",
        "DI0 counter #2 pre defined value  This fields defines the counter #2 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_3.
static const field_t hw_ipu_di0_sw_gen0_3[] =
{
    {
        "DI0_OFFSET_RESOLUTION_3",
        "DI0 counter #3 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_3",
        "DI0 counter #3 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_3",
        "DI0 counter #3 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_3",
        "DI0 counter #3 pre defined value  This fields defines the counter #3 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_4.
static const field_t hw_ipu_di0_sw_gen0_4[] =
{
    {
        "DI0_OFFSET_RESOLUTION_4",
        "DI0 counter #4 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_4",
        "DI0 counter #4 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_4",
        "DI0 counter #4 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_4",
        "DI0 counter #4 pre defined value  This fields defines the counter #4 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_5.
static const field_t hw_ipu_di0_sw_gen0_5[] =
{
    {
        "DI0_OFFSET_RESOLUTION_5",
        "DI0 counter #5 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_5",
        "DI0 counter #5 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_5",
        "DI0 counter #5 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_5",
        "DI0 counter #5 pre defined value  This fields defines the counter #5 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_6.
static const field_t hw_ipu_di0_sw_gen0_6[] =
{
    {
        "DI0_OFFSET_RESOLUTION_6",
        "DI0 counter #6 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_6",
        "DI0 counter #6 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_6",
        "DI0 counter #6 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_6",
        "DI0 counter #6 pre defined value  This fields defines the counter #6 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_7.
static const field_t hw_ipu_di0_sw_gen0_7[] =
{
    {
        "DI0_OFFSET_RESOLUTION_1",
        "DI0 counter #7 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_7",
        "DI0 counter #7 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_7",
        "DI0 counter #1 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_7",
        "DI0 counter #7 pre defined value  This fields defines the counter #7 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_8.
static const field_t hw_ipu_di0_sw_gen0_8[] =
{
    {
        "DI0_OFFSET_RESOLUTION_8",
        "DI0 counter #8 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_8",
        "DI0 counter #8 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_8",
        "DI0 counter #8 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_8",
        "DI0 counter #8 pre defined value  This fields defines the counter #8 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN0_9.
static const field_t hw_ipu_di0_sw_gen0_9[] =
{
    {
        "DI0_OFFSET_RESOLUTION_9",
        "DI0 counter #9 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_OFFSET_VALUE_9",
        "DI0 counter #9 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_RESOLUTION_9",
        "DI0 counter #9 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_RUN_VALUE_M1_9",
        "DI0 counter #9 pre defined value  This fields defines the counter #9 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_1.
static const field_t hw_ipu_di0_sw_gen1_1[] =
{
    {
        "DI0_CNT_UP_1",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_CLR_SEL_1",
        "DI0 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_TRIGGER_SEL_1",
        "DI0 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_1",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_1",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_1",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_GEN_EN_1",
        "DI0 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_2.
static const field_t hw_ipu_di0_sw_gen1_2[] =
{
    {
        "DI0_CNT_UP_2",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_CLR_SEL_2",
        "DI0 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_TRIGGER_SEL_2",
        "DI0 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_2",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_2",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_2",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_GEN_EN_2",
        "DI0 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_3.
static const field_t hw_ipu_di0_sw_gen1_3[] =
{
    {
        "DI0_CNT_UP_3",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_CLR_SEL_3",
        "DI0 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_TRIGGER_SEL_3",
        "DI0 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_3",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_3",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_3",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_GEN_EN_3",
        "DI0 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_4.
static const field_t hw_ipu_di0_sw_gen1_4[] =
{
    {
        "DI0_CNT_UP_4",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_CLR_SEL_4",
        "DI0 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_TRIGGER_SEL_4",
        "DI0 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_4",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_4",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_4",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_GEN_EN_4",
        "DI0 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_5.
static const field_t hw_ipu_di0_sw_gen1_5[] =
{
    {
        "DI0_CNT_UP_5",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_CLR_SEL_5",
        "DI0 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_TRIGGER_SEL_5",
        "DI0 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_5",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_5",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_5",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_GEN_EN_5",
        "DI0 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_6.
static const field_t hw_ipu_di0_sw_gen1_6[] =
{
    {
        "DI0_CNT_UP_6",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_CLR_SEL_6",
        "DI0 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_TRIGGER_SEL_6",
        "DI0 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_6",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_6",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_6",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_GEN_EN_6",
        "DI0 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_7.
static const field_t hw_ipu_di0_sw_gen1_7[] =
{
    {
        "DI0_CNT_UP_7",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_CLR_SEL_7",
        "DI0 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_TRIGGER_SEL_7",
        "DI0 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_7",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_7",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_7",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_GEN_EN_7",
        "DI0 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_8.
static const field_t hw_ipu_di0_sw_gen1_8[] =
{
    {
        "DI0_CNT_UP_8",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_CLR_SEL_8",
        "DI0 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_TRIGGER_SEL_8",
        "DI0 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_8",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_8",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_8",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_POLARITY_GEN_EN_8",
        "DI0 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SW_GEN1_9.
static const field_t hw_ipu_di0_sw_gen1_9[] =
{
    {
        "DI0_CNT_UP_9",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_TAG_SEL_9",
        "Counter #9 can send a synchronous tag when counter #9 reach its predef"
        "ined value or when it's triggering counter reaches its pre defined val"
        "ue.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_DOWN_9",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_CLR_SEL_9",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CNT_AUTO_RELOAD_9",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_GENTIME_SEL_9",
        "Counter #9 main waveform select  This field defines the counter that c"
        "ounter #9's auxiliary waveform will be attached too.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SYNC_AS_GEN.
static const field_t hw_ipu_di0_sync_as_gen[] =
{
    {
        "DI0_SYNC_START",
        "DI0 Sync start  This field defines the number of low (including blanki"
        "ng rows) on the which the DI0 starts preparing the data for the next f"
        "rame.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_VSYNC_SEL",
        "VSYNC select  This field defines which of the counters functions as VS"
        "YNC signal",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SYNC_START_EN",
        "di0_sync_start_en",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_DW_GEN_I.
static const field_t hw_ipu_di0_dw_gen_i[] =
{
    {
        "DI0_PT_0",
        "DI0 PIN_11 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_11 pin.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PT_1",
        "DI0 PIN_12 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_12 pin.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PT_2",
        "DI0 PIN_13 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_13 pin.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PT_3",
        "DI0 PIN_14 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_14 pin.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PT_4",
        "DI0 PIN_15 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_15 pin.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PT_5",
        "DI0 PIN_16 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_16 pin.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PT_6",
        "DI0 PIN_17 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_17 pin.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CST",
        "DI0 Chip Select pointer for waveform <i>  This field points to a regis"
        "ter that defines the waveform of the CS pin.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_COMPONNENT_SIZE",
        "DI0 component Size  This field defines the amount of IPU cycles betwee"
        "n any 2 components",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_ACCESS_SIZE",
        "DI0 Access Size <i>  This field defines the amount of IPU cycles betwe"
        "en any 2 accesses (an access may be a pixel or generic data that may h"
        "ave more one component)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_DW_SET0_I.
static const field_t hw_ipu_di0_dw_set0_i[] =
{
    {
        "DI0_DATA_CNT_UP0",
        "Waveform's rising edge position.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DATA_CNT_DOWN0",
        "Waveform's falling edge position.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_DW_SET1_I.
static const field_t hw_ipu_di0_dw_set1_i[] =
{
    {
        "DI0_DATA_CNT_UP1",
        "Waveform's rising edge position.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DATA_CNT_DOWN1",
        "Waveform's falling edge position.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_DW_SET2_I.
static const field_t hw_ipu_di0_dw_set2_i[] =
{
    {
        "DI0_DATA_CNT_UP2",
        "Waveform's rising edge position.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DATA_CNT_DOWN2",
        "Waveform's falling edge position.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_DW_SET3_I.
static const field_t hw_ipu_di0_dw_set3_i[] =
{
    {
        "DI0_DATA_CNT_UP3",
        "Waveform's rising edge position.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DATA_CNT_DOWN3",
        "Waveform's falling edge position.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_STP_REP_I.
static const field_t hw_ipu_di0_stp_rep_i[] =
{
    {
        "DI0_STEP_REPEAT1",
        "Step Repeat <i>  This fields defines the amount of repetitions that wi"
        "ll be performed by the counter <i>",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_STEP_REPEAT",
        "Step Repeat <i>  This fields defines the amount of repetitions that wi"
        "ll be performed by the counter <i>",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_STP_REP_9.
static const field_t hw_ipu_di0_stp_rep_9[] =
{
    {
        "DI0_STEP_REPEAT_9",
        "Step Repeat 9  This fields defines the amount of repetitions that will"
        " be performed by the counter 9",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SER_CONF.
static const field_t hw_ipu_di0_ser_conf[] =
{
    {
        "DI0_WAIT4SERIAL",
        "Wait for Serial  When the parallel display share pins with the serial "
        "port.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SERIAL_CS_POLARITY",
        "Serial Chip Select Polarity  The output polarity of the SER_CS pin",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SERIAL_RS_POLARITY",
        "Serial RS Polarity  The output polarity of the SER_RS pin",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SERIAL_DATA_POLARITY",
        "Serial Data Polarity  The output polarity of the SER_DATA pin",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SER_CLK_POLARITY",
        "Serial Clock Polarity  The output polarity of the SER_CLK pin",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_LLA_SER_ACCESS",
        "Direct Low Level Access to Serial display",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SERIAL_LATCH",
        "DI0 Serial Latch  This field defines how many cycles to insert between"
        " serial read accesses start to data sampling in the",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SERIAL_LLA_PNTR_RS_W_0",
        "RS 0 waveform pointer for write low level access  This pointer defines"
        " which waveform set will be chosen when the low level write access is "
        "targeted to RS group 0.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SERIAL_LLA_PNTR_RS_W_1",
        "RS 1 waveform pointer for write low level access  This pointer defines"
        " which waveform set will be chosen when the low level write access is "
        "targeted to RS group 1.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SERIAL_LLA_PNTR_RS_R_0",
        "RS 2 waveform pointer for read low level access  This pointer defines "
        "which waveform set will be chosen when the read low level access is ta"
        "rgeted to RS group 0.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_SERIAL_LLA_PNTR_RS_R_1",
        "RS 3 waveform pointer for read low level access  This pointer defines "
        "which waveform set will be chosen when the read low level access is ta"
        "rgeted to RS group 1.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SSC.
static const field_t hw_ipu_di0_ssc[] =
{
    {
        "DI0_BYTE_EN_PNTR",
        "Byte Enable Pointer  This pointer selects the pin asserted along with "
        "the byte enables signals",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_BYTE_EN_RD_IN",
        "Byte Enable Read In  This bit selects the source of the byte enable pi"
        "ns",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_WAIT_ON",
        "Wait On  This field defines the DC's response to WAIT signal",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CS_ERM",
        "DI0 GLUELOGIC error recovery mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PIN11_ERM",
        "DI0 PIN11 error recovery mode.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PIN12_ERM",
        "DI0 PIN12 error recovery mode.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PIN13_ERM",
        "DI0 PIN13 error recovery mode.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PIN14_ERM",
        "DI0 PIN14 error recovery mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PIN15_ERM",
        "DI0 PIN15 error recovery mode.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PIN16_ERM",
        "DI0 PIN16 error recovery mode.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_PIN17_ERM",
        "DI0 PIN17 error recovery mode.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_POL.
static const field_t hw_ipu_di0_pol[] =
{
    {
        "DI0_DRDY_POLARITY",
        "DI0 output dynamic pin's polarity for synchronous access  This bits de"
        "fine the polarity of each of the DI's outputs when synchronous display"
        " access is asserted  The pins' default polarity is the same as defined"
        " in the di0_drdy_polarity_[17:11] bits",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_DRDY_DATA_POLARITY",
        "Data Polarity associated with DRDY",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CS0_POLARITY",
        "DI0 output pin's polarity for CS1  This bits define the polarity of ea"
        "ch of the DI's outputs when CS1 is asserted",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CS0_DATA_POLARITY",
        "Data Polarity associated with CS0",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CS1_POLARITY",
        "DI0 output pin's polarity for CS1  This bits define the polarity of ea"
        "ch of the DI's outputs when CS1 is asserted",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CS1_DATA_POLARITY",
        "Data Polarity associated with CS1",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CS0_BYTE_EN_POLARITY",
        "Byte Enable associated with CS0 polarity  This bit defines the polarit"
        "y of the byte enable signals to the display",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_CS1_BYTE_EN_POLARITY",
        "Byte Enable associated with CS1 polarity  This bit defines the polarit"
        "y of the byte enable signals to the display",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_WAIT_POLARITY",
        "WAIT polarity  This bit defines the polarity of the wait signal input "
        "coming from the displa1",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_AW0.
static const field_t hw_ipu_di0_aw0[] =
{
    {
        "DI0_AW_HSTART",
        "This field defines the horizontal start of the active window  DI0_AW_H"
        "START < DI0_AW_HEND",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_AW_HCOUNT_SEL",
        "GM: This field selects the counter that counts the horizontal position"
        " of the display's active window",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_AW_HEND",
        "This field defines the horizontal end of the active window",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_AW_TRIG_SEL",
        "This field selects the trigger for sending data during the display's a"
        "ctive window",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_AW1.
static const field_t hw_ipu_di0_aw1[] =
{
    {
        "DI0_AW_VSTART",
        "This field defines the vertical start of the active window  DI0_AW_VST"
        "ART < DI0_AW_VEND",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_AW_VCOUNT_SEL",
        "This field selects the counter that counts the vertical position of th"
        "e display's active window",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_AW_VEND",
        "This field defines the vertical end of the active window",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_SCR_CONF.
static const field_t hw_ipu_di0_scr_conf[] =
{
    {
        "DI0_SCREEN_HEIGHT",
        "This field defines the number of display rows (Number_of_ROWS = DI0_SC"
        "REEN_HEIGHT+1)  This field is used for VSYNC calculation and for anti-"
        "tearing",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI0_STAT.
static const field_t hw_ipu_di0_stat[] =
{
    {
        "DI0_READ_FIFO_EMPTY",
        "This bit indicates an empty state of the DI0 FIFO when performing a re"
        "ad.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI0_READ_FIFO_FULL",
        "This bit indicates a full state of the DI0 FIFO when performing a read"
        ".",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI0_READ_CNTR_EMPTY",
        "This bit indicates an empty state of the DI0 FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI0_CNTR_FIFO_FULL",
        "This bit indicates a full state of the DI0 FIFO.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_GENERAL.
static const field_t hw_ipu_di1_general[] =
{
    {
        "DI1_POLARITY",
        "DI1 output pin's polarity  This bits define the polarity of each of th"
        "e DI's outputs.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_POLARITY_CS0",
        "DI1 Chip Select's 0 polarity  This bits define the polarity of the DI'"
        "s CS0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_POLARITY_CS1",
        "DI1 Chip Select's 1 polarity  This bits define the polarity of the DI'"
        "s CS1.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_ERM_VSYNC_SEL",
        "DI1 error recovery module's VSYNC source select  The error recovery bl"
        "ock detect a case where the DI's VSYNC is asserted before the EOF.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_ERR_TREATMENT",
        "In case of synchronous flow error there are 2 ways to handle the displ"
        "ay",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SYNC_COUNT_SEL",
        "For synchronous flow error: selects synchronous flow synchronization c"
        "ounter in DI:",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_POLARITY_DISP_CLK",
        "DI1 Output Clock's polarity  This bits define the polarity of the DI's"
        " clock.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_WATCHDOG_MODE",
        "DI1 watchdog mode  In case of a display error where the DI clock is st"
        "opped (defined at di0_err_treatment).",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CLK_EXT",
        "DI1 External Clock.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_VSYNC_EXT",
        "DI1 External VSYNC.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_MASK_SEL",
        "DI1 Mask select.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DISP_CLOCK_INIT",
        "Display clock's initial mode  For synchronization error conditions the"
        " display clock can be stopped on the next VSYNC",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CLOCK_STOP_MODE",
        "DI clock stop mode  When performing a clock change.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DISP_Y_SEL",
        "DI1 Display Vertical coordinate (Y) select.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PIN8_PIN15_SEL",
        "This bit routes PIN8 over PIN15",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_BS_CLKGEN0.
static const field_t hw_ipu_di1_bs_clkgen0[] =
{
    {
        "DI1_DISP_CLK_PERIOD",
        "DI1 Display Clock Period  This field defines the Display interface clo"
        "ck period for display write access.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DISP_CLK_OFFSET",
        "DI1 Display Clock Offset  The DI has the ability to delay the display'"
        "s clock  This field defines the amount of IPU's clock cycles added as "
        "delay on this clock.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_BS_CLKGEN1.
static const field_t hw_ipu_di1_bs_clkgen1[] =
{
    {
        "DI1_DISP_CLK_UP",
        "DI1 display clock rising edge position  This parameter contains an int"
        "eger part (bits 8:1) and a fractional part (bit 0).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DISP_CLK_DOWN",
        "DI1 display clock falling edge position  This parameter contains an in"
        "teger part (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_1.
static const field_t hw_ipu_di1_sw_gen0_1[] =
{
    {
        "DI1_OFFSET_RESOLUTION_1",
        "DI1 counter #1 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_1",
        "DI1 counter #1 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_1",
        "DI1 counter #1 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_1",
        "DI1 counter #1 pre defined value  This fields defines the counter #1 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_2.
static const field_t hw_ipu_di1_sw_gen0_2[] =
{
    {
        "DI1_OFFSET_RESOLUTION_2",
        "DI1 counter #2 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_2",
        "DI1 counter #2 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_2",
        "DI1 counter #2 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_2",
        "DI1 counter #2 pre defined value  This fields defines the counter #2 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_3.
static const field_t hw_ipu_di1_sw_gen0_3[] =
{
    {
        "DI1_OFFSET_RESOLUTION_3",
        "DI1 counter #3 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_3",
        "DI1 counter #3 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_3",
        "DI1 counter #3 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_3",
        "DI1 counter #3 pre defined value  This fields defines the counter #3 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_4.
static const field_t hw_ipu_di1_sw_gen0_4[] =
{
    {
        "DI1_OFFSET_RESOLUTION_4",
        "DI1 counter #4 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_4",
        "DI1 counter #4 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_4",
        "DI1 counter #4 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_4",
        "DI1 counter #4 pre defined value  This fields defines the counter #4 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_5.
static const field_t hw_ipu_di1_sw_gen0_5[] =
{
    {
        "DI1_OFFSET_RESOLUTION_5",
        "DI1 counter #5 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_5",
        "DI1 counter #5 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_5",
        "DI1 counter #5 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_5",
        "DI1 counter #5 pre defined value  This fields defines the counter #5 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_6.
static const field_t hw_ipu_di1_sw_gen0_6[] =
{
    {
        "DI1_OFFSET_RESOLUTION_6",
        "DI1 counter #6 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_6",
        "DI1 counter #6 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_6",
        "DI1 counter #6 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_6",
        "DI1 counter #6 pre defined value  This fields defines the counter #6 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_7.
static const field_t hw_ipu_di1_sw_gen0_7[] =
{
    {
        "DI1_OFFSET_RESOLUTION_1",
        "DI1 counter #7 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_7",
        "DI1 counter #7 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_7",
        "DI1 counter #1 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_7",
        "DI1 counter #7 pre defined value  This fields defines the counter #7 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_8.
static const field_t hw_ipu_di1_sw_gen0_8[] =
{
    {
        "DI1_OFFSET_RESOLUTION_8",
        "DI1 counter #8 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_8",
        "DI1 counter #8 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_8",
        "DI1 counter #8 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_8",
        "DI1 counter #8 pre defined value  This fields defines the counter #8 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN0_9.
static const field_t hw_ipu_di1_sw_gen0_9[] =
{
    {
        "DI1_OFFSET_RESOLUTION_9",
        "DI1 counter #9 offset Resolution  This field defines the trigger causi"
        "ng the offset counter to increment",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_OFFSET_VALUE_9",
        "DI1 counter #9 offset value  The counter can start counting after a pr"
        "e defined delay  This field defines the amount of cycles that the coun"
        "ter will be delayed by",
        3, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_RESOLUTION_9",
        "DI1 counter #9 Run Resolution  This field defines the trigger causing "
        "the counter to increment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_RUN_VALUE_M1_9",
        "DI1 counter #9 pre defined value  This fields defines the counter #9 p"
        "re defines value.",
        19, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_1.
static const field_t hw_ipu_di1_sw_gen1_1[] =
{
    {
        "DI1_CNT_UP_1",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_CLR_SEL_1",
        "DI1 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_TRIGGER_SEL_1",
        "DI1 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_1",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_1",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_1",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_GEN_EN_1",
        "DI1 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_2.
static const field_t hw_ipu_di1_sw_gen1_2[] =
{
    {
        "DI1_CNT_UP_2",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_CLR_SEL_2",
        "DI1 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_TRIGGER_SEL_2",
        "DI1 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_2",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_2",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_2",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_GEN_EN_2",
        "DI1 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_3.
static const field_t hw_ipu_di1_sw_gen1_3[] =
{
    {
        "DI1_CNT_UP_3",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_CLR_SEL_3",
        "DI1 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_TRIGGER_SEL_3",
        "DI1 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_3",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_3",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_3",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_GEN_EN_3",
        "DI1 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_4.
static const field_t hw_ipu_di1_sw_gen1_4[] =
{
    {
        "DI1_CNT_UP_4",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_CLR_SEL_4",
        "DI1 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_TRIGGER_SEL_4",
        "DI1 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_4",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_4",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_4",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_GEN_EN_4",
        "DI1 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_5.
static const field_t hw_ipu_di1_sw_gen1_5[] =
{
    {
        "DI1_CNT_UP_5",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_CLR_SEL_5",
        "DI1 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_TRIGGER_SEL_5",
        "DI1 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_5",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_5",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_5",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_GEN_EN_5",
        "DI1 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_6.
static const field_t hw_ipu_di1_sw_gen1_6[] =
{
    {
        "DI1_CNT_UP_6",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_CLR_SEL_6",
        "DI1 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_TRIGGER_SEL_6",
        "DI1 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_6",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_6",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_6",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_GEN_EN_6",
        "DI1 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_7.
static const field_t hw_ipu_di1_sw_gen1_7[] =
{
    {
        "DI1_CNT_UP_7",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_CLR_SEL_7",
        "DI1 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_TRIGGER_SEL_7",
        "DI1 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_7",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_7",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_7",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_GEN_EN_7",
        "DI1 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_8.
static const field_t hw_ipu_di1_sw_gen1_8[] =
{
    {
        "DI1_CNT_UP_8",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_CLR_SEL_8",
        "DI1 counter's polarity Clear select  This field selects the input to t"
        "he counter telling the counter wether to invert the output",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_TRIGGER_SEL_8",
        "DI1 Counter's toggling trigger select  This field selects the counter'"
        "s trigger causing the output to toggle",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_8",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_8",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_8",
        "Counter auto reload mode  1 The counter will automatically be reloaded"
        " forever, ignoring the value of the di1_step_repeat_<i> field  0 The c"
        "ounter will not be automatically reloaded, It will be reloaded for the"
        " amount of repeat times defined on the di1_step_repeat_<i> field",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_POLARITY_GEN_EN_8",
        "DI1 Counter polarity generator enable  The counter's output polarity c"
        "an be changed on the fly.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SW_GEN1_9.
static const field_t hw_ipu_di1_sw_gen1_9[] =
{
    {
        "DI1_CNT_UP_9",
        "Counter rising edge position  This parameter contains an integer part "
        "(bits 24:17) and a fractional part (bit 16).",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_TAG_SEL_9",
        "Counter #9 can send a synchronous tag when counter #9 reach its predef"
        "ined value or when it's triggering counter reaches its pre defined val"
        "ue.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_DOWN_9",
        "Counter falling edge position  This parameter contains an integer part"
        " (bits 24:17) and a fractional part (bit 16).",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_CLR_SEL_9",
        "Counter Clear select  This field defines the source of the signals tha"
        "t clears the counter.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CNT_AUTO_RELOAD_9",
        "Counter auto reload mode",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_GENTIME_SEL_9",
        "Counter #9 main waveform select  This field defines the counter that c"
        "ounter #9's auxiliary waveform will be attached too.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SYNC_AS_GEN.
static const field_t hw_ipu_di1_sync_as_gen[] =
{
    {
        "DI1_SYNC_START",
        "DI1 Sync start  This field defines the number of low (including blanki"
        "ng rows) on the which the DI1 starts preparing the data for the next f"
        "rame.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_VSYNC_SEL",
        "VSYNC select  This field defines which of the counters functions as VS"
        "YNC signal",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SYNC_START_EN",
        "di1_sync_start_en",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_DW_GEN_I.
static const field_t hw_ipu_di1_dw_gen_i[] =
{
    {
        "DI1_PT_0",
        "DI1 PIN_11 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_11 pin.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PT_1",
        "DI1 PIN_12 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_12 pin.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PT_2",
        "DI1 PIN_13 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_13 pin.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PT_3",
        "DI1 PIN_14 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_14 pin.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PT_4",
        "DI1 PIN_15 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_15 pin.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PT_5",
        "DI1 PIN_16 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_16 pin.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PT_6",
        "DI1 PIN_17 pointer for waveform <i>  This field points to a register t"
        "hat defines the waveform of the PIN_17 pin.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CST",
        "DI1 Chip Select pointer for waveform <i>  This field points to a regis"
        "ter that defines the waveform of the CS pin.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_COMPONNENT_SIZE",
        "DI1 component Size  This field defines the amount of IPU cycles betwee"
        "n any 2 components",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_ACCESS_SIZE",
        "DI1 Access Size <i>  This field defines the amount of IPU cycles betwe"
        "en any 2 accesses (an access may be a pixel or generic data that may h"
        "ave more one component)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_DW_SET0_I.
static const field_t hw_ipu_di1_dw_set0_i[] =
{
    {
        "DI1_DATA_CNT_UP0",
        "Waveform's rising edge position.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DATA_CNT_DOWN0",
        "Waveform's falling edge position.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_DW_SET1_I.
static const field_t hw_ipu_di1_dw_set1_i[] =
{
    {
        "DI1_DATA_CNT_UP1",
        "Waveform's rising edge position.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DATA_CNT_DOWN1",
        "Waveform's falling edge position.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_DW_SET2_I.
static const field_t hw_ipu_di1_dw_set2_i[] =
{
    {
        "DI1_DATA_CNT_UP2",
        "Waveform's rising edge position.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DATA_CNT_DOWN2",
        "Waveform's falling edge position.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_DW_SET3_I.
static const field_t hw_ipu_di1_dw_set3_i[] =
{
    {
        "DI1_DATA_CNT_UP3",
        "Waveform's rising edge position.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DATA_CNT_DOWN3",
        "Waveform's falling edge position.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_D1_STP_REP_I.
static const field_t hw_ipu_d1_stp_rep_i[] =
{
    {
        "DI1_STEP_REPEAT1",
        "Step Repeat <i>  This fields defines the amount of repetitions that wi"
        "ll be performed by the counter <i>",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_STEP_REPEAT",
        "Step Repeat <i>  This fields defines the amount of repetitions that wi"
        "ll be performed by the counter <i>",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_STP_REP_9.
static const field_t hw_ipu_di1_stp_rep_9[] =
{
    {
        "DI1_STEP_REPEAT_9",
        "Step Repeat 9  This fields defines the amount of repetitions that will"
        " be performed by the counter 9.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SER_CONF.
static const field_t hw_ipu_di1_ser_conf[] =
{
    {
        "DI1_WAIT4SERIAL",
        "Wait for Serial  When the parallel display share pins with the serial "
        "port.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SERIAL_CS_POLARITY",
        "Serial Chip Select Polarity  The output polarity of the SER_CS pin",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SERIAL_RS_POLARITY",
        "Serial RS Polarity  The output polarity of the SER_RS pin",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SERIAL_DATA_POLARITY",
        "Serial Data Polarity  The output polarity of the SER_DATA pin",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SER_CLK_POLARITY",
        "Serial Clock Polarity  The output polarity of the SER_CLK pin",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_LLA_SER_ACCESS",
        "Direct Low Level Access to Serial display",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SERIAL_LATCH",
        "DI1 Serial Latch  This field defines how many cycles to insert between"
        " serial read accesses start to data sampling in the",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SERIAL_LLA_PNTR_RS_W_0",
        "RS 0 waveform pointer for write low level access  This pointer defines"
        " which waveform set will be chosen when the write low level access is "
        "targeted to RS group 0.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SERIAL_LLA_PNTR_RS_W_1",
        "RS 1 waveform pointer for write low level access  This pointer defines"
        " which waveform set will be chosen when the write low level access is "
        "targeted to RS group 1.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SERIAL_LLA_PNTR_RS_R_0",
        "RS 2 waveform pointer for low level access  This pointer defines which"
        " waveform set will be chosen when the read low level access is targete"
        "d to RS group 0.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_SERIAL_LLA_PNTR_RS_R_1",
        "RS 3 waveform pointer for read low level access  This pointer defines "
        "which waveform set will be chosen when the read low level access is ta"
        "rgeted to RS group 1.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SSC.
static const field_t hw_ipu_di1_ssc[] =
{
    {
        "DI1_BYTE_EN_PNTR",
        "Byte Enable Pointer  This pointer selects the pin asserted along with "
        "the byte enables signals",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_BYTE_EN_RD_IN",
        "Byte Enable Read In  This bit selects the source of the byte enable pi"
        "ns",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_BYTE_EN_POLARITY",
        "Byte Enable polarity  This bit defines the polarity of the byte enable"
        " signals to the display.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_WAIT_ON",
        "Wait On  This field defines the DC's response to WAIT signal",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CS_ERM",
        "DI1 GLUELOGIC error recovery mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PIN11_ERM",
        "DI1 PIN11 error recovery mode.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PIN12_ERM",
        "DI1 PIN12 error recovery mode.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PIN13_ERM",
        "DI1 PIN13 error recovery mode.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PIN14_ERM",
        "DI1 PIN14 error recovery mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PIN15_ERM",
        "DI1 PIN15 error recovery mode.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PIN16_ERM",
        "DI1 PIN16 error recovery mode.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_PIN17_ERM",
        "DI1 PIN17 error recovery mode.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_POL.
static const field_t hw_ipu_di1_pol[] =
{
    {
        "DI1_DRDY_POLARITY",
        "DI1 output dynamic pin's polarity for synchronous access  This bits de"
        "fine the polarity of each of the DI's outputs when synchronous display"
        " access is asserted  The pins' default polarity is the same as defined"
        " in the di0_drdy_polarity_[17:11] bits",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DRDY_DATA_POLARITY",
        "Data Polarity associated with DRDY",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CS0_POLARITY",
        "DI1 output pin's polarity for CS1  This bits define the polarity of ea"
        "ch of the DI's outputs when CS1 is asserted",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CS0_DATA_POLARITY",
        "Data Polarity associated with CS0",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CS1_POLARITY",
        "DI1 output pin's polarity for CS1  This bits define the polarity of ea"
        "ch of the DI's outputs when CS1 is asserted",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CS1_DATA_POLARITY",
        "Data Polarity associated with CS1",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CS0_BYTE_EN_POLARITY",
        "Byte Enable associated with CS0 polarity  This bit defines the polarit"
        "y of the byte enable signals to the display",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_CS1_BYTE_EN_POLARITY",
        "Byte Enable associated with CS1 polarity  This bit defines the polarit"
        "y of the byte enable signals to the display",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_WAIT_POLARITY",
        "WAIT polarity  This bit defines the polarity of the wait signal input "
        "coming from the displa1",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_AW0.
static const field_t hw_ipu_di1_aw0[] =
{
    {
        "DI1_AW_HSTART",
        "This field defines the horizontal start of the active window  DI1_AW_H"
        "START < DI1_AW_HEND",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_AW_HCOUNT_SEL",
        "This field selects the counter that counts the horizontal position of "
        "the display's active window",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_AW_HEND",
        "This field defines the horizontal end of the active window",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_AW_TRIG_SEL",
        "This field selects the trigger for sending data during the display's a"
        "ctive window",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_AW1.
static const field_t hw_ipu_di1_aw1[] =
{
    {
        "DI1_AW_VSTART",
        "This field defines the vertical start of the active window  DI1_AW_VST"
        "ART < DI1_AW_VEND",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_AW_VCOUNT_SEL",
        "This field selects the counter that counts the vertical position of th"
        "e display's active window",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_AW_VEND",
        "This field defines the vertical end of the active window",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_SCR_CONF.
static const field_t hw_ipu_di1_scr_conf[] =
{
    {
        "DI1_SCREEN_HEIGHT",
        "This field defines the number of display rows (Number_of_ROWS = DI1_SC"
        "REEN_HEIGHT+1)  This field is used for VSYNC calculation and for anti-"
        "tearing",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DI1_STAT.
static const field_t hw_ipu_di1_stat[] =
{
    {
        "DI1_READ_FIFO_EMPTY",
        "This bit indicates an empty state of the DI1 FIFO when performing a re"
        "ad.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI1_READ_FIFO_FULL",
        "This bit indicates a full state of the DI1 FIFO when performing a read"
        ".",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI1_CNTR_FIFO_EMPTY",
        "This bit indicates an empty state of the DI1 FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DI1_CNTR_FIFO_FULL",
        "This bit indicates a full state of the DI1 FIFO.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SMFC_MAP.
static const field_t hw_ipu_smfc_map[] =
{
    {
        "MAP_CH0",
        "DMASMFC channel 0 mapping bits.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAP_CH1",
        "DMASMFC channel 1 mapping bits.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAP_CH2",
        "DMASMFC channel 2 mapping bits.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAP_CH3",
        "DMASMFC channel 3mapping bits.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SMFC_WMC.
static const field_t hw_ipu_smfc_wmc[] =
{
    {
        "WM0_SET",
        "Watermark \"set\" level of DMASMFC channel 0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WM0_CLR",
        "Watermark \"clear\" level of DMASMFC channel 0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WM1_SET",
        "Watermark \"set\" level of DMASMFC channel 1.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WM1_CLR",
        "Watermark \"clear\" level of DMASMFC channel 1.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WM2_SET",
        "Watermark \"set\" level of DMASMFC channel 2.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WM2_CLR",
        "Watermark \"clear\" level of DMASMFC channel 2.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WM3_SET",
        "Watermark \"set\" level of DMASMFC channel 3",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WM3_CLR",
        "Watermark \"clear\" level of DMASMFC channel 3.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_SMFC_BS.
static const field_t hw_ipu_smfc_bs[] =
{
    {
        "BURST0_SIZE",
        "Burst Size of SMFCDMA channel 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST1_SIZE",
        "Burst Size of SMFCDMA channel 1.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST2_SIZE",
        "Burst Size of SMFCDMA channel 2.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST3_SIZE",
        "Burst Size of SMFCDMA channel 3.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_READ_CH_CONF.
static const field_t hw_ipu_dc_read_ch_conf[] =
{
    {
        "RD_CHANNEL_EN",
        "This bit enables the read channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DI_ID_0",
        "This bit select the DI which a read transaction can be performed throu"
        "gh",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DISP_ID_0",
        "The field defines which one of the 4 displays can be read.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W_SIZE_0",
        "Word Size  The data coming from the IDMAC is 32bit wide.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAN_MASK_DEFAULT_0",
        "Event mask bit for the read channel  When more then one event is used "
        "during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event be"
        "sides the event that is defined as the highest priority event",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS_ID_0",
        "This bit maps an asynchronous display to a chip select",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS_ID_1",
        "This bit maps an asynchronous display to a chip select",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS_ID_2",
        "This bit maps an asynchronous display to a chip select",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS_ID_3",
        "This bit maps an asynchronous display to a chip select",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIME_OUT_VALUE",
        "Time out value.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_READ_SH_ADDR.
static const field_t hw_ipu_dc_read_sh_addr[] =
{
    {
        "ST_ADDR_0",
        "This field defines the start address within the display's memory space"
        " where the read transactions will be done from.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL0_CH_0.
static const field_t hw_ipu_dc_rl0_ch_0[] =
{
    {
        "COD_NF_PRIORITY_CHAN_0",
        "This field defines the priority of the new frame (NF) event  The prior"
        "ity between the events should be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NF_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new Frame event (NF) resides",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_PRIORITY_CHAN_0",
        "This field defines the priority of the new line (NL) event  The priori"
        "ty between the events should be set to a unique value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new line event (NL) resides",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL1_CH_0.
static const field_t hw_ipu_dc_rl1_ch_0[] =
{
    {
        "COD_EOF_PRIORITY_CHAN_0",
        "This field defines the priority of the end-of-frame event (EOF) event "
        " The priority between the events should be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOF_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end-of-frame event (EOF) resides",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_PRIORITY_CHAN_0",
        "This field defines the priority of the new field event  The priority b"
        "etween the events should be set to a unique value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new field event resides",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL2_CH_0.
static const field_t hw_ipu_dc_rl2_ch_0[] =
{
    {
        "COD_EOL_PRIORITY_CHAN_0",
        "This field defines the priority of the end-of-line event (EOL) event  "
        "The priority between the events should be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOL_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end-of-line event (EOL) resides",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_PRIORITY_CHAN_0",
        "This field defines the priority of the end-of-field event  The priorit"
        "y between the events should be set to a unique value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end-of-field event resides",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL3_CH_0.
static const field_t hw_ipu_dc_rl3_ch_0[] =
{
    {
        "COD_NEW_ADDR_PRIORITY_CHAN_0",
        "This field defines the priority of the new address event  The priority"
        " between the events should be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_PRIORITY_CHAN_0",
        "This field defines the priority of the new channel event  The priority"
        " between the events should be set to a unique value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL4_CH_0.
static const field_t hw_ipu_dc_rl4_ch_0[] =
{
    {
        "COD_NEW_DATA_PRIORITY_CHAN_0",
        "This field defines the priority of the new data event  The priority be"
        "tween the events should be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_CONF_1.
static const field_t hw_ipu_dc_wr_ch_conf_1[] =
{
    {
        "W_SIZE_1",
        "Word Size associated with channel #1  The data coming from the IDMAC i"
        "s 32bit wide.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DI_ID_1",
        "This bit select the DI which a transaction associated with channel #1 "
        "can be performed to",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DISP_ID_1",
        "The field defines which one of the 4 displays is associated with chann"
        "el #1.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_CHAN_TYP_1",
        "This field define the mode of operation of channel #1",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAN_MASK_DEFAULT_1",
        "Event mask bit for channel #1  When more then one event is used during"
        " a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides "
        "the event that is defined as the highest priority event",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_MODE_1",
        "Field mode bit for channel #1  This bit defines if the channel works i"
        "n field mode or frame mode; This bit is relevant if the flow is sync f"
        "low",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_START_TIME_1",
        "This field defines the delay between display 's vertical synchronizati"
        "on pulse and the start time point of DC's channel 1 window.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_ADDR_1.
static const field_t hw_ipu_dc_wr_ch_addr_1[] =
{
    {
        "ST_ADDR_1",
        "This field defines the start address within the display's memory space"
        " where the write transactions will be done to for channel #1.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL0_CH_1.
static const field_t hw_ipu_dc_rl0_ch_1[] =
{
    {
        "COD_NF_PRIORITY_CHAN_1",
        "This field defines the priority of the new frame event (associated wit"
        "h channel #1)  The priority between the events should be set to a uniq"
        "ue value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NF_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new frame event resides (associated wi"
        "th channel #1)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_PRIORITY_CHAN_1",
        "This field defines the priority of the new line event (associated with"
        " channel #1)  The priority between the events should be set to a uniqu"
        "e value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new line event resides (associated wit"
        "h channel #1)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL1_CH_1.
static const field_t hw_ipu_dc_rl1_ch_1[] =
{
    {
        "COD_EOF_PRIORITY_CHAN_1",
        "This field defines the priority of the end of frame event (associated "
        "with channel #1)  The priority between the events should be set to a u"
        "nique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOF_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of frame event resides (associated"
        " with channel #1)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_PRIORITY_CHAN_1",
        "This field defines the priority of the new field event (associated wit"
        "h channel #1)  The priority between the events should be set to a uniq"
        "ue value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new field event resides (associated wi"
        "th channel #1)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL2_CH_1.
static const field_t hw_ipu_dc_rl2_ch_1[] =
{
    {
        "COD_EOL_PRIORITY_CHAN_1",
        "This field defines the priority of the end of line event (associated w"
        "ith channel #1)  The priority between the events should be set to a un"
        "ique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOL_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of line event resides (associated "
        "with channel #1)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_PRIORITY_CHAN_1",
        "This field defines the priority of the end of field event (associated "
        "with channel #1)  The priority between the events should be set to a u"
        "nique value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of field event resides (associated"
        " with channel #1)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL3_CH_1.
static const field_t hw_ipu_dc_rl3_ch_1[] =
{
    {
        "COD_NEW_ADDR_PRIORITY_CHAN_1",
        "This field defines the priority of the new address event (associated w"
        "ith channel #1)  The priority between the events should be set to a un"
        "ique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #1)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_PRIORITY_CHAN_1",
        "This field defines the priority of the new channel event (associated w"
        "ith channel #1)  The priority between the events should be set to a un"
        "ique value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #1)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL4_CH_1.
static const field_t hw_ipu_dc_rl4_ch_1[] =
{
    {
        "COD_NEW_DATA_PRIORITY_CHAN_1",
        "This field defines the priority of the new data event (associated with"
        " channel #1)  The priority between the events should be set to a uniqu"
        "e value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #1)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_CONF_2.
static const field_t hw_ipu_dc_wr_ch_conf_2[] =
{
    {
        "W_SIZE_2",
        "Word Size  The data coming from the IDMAC is 32bit wide.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DI_ID_2",
        "This bit select the DI which a transaction associated with channel #2 "
        "can be performed to",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DISP_ID_2",
        "The field defines which one of the 4 displays is associated with chann"
        "el #2.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_CHAN_TYP_2",
        "This field define the mode of operation of channel #2",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAN_MASK_DEFAULT_2",
        "Event mask bit for channel #2  When more then one event is used during"
        " a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides "
        "the event that is defined as the highest priority event",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_START_TIME_2",
        "This field defines the delay between display 's vertical synchronizati"
        "on pulse and the start time point of DC's channel 2 window.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_ADDR_2.
static const field_t hw_ipu_dc_wr_ch_addr_2[] =
{
    {
        "ST_ADDR_2",
        "This field defines the start address within the display's memory space"
        " where the write transactions will be done to for channel #2.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL0_CH_2.
static const field_t hw_ipu_dc_rl0_ch_2[] =
{
    {
        "COD_NF_PRIORITY_CHAN_2",
        "This field defines the priority of the new frame event (associated wit"
        "h channel #2)  The priority between the events should be set to a uniq"
        "ue value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NF_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new frame event resides (associated wi"
        "th channel #2)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_PRIORITY_CHAN_2",
        "This field defines the priority of the new line event (associated with"
        " channel #2)  The priority between the events should be set to a uniqu"
        "e value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new line event resides (associated wit"
        "h channel #2)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL1_CH_2.
static const field_t hw_ipu_dc_rl1_ch_2[] =
{
    {
        "COD_EOF_PRIORITY_CHAN_2",
        "This field defines the priority of the end of frame event (associated "
        "with channel #2)  The priority between the events should be set to a u"
        "nique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOF_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of frame event resides (associated"
        " with channel #2)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_PRIORITY_CHAN_2",
        "This field defines the priority of the new field event (associated wit"
        "h channel #2)  The priority between the events should be set to a uniq"
        "ue value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new field event resides (associated wi"
        "th channel #2)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL2_CH_2.
static const field_t hw_ipu_dc_rl2_ch_2[] =
{
    {
        "COD_EOL_PRIORITY_CHAN_2",
        "This field defines the priority of the end of line event (associated w"
        "ith channel #2)  The priority between the events should be set to a un"
        "ique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOL_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of line event resides (associated "
        "with channel #2)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_PRIORITY_CHAN_2",
        "This field defines the priority of the end of field event (associated "
        "with channel #2)  The priority between the events should be set to a u"
        "nique value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of field event resides (associated"
        " with channel #2)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL3_CH_2.
static const field_t hw_ipu_dc_rl3_ch_2[] =
{
    {
        "COD_NEW_ADDR_PRIORITY_CHAN_2",
        "This field defines the priority of the end of line event (associated w"
        "ith channel #2)  The priority between the events should be set to a un"
        "ique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #2)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_PRIORITY_CHAN_2",
        "This field defines the priority of the end of line event (associated w"
        "ith channel #2)  The priority between the events should be set to a un"
        "ique value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #2)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL4_CH_2.
static const field_t hw_ipu_dc_rl4_ch_2[] =
{
    {
        "COD_NEW_DATA_PRIORITY_CHAN_2",
        "This field defines the priority of the end of line event (associated w"
        "ith channel #2)  The priority between the events should be set to a un"
        "ique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_2",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #2)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_CMD_CH_CONF_3.
static const field_t hw_ipu_dc_cmd_ch_conf_3[] =
{
    {
        "W_SIZE_3",
        "Word Size associated with channel #3  The data coming from the IDMAC i"
        "s 32bit wide.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_CMND_START_CHAN_RS0_3",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the command start event resides (associate"
        "d with channel #3); This field is relevant when RS is equal to 0",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_CMND_START_CHAN_RS1_3",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the command start event resides (associate"
        "d with channel #3); This field is relevant when RS is equal to 1",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_CMD_CH_CONF_4.
static const field_t hw_ipu_dc_cmd_ch_conf_4[] =
{
    {
        "W_SIZE_4",
        "Word Size associated with channel #4  The data coming from the IDMAC i"
        "s 32bit wide.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_CMND_START_CHAN_RS0_4",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the command start event resides (associate"
        "d with channel #4); This field is relevant when RS is equal to 0",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_CMND_START_CHAN_RS1_4",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the command start event resides (associate"
        "d with channel #4); This field is relevant when RS is equal to 1",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_CONF_5.
static const field_t hw_ipu_dc_wr_ch_conf_5[] =
{
    {
        "W_SIZE_5",
        "Word Size associated with channel #5  The data coming from the IDMAC i"
        "s 32bit wide.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DI_ID_5",
        "This bit select the DI which a transaction associated with channel #5 "
        "can be performed to.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DISP_ID_5",
        "The field defines which one of the 4 displays is associated with chann"
        "el #5.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_CHAN_TYP_5",
        "This field define the mode of operation of channel #5",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAN_MASK_DEFAULT_5",
        "Event mask bit for channel #5  When more then one event is used during"
        " a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides "
        "the event that is defined as the highest priority event",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_MODE_5",
        "Field mode bit for channel #5  This bit defines if the channel works i"
        "n field mode or frame mode; This bit is relevant if the flow is sync f"
        "low",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_START_TIME_5",
        "This field defines the delay between display 's vertical synchronizati"
        "on pulse and the start time point of DC's channel 5 window.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_ADDR_5.
static const field_t hw_ipu_dc_wr_ch_addr_5[] =
{
    {
        "ST_ADDR_5",
        "This field defines the start address within the display's memory space"
        " where the write transactions will be done to for channel #5.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL0_CH_5.
static const field_t hw_ipu_dc_rl0_ch_5[] =
{
    {
        "COD_NF_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NF_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new frame event resides (associated wi"
        "th channel #5)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new line event resides (associated wit"
        "h channel #5)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL1_CH_5.
static const field_t hw_ipu_dc_rl1_ch_5[] =
{
    {
        "COD_EOF_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOF_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of frame event resides (associated"
        " with channel #5)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new field event resides (associated wi"
        "th channel #5)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL2_CH_5.
static const field_t hw_ipu_dc_rl2_ch_5[] =
{
    {
        "COD_EOL_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOL_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of line event resides (associated "
        "with channel #5)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of field event resides (associated"
        " with channel #5)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL3_CH_5.
static const field_t hw_ipu_dc_rl3_ch_5[] =
{
    {
        "COD_NEW_ADDR_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #5)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #5)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL4_CH_5.
static const field_t hw_ipu_dc_rl4_ch_5[] =
{
    {
        "COD_NEW_DATA_PRIORITY_CHAN_5",
        "This field defines the priority of the new line event (associated with"
        " channel #5)  The priority between the events should be set to a uniqu"
        "e value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_5",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #5)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_CONF_6.
static const field_t hw_ipu_dc_wr_ch_conf_6[] =
{
    {
        "W_SIZE_6",
        "Word Size associated with channel #6  The data coming from the IDMAC i"
        "s 32bit wide.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DI_ID_6",
        "This bit select the DI which a transaction associated with channel #6 "
        "can be performed to",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_DISP_ID_6",
        "The field defines which one of the 4 displays is associated with chann"
        "el #6.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_CHAN_TYP_6",
        "This field define the mode of operation of channel #6",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAN_MASK_DEFAULT_6",
        "Event mask bit for channel #6  When more then one event is used during"
        " a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides "
        "the event that is defined as the highest priority event",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROG_START_TIME_6",
        "This field defines the delay between display 's vertical synchronizati"
        "on pulse and the start time point of DC's channel 6 window.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_ADDR_6.
static const field_t hw_ipu_dc_wr_ch_addr_6[] =
{
    {
        "ST_ADDR_6",
        "This field defines the start address within the display's memory space"
        " where the write transactions will be done to for channel #6.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL0_CH_6.
static const field_t hw_ipu_dc_rl0_ch_6[] =
{
    {
        "COD_NF_PRIORITY_CHAN_6",
        "This field defines the priority of the new frame event (associated wit"
        "h channel #6)  The priority between the events should be set to a uniq"
        "ue value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NF_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new frame event resides (associated wi"
        "th channel #6)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_PRIORITY_CHAN_6",
        "This field defines the priority of the new line event (associated with"
        " channel #6)  The priority between the events should be set to a uniqu"
        "e value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NL_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new line event resides (associated wit"
        "h channel #6)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL1_CH_6.
static const field_t hw_ipu_dc_rl1_ch_6[] =
{
    {
        "COD_EOF_PRIORITY_CHAN_6",
        "This field defines the priority of the new field event (associated wit"
        "h channel #6)  The priority between the events should be set to a uniq"
        "ue value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOF_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of frame event resides (associated"
        " with channel #6)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_PRIORITY_CHAN_6",
        "This field defines the priority of the new field event (associated wit"
        "h channel #6)  The priority between the events should be set to a uniq"
        "ue value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NFIELD_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new field event resides (associated wi"
        "th channel #6)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL2_CH_6.
static const field_t hw_ipu_dc_rl2_ch_6[] =
{
    {
        "COD_EOL_PRIORITY_CHAN_6",
        "This field defines the priority of the new field event (associated wit"
        "h channel #6)  The priority between the events should be set to a uniq"
        "ue value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOL_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of line event resides (associated "
        "with channel #6)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_PRIORITY_CHAN_6",
        "This field defines the priority of the new field event (associated wit"
        "h channel #6)  The priority between the events should be set to a uniq"
        "ue value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EOFIELD_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the end of field event resides (associated"
        " with channel #6)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL3_CH_6.
static const field_t hw_ipu_dc_rl3_ch_6[] =
{
    {
        "COD_NEW_ADDR_PRIORITY_CHAN_6",
        "This field defines the priority of the new field event (associated wit"
        "h channel #6)  The priority between the events should be set to a uniq"
        "ue value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #6)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_PRIORITY_CHAN_6",
        "This field defines the priority of the new field event (associated wit"
        "h channel #6)  The priority between the events should be set to a uniq"
        "ue value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #6)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL4_CH_6.
static const field_t hw_ipu_dc_rl4_ch_6[] =
{
    {
        "COD_NEW_DATA_PRIORITY_CHAN_6",
        "This field defines the priority of the new field event (associated wit"
        "h channel #6)  The priority between the events should be set to a uniq"
        "ue value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_6",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #6)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_CONF1_8.
static const field_t hw_ipu_dc_wr_ch_conf1_8[] =
{
    {
        "W_SIZE_8",
        "Word Size associated with channel #8  The data coming from the IDMAC i"
        "s 32bit wide.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAN_MASK_DEFAULT_8",
        "Event mask bit for channel #8  When more then one event is used during"
        " a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides "
        "the event that is defined as the highest priority event",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_DISP_ID_8",
        "The field defines which one of the 4 displays is associated with chann"
        "el #8.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_CONF2_8.
static const field_t hw_ipu_dc_wr_ch_conf2_8[] =
{
    {
        "NEW_ADDR_SPACE_SA_8",
        "Channel #8 is used for ARM platform direct access to the display.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL1_CH_8.
static const field_t hw_ipu_dc_rl1_ch_8[] =
{
    {
        "COD_NEW_ADDR_PRIORITY_CHAN_8",
        "This field defines the priority of the new address event (associated w"
        "ith channel #8, both regions)  The priority between the events should "
        "be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_W_8_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #8, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_W_8_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #8, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL2_CH_8.
static const field_t hw_ipu_dc_rl2_ch_8[] =
{
    {
        "COD_NEW_CHAN_PRIORITY_CHAN_8",
        "This field defines the priority of the new address event (associated w"
        "ith channel #8, both regions)  The priority between the events should "
        "be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_W_8_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #8, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_W_8_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #8, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL3_CH_8.
static const field_t hw_ipu_dc_rl3_ch_8[] =
{
    {
        "COD_NEW_DATA_PRIORITY_CHAN_8",
        "This field defines the priority of the new address event (associated w"
        "ith channel #8, both regions)  The priority between the events should "
        "be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_W_8_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #8, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_W_8_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #8,second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL4_CH_8.
static const field_t hw_ipu_dc_rl4_ch_8[] =
{
    {
        "COD_NEW_ADDR_START_CHAN_R_8_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #8, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_R_8_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #8, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL5_CH_8.
static const field_t hw_ipu_dc_rl5_ch_8[] =
{
    {
        "COD_NEW_CHAN_START_CHAN_R_8_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #8, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_R_8_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #8, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL6_CH_8.
static const field_t hw_ipu_dc_rl6_ch_8[] =
{
    {
        "COD_NEW_DATA_START_CHAN_R_8_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #8, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_R_8_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #8, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_CONF1_9.
static const field_t hw_ipu_dc_wr_ch_conf1_9[] =
{
    {
        "W_SIZE_9",
        "Word Size associated with channel #9  The data coming from the IDMAC i"
        "s 32bit wide.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAN_MASK_DEFAULT_9",
        "Event mask bit for channel #9  When more then one event is used during"
        " a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides "
        "the event that is defined as the highest priority event",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_DISP_ID_9",
        "The field defines which one of the 4 displays is associated with chann"
        "el #9.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_CONF2_9.
static const field_t hw_ipu_dc_wr_ch_conf2_9[] =
{
    {
        "NEW_ADDR_SPACE_SA_9",
        "Channel #8 is used for ARM platform direct access to the display.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL1_CH_9.
static const field_t hw_ipu_dc_rl1_ch_9[] =
{
    {
        "COD_NEW_ADDR_PRIORITY_CHAN_9",
        "This field defines the priority of the new address event (associated w"
        "ith channel #9, both regions)  The priority between the events should "
        "be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_W_9_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #9, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_W_9_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #9, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL2_CH_9.
static const field_t hw_ipu_dc_rl2_ch_9[] =
{
    {
        "COD_NEW_CHAN_PRIORITY_CHAN_9",
        "This field defines the priority of the new address event (associated w"
        "ith channel #9, both regions)  The priority between the events should "
        "be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_W_9_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #9, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_W_9_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #9, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL3_CH_9.
static const field_t hw_ipu_dc_rl3_ch_9[] =
{
    {
        "COD_NEW_DATA_PRIORITY_CHAN_9",
        "This field defines the priority of the new address event (associated w"
        "ith channel #9, both regions)  The priority between the events should "
        "be set to a unique value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_W_9_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #9, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_W_9_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #9, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL4_CH_9.
static const field_t hw_ipu_dc_rl4_ch_9[] =
{
    {
        "COD_NEW_ADDR_START_CHAN_R_9_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #9, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_ADDR_START_CHAN_R_9_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new address event resides (associated "
        "with channel #9, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL5_CH_9.
static const field_t hw_ipu_dc_rl5_ch_9[] =
{
    {
        "COD_NEW_CHAN_START_CHAN_R_9_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #9, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_CHAN_START_CHAN_R_9_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new channel event resides (associated "
        "with channel #9, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_RL6_CH_9.
static const field_t hw_ipu_dc_rl6_ch_9[] =
{
    {
        "COD_NEW_DATA_START_CHAN_R_9_0",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #9, first region)",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_NEW_DATA_START_CHAN_R_9_1",
        "This field is a pointer to the address within the microcode memory whe"
        "re the routine that handles the new data event resides (associated wit"
        "h channel #9, second region)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_GEN.
static const field_t hw_ipu_dc_gen[] =
{
    {
        "SYNC_1_6",
        "This field",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_EN",
        "Enable of the mask channel",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK4CHAN_5",
        "Sync flow can be associated with a mask channel.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_PRIORITY_5",
        "When 2 sync flows are running, this bit sets the priority of channel #"
        "5.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_PRIORITY_1",
        "When 2 sync flows are running, this bit sets the priority of channel #"
        "1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_CH5_TYPE",
        "Channel 5 is used for synchronous flow.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_BKDIV",
        "Blinking Rate  This field defines the blinking rate.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC_BK_EN",
        "Cursor blinking enable",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DISP_CONF1_0.
static const field_t hw_ipu_dc_disp_conf1_0[] =
{
    {
        "DISP_TYP_0",
        "This field defines the type of the display",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_INCREMENT_0",
        "This field is the increment step for auto increment mode",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_BE_L_INC_0",
        "This bits define the increment mode when the latest access was done wi"
        "th some of the byte enable signals are low, in that case different inc"
        "rement should be done instead of the normal auto increment of the addr"
        "ess  IF MCU_ACC_LB_MASK_0 is 0 then only 00 and 10 values are allowed.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_ACC_LB_MASK_0",
        "The DC compares between the current access to the a calculated address"
        ".",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISP_RD_VALUE_PTR_0",
        "When the display works in wait for status mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DISP_CONF1_1.
static const field_t hw_ipu_dc_disp_conf1_1[] =
{
    {
        "DISP_TYP_1",
        "This field defines the type of the display",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_INCREMENT_1",
        "This field is the increment step for auto increment mode",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_BE_L_INC_1",
        "This bits define the increment mode when the latest access was done wi"
        "th some of the byte enable signals are low, in that case different inc"
        "rement should be done instead of the normal auto increment of the addr"
        "ess  IF MCU_ACC_LB_MASK_1 is 0 then only 00 and 10 values are allowed.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_ACC_LB_MASK_1",
        "The DC compares between the current access to the a calculated address"
        ".",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISP_RD_VALUE_PTR_1",
        "When the display works in wait for status mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DISP_CONF1_2.
static const field_t hw_ipu_dc_disp_conf1_2[] =
{
    {
        "DISP_TYP_2",
        "This field defines the type of the display",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_INCREMENT_2",
        "This field is the increment step for auto increment mode",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_BE_L_INC_2",
        "This bits define the increment mode when the latest access was done wi"
        "th some of the byte enable signals are low, in that case different inc"
        "rement should be done instead of the normal auto increment of the addr"
        "ess  IF MCU_ACC_LB_MASK_2 is 0 then only 00 and 10 values are allowed.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_ACC_LB_MASK_2",
        "The DC compares between the current access to the a calculated address"
        ".",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISP_RD_VALUE_PTR_2",
        "When the display works in wait for status mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DISP_CONF1_3.
static const field_t hw_ipu_dc_disp_conf1_3[] =
{
    {
        "DISP_TYP_3",
        "This field defines the type of the display",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_INCREMENT_3",
        "This field is the increment step for auto increment mode",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_BE_L_INC_3",
        "This bits define the increment mode when the latest access was done wi"
        "th some of the byte enable signals are low, in that case different inc"
        "rement should be done instead of the normal auto increment of the addr"
        "ess  IF MCU_ACC_LB_MASK_3 is 0 then only 00 and 10 values are allowed.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_ACC_LB_MASK_3",
        "The DC compares between the current access to the a calculated address"
        ".",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISP_RD_VALUE_PTR_3",
        "When the display works in wait for status mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DISP_CONF2_0.
static const field_t hw_ipu_dc_disp_conf2_0[] =
{
    {
        "SL_0",
        "Stride line of display 0",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DISP_CONF2_1.
static const field_t hw_ipu_dc_disp_conf2_1[] =
{
    {
        "SL_1",
        "Stride line of display 1",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DISP_CONF2_2.
static const field_t hw_ipu_dc_disp_conf2_2[] =
{
    {
        "SL_2",
        "Stride line of display 2",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DISP_CONF2_3.
static const field_t hw_ipu_dc_disp_conf2_3[] =
{
    {
        "SL_3",
        "Stride line of display 3",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DI0_CONF_1.
static const field_t hw_ipu_dc_di0_conf_1[] =
{
    {
        "DI_READ_DATA_MASK_0",
        "This field defines the mask value of the data read from the display.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DI0_CONF_2.
static const field_t hw_ipu_dc_di0_conf_2[] =
{
    {
        "DI_READ_DATA_ACK_VALUE_0",
        "This is the expected data to be read from the display.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DI1_CONF_1.
static const field_t hw_ipu_dc_di1_conf_1[] =
{
    {
        "DI_READ_DATA_MASK_1",
        "This field defines the mask value of the data read from the display.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_DI1_CONF_2.
static const field_t hw_ipu_dc_di1_conf_2[] =
{
    {
        "DI_READ_DATA_ACK_VALUE_1",
        "This is the expected data to be read from the display.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_0.
static const field_t hw_ipu_dc_map_conf_0[] =
{
    {
        "MAPPING_PNTR_BYTE0_0",
        "Mapping pointer #0 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_0",
        "Mapping pointer #0 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_0",
        "Mapping pointer #0 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_1",
        "Mapping pointer #1 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_1",
        "Mapping pointer #1 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_1",
        "Mapping pointer #1 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_1.
static const field_t hw_ipu_dc_map_conf_1[] =
{
    {
        "MAPPING_PNTR_BYTE0_2",
        "Mapping pointer #1 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_2",
        "Mapping pointer #1 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_2",
        "Mapping pointer #1 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_3",
        "Mapping pointer #3 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_3",
        "Mapping pointer #3 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_3",
        "Mapping pointer #3 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_2.
static const field_t hw_ipu_dc_map_conf_2[] =
{
    {
        "MAPPING_PNTR_BYTE0_4",
        "Mapping pointer #4 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_4",
        "Mapping pointer #4 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_4",
        "Mapping pointer #4 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_5",
        "Mapping pointer #5 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_5",
        "Mapping pointer #5 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_5",
        "Mapping pointer #5 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_3.
static const field_t hw_ipu_dc_map_conf_3[] =
{
    {
        "MAPPING_PNTR_BYTE0_6",
        "Mapping pointer #6 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_6",
        "Mapping pointer #6 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_6",
        "Mapping pointer #6 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_7",
        "Mapping pointer #7 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_7",
        "Mapping pointer #7 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_7",
        "Mapping pointer #7 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_4.
static const field_t hw_ipu_dc_map_conf_4[] =
{
    {
        "MAPPING_PNTR_BYTE0_8",
        "Mapping pointer #8 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_8",
        "Mapping pointer #8 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_8",
        "Mapping pointer #8 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_9",
        "Mapping pointer #9 for Byte 0  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_1",
        "Mapping pointer #9 for Byte 1  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_9",
        "Mapping pointer #9 for Byte 2  This field is a pointer to the set of M"
        "D_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_5.
static const field_t hw_ipu_dc_map_conf_5[] =
{
    {
        "MAPPING_PNTR_BYTE0_10",
        "Mapping pointer #10 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_10",
        "Mapping pointer #10 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_10",
        "Mapping pointer #10 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_11",
        "Mapping pointer #11 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_11",
        "Mapping pointer #11 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_11",
        "Mapping pointer #11 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_6.
static const field_t hw_ipu_dc_map_conf_6[] =
{
    {
        "MAPPING_PNTR_BYTE0_12",
        "Mapping pointer #12 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_12",
        "Mapping pointer #12 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_12",
        "Mapping pointer #12 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_13",
        "Mapping pointer #13 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_13",
        "Mapping pointer #13 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_13",
        "Mapping pointer #13 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_7.
static const field_t hw_ipu_dc_map_conf_7[] =
{
    {
        "MAPPING_PNTR_BYTE0_14",
        "Mapping pointer #14 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_14",
        "Mapping pointer #14 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_14",
        "Mapping pointer #14 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_15",
        "Mapping pointer #15 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_15",
        "Mapping pointer #15 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_15",
        "Mapping pointer #15 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_8.
static const field_t hw_ipu_dc_map_conf_8[] =
{
    {
        "MAPPING_PNTR_BYTE0_16",
        "Mapping pointer #16 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_16",
        "Mapping pointer #16 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_16",
        "Mapping pointer #16 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_17",
        "Mapping pointer #17 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_17",
        "Mapping pointer #17 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_17",
        "Mapping pointer #17 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_9.
static const field_t hw_ipu_dc_map_conf_9[] =
{
    {
        "MAPPING_PNTR_BYTE0_18",
        "Mapping pointer #18 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_18",
        "Mapping pointer #18 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_18",
        "Mapping pointer #18 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_19",
        "Mapping pointer #19 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_19",
        "Mapping pointer #19 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_19",
        "Mapping pointer #19 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_10.
static const field_t hw_ipu_dc_map_conf_10[] =
{
    {
        "MAPPING_PNTR_BYTE0_20",
        "Mapping pointer #20 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_20",
        "Mapping pointer #20 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_20",
        "Mapping pointer #20 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_21",
        "Mapping pointer #21 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_21",
        "Mapping pointer #21 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_21",
        "Mapping pointer #21 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_11.
static const field_t hw_ipu_dc_map_conf_11[] =
{
    {
        "MAPPING_PNTR_BYTE0_22",
        "Mapping pointer #22 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_22",
        "Mapping pointer #22 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_22",
        "Mapping pointer #22 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_23",
        "Mapping pointer #23 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_23",
        "Mapping pointer #23 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_23",
        "Mapping pointer #23 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_12.
static const field_t hw_ipu_dc_map_conf_12[] =
{
    {
        "MAPPING_PNTR_BYTE0_24",
        "Mapping pointer #24 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_24",
        "Mapping pointer #24 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_24",
        "Mapping pointer #24 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_25",
        "Mapping pointer #25 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_25",
        "Mapping pointer #25 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_25",
        "Mapping pointer #25 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_13.
static const field_t hw_ipu_dc_map_conf_13[] =
{
    {
        "MAPPING_PNTR_BYTE0_26",
        "Mapping pointer #26 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_26",
        "Mapping pointer #26 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_26",
        "Mapping pointer #26 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_27",
        "Mapping pointer #27 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_27",
        "Mapping pointer #27 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_27",
        "Mapping pointer #27 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_14.
static const field_t hw_ipu_dc_map_conf_14[] =
{
    {
        "MAPPING_PNTR_BYTE2_28",
        "Mapping pointer #28 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_28",
        "Mapping pointer #28 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_28F",
        "Mapping pointer #28 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE0_29",
        "Mapping pointer #29 for Byte 0  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE1_29",
        "Mapping pointer #29 for Byte 1  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAPPING_PNTR_BYTE2_29",
        "Mapping pointer #29 for Byte 2  This field is a pointer to the set of "
        "MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2",
        26, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_15.
static const field_t hw_ipu_dc_map_conf_15[] =
{
    {
        "MD_MASK_0",
        "Mapping unit's mask value #0  This field defines the mask value #0 wit"
        "hin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_0",
        "Mapping unit's offset parameter #0  This field defines the offset para"
        "meter #0 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_1",
        "Mapping unit's mask value #1  This field defines the mask value #1 wit"
        "hin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_1",
        "Mapping unit's offset parameter #1  This field defines the offset para"
        "meter #1 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_16.
static const field_t hw_ipu_dc_map_conf_16[] =
{
    {
        "MD_MASK_0",
        "Mapping unit's mask value #2  This field defines the mask value #2 wit"
        "hin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_2",
        "Mapping unit's offset parameter #2  This field defines the offset para"
        "meter #2 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_3",
        "Mapping unit's mask value #3  This field defines the mask value #3 wit"
        "hin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_3",
        "Mapping unit's offset parameter #3  This field defines the offset para"
        "meter #3 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_17.
static const field_t hw_ipu_dc_map_conf_17[] =
{
    {
        "MD_MASK_4",
        "Mapping unit's mask value #4  This field defines the mask value #4 wit"
        "hin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_4",
        "Mapping unit's offset parameter #4  This field defines the offset para"
        "meter #4 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_5",
        "Mapping unit's mask value #5  This field defines the mask value #5 wit"
        "hin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_5",
        "Mapping unit's offset parameter #5  This field defines the offset para"
        "meter #5 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_18.
static const field_t hw_ipu_dc_map_conf_18[] =
{
    {
        "MD_MASK_6",
        "Mapping unit's mask value #6  This field defines the mask value #6 wit"
        "hin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_6",
        "Mapping unit's offset parameter #6  This field defines the offset para"
        "meter #6 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_7",
        "Mapping unit's mask value #7  This field defines the mask value #7 wit"
        "hin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_7",
        "Mapping unit's offset parameter #7  This field defines the offset para"
        "meter #7 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_19.
static const field_t hw_ipu_dc_map_conf_19[] =
{
    {
        "MD_MASK_8",
        "Mapping unit's mask value #8  This field defines the mask value #8 wit"
        "hin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_8",
        "Mapping unit's offset parameter #8  This field defines the offset para"
        "meter #8 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_9",
        "Mapping unit's mask value #9  This field defines the mask value #9 wit"
        "hin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_9",
        "Mapping unit's offset parameter #9  This field defines the offset para"
        "meter #9 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_20.
static const field_t hw_ipu_dc_map_conf_20[] =
{
    {
        "MD_MASK_10",
        "Mapping unit's mask value #10  This field defines the mask value #10 w"
        "ithin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_10",
        "Mapping unit's offset parameter #10  This field defines the offset par"
        "ameter #10 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_11",
        "Mapping unit's mask value #11  This field defines the mask value #11 w"
        "ithin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_11",
        "Mapping unit's offset parameter #11  This field defines the offset par"
        "ameter #11 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_21.
static const field_t hw_ipu_dc_map_conf_21[] =
{
    {
        "MD_MASK_12",
        "Mapping unit's mask value #12  This field defines the mask value #12 w"
        "ithin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_12",
        "Mapping unit's offset parameter #12  This field defines the offset par"
        "ameter #12 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_13",
        "Mapping unit's mask value #13  This field defines the mask value #13 w"
        "ithin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_13",
        "Mapping unit's offset parameter #13  This field defines the offset par"
        "ameter #13 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_22.
static const field_t hw_ipu_dc_map_conf_22[] =
{
    {
        "MD_MASK_14",
        "Mapping unit's mask value #14  This field defines the mask value #14 w"
        "ithin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_14",
        "Mapping unit's offset parameter #14  This field defines the offset par"
        "ameter #14 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_15",
        "Mapping unit's mask value #15  This field defines the mask value #15 w"
        "ithin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_15",
        "Mapping unit's offset parameter #15  This field defines the offset par"
        "ameter #15 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_23.
static const field_t hw_ipu_dc_map_conf_23[] =
{
    {
        "MD_MASK_16",
        "Mapping unit's mask value #16  This field defines the mask value #16 w"
        "ithin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_16",
        "Mapping unit's offset parameter #16  This field defines the offset par"
        "ameter #16 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_17",
        "Mapping unit's mask value #17  This field defines the mask value #17 w"
        "ithin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_17",
        "Mapping unit's offset parameter #17  This field defines the offset par"
        "ameter #17 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_24.
static const field_t hw_ipu_dc_map_conf_24[] =
{
    {
        "MD_MASK_18",
        "Mapping unit's mask value #18  This field defines the mask value #18 w"
        "ithin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_18",
        "Mapping unit's offset parameter #18  This field defines the offset par"
        "ameter #18 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_19",
        "Mapping unit's mask value #19  This field defines the mask value #19 w"
        "ithin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_19",
        "Mapping unit's offset parameter #19  This field defines the offset par"
        "ameter #19 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_25.
static const field_t hw_ipu_dc_map_conf_25[] =
{
    {
        "MD_MASK_20",
        "Mapping unit's mask value #20  This field defines the mask value #20 w"
        "ithin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_20",
        "Mapping unit's offset parameter #20  This field defines the offset par"
        "ameter #20 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_21",
        "Mapping unit's mask value #21  This field defines the mask value #21 w"
        "ithin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_21",
        "Mapping unit's offset parameter #21  This field defines the offset par"
        "ameter #21 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_MAP_CONF_26.
static const field_t hw_ipu_dc_map_conf_26[] =
{
    {
        "MD_MASK_22",
        "Mapping unit's mask value #22  This field defines the mask value #22 w"
        "ithin the 8bit word coming from the DC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_22",
        "Mapping unit's offset parameter #22  This field defines the offset par"
        "ameter #22 within the 24bit word coming from the DC.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_MASK_23",
        "Mapping unit's mask value #23  This field defines the mask value #23 w"
        "ithin the 8bit word coming from the DC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MD_OFFSET_23",
        "Mapping unit's offset parameter #23  This field defines the offset par"
        "ameter #23 within the 24bit word coming from the DC.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE0_0.
static const field_t hw_ipu_dc_ugde0_0[] =
{
    {
        "ID_CODED_0",
        "This field defines the number of DC channel number that user's general"
        " event #0 will be associated to.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EV_PRIORITY_0",
        "This field defines the priority of the user general event #0  The prio"
        "rity between the events should be set to a unique value.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EV_START_0",
        "This field holds a pointer in the microcode holding the routine to be "
        "performed following the user general event #0.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_ODD_START_0",
        "This field holds a pointer in the microcode holding the routine to be "
        "performed following the user general event #0.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODD_EN_0",
        "The user's general event #0 may be split into 2 internal signals.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTORESTART_0",
        "User's general event #0 auto restart mode",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NF_NL_0",
        "the user may attach his general event #0 to New-line New-Frame and New"
        "-field events.",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE0_1.
static const field_t hw_ipu_dc_ugde0_1[] =
{
    {
        "STEP_0",
        "This field holds the pre defined value that the counter counts too.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE0_2.
static const field_t hw_ipu_dc_ugde0_2[] =
{
    {
        "OFFSET_DT_0",
        "This field defines the offset value from which the counter of user gen"
        "eral event #0 will start counting from",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE0_3.
static const field_t hw_ipu_dc_ugde0_3[] =
{
    {
        "STEP_REPEAT_0",
        "When auto reload mode is disabled this field defines the number of eve"
        "nts that will be generated by the user general event #0 mechanism",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE1_0.
static const field_t hw_ipu_dc_ugde1_0[] =
{
    {
        "ID_CODED_1",
        "This field defines the number of DC channel number that user's general"
        " event #1 will be associated to",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EV_PRIORITY_1",
        "This field defines the priority of the user general event #1  The prio"
        "rity between the events should be set to a unique value.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EV_START_1",
        "This field holds a pointer in the microcode holding the routine to be "
        "performed following the user general event #1.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_ODD_START_1",
        "This field holds a pointer in the microcode holding the routine to be "
        "performed following the user general event #1.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODD_EN_1",
        "The user's general event #1 may be split into 2 internal signals.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTORESTART_1",
        "User's general event #1 auto restart mode",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NF_NL_1",
        "the user may attach his general event #1 to New-line New-Frame and New"
        "-field events.",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE1_1.
static const field_t hw_ipu_dc_ugde1_1[] =
{
    {
        "STEP_1",
        "This field hold the pre defined value that the counter counts too",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE1_2.
static const field_t hw_ipu_dc_ugde1_2[] =
{
    {
        "OFFSET_DT_1",
        "This field defines the offset value from which the counter of user gen"
        "eral event #1 will start counting from",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE1_3.
static const field_t hw_ipu_dc_ugde1_3[] =
{
    {
        "STEP_REPEAT_1",
        "When auto reload mode is disabled this field defines the number of eve"
        "nts that will be generated by the user general event #1 mechanism",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE2_0.
static const field_t hw_ipu_dc_ugde2_0[] =
{
    {
        "ID_CODED_2",
        "This field defines the number of DC channel number that user's general"
        " event #2 will be associated to",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EV_PRIORITY_2",
        "This field defines the priority of the user general event #2  The prio"
        "rity between the events should be set to a unique value.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EV_START_2",
        "This field holds a pointer in the microcode holding the routine to be "
        "performed following the user general event #2.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_ODD_START_2",
        "This field holds a pointer in the microcode holding the routine to be "
        "performed following the user general event #2 When ODD_MODE is enabled"
        ", only the odd events will use this pointer  When ODD_MODE is disabled"
        " this field is ignored",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODD_EN_2",
        "The user's general event #2 may be split into 2 internal signals.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTORESTART_2",
        "User's general event #2 auto restart mode",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NF_NL_2",
        "the user may attach his general event #2 to New-line New-Frame and New"
        "-field events.",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE2_1.
static const field_t hw_ipu_dc_ugde2_1[] =
{
    {
        "STEP_2",
        "This field hold the pre defined value that the counter counts too",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE2_2.
static const field_t hw_ipu_dc_ugde2_2[] =
{
    {
        "OFFSET_DT_2",
        "This field defines the offset value from which the counter of user gen"
        "eral event #2 will start counting from",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE2_3.
static const field_t hw_ipu_dc_ugde2_3[] =
{
    {
        "STEP_REPEAT_2",
        "When auto reload mode is disabled this field defines the number of eve"
        "nts that will be generated by the user general event #2 mechanism",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE3_0.
static const field_t hw_ipu_dc_ugde3_0[] =
{
    {
        "ID_CODED_3",
        "This field defines the number of DC channel number that user's general"
        " event #3 will be associated to",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EV_PRIORITY_3",
        "This field defines the priority of the user general event #3",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_EV_START_3",
        "This field holds a pointer in the microcode holding the routine to be "
        "performed following the user general event #3.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COD_ODD_START_3",
        "This field holds a pointer in the microcode holding the routine to be "
        "performed following the user general event #3.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODD_EN_3",
        "The user's general event #3 may be split into 2 internal signals.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTORESTART_3",
        "User's general event #3 auto restart mode",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NF_NL_3",
        "the user may attach his general event #3 to New-line New-Frame and New"
        "-field events.",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE3_1.
static const field_t hw_ipu_dc_ugde3_1[] =
{
    {
        "STEP_3",
        "This field hold the pre defined value that the counter counts too",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE3_2.
static const field_t hw_ipu_dc_ugde3_2[] =
{
    {
        "OFFSET_DT_3",
        "This field defines the offset value from which the counter of user gen"
        "eral event #3 will start counting from",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_UGDE3_3.
static const field_t hw_ipu_dc_ugde3_3[] =
{
    {
        "STEP_REPEAT_3",
        "When auto reload mode is disabled this field defines the number of eve"
        "nts that will be generated by the user general event #3 mechanism",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_LLA0.
static const field_t hw_ipu_dc_lla0[] =
{
    {
        "MCU_RS_0_0",
        "This field holds a pointer in the microcode handling the RS_0 routine "
        "for the display defined at DISP_ID_8, when in Low level access mode,",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_1_0",
        "This field holds a pointer in the microcode handling the RS_1 routine "
        "for the display defined at DISP_ID_8, when in Low level access mode,",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_2_0",
        "This field holds a pointer in the microcode handling the RS_2 routine "
        "for the display defined at DISP_ID_8, when in Low level access mode,",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_3_0",
        "This field holds a pointer in the microcode handling the RS_3 routine "
        "for the display defined at DISP_ID_8, when in Low level access mode,",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_LLA1.
static const field_t hw_ipu_dc_lla1[] =
{
    {
        "MCU_RS_0_1",
        "This field holds a pointer in the microcode handling the RS_0 routine "
        "for the display defined at DISP_ID_9, when in Low level access mode,",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_1_1",
        "This field holds a pointer in the microcode handling the RS_1 routine "
        "for the display defined at DISP_ID_9, when in Low level access mode,",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_2_1",
        "This field holds a pointer in the microcode handling the RS_2 routine "
        "for the display defined at DISP_ID_9, when in Low level access mode,",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_3_1",
        "This field holds a pointer in the microcode handling the RS_3 routine "
        "for the display defined at DISP_ID_9, when in Low level access mode,",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_R_LLA0.
static const field_t hw_ipu_dc_r_lla0[] =
{
    {
        "MCU_RS_R_0_0",
        "This field holds a pointer in the microcode handling the RS_0 routine "
        "for the display defined at DISP_ID_8, when in Read Low level access mo"
        "de,",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_R_1_0",
        "This field holds a pointer in the microcode handling the RS_1 routine "
        "for the display defined at DISP_ID_8, when in Read Low level access mo"
        "de,",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_2_0",
        "This field holds a pointer in the microcode handling the RS_2 routine "
        "for the display defined at DISP_ID_8, when in Read Low level access mo"
        "de,",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_3_0",
        "This field holds a pointer in the microcode handling the RS_3 routine "
        "for the display defined at DISP_ID_8, when in Read Low level access mo"
        "de,",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_R_LLA1.
static const field_t hw_ipu_dc_r_lla1[] =
{
    {
        "MCU_RS_R_0_1",
        "This field holds a pointer in the microcode handling the RS_0 routine "
        "for the display defined at DISP_ID_9, when in Read Low level access mo"
        "de,",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_R_1_1",
        "This field holds a pointer in the microcode handling the RS_1 routine "
        "for the display defined at DISP_ID_9, when in Read Low level access mo"
        "de,",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_R_2_1",
        "This field holds a pointer in the microcode handling the RS_2 routine "
        "for the display defined at DISP_ID_9, when in Read Low level access mo"
        "de,",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MCU_RS_R_3_1",
        "This field holds a pointer in the microcode handling the RS_3 routine "
        "for the display defined at DISP_ID_9, when in Read Low level access mo"
        "de,",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_WR_CH_ADDR_5_ALT.
static const field_t hw_ipu_dc_wr_ch_addr_5_alt[] =
{
    {
        "ST_ADDR_5_ALT",
        "This field defines the start address within the display's memory space"
        " where the write transactions will be done to for channel #5, when alt"
        "ernate flow is performed via channel #5",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DC_STAT.
static const field_t hw_ipu_dc_stat[] =
{
    {
        "DC_TRIPLE_BUF_CNT_FULL_0",
        "This bit indicates a FIFO full state on the DC FIFO accessing DI0 when"
        " write to the display flow is used",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_TRIPLE_BUF_CNT_EMPTY_0",
        "This bit indicates a FIFO empty state on the DC FIFO accessing DI0 whe"
        "n write to the display flow is used",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_TRIPLE_BUF_DATA_FULL_0",
        "This bit indicates a FIFO full state on the DC FIFO accessing DI0 when"
        " read from the display flow is used",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_TRIPLE_BUF_DATA_EMPTY_0",
        "This bit indicates a FIFO empty state on the DC FIFO accessing DI0 whe"
        "n read from the display flow is used",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_TRIPLE_BUF_CNT_FULL_1",
        "This bit indicates a FIFO full state on the DC FIFO accessing DI1 when"
        " write to the display flow is used",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_TRIPLE_BUF_CNT_EMPTY_1",
        "This bit indicates a FIFO empty state on the DC FIFO accessing DI1 whe"
        "n write to the display flow is used",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_TRIPLE_BUF_DATA_FULL_1",
        "This bit indicates a FIFO empty state on the DC FIFO accessing DI1 whe"
        "n read from the display flow is used",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC_TRIPLE_BUF_DATA_EMPTY_1",
        "This bit indicates a FIFO full state on the DC FIFO accessing DI1 when"
        " write to the display flow is used",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_RD_CHAN.
static const field_t hw_ipu_dmfc_rd_chan[] =
{
    {
        "DMFC_BURST_SIZE_0",
        "Read burst Size  This field defines the burst size of the DMFC's read "
        "accesses.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_0",
        "Watermark enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_0",
        "Watermark Set  This field defines the watermark's level of the DMFC re"
        "ad FIFO.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_0",
        "Watermark Clear  This field defines the watermark's level of the DMFC "
        "read FIFO.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_PPW_C",
        "Pixel Per Word coded.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_WR_CHAN.
static const field_t hw_ipu_dmfc_wr_chan[] =
{
    {
        "DMFC_ST_ADDR_1",
        "DMFC Start Address for IDMAC's channel 28  This field defines the base"
        " address at the DMFC's FIFO of the partition allocated to the channel "
        "connected to IDMAC's channel 28.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_1",
        "DMFC FIFO size for IDMAC's channel 28  This field defines the FIFO par"
        "tition for the DMFC channel connected to IDMAC's channel 28",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_1",
        "Burst size of IDMAC's channel 28  This field defines the burst size of"
        " the IDMAC's channel 28 write accesses.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_ST_ADDR_2",
        "DMFC Start Address for IDMAC's channel 41  This field defines the base"
        " address at the DMFC's FIFO of the partition allocated to the channel "
        "connected to IDMAC's channel 41.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_2",
        "DMFC FIFO size for IDMAC's channel 41  This field defines the FIFO par"
        "tition for the DMFC channel connected to IDMAC's channel 41",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_2",
        "Burst size of IDMAC's channel 41  This field defines the burst size of"
        " the IDMAC's channel 41 write accesses.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_ST_ADDR_1C",
        "DMFC Start Address for IDMAC's channel 42  This field defines the base"
        " address at the DMFC's FIFO of the partition allocated to the channel "
        "connected to IDMAC's channel 42.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_1C",
        "DMFC FIFO size for IDMAC's channel 42  This field defines the FIFO par"
        "tition for the DMFC channel connected to IDMAC's channel 42",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_1C",
        "Burst size of IDMAC's channel 42  This field defines the burst size of"
        " the IDMAC's channel 42 write accesses.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_ST_ADDR_2C",
        "DMFC Start Address for IDMAC's channel 43  This field defines the base"
        " address at the DMFC's FIFO of the partition allocated to the channel "
        "connected to IDMAC's channel 43.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_2C",
        "DMFC FIFO size for IDMAC's channel 43  This field defines the FIFO par"
        "tition for the DMFC channel connected to IDMAC's channel 43",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_2C",
        "Burst size of IDMAC's channel 43  This field defines the burst size of"
        " the IDMAC's channel 43 write accesses.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_WR_CHAN_DEF.
static const field_t hw_ipu_dmfc_wr_chan_def[] =
{
    {
        "DMFC_WM_EN_1",
        "Watermark enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_1",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_1",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_2",
        "Watermark enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_2",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_2",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_1C",
        "Watermark enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_1C",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_1C",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_2C",
        "Watermark enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_2C",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_2C",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_DP_CHAN.
static const field_t hw_ipu_dmfc_dp_chan[] =
{
    {
        "DMFC_ST_ADDR_5B",
        "DMFC Start Address for IDMAC's channel 23  This field defines the base"
        " address at the DMFC's FIFO of the partition allocated to the channel "
        "connected to IDMAC's channel 23.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_5B",
        "DMFC FIFO size for IDMAC's channel 23  This field defines the FIFO par"
        "tition for the DMFC channel connected to IDMAC's channel 23",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_5B",
        "Burst size of IDMAC's channel 23  This field defines the burst size of"
        " the IDMAC's channel 23 write accesses.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_ST_ADDR_5F",
        "DMFC Start Address for IDMAC's channel 27  This field defines the base"
        " address at the DMFC's FIFO of the partition allocated to the channel "
        "connected to IDMAC's channel 27.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_5F",
        "DMFC FIFO size for IDMAC's channel 27  This field defines the FIFO par"
        "tition for the DMFC channel connected to IDMAC's channel 27",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_5F",
        "Burst size of IDMAC's channel 27  This field defines the burst size of"
        " the IDMAC's channel 27 write accesses.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_ST_ADDR_6B",
        "DMFC Start Address for IDMAC's channel 24  This field defines the base"
        " address at the DMFC's FIFO of the partition allocated to the channel "
        "connected to IDMAC's channel 24.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_6B",
        "DMFC FIFO size for IDMAC's channel 24  This field defines the FIFO par"
        "tition for the DMFC channel connected to IDMAC's channel 24",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_6B",
        "Burst size of IDMAC's channel 24  This field defines the burst size of"
        " the IDMAC's channel 24 write accesses.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_ST_ADDR_6F",
        "DMFC Start Address for IDMAC's channel 29  This field defines the base"
        " address at the DMFC's FIFO of the partition allocated to the channel "
        "connected to IDMAC's channel 29.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_6F",
        "DMFC FIFO size for IDMAC's channel 29  This field defines the FIFO par"
        "tition for the DMFC channel connected to IDMAC's channel 29",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_6F",
        "Burst size of IDMAC's channel 29  This field defines the burst size of"
        " the IDMAC's channel 29 write accesses.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_DP_CHAN_DEF.
static const field_t hw_ipu_dmfc_dp_chan_def[] =
{
    {
        "DMFC_WM_EN_5B",
        "Watermark enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_5B",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_5B",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_5F",
        "Watermark enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_5F",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_5F",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_6B",
        "Watermark enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_6B",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_6B",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_6F",
        "Watermark enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_6F",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_6F",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_GENERAL_1.
static const field_t hw_ipu_dmfc_general_1[] =
{
    {
        "DMFC_DCDP_SYNC_PR",
        "DMFC's memory access priority settings for simultaneous synchronous fl"
        "ows from DC & DP",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_9",
        "Burst size of IDMAC's channel 44  This field defines the burst size of"
        " the IDMAC's channel 44 write accesses.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_9",
        "Watermark enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_9",
        "Watermark Set  This field defines the watermark's level of the DMFC wr"
        "ite FIFO.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_9",
        "Watermark Clear  This field defines the watermark's level of the DMFC'"
        "s write FIFO.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_1",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_2",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_3",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_4",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_5B",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_5F",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_6B",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_6F",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_9",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_GENERAL_2.
static const field_t hw_ipu_dmfc_general_2[] =
{
    {
        "DMFC_FRAME_WIDTH_RD",
        "Frame width for read channel from the display to the IDMAC; Units are "
        "pixels",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FRAME_HEIGHT_RD",
        "Frame height for read channel from the display to the IDMAC; Units are"
        " pixels",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_IC_CTRL.
static const field_t hw_ipu_dmfc_ic_ctrl[] =
{
    {
        "DMFC_IC_IN_PORT",
        "DMFC input port  When data is coming from the IC, the IC channel repla"
        "ces one of the IDMAC's channels connected to the DMFC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_IC_PPW_C",
        "Pixel Per Word coded from IC.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_IC_FRAME_WIDTH_RD",
        "Frame's width for the channel coming from IC.",
        6, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_IC_FRAME_HEIGHT_RD",
        "Frame's height for the channel coming from IC.",
        19, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_WR_CHAN_ALT.
static const field_t hw_ipu_dmfc_wr_chan_alt[] =
{
    {
        "DMFC_ST_ADDR_2_ALT",
        "DMFC Start Address for IDMAC's channel 41 (for alternate flow)  This f"
        "ield defines the base address at the DMFC's FIFO of the partition allo"
        "cated to the channel connected to IDMAC's channel 41.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_2_ALT",
        "DMFC FIFO size for IDMAC's channel 41 (for alternate flow)  This field"
        " defines the FIFO partition for the DMFC channel connected to IDMAC's "
        "channel 41",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_2_ALT",
        "Burst size of IDMAC's channel 41 (for alternate flow)  This field defi"
        "nes the burst size of the IDMAC's channel 41 write accesses.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_WR_CHAN_DEF_ALT.
static const field_t hw_ipu_dmfc_wr_chan_def_alt[] =
{
    {
        "DMFC_WM_EN_2_ALT",
        "Watermark enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_2_ALT",
        "Watermark Set (for alternate flow)  This field defines the watermark's"
        " level of the DMFC write FIFO.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_2_ALT",
        "Watermark Clear (for alternate flow)  This field defines the watermark"
        "'s level of the DMFC's write FIFO.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_DP_CHAN_ALT.
static const field_t hw_ipu_dmfc_dp_chan_alt[] =
{
    {
        "DMFC_ST_ADDR_5B_ALT",
        "DMFC Start Address for IDMAC's channel 23 (for alternate flow)  This f"
        "ield defines the base address at the DMFC's FIFO of the partition allo"
        "cated to the channel connected to IDMAC's channel 23.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_5B_ALT",
        "DMFC FIFO size for IDMAC's channel 23 (for alternate flow)  This field"
        " defines the FIFO partition for the DMFC channel connected to IDMAC's "
        "channel 23",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_5B_ALT",
        "Burst size of IDMAC's channel 23 (for alternate flow)  This field defi"
        "nes the burst size of the IDMAC's channel 23 write accesses.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_ST_ADDR_6B_ALT",
        "DMFC Start Address for IDMAC's channel 24 (for alternate flow)  This f"
        "ield defines the base address at the DMFC's FIFO of the partition allo"
        "cated to the channel connected to IDMAC's channel 24.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_6B_ALT",
        "DMFC FIFO size for IDMAC's channel 24 (for alternate flow)  This field"
        " defines the FIFO partition for the DMFC channel connected to IDMAC's "
        "channel 24",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_6B_ALT",
        "Burst size of IDMAC's channel 24 (for alternate flow)  This field defi"
        "nes the burst size of the IDMAC's channel 24 write accesses.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_ST_ADDR_6F_ALT",
        "DMFC Start Address for IDMAC's channel 29 (for alternate flow)  This f"
        "ield defines the base address at the DMFC's FIFO of the partition allo"
        "cated to the channel connected to IDMAC's channel 29.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_FIFO_SIZE_6F_ALT",
        "DMFC FIFO size for IDMAC's channel 29 (for alternate flow)  This field"
        " defines the FIFO partition for the DMFC channel connected to IDMAC's "
        "channel 29",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_BURST_SIZE_6F_ALT",
        "Burst size of IDMAC's channel 29 (for alternate flow)  This field defi"
        "nes the burst size of the IDMAC's channel 29 write accesses.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_DP_CHAN_DEF_ALT.
static const field_t hw_ipu_dmfc_dp_chan_def_alt[] =
{
    {
        "DMFC_WM_EN_5B_ALT",
        "Watermark enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_5B_ALT",
        "Watermark Set (for alternate flow)  This field defines the watermark's"
        " level of the DMFC write FIFO.",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_5B_ALT",
        "Watermark Clear (for alternate flow)  This field defines the watermark"
        "'s level of the DMFC's write FIFO.",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_6B_ALT",
        "Watermark enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_6B_ALT",
        "Watermark Set (for alternate flow)  This field defines the watermark's"
        " level of the DMFC write FIFO.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_6B_ALT",
        "Watermark Clear (for alternate flow)  This field defines the watermark"
        "'s level of the DMFC's write FIFO.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_EN_6F_ALT",
        "Watermark enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_SET_6F_ALT",
        "Watermark Set (for alternate flow)  This field defines the watermark's"
        " level of the DMFC write FIFO.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMFC_WM_CLR_6F_ALT",
        "Watermark Clear (for alternate flow)  This field defines the watermark"
        "'s level of the DMFC's write FIFO.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_GENERAL1_ALT.
static const field_t hw_ipu_dmfc_general1_alt[] =
{
    {
        "WAIT4EOT_2_ALT",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_5B_ALT",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_6B_ALT",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT4EOT_6F_ALT",
        "In normal operation the DMFC sends requests to the IDMAC whenever ther"
        "e is room in the FIFO.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DMFC_STAT.
static const field_t hw_ipu_dmfc_stat[] =
{
    {
        "DMFC_FIFO_FULL",
        "This bit indicates on a DMFC FIFO#<i> full condition.",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMFC_FIFO_EMPTY",
        "This bit indicates on a DMFC FIFO#<i> empty condition.",
        12, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMFC_IC_BUFFER_FULL",
        "This bit indicates on a IC FIFO, inside the DMFC, full condition.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMFC_IC_BUFFER_EMPTY",
        "This bit indicates on a IC FIFO, inside the DMFC, empty condition.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_FSIZE.
static const field_t hw_ipu_vdi_fsize[] =
{
    {
        "VDI_FWIDTH",
        "Frame width.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_FHEIGHT",
        "Frame height  The value to be written to this register is the frame's "
        "height minus 1.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_C.
static const field_t hw_ipu_vdi_c[] =
{
    {
        "VDI_CH_422",
        "Chroma format at input and output of VDI C .",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_MOT_SEL",
        "Motion select.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_BURST_SIZE1",
        "Burst Size for channels 1 or 4 (channels 1 and 4 are not working simul"
        "taneously).",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_BURST_SIZE2",
        "Burst Size for channel 2.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_BURST_SIZE3",
        "Burst Size for channel 3.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_VWM1_SET",
        "VDI C WaterMark \"set\" level for channel 1 or channel 2 (channels 1 a"
        "nd 4 are not working simultaneously).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_VWM1_CLR",
        "VDI C WaterMark \"clear\" level for channel 1 or channel 4 (channels 1"
        " and 4 are not working simultaneously).",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_VWM3_SET",
        "VDI C WaterMark \"set\" level for channel 3.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_VWM3_CLR",
        "VDI C WaterMark \"clear\" level for channel 3.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_C2.
static const field_t hw_ipu_vdi_c2[] =
{
    {
        "VDI_CMB_EN",
        "Combining enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_KEY_COLOR_EN",
        "Key Color Enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_GLB_A_EN",
        "Global alpha enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_PLANE_1_EN",
        "Plane 1 enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_CMDP_1.
static const field_t hw_ipu_vdi_cmdp_1[] =
{
    {
        "VDI_KEY_COLOR_B",
        "Blue component of Key Color",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_KEY_COLOR_G",
        "Green component of Key Color",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_KEY_COLOR_R",
        "Red component of Key Color",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_ALPHA",
        "Global Alpha  Actual value of the alpha is VDI_ALPHA + VDI_ALPHA[7]",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_CMDP_2.
static const field_t hw_ipu_vdi_cmdp_2[] =
{
    {
        "VDI_KEY_COLOR_B",
        "Blue component of background Color",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_KEY_COLOR_G",
        "Green component of background Color",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_KEY_COLOR_R",
        "Red component of background Color",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_PS_1.
static const field_t hw_ipu_vdi_ps_1[] =
{
    {
        "VDI_FWIDTH1",
        "Plane 1 width.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_FHEIGHT1",
        "Plane 1 height  The value to be written to this register is the plane'"
        "s height minus 1.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_PS_2.
static const field_t hw_ipu_vdi_ps_2[] =
{
    {
        "VDI_OFFSET_HOR1",
        "Horizontal offset of plane 1",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_OFFSET_VER1",
        "Vertical offset of plane 1",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_PS_3.
static const field_t hw_ipu_vdi_ps_3[] =
{
    {
        "VDI_FWIDTH3",
        "Plane 3 width.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_FHEIGHT3",
        "Plane 3 height  The value to be written to this register is the plane'"
        "s height minus 1.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_VDI_PS_4.
static const field_t hw_ipu_vdi_ps_4[] =
{
    {
        "VDI_OFFSET_HOR3",
        "Horizontal offset of plane 3",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDI_OFFSET_VER3",
        "Vertical offset of plane 3",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_SUB_ADDR_0.
static const field_t hw_ipu_idmac_sub_addr_0[] =
{
    {
        "IDMAC_SUB_ADDR",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_SUB_ADDR_4.
static const field_t hw_ipu_idmac_sub_addr_4[] =
{
    {
        "IDMAC_SUB_ADDR_28",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR_8",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR_21",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_SUB_ADDR_1.
static const field_t hw_ipu_idmac_sub_addr_1[] =
{
    {
        "IDMAC_SUB_ADDR3",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR2",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR1",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_SUB_ADDR",
        "The CPMEM alternative entry [i] holds the parameters of the channel th"
        "at is number appears in IDMAC_SUB_ADDR[i].",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_COM_CONF_SYNC.
static const field_t hw_ipu_dp_com_conf_sync[] =
{
    {
        "DP_FG_EN_SYNC",
        "FG_EN - partial plane Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWSEL_SYNC",
        "GWSEL - Graphic Window Select  Select graphic window to be on partial "
        "plane or full plane.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWAM_SYNC",
        "GWAM - Graphic Window Alpha Mode  Select the use of Alpha to be global"
        " or local.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKE_SYNC",
        "GWCKE - Graphic Window Color Keying Enable  Enable or disable graphic "
        "window color keying.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_COC_SYNC",
        "COC - Cursor Operation Control  Controls the format of the cursor and "
        "the type of arithmetic operations",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_DEF_SYNC",
        "CSC_DEF  Enable or disable Color Space Conversion.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_GAMUT_SAT_EN_SYNC",
        "CSC_GAMUT_SAT_EN  Indicate if GAMUT saturation is enabled",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_YUV_SAT_MODE_SYNC",
        "CSC_YUV_SAT_MODE  YUV saturation mode for color space conversion",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_EN_SYNC",
        "GAMMA_EN - Gamma correction block enable bit",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_YUV_EN_SYNC",
        "GAMMA's YUV mode enable for sync flow",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GRAPH_WIND_CTRL_SYNC.
static const field_t hw_ipu_dp_graph_wind_ctrl_sync[] =
{
    {
        "DP_GWCKB_SYNC",
        "GWCKB - Graphic Window Color Keying Blue Component  Defines the blue c"
        "omponent of graphic window color keying.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKG_SYNC",
        "GWCKG - Graphic Window Color Keying Green Component  Defines the green"
        " component of graphic window color keying.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKR_SYNC",
        "GWCKR - Graphic Window Color Keying Red Component  Defines the red com"
        "ponent of graphic window color keying.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWAV_SYNC",
        "GWAV - Graphic Window Alpha Value  Defines the alpha value of graphic "
        "window used for alpha blending between graphic window and full plane.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_FG_POS_SYNC.
static const field_t hw_ipu_dp_fg_pos_sync[] =
{
    {
        "DP_FGYP_SYNC",
        "FGYP partial plane window Y position  partial plane Window Y Position "
        "- Specifies the number of lines between the start of full plane window"
        "s Y position and the beginning of the first data.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_FGXP_SYNC",
        "FGXP partial plane Window X Position.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CUR_POS_SYNC.
static const field_t hw_ipu_dp_cur_pos_sync[] =
{
    {
        "DP_CXW_SYNC",
        "CXW - Cursor Width.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CXP_SYNC",
        "CXP - Cursor X Position  Represents the cursors horizontal starting po"
        "sition X in pixel count (from 0 to CXW).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CYH_SYNC",
        "CYH - Cursor Height  Specifies the height of the hardware cursor in pi"
        "xels.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CYP_SYNC",
        "CYP - Cursor Y Position  Represents the cursors vertical starting posi"
        "tion Y in pixel count (from 0 to CYH).Live View Resolution Mode.",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CUR_MAP_SYNC.
static const field_t hw_ipu_dp_cur_map_sync[] =
{
    {
        "DP_CUR_COL_R_SYNC",
        "CUR_COL_B - Cursor Red Field  Defines the Red component of the cursor "
        "color in color mode",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CUR_COL_G_SYNC",
        "CUR_COL_G - Cursor Green Field  Defines the Green component of the cur"
        "sor color in color mode",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CUR_COL_B_SYNC",
        "CUR_COL_B - Cursor Blue Field  Defines the Blue component of the curso"
        "r color in color mode",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GAMMA_C_SYNC_I.
static const field_t hw_ipu_dp_gamma_c_sync_i[] =
{
    {
        "DP_GAMMA_C_SYNC1",
        "CONSTANTi parameter of Gamma Correction.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_C_SYNC",
        "CONSTANTi+1 parameter of Gamma Correction.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GAMMA_S_SYNC_I.
static const field_t hw_ipu_dp_gamma_s_sync_i[] =
{
    {
        "DP_GAMMA_S_SYNC3",
        "SLOPE<4*i> parameter of Gamma Correction.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_SYNC2",
        "SLOPE<4*i+1> parameter of Gamma Correction.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_SYNC1",
        "SLOPE<4*i+2> parameter of Gamma Correction.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_SYNC",
        "SLOPE<4*i+3> parameter of Gamma Correction.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CSCA_SYNC_I.
static const field_t hw_ipu_dp_csca_sync_i[] =
{
    {
        "DP_CSC_A_SYNC1",
        "A<2*i> parameter of color conversion.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_A_SYNC",
        "A<2*i+1> parameter of color conversion",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_SCS_SYNC_0.
static const field_t hw_ipu_dp_scs_sync_0[] =
{
    {
        "DP_CSC_A8_SYNC",
        "A9 parameter of color conversion.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_B0_SYNC",
        "B0 parameter of color conversion.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S0_SYNC",
        "S0 parameter of color conversion.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_SCS_SYNC_1.
static const field_t hw_ipu_dp_scs_sync_1[] =
{
    {
        "DP_CSC_B1_SYNC",
        "B0 parameter of color conversion.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S1_SYNC",
        "S0 parameter of color conversion.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_B2_SYNC",
        "B0 parameter of color conversion.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S2_SYNC",
        "S0 parameter of color conversion.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CUR_POS_ALT.
static const field_t hw_ipu_dp_cur_pos_alt[] =
{
    {
        "DP_CXW_SYNC_ALT",
        "CXW_ALT - Cursor Width.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CXP_SYNC_ALT",
        "CXP_ALT - Cursor X Position  Represents the cursors horizontal startin"
        "g position X in pixel count (from 0 to CXW) for the alternative flow.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CYH_SYNC_ALT",
        "CYH_ALT - Cursor Height  Specifies the height of the hardware cursor i"
        "n pixels.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CYP_SYNC_ALT",
        "CYP_ALT - Cursor Y Position  Represents the cursors vertical starting "
        "position Y in pixel count (from 0 to CYH).Live View Resolution Mode fo"
        "r the alternative flow.",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_COM_CONF_ASYNC0.
static const field_t hw_ipu_dp_com_conf_async0[] =
{
    {
        "DP_GWSEL_ASYNC0",
        "GWSEL - Graphic Window Select  Select graphic window to be on partial "
        "plane or full plane.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWAM_ASYNC0",
        "GWAM - Graphic Window Alpha Mode  Select the use of Alpha to be global"
        " or local.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKE_ASYNC0",
        "GWCKE - Graphic Window Color Keying Enable  Enable or disable graphic "
        "window color keying.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_COC_ASYNC0",
        "COC - Cursor Operation Control  Controls the format of the cursor and "
        "the type of arithmetic operations",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_DEF_ASYNC0",
        "CSC_DEF  Enable or disable Color Space Conversion.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_GAMUT_SAT_EN_ASYNC0",
        "CSC_GAMUT_SAT_EN  Indicate if GAMUT saturation is enabled",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_YUV_SAT_MODE_ASYNC0",
        "CSC_YUV_SAT_MODE  YUV saturation mode for color space conversion",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_EN_ASYNC0",
        "GAMMA_EN - Gamma correction block enable bit",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_YUV_EN_ASYNC0",
        "GAMMA's YUV mode enable for async flow 0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GRAPH_WIND_CTRL_ASYNC0.
static const field_t hw_ipu_dp_graph_wind_ctrl_async0[] =
{
    {
        "DP_GWCKB_ASYNC0",
        "GWCKB - Graphic Window Color Keying Blue Component  Defines the blue c"
        "omponent of graphic window color keying.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKG_ASYNC0",
        "GWCKG - Graphic Window Color Keying Green Component  Defines the green"
        " component of graphic window color keying.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKR_ASYNC0",
        "GWCKR - Graphic Window Color Keying Red Component  Defines the red com"
        "ponent of graphic window color keying.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWAV_ASYNC0",
        "GWAV - Graphic Window Alpha Value  Defines the alpha value of graphic "
        "window used for alpha blending between graphic window and full plane.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_FG_POS_ASYNC0.
static const field_t hw_ipu_dp_fg_pos_async0[] =
{
    {
        "DP_FGYP_ASYNC0",
        "FGYP partial plane window Y position  partial plane Window Y Position "
        "- Specifies the number of lines between the start of full plane window"
        "s Y position and the beginning of the first data.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_FGXP_ASYNC0",
        "FGXP partial plane Window X Position.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CUR_POS_ASYNC0.
static const field_t hw_ipu_dp_cur_pos_async0[] =
{
    {
        "DP_CXW_ASYNC0",
        "CXW - Cursor Width.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CXP_ASYNC0",
        "CXP - Cursor X Position  Represents the cursors horizontal starting po"
        "sition X in pixel count (from 0 to CXW).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CYH_ASYNC0",
        "CYH - Cursor Height  Specifies the height of the hardware cursor in pi"
        "xels.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CYP_ASYNC0",
        "CYP - Cursor Y Position  Represents the cursors vertical starting posi"
        "tion Y in pixel count (from 0 to CYH).Live View Resolution Mode.",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CUR_MAP_ASYNC0.
static const field_t hw_ipu_dp_cur_map_async0[] =
{
    {
        "DP_CUR_COL_R_ASYNC0",
        "CUR_COL_R - Cursor Red Field  Defines the Red component of the cursor "
        "color in color mode",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CUR_COL_G_ASYNC0",
        "CUR_COL_G - Cursor Green Field  Defines the Green component of the cur"
        "sor color in color mode",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CUR_COL_B_ASYNC0",
        "CUR_COL_B - Cursor Blue Field  Defines the Blue component of the curso"
        "r color in color mode",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GAMMA_C_ASYNC0_I.
static const field_t hw_ipu_dp_gamma_c_async0_i[] =
{
    {
        "DP_GAMMA_C_ASYNC01",
        "CONSTANTi parameter of Gamma Correction.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_C_ASYNC0",
        "CONSTANTi+1 parameter of Gamma Correction.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GAMMA_S_ASYNC0_I.
static const field_t hw_ipu_dp_gamma_s_async0_i[] =
{
    {
        "DP_GAMMA_S_ASYNC03",
        "SLOPE<4*i> parameter of Gamma Correction.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_ASYNC02",
        "SLOPE<4*i+1> parameter of Gamma Correction.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_ASYNC01",
        "SLOPE<4*i+2> parameter of Gamma Correction.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_ASYNC0",
        "SLOPE<4*i+3> parameter of Gamma Correction.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CSCA_ASYNC0_I.
static const field_t hw_ipu_dp_csca_async0_i[] =
{
    {
        "DP_CSC_A_ASYNC01",
        "A<2*i> parameter of color conversion.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_A_ASYNC0",
        "A<2*i+1> parameter of color conversion",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CSC_ASYNC0_0.
static const field_t hw_ipu_dp_csc_async0_0[] =
{
    {
        "DP_CSC_A8_ASYNC0",
        "A9 parameter of color conversion.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_B0_ASYNC0",
        "B0 parameter of color conversion.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S0_ASYNC0",
        "S0 parameter of color conversion.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CSC_ASYNC_1.
static const field_t hw_ipu_dp_csc_async_1[] =
{
    {
        "DP_CSC_B1_ASYNC0",
        "B0 parameter of color conversion.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S1_ASYNC0",
        "S0 parameter of color conversion.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_B2_ASYNC0",
        "B0 parameter of color conversion.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S2_ASYNC0",
        "S0 parameter of color conversion.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_COM_CONF_ASYNC1.
static const field_t hw_ipu_dp_com_conf_async1[] =
{
    {
        "DP_GWSEL_ASYNC1",
        "GWSEL - Graphic Window Select  Select graphic window to be on partial "
        "plane or full plane.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWAM_ASYNC1",
        "GWAM - Graphic Window Alpha Mode  Select the use of Alpha to be global"
        " or local.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKE_ASYNC1",
        "GWCKE - Graphic Window Color Keying Enable  Enable or disable graphic "
        "window color keying.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_COC_ASYNC1",
        "COC - Cursor Operation Control  Controls the format of the cursor and "
        "the type of arithmetic operations",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_DEF_ASYNC1",
        "CSC_DEF  Enable or disable Color Space Conversion.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_GAMUT_SAT_EN_ASYNC1",
        "CSC_GAMUT_SAT_EN  Indicate if GAMUT saturation is enabled",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_YUV_SAT_MODE_ASYNC1",
        "CSC_YUV_SAT_MODE  YUV saturation mode for color space conversion",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_EN_ASYNC1",
        "GAMMA_EN - Gamma correction block enable bit",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_YUV_EN_ASYNC1",
        "GAMMA's YUV mode enable for async flow 1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GRAPH_WIND_CTRL_ASYNC1.
static const field_t hw_ipu_dp_graph_wind_ctrl_async1[] =
{
    {
        "DP_GWCKB_ASYNC1",
        "GWCKB - Graphic Window Color Keying Blue Component  Defines the blue c"
        "omponent of graphic window color keying.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKG_ASYNC1",
        "GWCKG - Graphic Window Color Keying Green Component  Defines the green"
        " component of graphic window color keying.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWCKR_ASYNC1",
        "GWCKR - Graphic Window Color Keying Red Component  Defines the red com"
        "ponent of graphic window color keying.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GWAV_ASYNC1",
        "GWAV - Graphic Window Alpha Value  Defines the alpha value of graphic "
        "window used for alpha blending between graphic window and full plane.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_FG_POS_ASYNC1.
static const field_t hw_ipu_dp_fg_pos_async1[] =
{
    {
        "DP_FGYP_ASYNC1",
        "FGYP partial plane window Y position  partial plane Window Y Position "
        "- Specifies the number of lines between the start of full plane window"
        "s Y position and the beginning of the first data.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_FGXP_ASYNC1",
        "FGXP partial plane Window X Position.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CUR_POS_ASYNC1.
static const field_t hw_ipu_dp_cur_pos_async1[] =
{
    {
        "DP_CXW_ASYNC1",
        "CXW - Cursor Width.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CXP_ASYNC1",
        "CXP - Cursor X Position  Represents the cursors horizontal starting po"
        "sition X in pixel count (from 0 to CXW).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CYH_ASYNC1",
        "CYH - Cursor Height  Specifies the height of the hardware cursor in pi"
        "xels.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CYP_ASYNC1",
        "CYP - Cursor Y Position  Represents the cursors vertical starting posi"
        "tion Y in pixel count (from 0 to CYH).Live View Resolution Mode.",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CUR_MAP_ASYNC1.
static const field_t hw_ipu_dp_cur_map_async1[] =
{
    {
        "DP_CUR_COL_R_ASYNC1",
        "CUR_COL_R - Cursor Red Field  Defines the Red component of the cursor "
        "color in color mode",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CUR_COL_G_ASYNC1",
        "CUR_COL_G - Cursor Green Field  Defines the Green component of the cur"
        "sor color in color mode",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CUR_COL_B_ASYNC1",
        "CUR_COL_B - Cursor Blue Field  Defines the Blue component of the curso"
        "r color in color mode",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GAMMA_C_ASYNC1_I.
static const field_t hw_ipu_dp_gamma_c_async1_i[] =
{
    {
        "DP_GAMMA_C_ASYNC11",
        "CONSTANTi parameter of Gamma Correction.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_C_ASYNC1",
        "CONSTANTi+1 parameter of Gamma Correction.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_GAMMA_S_ASYN1_I.
static const field_t hw_ipu_dp_gamma_s_asyn1_i[] =
{
    {
        "DP_GAMMA_S_ASYNC13",
        "SLOPE<4*i> parameter of Gamma Correction.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_ASYNC12",
        "SLOPE<4*i+1> parameter of Gamma Correction.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_ASYNC11",
        "SLOPE<4*i+2> parameter of Gamma Correction.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_GAMMA_S_ASYNC1",
        "SLOPE<4*i+3> parameter of Gamma Correction.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CSCA_ASYNC1_I.
static const field_t hw_ipu_dp_csca_async1_i[] =
{
    {
        "DP_CSC_A_ASYNC11",
        "A<2*i> parameter of color conversion.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_A_ASYNC1",
        "A<2*i+1> parameter of color conversion.",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CSC_ASYNC1_0.
static const field_t hw_ipu_dp_csc_async1_0[] =
{
    {
        "DP_CSC_A8_ASYNC1",
        "A9 parameter of color conversion.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_B0_ASYNC1",
        "B0 parameter of color conversion.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S0_ASYNC1",
        "S0 parameter of color conversion.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_DP_CSC_ASYNC1_1.
static const field_t hw_ipu_dp_csc_async1_1[] =
{
    {
        "DP_CSC_B1_ASYNC1",
        "B0 parameter of color conversion.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S1_ASYNC1",
        "S0 parameter of color conversion.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_B2_ASYNC1",
        "B0 parameter of color conversion.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_CSC_S2_ASYNC1",
        "S0 parameter of color conversion.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_BNDM_EN_2.
static const field_t hw_ipu_idmac_bndm_en_2[] =
{
    {
        "IDMAC_BNDM_EN_45",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_46",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_47",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_48",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_49",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDMAC_BNDM_EN_50",
        "IDMAC Band Mode Enable bit [i]  This bit controls if the channel curre"
        "ntly works in band mode.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IPU_IDMAC_SC_CORD.
static const field_t hw_ipu_idmac_sc_cord[] =
{
    {
        "SY0",
        "Scroll Y coordination  This field indicates the Y coordinate of the sc"
        "roll.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SX0",
        "Scroll X coordination  This field indicates the X coordinate of the sc"
        "roll.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IPU module.
static const reg_t hw_ipu[] =
{
    {
        "CONF",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_ipu_conf
    },
    {
        "SISG_CTRL0",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_sisg_ctrl0
    },
    {
        "SISG_CTRL1",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_sisg_ctrl1
    },
    {
        "SISG_SET_I",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_sisg_set_i
    },
    {
        "SISG_CLR_I",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_sisg_clr_i
    },
    {
        "INT_CTRL_1",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_int_ctrl_1
    },
    {
        "INT_CTRL_2",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_int_ctrl_2
    },
    {
        "INT_CTRL_3",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_int_ctrl_3
    },
    {
        "INT_CTRL_4",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_int_ctrl_4
    },
    {
        "INT_CTRL_5",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_int_ctrl_5
    },
    {
        "INT_CTRL_6",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_int_ctrl_6
    },
    {
        "INT_CTRL_7",
        "This register contains part of IPUIPU interrupts controls.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_int_ctrl_7
    },
    {
        "INT_CTRL_8",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_int_ctrl_8
    },
    {
        "INT_CTRL_9",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_int_ctrl_9
    },
    {
        "INT_CTRL_10",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ipu_int_ctrl_10
    },
    {
        "INT_CTRL_11",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_int_ctrl_11
    },
    {
        "INT_CTRL_12",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_int_ctrl_12
    },
    {
        "INT_CTRL_13",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_int_ctrl_13
    },
    {
        "INT_CTRL_14",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_int_ctrl_14
    },
    {
        "INT_CTRL_15",
        "This register contains part of IPU interrupts controls.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_ipu_int_ctrl_15
    },
    {
        "SDMA_EVENT_1",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_sdma_event_1
    },
    {
        "SDMA_EVENT_2",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_sdma_event_2
    },
    {
        "SDMA_EVENT_3",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_sdma_event_3
    },
    {
        "SDMA_EVENT_4",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_sdma_event_4
    },
    {
        "SDMA_EVENT_7",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_sdma_event_7
    },
    {
        "SDMA_EVENT_8",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_sdma_event_8
    },
    {
        "SDMA_EVENT_11",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_sdma_event_11
    },
    {
        "SDMA_EVENT_12",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_sdma_event_12
    },
    {
        "SDMA_EVENT_13",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_sdma_event_13
    },
    {
        "SDMA_EVENT_14",
        "This register contains part of IPU SDMA events controls.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_sdma_event_14
    },
    {
        "SRM_PRI1",
        "The register controls the priority of SRM updates.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_srm_pri1
    },
    {
        "SRM_PRI2",
        "The register controls the priority of SRM updates.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ipu_srm_pri2
    },
    {
        "FS_PROC_FLOW1",
        "This register contain controls for IPU's tasks.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ipu_fs_proc_flow1
    },
    {
        "FS_PROC_FLOW2",
        "This register contains controls for IPU's tasks.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_fs_proc_flow2
    },
    {
        "FS_PROC_FLOW3",
        "This register contains controls for IPU's tasks.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_fs_proc_flow3
    },
    {
        "FS_DISP_FLOW1",
        "This register contains controls for IPU's tasks.",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_fs_disp_flow1
    },
    {
        "FS_DISP_FLOW2",
        "This register contains controls for IPU's tasks.",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_fs_disp_flow2
    },
    {
        "SKIP",
        "This register controls the different frame skipping supported by the I"
        "PU.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_skip
    },
    {
        "DISP_ALT_CONF",
        "This register controls various parameters that are used for alternate "
        "flows related to the display modules.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_ipu_disp_alt_conf
    },
    {
        "DISP_GEN",
        "This register controls various aspects of the display port.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_disp_gen
    },
    {
        "DISP_ALT1",
        "This register controls various aspects of the display port.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_disp_alt1
    },
    {
        "DISP_ALT2",
        "This register controls various aspects of the display port.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_disp_alt2
    },
    {
        "DISP_ALT3",
        "This register controls various aspects of the display port.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_disp_alt3
    },
    {
        "DISP_ALT4",
        "This register controls various aspects of the display port.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_disp_alt4
    },
    {
        "SNOOP",
        "This register controls the snooping mechanism",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_snoop
    },
    {
        "MEM_RST",
        "This register controls the memory reset mechanism.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_mem_rst
    },
    {
        "PM",
        "This register controls the automatic transitions of the IPU between di"
        "fferent power modes of the SoC and handles the clock change modes.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ipu_pm
    },
    {
        "GPR",
        "The register contains general purpose bits.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_gpr
    },
    {
        "CH_DB_MODE_SEL0",
        "The register contains double buffer mode select control information fo"
        "r 32 IPU's DMA channels.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_ch_db_mode_sel0
    },
    {
        "CH_DB_MODE_SEL1",
        "The register contains double buffer mode select control information fo"
        "r 32 IPU's DMA channels.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_ch_db_mode_sel1
    },
    {
        "ALT_CH_DB_MODE_SEL0",
        "The register contains double buffer mode select control information fo"
        "r 32 IPU's DMA channels.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_alt_ch_db_mode_sel0
    },
    {
        "ALT_CH_DB_MODE_SEL1",
        "The register contains double buffer mode select control information fo"
        "r 32 IPU's DMA channels.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_alt_ch_db_mode_sel1
    },
    {
        "ALT_CH_TRB_MODE_SEL0",
        "The register contains triple buffer mode select control information fo"
        "r 32 IPU's DMA channels.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ipu_alt_ch_trb_mode_sel0
    },
    {
        "ALT_CH_TRB_MODE_SEL1",
        "The register contains triple buffer mode select control information fo"
        "r 32 IPU's DMA channels.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_alt_ch_trb_mode_sel1
    },
    {
        "INT_STAT_1",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_int_stat_1
    },
    {
        "INT_STAT_2",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_int_stat_2
    },
    {
        "INT_STAT_3",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_int_stat_3
    },
    {
        "INT_STAT_4",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_int_stat_4
    },
    {
        "INT_STAT_5",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_int_stat_5
    },
    {
        "INT_STAT_6",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_int_stat_6
    },
    {
        "INT_STAT_7",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_int_stat_7
    },
    {
        "INT_STAT_8",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_int_stat_8
    },
    {
        "INT_STAT_9",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_int_stat_9
    },
    {
        "INT_STAT_10",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ipu_int_stat_10
    },
    {
        "INT_STAT_11",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_int_stat_11
    },
    {
        "INT_STAT_12",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_int_stat_12
    },
    {
        "INT_STAT_13",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_int_stat_13
    },
    {
        "INT_STAT_14",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_int_stat_14
    },
    {
        "INT_STAT_15",
        "IPU status registers are not stored in the SRM during power gating mod"
        "e.IPU status registers are not stored in the SRM during power gating m"
        "ode.This register contains part of IPU interrupts status bits.",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_ipu_int_stat_15
    },
    {
        "CUR_BUF_0",
        "This register contains the current buffer status information bit for e"
        "ach DMA channel.",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        false, // Writable
        27, // Number of bitfields
        hw_ipu_cur_buf_0
    },
    {
        "CUR_BUF_1",
        "This register contains the current buffer status information bit for e"
        "ach DMA channel.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_ipu_cur_buf_1
    },
    {
        "ALT_CUR_0",
        "This register contains the current buffer status information bit for e"
        "ach DMA channel.",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_ipu_alt_cur_0
    },
    {
        "ALT_CUR_1",
        "This register contains the current buffer status information bit for e"
        "ach DMA channel.",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_ipu_alt_cur_1
    },
    {
        "SRM_STAT",
        "The register contains status bits of SRM updates.",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_ipu_srm_stat
    },
    {
        "PROC_TASKS_STAT",
        "This register contains status bits for IPU's tasks.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_ipu_proc_tasks_stat
    },
    {
        "DISP_TASKS_STAT",
        "This register contains status bits for IPU's tasks.",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_ipu_disp_tasks_stat
    },
    {
        "TRIPLE_CUR_BUF_0",
        "This register contains the current buffer status information for tripl"
        "e buffer mode for each DMA channel.",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_ipu_triple_cur_buf_0
    },
    {
        "TRIPLE_CUR_BUF_1",
        "This register contains the current buffer status information for tripl"
        "e buffer mode for each DMA channel.",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_ipu_triple_cur_buf_1
    },
    {
        "TRIPLE_CUR_BUF_2",
        "This register contains the current buffer status information for tripl"
        "e buffer mode for each DMA channel.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ipu_triple_cur_buf_2
    },
    {
        "TRIPLE_CUR_BUF_3",
        "This register contains the current buffer status information for tripl"
        "e buffer mode for each DMA channel.",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ipu_triple_cur_buf_3
    },
    {
        "CH_BUF0_RDY0",
        "The register contains buffer 0 ready control information for 32 IPU's "
        "DMA channels (31-0).",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_ch_buf0_rdy0
    },
    {
        "CH_BUF0_RDY1",
        "The register contains buffer 0 ready control information for 32 IPU's "
        "DMA channels (63-32).",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_ch_buf0_rdy1
    },
    {
        "CH_BUF1_RDY0",
        "The register contains buffer 1 ready control information for 32 IPU's "
        "DMA channels (31-0).",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_ch_buf1_rdy0
    },
    {
        "CH_BUF1_RDY1",
        "The register contains buffer 0 ready control information for 32 IPU's "
        "DMA channels (63-32).",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_ch_buf1_rdy1
    },
    {
        "ALT_CH_BUF0_RDY0",
        "The register contains buffer 0 ready control information for 32 IPU's "
        "DMA channels (31-0).",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_alt_ch_buf0_rdy0
    },
    {
        "ALT_CH_BUF0_RDY1",
        "The register contains buffer 0 ready control information for 32 IPU's "
        "DMA channels (63-32).",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_alt_ch_buf0_rdy1
    },
    {
        "ALT_CH_BUF1_RDY0",
        "The register contains buffer 1 ready control information for 32 IPU's "
        "DMA channels (31-0).",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_alt_ch_buf1_rdy0
    },
    {
        "ALT_CH_BUF1_RDY1",
        "The register contains buffer 0 ready control information for 32 IPU's "
        "DMA channels (63-32).",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_alt_ch_buf1_rdy1
    },
    {
        "CH_BUF2_RDY0",
        "The register contains buffer 2 ready control information for 32 IPU's "
        "DMA channels (31-0).",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ipu_ch_buf2_rdy0
    },
    {
        "CH_BUF2_RDY1",
        "The register contains buffer 2 ready control information for 32 IPU's "
        "DMA channels (63-32).",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_ch_buf2_rdy1
    },
    {
        "IDMAC_CONF",
        "",
        4, // Width in bytes
        0x00001f40, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ipu_idmac_conf
    },
    {
        "IDMAC_CH_EN_1",
        "",
        4, // Width in bytes
        0x00001f44, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_ipu_idmac_ch_en_1
    },
    {
        "IDMAC_ALT_SEP_ALPHA",
        "",
        4, // Width in bytes
        0x00001f4a, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_idmac_alt_sep_alpha
    },
    {
        "IDMAC_CH_PRI_1",
        "",
        4, // Width in bytes
        0x00001f4e, // Base address offset
        true, // Readable
        true, // Writable
        23, // Number of bitfields
        hw_ipu_idmac_ch_pri_1
    },
    {
        "IDMAC_CH_PRI_2",
        "",
        4, // Width in bytes
        0x00001f52, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ipu_idmac_ch_pri_2
    },
    {
        "IDMAC_WM_EN_2",
        "",
        4, // Width in bytes
        0x00001f54, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_idmac_wm_en_2
    },
    {
        "IDMAC_LOCK_EN_1",
        "",
        4, // Width in bytes
        0x00001f58, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ipu_idmac_lock_en_1
    },
    {
        "IDMAC_CH_BUSY_1",
        "",
        4, // Width in bytes
        0x00001fa4, // Base address offset
        true, // Readable
        false, // Writable
        26, // Number of bitfields
        hw_ipu_idmac_ch_busy_1
    },
    {
        "IDMAC_CH_BUSY_2",
        "",
        4, // Width in bytes
        0x00001fa8, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_ipu_idmac_ch_busy_2
    },
    {
        "IDMAC_SEP_ALPHA",
        "",
        4, // Width in bytes
        0x0000800c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_idmac_sep_alpha
    },
    {
        "IDMAC_WM_EN_1",
        "",
        4, // Width in bytes
        0x0000801c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ipu_idmac_wm_en_1
    },
    {
        "IDMAC_SC_CORD_1",
        "",
        4, // Width in bytes
        0x0000804c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_idmac_sc_cord_1
    },
    {
        "IDMAC_CH_EN_2",
        "",
        4, // Width in bytes
        0x00013888, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_idmac_ch_en_2
    },
    {
        "IDMAC_LOCK_EN_2",
        "",
        4, // Width in bytes
        0x00013978, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_idmac_lock_en_2
    },
    {
        "IDMAC_SUB_ADDR_2",
        "",
        4, // Width in bytes
        0x000139b0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_idmac_sub_addr_2
    },
    {
        "IDMAC_SUB_ADDR_3",
        "",
        4, // Width in bytes
        0x000139b4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_idmac_sub_addr_3
    },
    {
        "IDMAC_BNDM_EN_1",
        "",
        4, // Width in bytes
        0x00013a38, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_idmac_bndm_en_1
    },
    {
        "DP_DEBUG_CNT",
        "This is the debug unit control register.",
        4, // Width in bytes
        0x000180bc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_debug_cnt
    },
    {
        "DP_DEBUG_STAT",
        "",
        4, // Width in bytes
        0x000180c0, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_ipu_dp_debug_stat
    },
    {
        "IC_CONF",
        "This register contains control parameter for IC 3 tasks (pre-processin"
        "g for encoding, pre-processing for view-finder and post processing).",
        4, // Width in bytes
        0x00020000, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ipu_ic_conf
    },
    {
        "IC_PRP_ENC_RSC",
        "This register contains the resizing and downsizing parameters for Prep"
        "rocessing task for encoding.",
        4, // Width in bytes
        0x00020004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_ic_prp_enc_rsc
    },
    {
        "IC_PRP_VF_RSC",
        "This register contains the resizing and downsizing parameters for prep"
        "rocessing task for display.",
        4, // Width in bytes
        0x00020008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_ic_prp_vf_rsc
    },
    {
        "IC_PP_RSC",
        "This register contains the resizing and downsizing parameters for Post"
        "-Processing task for display.",
        4, // Width in bytes
        0x0002000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_ic_pp_rsc
    },
    {
        "IC_CMBP_1",
        "",
        4, // Width in bytes
        0x00020010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_ic_cmbp_1
    },
    {
        "IC_CMBP_2",
        "",
        4, // Width in bytes
        0x00020014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_ic_cmbp_2
    },
    {
        "IC_IDMAC_1",
        "",
        4, // Width in bytes
        0x00020018, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_ipu_ic_idmac_1
    },
    {
        "IC_IDMAC_2",
        "",
        4, // Width in bytes
        0x0002001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_ic_idmac_2
    },
    {
        "IC_IDMAC_3",
        "",
        4, // Width in bytes
        0x00020020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_ic_idmac_3
    },
    {
        "IC_IDMAC_4",
        "",
        4, // Width in bytes
        0x00020024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_ic_idmac_4
    },
    {
        "CSI0_SENS_CONF",
        "",
        4, // Width in bytes
        0x00030000, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_ipu_csi0_sens_conf
    },
    {
        "CSI0_SENS_FRM_SIZE",
        "",
        4, // Width in bytes
        0x00030004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csi0_sens_frm_size
    },
    {
        "CSI0_ACT_FRM_SIZE",
        "",
        4, // Width in bytes
        0x00030008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csi0_act_frm_size
    },
    {
        "CSI0_OUT_FRM_CTRL",
        "",
        4, // Width in bytes
        0x0003000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi0_out_frm_ctrl
    },
    {
        "CSI0_TST_CTRL",
        "",
        4, // Width in bytes
        0x00030010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi0_tst_ctrl
    },
    {
        "CSI0_CCIR_CODE_1",
        "",
        4, // Width in bytes
        0x00030014, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_csi0_ccir_code_1
    },
    {
        "CSI0_CCIR_CODE_2",
        "",
        4, // Width in bytes
        0x00030018, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_csi0_ccir_code_2
    },
    {
        "CSI0_CCIR_CODE_3",
        "",
        4, // Width in bytes
        0x0003001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_csi0_ccir_code_3
    },
    {
        "CSI0_DI",
        "",
        4, // Width in bytes
        0x00030020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi0_di
    },
    {
        "CSI0_SKIP",
        "This register controls the frame skipping supported between CSI0 and t"
        "he SMFC.",
        4, // Width in bytes
        0x00030024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_csi0_skip
    },
    {
        "CSIO_CPD_CTRL",
        "",
        4, // Width in bytes
        0x00030028, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_csio_cpd_ctrl
    },
    {
        "CSIO_CPD_RC_I",
        "These registers contain CONSTANT <i> parameters used for companding of"
        " red component.",
        4, // Width in bytes
        0x0003002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csio_cpd_rc_i
    },
    {
        "CSIO_CPD_RS_I",
        "These registers contain SLOPE <i> parameters used for companding of re"
        "d component.",
        4, // Width in bytes
        0x0003004c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csio_cpd_rs_i
    },
    {
        "CSIO_CPD_GRC_I",
        "These registers contain CONSTANTi parameters used for companding of gr"
        "een components in GRGR rows.",
        4, // Width in bytes
        0x0003005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csio_cpd_grc_i
    },
    {
        "CSIO_CPD_GRS_I",
        "These registers contain SLOPEi parameters used for companding of green"
        " components in GRGR rows.",
        4, // Width in bytes
        0x0003007c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csio_cpd_grs_i
    },
    {
        "CSIO_CPD_GBC_I",
        "These registers contain CONSTANTi parameters used for companding of gr"
        "een components in GBGB rows.",
        4, // Width in bytes
        0x0003008c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csio_cpd_gbc_i
    },
    {
        "CSIO_CPD_GBS_I",
        "These registers contain SLOPEi parameters used for companding of green"
        " components in GBGB rows.",
        4, // Width in bytes
        0x000300ac, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csio_cpd_gbs_i
    },
    {
        "CSIO_CPD_BC_I",
        "These registers contain CONSTANTi parameters used for companding of bl"
        "ue component.",
        4, // Width in bytes
        0x000300bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csio_cpd_bc_i
    },
    {
        "CSIO_CPD_BS_I",
        "These registers contain SLOPEi parameters used for companding of red c"
        "omponent.",
        4, // Width in bytes
        0x000300dc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csio_cpd_bs_i
    },
    {
        "CSI0_CPD_OFFSET1",
        "These registers contain Offset parameters used for companding.",
        4, // Width in bytes
        0x000300ec, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_csi0_cpd_offset1
    },
    {
        "CSI0_CPD_OFFSET2",
        "This register contain Offset parameters used for companding.",
        4, // Width in bytes
        0x000300f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_csi0_cpd_offset2
    },
    {
        "CSI1_SENS_CONF",
        "",
        4, // Width in bytes
        0x00038000, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_ipu_csi1_sens_conf
    },
    {
        "CSI1_SENS_FRM_SIZE",
        "",
        4, // Width in bytes
        0x00038004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csi1_sens_frm_size
    },
    {
        "CSI1_ACT_FRM_SIZE",
        "",
        4, // Width in bytes
        0x00038008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csi1_act_frm_size
    },
    {
        "CSI1_OUT_FRM_CTRL",
        "",
        4, // Width in bytes
        0x0003800c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi1_out_frm_ctrl
    },
    {
        "CSI1_TST_CTRL",
        "",
        4, // Width in bytes
        0x00038010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi1_tst_ctrl
    },
    {
        "CSI1_CCIR_CODE_1",
        "",
        4, // Width in bytes
        0x00038014, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_csi1_ccir_code_1
    },
    {
        "CSI1_CCIR_CODE_2",
        "",
        4, // Width in bytes
        0x00038018, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_csi1_ccir_code_2
    },
    {
        "CSI1_CCIR_CODE_3",
        "",
        4, // Width in bytes
        0x0003801c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_csi1_ccir_code_3
    },
    {
        "CSI1_DI",
        "",
        4, // Width in bytes
        0x00038020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi1_di
    },
    {
        "CSI1_SKIP",
        "This register control the frame skipping supported between CSI1 and th"
        "e SMFC.",
        4, // Width in bytes
        0x00038024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_csi1_skip
    },
    {
        "CSI1_CPD_CTRL",
        "",
        4, // Width in bytes
        0x00038028, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_ipu_csi1_cpd_ctrl
    },
    {
        "CSI1_CPD_RC_I",
        "These registers contain CONSTANT <i> parameters used for companding of"
        " red component.",
        4, // Width in bytes
        0x0003802c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csi1_cpd_rc_i
    },
    {
        "CSI1_CPD_RS_I",
        "These registers contain SLOPE <i> parameters used for companding of re"
        "d component.",
        4, // Width in bytes
        0x0003804c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi1_cpd_rs_i
    },
    {
        "CSI1_CPD_GRC_I",
        "These registers contain CONSTANTi parameters used for companding of gr"
        "een components in GRGR rows.",
        4, // Width in bytes
        0x0003805c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csi1_cpd_grc_i
    },
    {
        "CSI1_CPD_GRS_I",
        "These registers contain SLOPEi parameters used for companding of green"
        " components in GRGR rows.",
        4, // Width in bytes
        0x0003807c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi1_cpd_grs_i
    },
    {
        "CSI1_CPD_GBC_I",
        "These registers contain CONSTANTi parameters used for companding of gr"
        "een components in GBGB rows.",
        4, // Width in bytes
        0x0003808c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csi1_cpd_gbc_i
    },
    {
        "CSI1_CPD_GBS_I",
        "These registers contain SLOPEi parameters used for companding of green"
        " components in GBGB rows.",
        4, // Width in bytes
        0x000380ac, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi1_cpd_gbs_i
    },
    {
        "CSI1_CPD_BC_I",
        "These registers contend CONSTANTi parameters used for companding of bl"
        "ue component.",
        4, // Width in bytes
        0x000380bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_csi1_cpd_bc_i
    },
    {
        "CSI1_CPD_BS_I",
        "This registers contain SLOPEi parameters used for companding of red co"
        "mponent.",
        4, // Width in bytes
        0x000380dc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_csi1_cpd_bs_i
    },
    {
        "CSI1_CPD_OFFSET1",
        "These registers contain Offset parameters used for companding.",
        4, // Width in bytes
        0x000380ec, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_csi1_cpd_offset1
    },
    {
        "CSI1_CPD_OFFSET2",
        "These registers contain Offset parameters used for companding.",
        4, // Width in bytes
        0x000380f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_csi1_cpd_offset2
    },
    {
        "DI0_GENERAL",
        "",
        4, // Width in bytes
        0x00040000, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_ipu_di0_general
    },
    {
        "DI0_BS_CLKGEN0",
        "",
        4, // Width in bytes
        0x00040004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di0_bs_clkgen0
    },
    {
        "DI0_BS_CLKGEN1",
        "",
        4, // Width in bytes
        0x00040008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di0_bs_clkgen1
    },
    {
        "DI0_SW_GEN0_1",
        "",
        4, // Width in bytes
        0x0004000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_1
    },
    {
        "DI0_SW_GEN0_2",
        "",
        4, // Width in bytes
        0x00040010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_2
    },
    {
        "DI0_SW_GEN0_3",
        "",
        4, // Width in bytes
        0x00040014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_3
    },
    {
        "DI0_SW_GEN0_4",
        "",
        4, // Width in bytes
        0x00040018, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_4
    },
    {
        "DI0_SW_GEN0_5",
        "",
        4, // Width in bytes
        0x0004001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_5
    },
    {
        "DI0_SW_GEN0_6",
        "",
        4, // Width in bytes
        0x00040020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_6
    },
    {
        "DI0_SW_GEN0_7",
        "",
        4, // Width in bytes
        0x00040024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_7
    },
    {
        "DI0_SW_GEN0_8",
        "",
        4, // Width in bytes
        0x00040028, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_8
    },
    {
        "DI0_SW_GEN0_9",
        "",
        4, // Width in bytes
        0x0004002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_sw_gen0_9
    },
    {
        "DI0_SW_GEN1_1",
        "",
        4, // Width in bytes
        0x00040030, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di0_sw_gen1_1
    },
    {
        "DI0_SW_GEN1_2",
        "",
        4, // Width in bytes
        0x00040034, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di0_sw_gen1_2
    },
    {
        "DI0_SW_GEN1_3",
        "",
        4, // Width in bytes
        0x00040038, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di0_sw_gen1_3
    },
    {
        "DI0_SW_GEN1_4",
        "",
        4, // Width in bytes
        0x0004003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di0_sw_gen1_4
    },
    {
        "DI0_SW_GEN1_5",
        "",
        4, // Width in bytes
        0x00040040, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di0_sw_gen1_5
    },
    {
        "DI0_SW_GEN1_6",
        "",
        4, // Width in bytes
        0x00040044, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di0_sw_gen1_6
    },
    {
        "DI0_SW_GEN1_7",
        "",
        4, // Width in bytes
        0x00040048, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di0_sw_gen1_7
    },
    {
        "DI0_SW_GEN1_8",
        "",
        4, // Width in bytes
        0x0004004c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di0_sw_gen1_8
    },
    {
        "DI0_SW_GEN1_9",
        "",
        4, // Width in bytes
        0x00040050, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_di0_sw_gen1_9
    },
    {
        "DI0_SYNC_AS_GEN",
        "",
        4, // Width in bytes
        0x00040054, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_di0_sync_as_gen
    },
    {
        "DI0_DW_GEN_I",
        "The DI0_DW_GEN_<i> register holds pointers for the waveform generators"
        ".",
        4, // Width in bytes
        0x00040058, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ipu_di0_dw_gen_i
    },
    {
        "DI0_DW_SET0_I",
        "",
        4, // Width in bytes
        0x00040088, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di0_dw_set0_i
    },
    {
        "DI0_DW_SET1_I",
        "",
        4, // Width in bytes
        0x000400b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di0_dw_set1_i
    },
    {
        "DI0_DW_SET2_I",
        "",
        4, // Width in bytes
        0x000400e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di0_dw_set2_i
    },
    {
        "DI0_DW_SET3_I",
        "",
        4, // Width in bytes
        0x00040118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di0_dw_set3_i
    },
    {
        "DI0_STP_REP_I",
        "",
        4, // Width in bytes
        0x00040148, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di0_stp_rep_i
    },
    {
        "DI0_STP_REP_9",
        "",
        4, // Width in bytes
        0x00040158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_di0_stp_rep_9
    },
    {
        "DI0_SER_CONF",
        "",
        4, // Width in bytes
        0x0004015c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ipu_di0_ser_conf
    },
    {
        "DI0_SSC",
        "",
        4, // Width in bytes
        0x00040160, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ipu_di0_ssc
    },
    {
        "DI0_POL",
        "",
        4, // Width in bytes
        0x00040164, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_di0_pol
    },
    {
        "DI0_AW0",
        "",
        4, // Width in bytes
        0x00040168, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di0_aw0
    },
    {
        "DI0_AW1",
        "",
        4, // Width in bytes
        0x0004016c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_di0_aw1
    },
    {
        "DI0_SCR_CONF",
        "",
        4, // Width in bytes
        0x00040170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_di0_scr_conf
    },
    {
        "DI0_STAT",
        "",
        4, // Width in bytes
        0x00040174, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_ipu_di0_stat
    },
    {
        "DI1_GENERAL",
        "",
        4, // Width in bytes
        0x00048000, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_ipu_di1_general
    },
    {
        "DI1_BS_CLKGEN0",
        "",
        4, // Width in bytes
        0x00048004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di1_bs_clkgen0
    },
    {
        "DI1_BS_CLKGEN1",
        "",
        4, // Width in bytes
        0x00048008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di1_bs_clkgen1
    },
    {
        "DI1_SW_GEN0_1",
        "",
        4, // Width in bytes
        0x0004800c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_1
    },
    {
        "DI1_SW_GEN0_2",
        "",
        4, // Width in bytes
        0x00048010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_2
    },
    {
        "DI1_SW_GEN0_3",
        "",
        4, // Width in bytes
        0x00048014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_3
    },
    {
        "DI1_SW_GEN0_4",
        "",
        4, // Width in bytes
        0x00048018, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_4
    },
    {
        "DI1_SW_GEN0_5",
        "",
        4, // Width in bytes
        0x0004801c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_5
    },
    {
        "DI1_SW_GEN0_6",
        "",
        4, // Width in bytes
        0x00048020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_6
    },
    {
        "DI1_SW_GEN0_7",
        "",
        4, // Width in bytes
        0x00048024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_7
    },
    {
        "DI1_SW_GEN0_8",
        "",
        4, // Width in bytes
        0x00048028, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_8
    },
    {
        "DI1_SW_GEN0_9",
        "",
        4, // Width in bytes
        0x0004802c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_sw_gen0_9
    },
    {
        "DI1_SW_GEN1_1",
        "",
        4, // Width in bytes
        0x00048030, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di1_sw_gen1_1
    },
    {
        "DI1_SW_GEN1_2",
        "",
        4, // Width in bytes
        0x00048034, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di1_sw_gen1_2
    },
    {
        "DI1_SW_GEN1_3",
        "",
        4, // Width in bytes
        0x00048038, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di1_sw_gen1_3
    },
    {
        "DI1_SW_GEN1_4",
        "",
        4, // Width in bytes
        0x0004803c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di1_sw_gen1_4
    },
    {
        "DI1_SW_GEN1_5",
        "",
        4, // Width in bytes
        0x00048040, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di1_sw_gen1_5
    },
    {
        "DI1_SW_GEN1_6",
        "",
        4, // Width in bytes
        0x00048044, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di1_sw_gen1_6
    },
    {
        "DI1_SW_GEN1_7",
        "",
        4, // Width in bytes
        0x00048048, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di1_sw_gen1_7
    },
    {
        "DI1_SW_GEN1_8",
        "",
        4, // Width in bytes
        0x0004804c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_di1_sw_gen1_8
    },
    {
        "DI1_SW_GEN1_9",
        "",
        4, // Width in bytes
        0x00048050, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_di1_sw_gen1_9
    },
    {
        "DI1_SYNC_AS_GEN",
        "",
        4, // Width in bytes
        0x00048054, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_di1_sync_as_gen
    },
    {
        "DI1_DW_GEN_I",
        "The DI1_DW_GEN_<i> register holds pointers for the waveform generators"
        ".",
        4, // Width in bytes
        0x00048058, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ipu_di1_dw_gen_i
    },
    {
        "DI1_DW_SET0_I",
        "",
        4, // Width in bytes
        0x00048088, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di1_dw_set0_i
    },
    {
        "DI1_DW_SET1_I",
        "",
        4, // Width in bytes
        0x000480b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di1_dw_set1_i
    },
    {
        "DI1_DW_SET2_I",
        "",
        4, // Width in bytes
        0x000480e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di1_dw_set2_i
    },
    {
        "DI1_DW_SET3_I",
        "",
        4, // Width in bytes
        0x00048118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_di1_dw_set3_i
    },
    {
        "D1_STP_REP_I",
        "",
        4, // Width in bytes
        0x00048148, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_d1_stp_rep_i
    },
    {
        "DI1_STP_REP_9",
        "",
        4, // Width in bytes
        0x00048158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_di1_stp_rep_9
    },
    {
        "DI1_SER_CONF",
        "",
        4, // Width in bytes
        0x0004815c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ipu_di1_ser_conf
    },
    {
        "DI1_SSC",
        "",
        4, // Width in bytes
        0x00048160, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_di1_ssc
    },
    {
        "DI1_POL",
        "",
        4, // Width in bytes
        0x00048164, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_di1_pol
    },
    {
        "DI1_AW0",
        "",
        4, // Width in bytes
        0x00048168, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_di1_aw0
    },
    {
        "DI1_AW1",
        "",
        4, // Width in bytes
        0x0004816c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_di1_aw1
    },
    {
        "DI1_SCR_CONF",
        "",
        4, // Width in bytes
        0x00048170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_di1_scr_conf
    },
    {
        "DI1_STAT",
        "",
        4, // Width in bytes
        0x00048174, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_ipu_di1_stat
    },
    {
        "SMFC_MAP",
        "The purpose of this register is to map CSI frames to IDMAC channels.",
        4, // Width in bytes
        0x00050000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_smfc_map
    },
    {
        "SMFC_WMC",
        "The purpose of this register is to control watermarks levels of DMA ch"
        "annels.",
        4, // Width in bytes
        0x00050004, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ipu_smfc_wmc
    },
    {
        "SMFC_BS",
        "This register holds the burst size value for each DMASMFC channel.",
        4, // Width in bytes
        0x00050008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_smfc_bs
    },
    {
        "DC_READ_CH_CONF",
        "",
        4, // Width in bytes
        0x00058000, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ipu_dc_read_ch_conf
    },
    {
        "DC_READ_SH_ADDR",
        "",
        4, // Width in bytes
        0x00058004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_read_sh_addr
    },
    {
        "DC_RL0_CH_0",
        "",
        4, // Width in bytes
        0x00058008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl0_ch_0
    },
    {
        "DC_RL1_CH_0",
        "",
        4, // Width in bytes
        0x0005800c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl1_ch_0
    },
    {
        "DC_RL2_CH_0",
        "",
        4, // Width in bytes
        0x00058010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl2_ch_0
    },
    {
        "DC_RL3_CH_0",
        "",
        4, // Width in bytes
        0x00058014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl3_ch_0
    },
    {
        "DC_RL4_CH_0",
        "",
        4, // Width in bytes
        0x00058018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl4_ch_0
    },
    {
        "DC_WR_CH_CONF_1",
        "",
        4, // Width in bytes
        0x0005801c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_dc_wr_ch_conf_1
    },
    {
        "DC_WR_CH_ADDR_1",
        "",
        4, // Width in bytes
        0x00058020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_wr_ch_addr_1
    },
    {
        "DC_RL0_CH_1",
        "",
        4, // Width in bytes
        0x00058024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl0_ch_1
    },
    {
        "DC_RL1_CH_1",
        "",
        4, // Width in bytes
        0x00058028, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl1_ch_1
    },
    {
        "DC_RL2_CH_1",
        "",
        4, // Width in bytes
        0x00058030, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl2_ch_1
    },
    {
        "DC_RL3_CH_1",
        "",
        4, // Width in bytes
        0x00058032, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl3_ch_1
    },
    {
        "DC_RL4_CH_1",
        "",
        4, // Width in bytes
        0x00058034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl4_ch_1
    },
    {
        "DC_WR_CH_CONF_2",
        "",
        4, // Width in bytes
        0x00058038, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_wr_ch_conf_2
    },
    {
        "DC_WR_CH_ADDR_2",
        "",
        4, // Width in bytes
        0x0005803c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_wr_ch_addr_2
    },
    {
        "DC_RL0_CH_2",
        "",
        4, // Width in bytes
        0x00058040, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl0_ch_2
    },
    {
        "DC_RL1_CH_2",
        "",
        4, // Width in bytes
        0x00058044, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl1_ch_2
    },
    {
        "DC_RL2_CH_2",
        "",
        4, // Width in bytes
        0x00058048, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl2_ch_2
    },
    {
        "DC_RL3_CH_2",
        "",
        4, // Width in bytes
        0x0005804c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl3_ch_2
    },
    {
        "DC_RL4_CH_2",
        "",
        4, // Width in bytes
        0x00058050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl4_ch_2
    },
    {
        "DC_CMD_CH_CONF_3",
        "",
        4, // Width in bytes
        0x00058054, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_cmd_ch_conf_3
    },
    {
        "DC_CMD_CH_CONF_4",
        "",
        4, // Width in bytes
        0x00058058, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_cmd_ch_conf_4
    },
    {
        "DC_WR_CH_CONF_5",
        "",
        4, // Width in bytes
        0x0005805c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_dc_wr_ch_conf_5
    },
    {
        "DC_WR_CH_ADDR_5",
        "",
        4, // Width in bytes
        0x00058060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_wr_ch_addr_5
    },
    {
        "DC_RL0_CH_5",
        "",
        4, // Width in bytes
        0x00058064, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl0_ch_5
    },
    {
        "DC_RL1_CH_5",
        "",
        4, // Width in bytes
        0x00058068, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl1_ch_5
    },
    {
        "DC_RL2_CH_5",
        "",
        4, // Width in bytes
        0x0005806c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl2_ch_5
    },
    {
        "DC_RL3_CH_5",
        "",
        4, // Width in bytes
        0x00058070, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl3_ch_5
    },
    {
        "DC_RL4_CH_5",
        "",
        4, // Width in bytes
        0x00058074, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl4_ch_5
    },
    {
        "DC_WR_CH_CONF_6",
        "",
        4, // Width in bytes
        0x00058078, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_wr_ch_conf_6
    },
    {
        "DC_WR_CH_ADDR_6",
        "",
        4, // Width in bytes
        0x0005807c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_wr_ch_addr_6
    },
    {
        "DC_RL0_CH_6",
        "",
        4, // Width in bytes
        0x00058080, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl0_ch_6
    },
    {
        "DC_RL1_CH_6",
        "",
        4, // Width in bytes
        0x00058084, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl1_ch_6
    },
    {
        "DC_RL2_CH_6",
        "",
        4, // Width in bytes
        0x00058088, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl2_ch_6
    },
    {
        "DC_RL3_CH_6",
        "",
        4, // Width in bytes
        0x0005808c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_rl3_ch_6
    },
    {
        "DC_RL4_CH_6",
        "",
        4, // Width in bytes
        0x00058090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl4_ch_6
    },
    {
        "DC_WR_CH_CONF1_8",
        "",
        4, // Width in bytes
        0x00058094, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_wr_ch_conf1_8
    },
    {
        "DC_WR_CH_CONF2_8",
        "",
        4, // Width in bytes
        0x00058098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_wr_ch_conf2_8
    },
    {
        "DC_RL1_CH_8",
        "",
        4, // Width in bytes
        0x0005809c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_rl1_ch_8
    },
    {
        "DC_RL2_CH_8",
        "",
        4, // Width in bytes
        0x000580a0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_rl2_ch_8
    },
    {
        "DC_RL3_CH_8",
        "",
        4, // Width in bytes
        0x000580a4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_rl3_ch_8
    },
    {
        "DC_RL4_CH_8",
        "",
        4, // Width in bytes
        0x000580a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl4_ch_8
    },
    {
        "DC_RL5_CH_8",
        "",
        4, // Width in bytes
        0x000580ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl5_ch_8
    },
    {
        "DC_RL6_CH_8",
        "",
        4, // Width in bytes
        0x000580b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl6_ch_8
    },
    {
        "DC_WR_CH_CONF1_9",
        "",
        4, // Width in bytes
        0x000580b4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_wr_ch_conf1_9
    },
    {
        "DC_WR_CH_CONF2_9",
        "",
        4, // Width in bytes
        0x000580b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_wr_ch_conf2_9
    },
    {
        "DC_RL1_CH_9",
        "",
        4, // Width in bytes
        0x000580bc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_rl1_ch_9
    },
    {
        "DC_RL2_CH_9",
        "",
        4, // Width in bytes
        0x000580c0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_rl2_ch_9
    },
    {
        "DC_RL3_CH_9",
        "",
        4, // Width in bytes
        0x000580c4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dc_rl3_ch_9
    },
    {
        "DC_RL4_CH_9",
        "",
        4, // Width in bytes
        0x000580c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl4_ch_9
    },
    {
        "DC_RL5_CH_9",
        "",
        4, // Width in bytes
        0x000580cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl5_ch_9
    },
    {
        "DC_RL6_CH_9",
        "",
        4, // Width in bytes
        0x000580d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dc_rl6_ch_9
    },
    {
        "DC_GEN",
        "",
        4, // Width in bytes
        0x000580d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ipu_dc_gen
    },
    {
        "DC_DISP_CONF1_0",
        "",
        4, // Width in bytes
        0x000580d8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_dc_disp_conf1_0
    },
    {
        "DC_DISP_CONF1_1",
        "",
        4, // Width in bytes
        0x000580dc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_dc_disp_conf1_1
    },
    {
        "DC_DISP_CONF1_2",
        "",
        4, // Width in bytes
        0x000580e0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_dc_disp_conf1_2
    },
    {
        "DC_DISP_CONF1_3",
        "",
        4, // Width in bytes
        0x000580e4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_dc_disp_conf1_3
    },
    {
        "DC_DISP_CONF2_0",
        "",
        4, // Width in bytes
        0x000580e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_disp_conf2_0
    },
    {
        "DC_DISP_CONF2_1",
        "",
        4, // Width in bytes
        0x000580ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_disp_conf2_1
    },
    {
        "DC_DISP_CONF2_2",
        "",
        4, // Width in bytes
        0x000580f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_disp_conf2_2
    },
    {
        "DC_DISP_CONF2_3",
        "",
        4, // Width in bytes
        0x000580f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_disp_conf2_3
    },
    {
        "DC_DI0_CONF_1",
        "",
        4, // Width in bytes
        0x000580f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_di0_conf_1
    },
    {
        "DC_DI0_CONF_2",
        "",
        4, // Width in bytes
        0x000580fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_di0_conf_2
    },
    {
        "DC_DI1_CONF_1",
        "",
        4, // Width in bytes
        0x00058100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_di1_conf_1
    },
    {
        "DC_DI1_CONF_2",
        "",
        4, // Width in bytes
        0x00058104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_di1_conf_2
    },
    {
        "DC_MAP_CONF_0",
        "",
        4, // Width in bytes
        0x00058108, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_0
    },
    {
        "DC_MAP_CONF_1",
        "",
        4, // Width in bytes
        0x0005810c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_1
    },
    {
        "DC_MAP_CONF_2",
        "",
        4, // Width in bytes
        0x00058110, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_2
    },
    {
        "DC_MAP_CONF_3",
        "",
        4, // Width in bytes
        0x00058114, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_3
    },
    {
        "DC_MAP_CONF_4",
        "",
        4, // Width in bytes
        0x00058118, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_4
    },
    {
        "DC_MAP_CONF_5",
        "",
        4, // Width in bytes
        0x0005811c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_5
    },
    {
        "DC_MAP_CONF_6",
        "",
        4, // Width in bytes
        0x00058120, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_6
    },
    {
        "DC_MAP_CONF_7",
        "",
        4, // Width in bytes
        0x00058124, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_7
    },
    {
        "DC_MAP_CONF_8",
        "",
        4, // Width in bytes
        0x00058128, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_8
    },
    {
        "DC_MAP_CONF_9",
        "",
        4, // Width in bytes
        0x0005812c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_9
    },
    {
        "DC_MAP_CONF_10",
        "",
        4, // Width in bytes
        0x00058130, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_10
    },
    {
        "DC_MAP_CONF_11",
        "",
        4, // Width in bytes
        0x00058134, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_11
    },
    {
        "DC_MAP_CONF_12",
        "",
        4, // Width in bytes
        0x00058138, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_12
    },
    {
        "DC_MAP_CONF_13",
        "",
        4, // Width in bytes
        0x0005813c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_13
    },
    {
        "DC_MAP_CONF_14",
        "",
        4, // Width in bytes
        0x00058140, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_dc_map_conf_14
    },
    {
        "DC_MAP_CONF_15",
        "",
        4, // Width in bytes
        0x00058144, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_15
    },
    {
        "DC_MAP_CONF_16",
        "",
        4, // Width in bytes
        0x00058148, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_16
    },
    {
        "DC_MAP_CONF_17",
        "",
        4, // Width in bytes
        0x0005814c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_17
    },
    {
        "DC_MAP_CONF_18",
        "",
        4, // Width in bytes
        0x00058150, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_18
    },
    {
        "DC_MAP_CONF_19",
        "",
        4, // Width in bytes
        0x00058154, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_19
    },
    {
        "DC_MAP_CONF_20",
        "",
        4, // Width in bytes
        0x00058158, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_20
    },
    {
        "DC_MAP_CONF_21",
        "",
        4, // Width in bytes
        0x0005815c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_21
    },
    {
        "DC_MAP_CONF_22",
        "",
        4, // Width in bytes
        0x00058160, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_22
    },
    {
        "DC_MAP_CONF_23",
        "",
        4, // Width in bytes
        0x00058164, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_23
    },
    {
        "DC_MAP_CONF_24",
        "",
        4, // Width in bytes
        0x00058168, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_24
    },
    {
        "DC_MAP_CONF_25",
        "",
        4, // Width in bytes
        0x0005816c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_25
    },
    {
        "DC_MAP_CONF_26",
        "",
        4, // Width in bytes
        0x00058170, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_map_conf_26
    },
    {
        "DC_UGDE0_0",
        "",
        4, // Width in bytes
        0x00058174, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_dc_ugde0_0
    },
    {
        "DC_UGDE0_1",
        "",
        4, // Width in bytes
        0x00058178, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde0_1
    },
    {
        "DC_UGDE0_2",
        "",
        4, // Width in bytes
        0x0005817c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde0_2
    },
    {
        "DC_UGDE0_3",
        "",
        4, // Width in bytes
        0x00058180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde0_3
    },
    {
        "DC_UGDE1_0",
        "",
        4, // Width in bytes
        0x00058184, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_dc_ugde1_0
    },
    {
        "DC_UGDE1_1",
        "",
        4, // Width in bytes
        0x00058188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde1_1
    },
    {
        "DC_UGDE1_2",
        "",
        4, // Width in bytes
        0x0005818c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde1_2
    },
    {
        "DC_UGDE1_3",
        "",
        4, // Width in bytes
        0x00058190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde1_3
    },
    {
        "DC_UGDE2_0",
        "",
        4, // Width in bytes
        0x00058194, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_dc_ugde2_0
    },
    {
        "DC_UGDE2_1",
        "",
        4, // Width in bytes
        0x00058198, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde2_1
    },
    {
        "DC_UGDE2_2",
        "",
        4, // Width in bytes
        0x0005819c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde2_2
    },
    {
        "DC_UGDE2_3",
        "",
        4, // Width in bytes
        0x000581a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde2_3
    },
    {
        "DC_UGDE3_0",
        "",
        4, // Width in bytes
        0x000581a4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ipu_dc_ugde3_0
    },
    {
        "DC_UGDE3_1",
        "",
        4, // Width in bytes
        0x000581a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde3_1
    },
    {
        "DC_UGDE3_2",
        "",
        4, // Width in bytes
        0x000581ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde3_2
    },
    {
        "DC_UGDE3_3",
        "",
        4, // Width in bytes
        0x000581b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_ugde3_3
    },
    {
        "DC_LLA0",
        "",
        4, // Width in bytes
        0x000581b4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_lla0
    },
    {
        "DC_LLA1",
        "",
        4, // Width in bytes
        0x000581b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_lla1
    },
    {
        "DC_R_LLA0",
        "",
        4, // Width in bytes
        0x000581bc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_r_lla0
    },
    {
        "DC_R_LLA1",
        "",
        4, // Width in bytes
        0x000581c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dc_r_lla1
    },
    {
        "DC_WR_CH_ADDR_5_ALT",
        "",
        4, // Width in bytes
        0x000581c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_dc_wr_ch_addr_5_alt
    },
    {
        "DC_STAT",
        "",
        4, // Width in bytes
        0x000581c8, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_ipu_dc_stat
    },
    {
        "DMFC_RD_CHAN",
        "",
        4, // Width in bytes
        0x00060000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ipu_dmfc_rd_chan
    },
    {
        "DMFC_WR_CHAN",
        "",
        4, // Width in bytes
        0x00060004, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_dmfc_wr_chan
    },
    {
        "DMFC_WR_CHAN_DEF",
        "",
        4, // Width in bytes
        0x00060008, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_dmfc_wr_chan_def
    },
    {
        "DMFC_DP_CHAN",
        "",
        4, // Width in bytes
        0x0006000c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_dmfc_dp_chan
    },
    {
        "DMFC_DP_CHAN_DEF",
        "",
        4, // Width in bytes
        0x00060010, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ipu_dmfc_dp_chan_def
    },
    {
        "DMFC_GENERAL_1",
        "",
        4, // Width in bytes
        0x00060014, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ipu_dmfc_general_1
    },
    {
        "DMFC_GENERAL_2",
        "",
        4, // Width in bytes
        0x00060018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dmfc_general_2
    },
    {
        "DMFC_IC_CTRL",
        "",
        4, // Width in bytes
        0x0006001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dmfc_ic_ctrl
    },
    {
        "DMFC_WR_CHAN_ALT",
        "",
        4, // Width in bytes
        0x00060020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dmfc_wr_chan_alt
    },
    {
        "DMFC_WR_CHAN_DEF_ALT",
        "",
        4, // Width in bytes
        0x00060024, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dmfc_wr_chan_def_alt
    },
    {
        "DMFC_DP_CHAN_ALT",
        "",
        4, // Width in bytes
        0x00060028, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_dmfc_dp_chan_alt
    },
    {
        "DMFC_DP_CHAN_DEF_ALT",
        "",
        4, // Width in bytes
        0x0006002c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_dmfc_dp_chan_def_alt
    },
    {
        "DMFC_GENERAL1_ALT",
        "",
        4, // Width in bytes
        0x00060030, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dmfc_general1_alt
    },
    {
        "DMFC_STAT",
        "This register contains DMFC's status bits.",
        4, // Width in bytes
        0x00060034, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_ipu_dmfc_stat
    },
    {
        "VDI_FSIZE",
        "The register used to control size of VDI  C  input fields.",
        4, // Width in bytes
        0x00068000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_vdi_fsize
    },
    {
        "VDI_C",
        "The register used to control modes of operations of VDI  C  module.",
        4, // Width in bytes
        0x00068004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_vdi_c
    },
    {
        "VDI_C2",
        "The register used to control modes of operations of VDIC module.",
        4, // Width in bytes
        0x00068008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_vdi_c2
    },
    {
        "VDI_CMDP_1",
        "The register holds combining paramemters.",
        4, // Width in bytes
        0x0006800c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_vdi_cmdp_1
    },
    {
        "VDI_CMDP_2",
        "The register holds combining paramemters.",
        4, // Width in bytes
        0x00068010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_vdi_cmdp_2
    },
    {
        "VDI_PS_1",
        "The register holds the plane size's paramemters.",
        4, // Width in bytes
        0x00068014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_vdi_ps_1
    },
    {
        "VDI_PS_2",
        "The register holds the plane's offset paramemters.",
        4, // Width in bytes
        0x00068018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_vdi_ps_2
    },
    {
        "VDI_PS_3",
        "The register holds the plane size's paramemters.",
        4, // Width in bytes
        0x0006801c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_vdi_ps_3
    },
    {
        "VDI_PS_4",
        "The register holds the plane's offset paramemters.",
        4, // Width in bytes
        0x00068020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_vdi_ps_4
    },
    {
        "IDMAC_SUB_ADDR_0",
        "",
        4, // Width in bytes
        0x0008028c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ipu_idmac_sub_addr_0
    },
    {
        "IDMAC_SUB_ADDR_4",
        "",
        4, // Width in bytes
        0x0008030c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_idmac_sub_addr_4
    },
    {
        "IDMAC_SUB_ADDR_1",
        "",
        4, // Width in bytes
        0x00802c30, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_idmac_sub_addr_1
    },
    {
        "DP_COM_CONF_SYNC",
        "This register contains common configuration parameters for the DP.",
        4, // Width in bytes
        0x01040000, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ipu_dp_com_conf_sync
    },
    {
        "DP_GRAPH_WIND_CTRL_SYNC",
        "This register contains common configuration parameters for the DP.",
        4, // Width in bytes
        0x01040004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_graph_wind_ctrl_sync
    },
    {
        "DP_FG_POS_SYNC",
        "The DP partial plane Window Position Register is used to determine the"
        " starting position of the partial plane window relative to BG window p"
        "osition.",
        4, // Width in bytes
        0x01040008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_fg_pos_sync
    },
    {
        "DP_CUR_POS_SYNC",
        "The LCD Cursor Position Register is used to determine the starting pos"
        "ition of the cursor relative to BG windows position.",
        4, // Width in bytes
        0x0104000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_cur_pos_sync
    },
    {
        "DP_CUR_MAP_SYNC",
        "The LCD Color Cursor Mapping Register defines the color of the cursor "
        "in passive or TFT color modes.",
        4, // Width in bytes
        0x01040010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dp_cur_map_sync
    },
    {
        "DP_GAMMA_C_SYNC_I",
        "This registers contains CONSTANTi parameters used for gamma correction"
        " inside the display processor (DP).",
        4, // Width in bytes
        0x01040014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_gamma_c_sync_i
    },
    {
        "DP_GAMMA_S_SYNC_I",
        "This registers contains SLOPEi parameters used for Gamma Correction in"
        "side the display processor (DP).",
        4, // Width in bytes
        0x01040034, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_gamma_s_sync_i
    },
    {
        "DP_CSCA_SYNC_I",
        "",
        4, // Width in bytes
        0x01040044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_csca_sync_i
    },
    {
        "DP_SCS_SYNC_0",
        "",
        4, // Width in bytes
        0x01040054, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dp_scs_sync_0
    },
    {
        "DP_SCS_SYNC_1",
        "",
        4, // Width in bytes
        0x01040058, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_scs_sync_1
    },
    {
        "DP_CUR_POS_ALT",
        "The LCD Cursor Position Register is used to determine the starting pos"
        "ition of the cursor relative to BG windows position for the alternativ"
        "e flow.",
        4, // Width in bytes
        0x0104005c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_cur_pos_alt
    },
    {
        "DP_COM_CONF_ASYNC0",
        "This register contains common configuration parameters for the DP.",
        4, // Width in bytes
        0x01040060, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_dp_com_conf_async0
    },
    {
        "DP_GRAPH_WIND_CTRL_ASYNC0",
        "This register contains common configuration parameters for the DP.",
        4, // Width in bytes
        0x01040064, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_graph_wind_ctrl_async0
    },
    {
        "DP_FG_POS_ASYNC0",
        "The DP partial plane Window Position Register is used to determine the"
        " starting position of the partial plane window relative to BG window p"
        "osition.",
        4, // Width in bytes
        0x01040068, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_fg_pos_async0
    },
    {
        "DP_CUR_POS_ASYNC0",
        "The LCD Cursor Position Register is used to determine the starting pos"
        "ition of the cursor relative to BG windows position.",
        4, // Width in bytes
        0x0104006c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_cur_pos_async0
    },
    {
        "DP_CUR_MAP_ASYNC0",
        "The LCD Color Cursor Mapping Register defines the color of the cursor "
        "in passive or TFT color modes.",
        4, // Width in bytes
        0x01040070, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dp_cur_map_async0
    },
    {
        "DP_GAMMA_C_ASYNC0_I",
        "This registers contains CONSTANTi parameters used for gamma correction"
        " inside the display processor (DP).",
        4, // Width in bytes
        0x01040074, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_gamma_c_async0_i
    },
    {
        "DP_GAMMA_S_ASYNC0_I",
        "This registers contains SLOPEi parameters used for Gamma Correction in"
        "side the display processor (DP).",
        4, // Width in bytes
        0x01040094, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_gamma_s_async0_i
    },
    {
        "DP_CSCA_ASYNC0_I",
        "",
        4, // Width in bytes
        0x010400a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_csca_async0_i
    },
    {
        "DP_CSC_ASYNC0_0",
        "",
        4, // Width in bytes
        0x010400b4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dp_csc_async0_0
    },
    {
        "DP_CSC_ASYNC_1",
        "",
        4, // Width in bytes
        0x010400b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_csc_async_1
    },
    {
        "DP_COM_CONF_ASYNC1",
        "This register contains common configuration parameters for the DP.",
        4, // Width in bytes
        0x010400bc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ipu_dp_com_conf_async1
    },
    {
        "DP_GRAPH_WIND_CTRL_ASYNC1",
        "This register contains common configuration parameters for the DP.",
        4, // Width in bytes
        0x010400c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_graph_wind_ctrl_async1
    },
    {
        "DP_FG_POS_ASYNC1",
        "The DP partial plane Window Position Register is used to determine the"
        " starting position of the partial plane window relative to BG window p"
        "osition.",
        4, // Width in bytes
        0x010400c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_fg_pos_async1
    },
    {
        "DP_CUR_POS_ASYNC1",
        "The LCD Cursor Position Register is used to determine the starting pos"
        "ition of the cursor relative to BG windows position.",
        4, // Width in bytes
        0x010400c8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_cur_pos_async1
    },
    {
        "DP_CUR_MAP_ASYNC1",
        "The LCD Color Cursor Mapping Register defines the color of the cursor "
        "in passive or TFT color modes.",
        4, // Width in bytes
        0x010400cc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dp_cur_map_async1
    },
    {
        "DP_GAMMA_C_ASYNC1_I",
        "This registers contains CONSTANTi parameters used for gamma correction"
        " inside the display processor (DP).",
        4, // Width in bytes
        0x010400d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_gamma_c_async1_i
    },
    {
        "DP_GAMMA_S_ASYN1_I",
        "This registers contains SLOPEi parameters used for Gamma Correction in"
        "side the display processor (DP).",
        4, // Width in bytes
        0x010400f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_gamma_s_asyn1_i
    },
    {
        "DP_CSCA_ASYNC1_I",
        "",
        4, // Width in bytes
        0x01040100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_dp_csca_async1_i
    },
    {
        "DP_CSC_ASYNC1_0",
        "",
        4, // Width in bytes
        0x01040110, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ipu_dp_csc_async1_0
    },
    {
        "DP_CSC_ASYNC1_1",
        "",
        4, // Width in bytes
        0x01040114, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ipu_dp_csc_async1_1
    },
    {
        "IDMAC_BNDM_EN_2",
        "",
        4, // Width in bytes
        0x04ca91bc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ipu_idmac_bndm_en_2
    },
    {
        "IDMAC_SC_CORD",
        "",
        4, // Width in bytes
        0x803c4848, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ipu_idmac_sc_cord
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark KPP
#endif

// Bitfields in register KPP_KPCR.
static const field_t hw_kpp_kpcr[] =
{
    {
        "KRE",
        "Keypad Row Enable.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCO",
        "Keypad Column Strobe Open-Drain Enable.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KPSR.
static const field_t hw_kpp_kpsr[] =
{
    {
        "KPKD",
        "Keypad Key Depress.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KPKR",
        "Keypad Key Release.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KDSC",
        "Key Depress Synchronizer Clear.",
        2, // LSB
        2, // MSB
        false, // Readable
        true // Writable
    },
    {
        "KPP_KRSS",
        "Key Release Synchronizer Set.",
        3, // LSB
        3, // MSB
        false, // Readable
        true // Writable
    },
    {
        "KDIE",
        "Keypad Key Depress Interrupt Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KRIE",
        "Keypad Release Interrupt Enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KDDR.
static const field_t hw_kpp_kddr[] =
{
    {
        "KRDD",
        "Keypad Row Data Direction.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCDD",
        "Keypad Column Data Direction Register.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KPDR.
static const field_t hw_kpp_kpdr[] =
{
    {
        "KRD",
        "Keypad Row Data.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCD",
        "Keypad Column Data.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a KPP module.
static const reg_t hw_kpp[] =
{
    {
        "KPCR",
        "The Keypad Control Register determines which of the eight possible col"
        "umn strobes are to be open drain when configured as outputs, and which"
        " of the eight row sense lines are considered in generating an interrup"
        "t to the core.",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kpcr
    },
    {
        "KPSR",
        "The Keypad Status Register reflects the state of the key press detect "
        "circuit.",
        2, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_kpp_kpsr
    },
    {
        "KDDR",
        "The bits in the KPP_KDDR control the direction of the keypad port pins"
        ".",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kddr
    },
    {
        "KPDR",
        "This 16-bit register is used to access the column and row data.",
        2, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kpdr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LDB
#endif

// Bitfields in register LDB_CTRL.
static const field_t hw_ldb_ctrl[] =
{
    {
        "CH0_MODE",
        "LVDS channel 0 operation mode",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_MODE",
        "LVDS channel 1 operation mode",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLIT_MODE_EN",
        "Enable split mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_WIDTH_CH0",
        "Data width for LVDS channel 0.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BIT_MAPPING_CH0",
        "Data mapping for LVDS channel 0.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_WIDTH_CH1",
        "Data width for LVDS channel 1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BIT_MAPPING_CH1",
        "Data mapping for LVDS channel 1.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_VS_POLARITY",
        "Vsync polarity for IPU's DI0 interface.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_VS_POLARITY",
        "Vsync polarity for IPU's DI1 interface.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_CLK_SHIFT",
        "Shifts the LVDS output clock in relation to the data.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNTER_RESET_VAL",
        "Reset value for the LDB counter which determines when the shift regist"
        "ers are loaded with data.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LDB module.
static const reg_t hw_ldb[] =
{
    {
        "CTRL",
        "The register is implemented in the IOMUX Controller block (IOMUXC), as"
        " the register IOMUXC_GPR2.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ldb_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MIPI_CSI
#endif

// Bitfields in register MIPI_CSI_VERSION.
static const field_t hw_mipi_csi_version[] =
{
    {
        "VERSION",
        "Version of the CSI-2 Host Controller   Default Value: CSI_VERSION_ID",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_N_LANES.
static const field_t hw_mipi_csi_n_lanes[] =
{
    {
        "N_LANES",
        "Number of Active Data Lanes  Can only be updated when the PHY lane is "
        "in stop state.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_PHY_SHUTDOWNZ.
static const field_t hw_mipi_csi_phy_shutdownz[] =
{
    {
        "PHY_SHUTDOWNZ",
        "Shutdown input.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_DPHY_RSTZ.
static const field_t hw_mipi_csi_dphy_rstz[] =
{
    {
        "DPHY_RSTZ",
        "DPHY reset output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_CSI2_RESETN.
static const field_t hw_mipi_csi_csi2_resetn[] =
{
    {
        "CSI2_RESETN",
        "CSI-2 controller reset output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_PHY_STATE.
static const field_t hw_mipi_csi_phy_state[] =
{
    {
        "PHY_RXULPSESC_0",
        "Lane module 0 has entered the Ultra Low Power mode   Default Value: 0",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_RXULPSESC_1",
        "Lane module 1 has entered the Ultra Low Power mode   Default Value: 0",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_RXULPSESC_2",
        "Lane module 2 has entered the Ultra Low Power mode   Default Value: 0",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_RXULPSESC_3",
        "Lane module 3 has entered the Ultra Low Power mode   Default Value: 0",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_STOPSTATEDATA_0",
        "Data Lane 0 in Stop state   Default Value: 0",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_STOPSTATEDATA_1",
        "Data Lane 1 in Stop state   Default Value: 0",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_STOPSTATEDATA_2",
        "Data Lane 2 in Stop state   Default Value: 0",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_STOPSTATEDATA_3",
        "Data Lane 3 in Stop state   Default Value: 0",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_RXCLKACTIVEHS",
        "Indicates that the clock lane is actively receiving a DDR clock   Defa"
        "ult Value: 0",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_RXULPSCLKNOT",
        "Active Low.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_STOPSTATECLK",
        "Clock Lane in Stop state   Default Value: 0",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYPASS_2ECC_TST",
        "Payload Bypass test mode for double ECC errors   Default Value: 0",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_DATA_IDS_1.
static const field_t hw_mipi_csi_data_ids_1[] =
{
    {
        "DI0_DT",
        "Data ID 0 Data Type   Default Value: 0",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI0_VC",
        "Data ID 0 Virtual channel   Default Value: 0",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_DT",
        "Data ID 1 Data Type   Default Value: 0",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI1_VC",
        "Data ID 1 Virtual channel   Default Value: 0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI2_DT",
        "DATA ID 2 Data Type   Default Value: 0",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI2_VC",
        "DATA ID 2 Virtual channel   Default Value: 0",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI3_DT",
        "Data ID 3 Data Type   Default Value: 0",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI3_VC",
        "Data ID 3 Virtual channel   Default Value: 0",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_DATA_IDS_2.
static const field_t hw_mipi_csi_data_ids_2[] =
{
    {
        "DI4_DT",
        "Data ID 4 Data Type   Default Value: 0",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI4_VC",
        "Data ID 4 Virtual channel   Default Value: 0",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI5_DT",
        "Data ID 5 Data Type   D  efault Value: 0",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI5_VC",
        "Data ID 5 Virtual channel   Default Value: 0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI6_DT",
        "Data ID 6 Data Type   Default Value: 0",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI6_VC",
        "Data ID 6 Virtual channel   Default Value: 0",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI7_DT",
        "Data ID 7 Data Type   Default Value: 0",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DI7_VC",
        "Data ID 7 Virtual channel   Default Value: 0",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_ERR1.
static const field_t hw_mipi_csi_err1[] =
{
    {
        "PHY_ERRSOTSYNCHS_0",
        "Start of Transmission Error on data lane 0 (no synchronization achieve"
        "d)   Default Value: 0",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRSOTSYNCHS_1",
        "Start of Transmission Error on data lane 1 (no synchronization achieve"
        "d)   Default Value: 0",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRSOTSYNCHS_2",
        "Start of Transmission Error on data lane 2 (no synchronization achieve"
        "d)   Default Value: 0",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRSOTSYNCHS_3",
        "Start of Transmission Error on data lane 3 (no synchronization achieve"
        "d)   Default Value: 0",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_F_BNDRY_MATCH_VC0",
        "Error matching Frame Start with Frame End for Virtual Channel 0   Defa"
        "ult Value: 0",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_F_BNDRY_MATCH_VC1",
        "Error matching Frame Start with Frame End for Virtual Channel 1   Defa"
        "ult Value: 0",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_F_BNDRY_MATCH_VC2",
        "Error matching Frame Start with Frame End for Virtual Channel 2   Defa"
        "ult Value: 0",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_F_BNDRY_MATCH_VC3",
        "Error matching Frame Start with Frame End for Virtual Channel 3   Defa"
        "ult Value: 0",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_F_SEQ_VC0",
        "Incorrect Frame Sequence detected in Virtual Channel 0   Default Value"
        ": 0",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_F_SEQ_VC1",
        "Incorrect Frame Sequence detected in Virtual Channel 1   Default Value"
        ": 0",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_F_SEQ_VC2",
        "Incorrect Frame Sequence detected in Virtual Channel 2   Default Value"
        ": 0",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_F_SEQ_VC3",
        "Incorrect Frame Sequence detected in Virtual Channel 3   Default Value"
        ": 0",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_FRAME_DATA_VC0",
        "Last received frame, in Virtual Channel 0, had at least one CRC error "
        "  Default Value: 0",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_FRAME_DATA_VC1",
        "Last received frame, in Virtual Channel 1, had at least one CRC error "
        "  Default Value: 0",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_FRAME_DATA_VC2",
        "Last received frame, in Virtual Channel 2, had at least one CRC error "
        "  Default Value: 0",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_FRAME_DATA_VC3",
        "Last received frame, in Virtual Channel 3, had at least one CRC error "
        "  Default Value: 0",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_BNDRY_MATCH_DI0",
        "Error matching Line Start with Line End for vc0 and dt0   Default Valu"
        "e: 0",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_BNDRY_MATCH_DI1",
        "Error matching Line Start with Line End for vc1 and dt1   Default Valu"
        "e: 0",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_BNDRY_MATCH_DI2",
        "Error matching Line Start with Line End for vc2 and dt2   Default Valu"
        "e: 0",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_BNDRY_MATCH_DI3",
        "Error matching Line Start with Line End for vc3 and dt3   Default Valu"
        "e: 0",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_SEQ_DI0",
        "Error in the sequence of lines for vc0 and dt0   Default Value: 0",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_SEQ_DI1",
        "Error in the sequence of lines for vc1 and dt1   Default Value: 0",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_SEQ_DI2",
        "Error in the sequence of lines for vc2 and dt2   Default Value: 0",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_SEQ_DI3",
        "Error in the sequence of lines for vc3 and dt3   Default Value: 0",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC0_ERR_CRC",
        "Checksum Error detected on Virtual Channel 0   Default Value: 0",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC1_ERR_CRC",
        "Checksum Error detected on Virtual Channel 1   Default Value: 0",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC2_ERR_CRC",
        "Checksum Error detected on Virtual Channel 2   Default Value: 0",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC3_ERR_CRC",
        "Checksum Error detected on Virtual Channel 3   Default Value: 0",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_ECC_DOUBLE",
        "Header ECC contains 2 errors.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_ERR2.
static const field_t hw_mipi_csi_err2[] =
{
    {
        "PHY_ERRESC_0",
        "Escape Entry Error (ULPM) on data lane 0   Default Value: 0",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRESC_1",
        "Escape Entry Error (ULPM) on data lane 1   Default Value: 0",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRESC_2",
        "Escape Entry Error (ULPM) on data lane 2   Default Value: 0",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRESC_3",
        "Escape Entry Error (ULPM) on data lane 3   Default Value: 0",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRSOTHS_0",
        "Start of Transmission Error on data lane 0 (synchronization can still "
        "be achieved)   Default Value: 0",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRSOTHS_1",
        "Start of Transmission Error on data lane 1 (synchronization can still "
        "be achieved)   Default Value: 0",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRSOTHS_2",
        "Start of Transmission Error on data lane 2 (synchronization can still "
        "be achieved)   Default Value: 0",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHY_ERRSOTHS_3",
        "Start of Transmission Error on data lane 3 (synchronization can still "
        "be achieved)   Default Value: 0",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC0_ERR_ECC_CORRECTED",
        "Header error detected and corrected on Virtual Channel 0   Default Val"
        "ue: 0",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC1_ERR_ECC_CORRECTED",
        "Header error detected and corrected on Virtual Channel 1   Default Val"
        "ue: 0",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC2_ERR_ECC_CORRECTED",
        "Header error detected and corrected on Virtual Channel 2   Default Val"
        "ue: 0",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC3_ERR_ECC_CORRECTED",
        "Header error detected and corrected on Virtual Channel 3   Default Val"
        "ue: 0",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_ID_VC0",
        "Unrecognized or unimplemented data type detected in Virtual Channel 0 "
        "  Default Value: 0",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_ID_VC1",
        "Unrecognized or unimplemented data type detected in Virtual Channel 1 "
        "  Default Value: 0",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_ID_VC2",
        "Unrecognized or unimplemented data type detected in Virtual Channel 2 "
        "  Default Value: 0",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_ID_VC3",
        "Unrecognized or unimplemented data type detected in Virtual Channel 3 "
        "  Default Value: 0",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_BNDRY_MATCH_DI4",
        "Error matching Line Start with Line End for vc4 and dt4   Default Valu"
        "e: 0",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_BNDRY_MATCH_DI5",
        "Error matching Line Start with Line End for vc5 and dt5   Default Valu"
        "e: 0",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_BNDRY_MATCH_DI6",
        "Error matching Line Start with Line End for vc6 and dt6   Default Valu"
        "e: 0",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_BNDRY_MATCH_DI7",
        "Error matching Line Start with Line End for vc7 and dt7   Default Valu"
        "e: 0",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_SEQ_DI4",
        "Error in the sequence of lines for vc4 and dt4   Default Value: 0",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_SEQ_DI5",
        "Error in the sequence of lines for vc5 and dt5   Default Value: 0",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_SEQ_DI6",
        "Error in the sequence of lines for vc6 and dt6   Default Value: 0",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_L_SEQ_DI7",
        "Error in the sequence of lines for vc7 and dt7   Default Value: 0",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_MASK1.
static const field_t hw_mipi_csi_mask1[] =
{
    {
        "MASK_PHY_ERRSOTSYNCHS_0",
        "Mask for phy_errsotsynchs_0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRSOTSYNCHS_1",
        "Mask for phy_errsotsynchs_1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRSOTSYNCHS_2",
        "Mask for phy_errsotsynchs_2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRSOTSYNCHS_3",
        "Mask for phy_errsotsynchs_3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_F_BNDRY_MATCH_VC0",
        "Mask for err_f_bndry_match_vc0.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_F_BNDRY_MATCH_VC1",
        "Mask for err_f_bndry_match_vc1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_F_BNDRY_MATCH_VC2",
        "Mask for err_f_bndry_match_vc2.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_F_BNDRY_MATCH_VC3",
        "Mask for err_f_bndry_match_vc3.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_F_SEQ_VC0",
        "Mask for err_f_seq_vc0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_F_SEQ_VC1",
        "Mask for err_f_seq_vc1.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_F_SEQ_VC2",
        "Mask for err_f_seq_vc2.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_F_SEQ_VC3",
        "Mask for err_f_seq_vc3.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_FRAME_DATA_VC0",
        "Mask for err_frame_data_vc0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_FRAME_DATA_VC1",
        "Mask for err_frame_data_vc1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_FRAME_DATA_VC2",
        "Mask for err_frame_data_vc2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_FRAME_DATA_VC3",
        "Mask for err_frame_data_vc3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_BNDRY_MATCH_DI0",
        "Mask for err_l_bndry_match_di0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_BNDRY_MATCH_DI1",
        "Mask for err_l_bndry_match_di1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_BNDRY_MATCH_DI2",
        "Mask for err_l_bndry_match_di2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_BNDRY_MATCH_DI3",
        "Mask for err_l_bndry_match_di3.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_SEQ_DI0",
        "Mask for err_l_seq_di0.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_SEQ_DI1",
        "Mask for err_l_seq_di1.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_SEQ_DI2",
        "Mask for err_l_seq_di2.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_SEQ_DI3",
        "Mask for err_l_seq_di3.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VC0_ERR_CRC",
        "Mask for vc0_err_crc.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VC1_ERR_CRC",
        "Mask for vc1_err_crc.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VC2_ERR_CRC",
        "Mask for vc2_err_crc.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VC3_ERR_CRC",
        "Mask for vc3_err_crc.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_ECC_DOUBLE",
        "Mask for err_ecc_double.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_MASK2.
static const field_t hw_mipi_csi_mask2[] =
{
    {
        "MASK_PHY_ERRESC_0",
        "Mask for phy_erresc_0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRESC_1",
        "Mask for phy_erresc_1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRESC_2",
        "Mask for phy_erresc_2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRESC_3",
        "Mask for phy_erresc_3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRSOTHS_0",
        "Mask for phy_errsoths_0.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRSOTHS_1",
        "Mask for phy_errsoths_1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRSOTHS_2",
        "Mask for phy_errsoths_2.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PHY_ERRSOTHS_3",
        "Mask for phy_errsoths_3.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VC0_ERR_ECC_CORRECTED",
        "Mask for vc0_err_ecc_corrected.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VC1_ERR_ECC_CORRECTED",
        "Mask for vc1_err_ecc_corrected.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VC2_ERR_ECC_CORRECTED",
        "Mask for vc2_err_ecc_corrected.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VC3_ERR_ECC_CORRECTED",
        "Mask for vc3_err_ecc_corrected.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_ID_VC0",
        "Mask for err_id_vc0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_ID_VC1",
        "Mask for err_id_vc1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_ID_VC2",
        "Mask for err_id_vc2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_ID_VC3",
        "Mask for err_id_vc3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_BNDRY_MATCH_DI4",
        "Mask for err_l_bndry_match_di4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_BNDRY_MATCH_DI5",
        "Mask for err_l_bndry_match_di5.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_BNDRY_MATCH_DI6",
        "Mask for err_l_bndry_match_di6.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_BNDRY_MATCH_DI7",
        "Mask for err_l_bndry_match_di7.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_SEQ_DI4",
        "Mask for err_l_seq_di4.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_SEQ_DI5",
        "Mask for err_l_seq_di5.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_SEQ_DI6",
        "Mask for err_l_seq_di6.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_ERR_L_SEQ_DI7",
        "Mask for err_l_seq_di7.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_PHY_TST_CRTL0.
static const field_t hw_mipi_csi_phy_tst_crtl0[] =
{
    {
        "PHY_TESTCLR",
        "PHY test interface clear.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TESTCLK",
        "PHY test interface strobe signal.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_CSI_PHY_TST_CTRL1.
static const field_t hw_mipi_csi_phy_tst_ctrl1[] =
{
    {
        "PHY_TESTDIN",
        "PHY test interface input 8-bit data bus for internal register programm"
        "ing and test functionalities access   Default Value: 0",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TESTDOUT",
        "PHY output 8-bit data bus for read-back and internal probing functiona"
        "lities.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TESTEN",
        "PHY test interface operation selector:",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MIPI_CSI module.
static const reg_t hw_mipi_csi[] =
{
    {
        "VERSION",
        "Name: Controller Version Identification Register  Address Offset: 0x00"
        "0  Size: 32 bits  Default Value: CSI_VERSION_ID  Access: Read",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_csi_version
    },
    {
        "N_LANES",
        "Name: Number of Active Data Lanes  Address Offset: 0x004  Size: 2 bits"
        "  Default Value: CSI_N_LANES  Access: Read/Write",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_csi_n_lanes
    },
    {
        "PHY_SHUTDOWNZ",
        "Name: Phy shutdown control  Address Offset: 0x008  Size: 1 bit  Defaul"
        "t Value: 0  Access: Read/Write",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_csi_phy_shutdownz
    },
    {
        "DPHY_RSTZ",
        "Name: Phy reset control  Address Offset: 0x00C  Size: 1 bit  Default V"
        "alue: 0  Access: Read/Write",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_csi_dphy_rstz
    },
    {
        "CSI2_RESETN",
        "Name: CSI2 controller reset  Address Offset: 0x010  Size: 1 bit  Defau"
        "lt Value: 0  Access: Read/Write",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_csi_csi2_resetn
    },
    {
        "PHY_STATE",
        "Name: General settings for all blocks  Address Offset: 0x014  Size: 12"
        " bit  Default Value: 0  Access: Read (with exception of bit 11 which i"
        "s Read/Write)",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        12, // Number of bitfields
        hw_mipi_csi_phy_state
    },
    {
        "DATA_IDS_1",
        "Name: Data IDs for which IDI reports line boundary matching errors  Ad"
        "dress Offset: 0x018  Size: 32 bit  Default Value: 0  Access: Read/Writ"
        "e",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_csi_data_ids_1
    },
    {
        "DATA_IDS_2",
        "Name: Data IDs for which IDI reports line boundary matching errors  Ad"
        "dress Offset: 0x01C  Size: 32 bit  Default Value: 0  Access: Read/Writ"
        "e",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_csi_data_ids_2
    },
    {
        "ERR1",
        "Name: Error state register 1  Address Offset: 0x020  Size: 29 bit  Def"
        "ault Value: 0  Access: Read",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        29, // Number of bitfields
        hw_mipi_csi_err1
    },
    {
        "ERR2",
        "Name: Error state register 2  Address Offset: 0x024  Size: 24 bit  Def"
        "ault Value: 0  Access: Read",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        24, // Number of bitfields
        hw_mipi_csi_err2
    },
    {
        "MASK1",
        "Name: Masks for errors 1  Address Offset: 0x028  Size: 29 bit  Default"
        " Value: 0  Access: Read/Write",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        29, // Number of bitfields
        hw_mipi_csi_mask1
    },
    {
        "MASK2",
        "Name: Masks for errors 2  Address Offset: 0x02C  Size: 24 bit  Default"
        " Value: 0  Access: Read/Write",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_mipi_csi_mask2
    },
    {
        "PHY_TST_CRTL0",
        "Name: D-PHY Test interface control 0  Address Offset: 0x030  Size: 2 b"
        "it  Default Value: 0  Access: Read/Write",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mipi_csi_phy_tst_crtl0
    },
    {
        "PHY_TST_CTRL1",
        "Name: D-PHY Test interface control 1  Address Offset: 0x034  Size: 17 "
        "bit  Default Value: 0  Access: Read/Write",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_csi_phy_tst_ctrl1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MIPI_DSI
#endif

// Bitfields in register MIPI_DSI_VERSION.
static const field_t hw_mipi_dsi_version[] =
{
    {
        "VERSION",
        "Version of the DSI host controller",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PWR_UP.
static const field_t hw_mipi_dsi_pwr_up[] =
{
    {
        "SHUTDOWNZ",
        "Core power up",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_CLKMGR_CFG.
static const field_t hw_mipi_dsi_clkmgr_cfg[] =
{
    {
        "TX_ESC_CLK_DIVIDSION",
        "Division factor for TX ESCAPE clock source (lanebyteclk pin), values 0"
        " and 1 stop TX_ESC clock generation.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TO_CLK_DIVIDSION",
        "Division factor for Time Out clock used as timing unit in the configur"
        "ation of HS to LP and LP to HS transition error.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_DPI_CFG.
static const field_t hw_mipi_dsi_dpi_cfg[] =
{
    {
        "DPI_VID",
        "Configures the DPI Virtual Channel ID that will be indexed to the Vide"
        "o mode packets.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPI_COLOR_CODING",
        "DPI color coding.",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATAEN_ACTIVE_LOW",
        "Set to configure Data enable pin (dpidaten) as Active low",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_ACTIVE_LOW",
        "Set to configure Vertical Synchronism pin (dpivsync) as Active low",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_ACTIVE_LOW",
        "Set to configure Horizontal Synchronism pin (dpihsync) as Active low",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHUTD_ACTIVE_LOW",
        "Set to configure Shut Down pin (dpishutdn) as Active low",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COLORM_ACTIVE_LOW",
        "Set to configure Color Mode pin (dpicolcorm) as Active low",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN18_LOOSELY",
        "Enable 18 loosely packet pixel stream.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_DBI_CFG.
static const field_t hw_mipi_dsi_dbi_cfg[] =
{
    {
        "DBI_VID",
        "Configures the DBI Virtual Channel ID that will be indexed to the DCS "
        "packets.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IN_DBI_CONF",
        "Configures DBI input pixel data configuration;",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_SIZE_CONF",
        "Configures the size used to transport Write Lut commands;",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARTITIONING_EN",
        "Enables write memory continue through input command (system needs to e"
        "nsure correct partitioning of Long Write commands)",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUT_DBI_CONF",
        "Configures the DBI output pixel data configuration;",
        9, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_DBIS_CMDSIZE.
static const field_t hw_mipi_dsi_dbis_cmdsize[] =
{
    {
        "WR_CMD_SIZE",
        "Configures the size of the DCS write memory commands.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALLOWED_CMD_SIZE",
        "Configures the maximum allowed size of a DCS write memory command.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PCKHDL_CFG.
static const field_t hw_mipi_dsi_pckhdl_cfg[] =
{
    {
        "EN_EOTP_TX",
        "Enables EOTp transmission",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_EOTN_RX",
        "Enables EOTp reception",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_BTA",
        "Enables Bus Turn-Around request",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_ECC_RX",
        "Enables ECC reception, error correction and reporting",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CRC_RX",
        "Enables CRC reception and error reporting",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_VID_RX",
        "Generic interface read-back Virtual Channel identification",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_VID_MODE_CFG.
static const field_t hw_mipi_dsi_vid_mode_cfg[] =
{
    {
        "EN_VIDEO_MODE",
        "Enables DPI Video mode transmission",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_MODE_TYPE",
        "Selects video mode transmission type.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_LP_VSA",
        "Enables return to Low Power inside VSA period when timing allows",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_LP_VBP",
        "Enables return to Low Power inside VBP period when timing allows",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_LP_VFP",
        "Enables return to Low Power inside VFP period when timing allows",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_LP_VACT",
        "Enables return to Low Power inside VACT period when timing allows",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_LP_HBP",
        "Enables return to Low Power inside HBP period when timing allows",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_LP_HFP",
        "Enables return to Low Power inside HFP period when timing allows",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_MULTI_PKT",
        "Enables the tranmission of multi video packets in the HACT period",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_NULL_PKT",
        "Enables the tranmission of null packets in the HACT period",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAME_BTA_ACK",
        "Enables the request for an acknowledge response at the end of a frame",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_VID_PKT_CFG.
static const field_t hw_mipi_dsi_vid_pkt_cfg[] =
{
    {
        "VID_PKT_SIZE",
        "Configures the number of pixel on a single video packet.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM_CHUNKS",
        "Configures the number of chunks to be transmitted during a Line period"
        ".",
        11, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NULL_PKT_SIZE",
        "Configures the number of bytes in a null packet",
        21, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_CMD_MODE_CFG.
static const field_t hw_mipi_dsi_cmd_mode_cfg[] =
{
    {
        "EN_CMD_MODE",
        "Enables the Command Mode Protocol for transmissions.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_SW_0P_TX",
        "Configures the Generic Short Write Packet with 0 Parameters command tr"
        "ansmission type.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_SW_1P_TX",
        "Configures the Generic Short Write Packet with 1 Parameters command tr"
        "ansmission type.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_SW_2P_TX",
        "Configures the Generic Short Write Packet with 2 Parameters command tr"
        "ansmission type.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_SR_0P_TX",
        "Configures the Generic Short Read Packet with 0 Parameters command tra"
        "nsmission type.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_SR_1P_TX",
        "Configures the Generic Short Read Packet with 1 Parameters command tra"
        "nsmission type.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_SR_2P_TX",
        "Configures the Generic Short Read Packet with 2 Parameters command tra"
        "nsmission type.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCS_SW_0P_TX",
        "Configures the DCS Short Write Packet with 0 Parameters command transm"
        "ission type.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCS_SW_1P_TX",
        "Configures the DCS Short Write Packet with 1 Parameters command transm"
        "ission type.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCS_SW_2P_TX",
        "Configures the DCS Short Write Packet with 2 Parameters command transm"
        "ission type.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAX_RD_PKT_SIZE",
        "Configures the Maximum Read Packet Size command transmission type.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_LW_TX",
        "Configures the Generic Long Write Packet command transmission type.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCS_LW_TX",
        "Configures the DCS Long Write Packet command transmission type.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_ACK_RQST",
        "Enables the acknowledge request after each packet transmission",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_TEAR_FX",
        "Enables the tearing effect acknowledge request",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_TMR_LINE_CFG.
static const field_t hw_mipi_dsi_tmr_line_cfg[] =
{
    {
        "HSA_TIME",
        "Configures the Horizontal Synchronism Active period in lane byte clock"
        " cycles",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBP_TIME",
        "Configures the Horizontal Back Porch period in lane byte clock cycles",
        9, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HLINE_TIME",
        "Configures the size of the total line counted in lane byte cycles",
        18, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_VTIMING_CFG.
static const field_t hw_mipi_dsi_vtiming_cfg[] =
{
    {
        "VSA_LINES",
        "Configures the Vertical Synchronism Active period measured in horizont"
        "al lines",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBP_LINES",
        "Configures the Vertical Back Porch period measured in horizontal lines",
        4, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VFP_LINES",
        "Configures the Vertical Front Porch period measured in horizontal line"
        "s",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V_ACTIVE_LINES",
        "Configures the Vertical Active period measured in horizontal lines",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PHY_TMR_CFG.
static const field_t hw_mipi_dsi_phy_tmr_cfg[] =
{
    {
        "BTA_TIME",
        "Configures the maximum time required to perform the Bus Turn Around op"
        "eration measured in lane byte clock cycles",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_LP2HS_TIME",
        "Configures the maximum time that the PHY takes to go from Low Power to"
        " High Speed transmission measured in lane byte clock cycles",
        12, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_HS2LP_TIME",
        "Configures the maximum time that the PHY takes to go from High Speed t"
        "o Low Power transmission measured in lane byte clock cycles",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_GEN_HDR.
static const field_t hw_mipi_dsi_gen_hdr[] =
{
    {
        "GEN_HTYPE",
        "Configures the packet type to be transmitted through the generic inter"
        "face.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_HDATA",
        "Configures the packet data to be transmitted through the generic inter"
        "face",
        8, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_GEN_PLD_DATA.
static const field_t hw_mipi_dsi_gen_pld_data[] =
{
    {
        "GEN_PLD_DATA",
        "This register contains the input/output generic packet data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_CMD_PKT_STATUS.
static const field_t hw_mipi_dsi_cmd_pkt_status[] =
{
    {
        "GEN_CMD_EMPTY",
        "Reports the empty status of the generic command FIFO",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_CMD_FULL",
        "Reports the full status of the generic command FIFO",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_W_EMPTY",
        "Reports the empty status of the generic write payload FIFO",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_W_FULL",
        "Reports the full status of the generic write payload FIFO",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_R_EMPTY",
        "Reports the empty status of the generic read payload FIFO",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_R_FULL",
        "Reports the full status of the generic read payload FIFO",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_RD_CMD_BUSY",
        "Set when a read command is issued and cleared once the entire response"
        " is stored in the FIFO",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_CMD_EMPTY",
        "Reports the empty status of the DBI command FIFO",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_CMD_FULL",
        "Reports the full status of the DBI command FIFO",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_W_EMPTY",
        "Reports the empty status of the DBI write payload FIFO",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_W_FULL",
        "Reports the full status of the DBI write payload FIFO",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_R_EMPTY",
        "Reports the empty status of the DBI read payload FIFO",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_R_FULL",
        "Reports the full status of the DBI read payload FIFO",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_RD_CMD_BUSY",
        "Set when a read command is issued and cleared once the entire response"
        " is stored in the FIFO",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_TO_CNT_CFG0.
static const field_t hw_mipi_dsi_to_cnt_cfg0[] =
{
    {
        "HSTX_TO_CNT",
        "Configures the time out counter that will trigger a High Speed Transmi"
        "ssion Time Out Contention Detection (Measured in TO_CLK_DIVISION cycle"
        "s)",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPRX_TO_CNT",
        "Configures the time out counter that will trigger a Low Power Receptio"
        "n Time Out Contention Detection.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_ERROR_ST0.
static const field_t hw_mipi_dsi_error_st0[] =
{
    {
        "ACK_WITH_ERR_0",
        "Retrieves SoT Error from Display Acknowledge Error Report",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_1",
        "Retrieves SoT Sync Error from Display Acknowledge Error Report",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_2",
        "Retrieves EoT Sync Error from Display Acknowledge Error Report",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_3",
        "Retrieves Escape Mode Entry Command Error from Display Acknowledge Err"
        "or Report",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_4",
        "Retrieves Low-Power Transmit Sync Error from Display Acknowledge Error"
        " Report",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_5",
        "Retrieves HS Receive Timeout Error from Display Acknowledge Error Repo"
        "rt",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_6",
        "Retrieves False Control Error from Display Acknowledge Error Report",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_7",
        "Retrieves Reserved (specific to device) from Display Acknowledge Error"
        " Report",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_8",
        "Retrieves ECC Error, single-bit (detected and corrected) from Display "
        "Acknowledge Error Report",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_9",
        "Retrieves ECC Error, multi-bit (detected, not corrected) from Display "
        "Acknowledge Error Report",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_10",
        "Retrieves Checksum Error (Long packet only) from Display Acknowledge E"
        "rror Report",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_11",
        "Retrieves DSI Data Type Not Recognized from Display Acknowledge Error "
        "Report",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_12",
        "Retrieves DSI VC ID Invalid from Display Acknowledge Error Report",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_13",
        "Retrieves Invalid Transmission Length from Display Acknowledge Error R"
        "eport",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_14",
        "Retrieves Reserved (specific to device) from Display Acknowledge Error"
        " Report",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_15",
        "Retrieves DSI Protocol Violation from Display Acknowledge Error Report",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_0",
        "ErrEsc Escape Entry Error from Lane 0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_1",
        "ErrSyncEsc Low-Power Data Transmission Synchronization Error from Lane"
        " 0",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_2",
        "ErrControl Control Error from Lane 0",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_3",
        "ErrContentionLP0 LP0 Contention Error from Lane 0",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_4",
        "ErrContentionLP1 LP1 Contention Error from Lane 0",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_ERROR_ST1.
static const field_t hw_mipi_dsi_error_st1[] =
{
    {
        "TO_HS_TX",
        "High Speed Transmission Time Out Counter reached the end and Contentio"
        "n Detection as been detected",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TO_LP_RX",
        "Low Power Reception Time Out Counter reached the end and Contention De"
        "tection as been detected",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_SINLGE_ERR",
        "ECC single error was detected and corrected in a received packet",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_MULTI_ERR",
        "ECC multiple error was detected in a received packet",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_ERR",
        "CRC error was detected in the received packet payload",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKT_SIZE_ERR",
        "Packet size error was detected during packet reception",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOPT_ERR",
        "EOTp Packet not received at the end of the incoming peripheral transmi"
        "ssion",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPI_PLD_WR_ERR",
        "During a DPI pixel line storage the payload FIFO went full and data st"
        "ored is corrupted",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_CMD_WR_ERR",
        "System tried to write a command through the generic interface and FIFO"
        " was full, therefore the command was not written",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_WR_ERR",
        "System tried to write a payload data through the generic interface and"
        " FIFO was full, therefore the payload was not written",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_SEND_ERR",
        "During a generic interface packet build, the payload FIFO went empty a"
        "nd data was sent corrupted",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_RD_ERR",
        "During a DCS read data, the payload FIFO went empty and data was send "
        "to the interface corrupted",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_RECV_ERR",
        "During a generic interface packet read back, the payload FIFO went ful"
        "l and received data was corrupted",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_CMD_WR_ERR",
        "System tried to write a command through the DBI but the command FIFO w"
        "as full, therefore the command was not written",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_WR_ERR",
        "System tried to write payload data through the DBI interface and the F"
        "IFO was full, therefore the Command was not written",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_RD_ERR",
        "During a DCS read data, the payload FIFO went empty and data was send "
        "to the interface corrupted",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_RECV_ERR",
        "During a DBI read back packet, the payload FIFO went full and received"
        " data was corrupted",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_ILLEGAL_COMM_ERR",
        "Attempt to write an illegal command on the DPI interface and core bloc"
        "ked by transmission",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_ERROR_MSK0.
static const field_t hw_mipi_dsi_error_msk0[] =
{
    {
        "ACK_WITH_ERR_0",
        "Masks SoT Error from Display Acknowledge Error Report",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_1",
        "Masks SoT Sync Error from Display Acknowledge Error Report",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_2",
        "Masks EoT Sync Error from Display Acknowledge Error Report",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_3",
        "Masks Escape Mode Entry Command Error from Display Acknowledge Error R"
        "eport",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_4",
        "Masks Low-Power Transmit Sync Error from Display Acknowledge Error Rep"
        "ort",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_5",
        "Masks HS Receive Timeout Error from Display Acknowledge Error Report",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_6",
        "Masks False Control Error from Display Acknowledge Error Report",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_7",
        "Masks Reserved (specific to device) from Display Acknowledge Error Rep"
        "ort",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_8",
        "Masks ECC Error, single-bit (detected and corrected) from Display Ackn"
        "owledge Error Report",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_9",
        "Masks ECC Error, multi-bit (detected, not corrected) from Display Ackn"
        "owledge Error Report",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_10",
        "Masks Checksum Error (Long packet only) from Display Acknowledge Error"
        " Report",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_11",
        "Masks DSI Data Type Not Recognized from Display Acknowledge Error Repo"
        "rt",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_12",
        "Masks DSI VC ID Invalid from Display Acknowledge Error Report",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_13",
        "Masks Invalid Transmission Length from Display Acknowledge Error Repor"
        "t",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_14",
        "Masks Reserved (specific to device) from Display Acknowledge Error Rep"
        "ort",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK_WITH_ERR_15",
        "Masks DSI Protocol Violation from Display Acknowledge Error Report",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_0",
        "ErrEsc Escape Entry Error from Lane 0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_1",
        "ErrSyncEsc Low-Power Data Transmission Synchronization Error from Lane"
        " 0",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_2",
        "ErrControl Control Error from Lane 0",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_3",
        "ErrContentionLP0 LP0 Contention Error from Lane 0",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPHY_ERRORS_4",
        "ErrContentionLP1 LP1 Contention Error from Lane 0",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_ERROR_MSK1.
static const field_t hw_mipi_dsi_error_msk1[] =
{
    {
        "TO_HS_TX",
        "Masks High Speed Transmission Time Out Counter error",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TO_LP_RX",
        "Masks Low Power Reception Time Out Counter error",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_SINLGE_ERR",
        "Masks ECC single error",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_MULTI_ERR",
        "Masks ECC multiple error",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_ERR",
        "Masks CRC error",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKT_SIZE_ERR",
        "Masks Packet size error",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOPT_ERR",
        "Masks EOTp Packet not received error",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPI_PLD_WR_ERR",
        "Masks DPI pixel line payload FIFO full error",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_CMD_WR_ERR",
        "Masks command FIFO of generic interface full error",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_WR_ERR",
        "Masks payload data FIFO of generic interface full error",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_SEND_ERR",
        "Masks generic interface packet build FIFO empty error",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_RD_ERR",
        "Masks DCS read data payload FIFO empty error",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GEN_PLD_RECV_ERR",
        "Masks generic interface packet read back FIFO full error",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_CMD_WR_ERR",
        "Masks DBI command FIFO full error",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_WR_ERR",
        "Masks write payload data DBI FIFO full error",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_RD_ERR",
        "Masks payload DBI FIFO empty error",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_PLD_RECV_ERR",
        "Masks DBI read back packet payload FIFO full error",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBI_ILLEGAL_COMM_ERR",
        "Masks error attempt to write an illegal command on DPI",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PHY_RSTZ.
static const field_t hw_mipi_dsi_phy_rstz[] =
{
    {
        "PHY_SHUTDOWNZ",
        "D-PHY Shutdown disable when 1, used to place the complete D-PHY macro "
        "in power down",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_RSTZ",
        "D-PHY Reset disable when 1, used to place the digital section of D-PHY"
        " in reset state",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_ENABLECLK",
        "Enables D-PHY Clock Lane Module when 1",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PHY_IF_CFG.
static const field_t hw_mipi_dsi_phy_if_cfg[] =
{
    {
        "N_LANES",
        "Number of active data lanes.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_STOP_WAIT_TIME",
        "Configures minimum wait period to request an HS transmission after the"
        " stop state accounted in clock lane cycles",
        2, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PHY_IF_CTRL.
static const field_t hw_mipi_dsi_phy_if_ctrl[] =
{
    {
        "PHY_TXREQUESTCLKHS",
        "Controls D-PHY PPI txrequestclkHS",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TXREQULPSCLK",
        "ULPS mode Request on Clock Lane",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TXEXITULPSCLK",
        "ULPS mode Exit on Clock Lane",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TXREQULPSLAN",
        "ULPS mode Request on all active data lanes",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TXEXITULPSLAN",
        "ULPS mode Exit on on all active data lanes",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TX_TRIGGERS",
        "Controls the trigger transmissions",
        5, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PHY_STATUS.
static const field_t hw_mipi_dsi_phy_status[] =
{
    {
        "PHYLOCK",
        "Reports status of phylock D-PHY pin",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYDIRECTION",
        "Reports status of phydirection D-PHY pin",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYSTOPSTATECLKLANE",
        "Reports status of phystopstateclklane D-PHY pin",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYRXULPSCLKNOT",
        "Reports status of phyrxulpsclknot D-PHY pin",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYSTOPSTATE0LANE",
        "Reports status of phystopstate0lane D-PHY pin",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPSACTIVENOT0LANE",
        "Reports status of ulpsactivenot0lane D-PHY pin",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXULPSESC0LANE",
        "Reports status of rxulpsEsc0lane D-PHY pin",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYSTOPSTATE1LANE",
        "Reports status of phystopstate1lane D-PHY pin",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPSACTIVENOT1LANE",
        "Reports status of ulpsactivenot1lane D-PHY pin",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYSTOPSTATE2LANE",
        "Reports status of phystopstate2lane D-PHY pin",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPSACTIVENOT2LANE",
        "Reports status of ulpsactivenot2lane D-PHY pin",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYSTOPSTATE3LANE",
        "Reports status of phystopstate3lane D-PHY pin",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPSACTIVENOT3LANE",
        "Reports status of ulpsactivenot3lane D-PHY pin",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PHY_TST_CTRL0.
static const field_t hw_mipi_dsi_phy_tst_ctrl0[] =
{
    {
        "PHY_TESTCLR",
        "PHY test interface clear.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TESTCLK",
        "PHY test interface strobe signal.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_PHY_TST_CTRL1.
static const field_t hw_mipi_dsi_phy_tst_ctrl1[] =
{
    {
        "PHY_TESTDIN",
        "PHY test interface input 8-bit data bus for internal register programm"
        "ing and test functionalities access",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TESTDOUT",
        "PHY output 8-bit data bus for read-back and internal probing functiona"
        "lities",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_TESTEN",
        "PHY test interface operation selector: when 1 configures address write"
        " operation on the falling edge of TESTCLK; when 0 configures a data wr"
        "ite operation on the rising edge of TESTCLK",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MIPI_DSI module.
static const reg_t hw_mipi_dsi[] =
{
    {
        "VERSION",
        "Size: 32 bits  Offset: 0x0  Memory Access: R",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_version
    },
    {
        "PWR_UP",
        "Size: 32 bits  Offset: 0x4  Memory Access: R/W",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_pwr_up
    },
    {
        "CLKMGR_CFG",
        "Size: 32 bits  Offset: 0x8  Memory Access: R/W",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mipi_dsi_clkmgr_cfg
    },
    {
        "DPI_CFG",
        "Size: 32 bits  Offset: 0xc  Memory Access: R/W",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_dsi_dpi_cfg
    },
    {
        "DBI_CFG",
        "Size: 32 bits  Offset: 0x10  Memory Access: R/W",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_mipi_dsi_dbi_cfg
    },
    {
        "DBIS_CMDSIZE",
        "Size: 32 bits  Offset: 0x14  Memory Access: R/W",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mipi_dsi_dbis_cmdsize
    },
    {
        "PCKHDL_CFG",
        "Size: 32 bits  Offset: 0x18  Memory Access: R/W",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mipi_dsi_pckhdl_cfg
    },
    {
        "VID_MODE_CFG",
        "Size: 32 bits  Offset: 0x1c  Memory Access: R/W",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_mipi_dsi_vid_mode_cfg
    },
    {
        "VID_PKT_CFG",
        "Size: 32 bits  Offset: 0x20  Memory Access: R/W",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_dsi_vid_pkt_cfg
    },
    {
        "CMD_MODE_CFG",
        "Size: 32 bits  Offset: 0x24  Memory Access: R/W",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_mipi_dsi_cmd_mode_cfg
    },
    {
        "TMR_LINE_CFG",
        "Size: 32 bits  Offset: 0x28  Memory Access: R/W",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_dsi_tmr_line_cfg
    },
    {
        "VTIMING_CFG",
        "Size: 32 bits  Offset: 0x2c  Memory Access: R/W",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mipi_dsi_vtiming_cfg
    },
    {
        "PHY_TMR_CFG",
        "Size: 32 bits  Offset: 0x30  Memory Access: R/W",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_dsi_phy_tmr_cfg
    },
    {
        "GEN_HDR",
        "Size: 32 bits  Offset: 0x34  Memory Access: R/W",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mipi_dsi_gen_hdr
    },
    {
        "GEN_PLD_DATA",
        "Size: 32 bits  Offset: 0x38  Memory Access: R/W",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_gen_pld_data
    },
    {
        "CMD_PKT_STATUS",
        "Size: 32 bits  Offset: 0x3c  Memory Access: R/W",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_mipi_dsi_cmd_pkt_status
    },
    {
        "TO_CNT_CFG0",
        "Size: 32 bits  Offset: 0x40  Memory Access: R/W",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mipi_dsi_to_cnt_cfg0
    },
    {
        "ERROR_ST0",
        "Size: 32 bits  Offset: 0x44  Memory Access: R/W",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_mipi_dsi_error_st0
    },
    {
        "ERROR_ST1",
        "Size: 32 bits  Offset: 0x48  Memory Access: R/W",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_mipi_dsi_error_st1
    },
    {
        "ERROR_MSK0",
        "Size: 32 bits  Offset: 0x4c  Memory Access: R/W",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_mipi_dsi_error_msk0
    },
    {
        "ERROR_MSK1",
        "Size: 32 bits  Offset: 0x50  Memory Access: R/W",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_mipi_dsi_error_msk1
    },
    {
        "PHY_RSTZ",
        "Size: 32 bits  Offset: 0x54  Memory Access: R/W",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_dsi_phy_rstz
    },
    {
        "PHY_IF_CFG",
        "Size: 32 bits  Offset: 0x58  Memory Access: R/W",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mipi_dsi_phy_if_cfg
    },
    {
        "PHY_IF_CTRL",
        "Size: 32 bits  Offset: 0x5c  Memory Access: R/W",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mipi_dsi_phy_if_ctrl
    },
    {
        "PHY_STATUS",
        "Size: 32 bits  Offset: 0x60  Memory Access: R/W",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_mipi_dsi_phy_status
    },
    {
        "PHY_TST_CTRL0",
        "Size: 32 bits  Offset: 0x64  Memory Access: R/W",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mipi_dsi_phy_tst_ctrl0
    },
    {
        "PHY_TST_CTRL1",
        "Size: 32 bits  Offset: 0x68  Memory Access: R/W",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_dsi_phy_tst_ctrl1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MIPI_HSI
#endif

// Bitfields in register MIPI_HSI_CTRL.
static const field_t hw_mipi_hsi_ctrl[] =
{
    {
        "TX_CLK_DIVISOR",
        "This register holds the divisor of the base clock (tx_refclk) frequenc"
        "y for HSI Tx clock (internal clock used to drive Transmitter interface"
        ").",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_BREAK",
        "Seeting this bit to one trigger a transmission break at HSI Tx.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_TIMEOUT_CNT",
        "This value determines the interval by which DATA timeouts are detected"
        ".",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_TAIL_BIT_CNT",
        "The value determines the length of the Tailing bit counter.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_FRAME_BRST_CNT",
        "This value is to limit the continous Frame transmission count in Pipel"
        "ined Data flow.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_DLY_SEL",
        "These values denote the tap delay values for reception of data and fla"
        "g.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_DISABLE",
        "This bit must be set to zero for any DMA operation.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal HSI operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CONF.
static const field_t hw_mipi_hsi_tx_conf[] =
{
    {
        "TRANS_MODE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "When this bit gets set to one, HSI transmitter sends \"tx_wake\" signa"
        "l to Rx of other device.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_CNT",
        "",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_EN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_EN",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_EN",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_EN",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_EN",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_EN",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_EN",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_EN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_EN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_EN",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_EN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_EN",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_EN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_EN",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_EN",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_EN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CONF.
static const field_t hw_mipi_hsi_rx_conf[] =
{
    {
        "DATA_FLOW",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKE",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REC_MODE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAIL_BIT_CNT_EN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_CNT",
        "Receive Frame Timeout Counter:  The counter shall be started when the "
        "first bit of the Frame has been found.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_EN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_EN",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_EN",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_EN",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_EN",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_EN",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_EN",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_EN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_EN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_EN",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_EN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_EN",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_EN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_EN",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_EN",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_EN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_CAP.
static const field_t hw_mipi_hsi_cap[] =
{
    {
        "TX_CH_NU_SUPPORTE",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH_NU_SUPPORTE",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_CH_NU_SUPPORT",
        "",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_DMA_SUPPORT",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_DMA_SUPPORT",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAKEUP_EVENT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_WML0.
static const field_t hw_mipi_hsi_tx_wml0[] =
{
    {
        "CH8",
        "This value denotes the WML of Tx Channel 8.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9",
        "This value denotes the WML of Tx Channel 9.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10",
        "This value denotes the WML of Tx Channel 10.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11",
        "This value denotes the WML of Tx Channel 11.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12",
        "This value denotes the WML of Tx Channel 12.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13",
        "This value denotes the WML of Tx Channel 13.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14",
        "This value denotes the WML of Tx Channel 14.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15",
        "This value denotes the WML of Tx Channel 15.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_TML1.
static const field_t hw_mipi_hsi_tx_tml1[] =
{
    {
        "CH0",
        "This value denotes the WML of Tx Channel 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1",
        "This value denotes the WML of Tx Channel 1.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2",
        "This value denotes the WML of Tx Channel 2.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3",
        "This value denotes the WML of Tx Channel 3.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4",
        "This value denotes the WML of Tx Channel 4.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5",
        "This value denotes the WML of Tx Channel 5.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6",
        "This value denotes the WML of Tx Channel 6.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7",
        "This value denotes the WML of Tx Channel 7.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_ARB_PRI0.
static const field_t hw_mipi_hsi_tx_arb_pri0[] =
{
    {
        "CH0",
        "This value denotes the priority of Tx Channel 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1",
        "This value denotes the priority of Tx Channel 1.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2",
        "This value denotes the priority of Tx Channel 2.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3",
        "This value denotes the priority of Tx Channel 3.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4",
        "This value denotes the priority of Tx Channel 4.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5",
        "This value denotes the priority of Tx Channel 5.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6",
        "This value denotes the priority of Tx Channel 6.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7",
        "This value denotes the priority of Tx Channel 7.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_ARB_PRI1.
static const field_t hw_mipi_hsi_tx_arb_pri1[] =
{
    {
        "CH8",
        "This value denotes the priority of Tx Channel 8.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9",
        "This value denotes the priority of Tx Channel 9.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10",
        "This value denotes the priority of Tx Channel 10.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11",
        "This value denotes the priority of Tx Channel 11.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12",
        "This value denotes the priority of Tx Channel 12.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13",
        "This value denotes the priority of Tx Channel 13.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14",
        "This value denotes the priority of Tx Channel 14.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15",
        "This value denotes the priority of Tx Channel 15.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_LINE_ST.
static const field_t hw_mipi_hsi_line_st[] =
{
    {
        "TX_DATA_STATUS",
        "This field reflects the tx_data pin(only for debug).",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_FLAG_STATUS",
        "This field reflects the tx_flag pin(only for debug).",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_READY_STATUS",
        "This field reflects the tx_ready pin(only for debug).",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_WAKEUP_STATUS",
        "This field reflects the tx_wake pin(only for debug).",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_DATA_STATUS",
        "This field reflects the rx_data pin(only for debug).",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_FLAG_STATUS",
        "This field reflects the rx_flag pin(only for debug).",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_READY_STATUS",
        "This field reflects the rx_rdy pin(only for debug).",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_WAKEUP_STATUS",
        "This field reflects the rx_wake pin(only for debug).",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_ID_BIT.
static const field_t hw_mipi_hsi_id_bit[] =
{
    {
        "TX_CH",
        "This bit sets the number of channel ID bits per frame or stream for a "
        "transmit operation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH",
        "This bit sets the number of channel ID bits per frame or stream for a "
        "Receive operation.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_FIFO_THR_CONF.
static const field_t hw_mipi_hsi_fifo_thr_conf[] =
{
    {
        "RX_CH0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH6",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH7",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH8",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH9",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH10",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH11",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH12",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH13",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH14",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH15",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH0",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH1",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH2",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH3",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH4",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH5",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH6",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH7",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH8",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH9",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH10",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH11",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH12",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH13",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH14",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH15",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_CH_SFTRST.
static const field_t hw_mipi_hsi_ch_sftrst[] =
{
    {
        "RX_CH0",
        "Set this bit to zero to enable normal HSI operation.",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH1",
        "Set this bit to zero to enable normal HSI operation.",
        1, // LSB
        1, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH2",
        "Set this bit to zero to enable normal HSI operation.",
        2, // LSB
        2, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH3",
        "Set this bit to zero to enable normal HSI operation.",
        3, // LSB
        3, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH4",
        "Set this bit to zero to enable normal HSI operation.",
        4, // LSB
        4, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH5",
        "Set this bit to zero to enable normal HSI operation.",
        5, // LSB
        5, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH6",
        "Set this bit to zero to enable normal HSI operation.",
        6, // LSB
        6, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH7",
        "Set this bit to zero to enable normal HSI operation.",
        7, // LSB
        7, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH8",
        "Set this bit to zero to enable normal HSI operation.",
        8, // LSB
        8, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH9",
        "Set this bit to zero to enable normal HSI operation.",
        9, // LSB
        9, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH10",
        "Set this bit to zero to enable normal HSI operation.",
        10, // LSB
        10, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH11",
        "Set this bit to zero to enable normal HSI operation.",
        11, // LSB
        11, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH12",
        "Set this bit to zero to enable normal HSI operation.",
        12, // LSB
        12, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH13",
        "Set this bit to zero to enable normal HSI operation.",
        13, // LSB
        13, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH14",
        "Set this bit to zero to enable normal HSI operation.",
        14, // LSB
        14, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_CH15",
        "Set this bit to zero to enable normal HSI operation.",
        15, // LSB
        15, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH0",
        "Set this bit to zero to enable normal HSI operation.",
        16, // LSB
        16, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH1",
        "Set this bit to zero to enable normal HSI operation.",
        17, // LSB
        17, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH2",
        "Set this bit to zero to enable normal HSI operation.",
        18, // LSB
        18, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH3",
        "Set this bit to zero to enable normal HSI operation.",
        19, // LSB
        19, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH4",
        "Set this bit to zero to enable normal HSI operation.",
        20, // LSB
        20, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH5",
        "Set this bit to zero to enable normal HSI operation.",
        21, // LSB
        21, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH6",
        "Set this bit to zero to enable normal HSI operation.",
        22, // LSB
        22, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH7",
        "Set this bit to zero to enable normal HSI operation.",
        23, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH8",
        "Set this bit to zero to enable normal HSI operation.",
        24, // LSB
        24, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH9",
        "Set this bit to zero to enable normal HSI operation.",
        25, // LSB
        25, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH10",
        "Set this bit to zero to enable normal HSI operation.",
        26, // LSB
        26, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH11",
        "Set this bit to zero to enable normal HSI operation.",
        27, // LSB
        27, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH12",
        "Set this bit to zero to enable normal HSI operation.",
        28, // LSB
        28, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH13",
        "Set this bit to zero to enable normal HSI operation.",
        29, // LSB
        29, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH14",
        "Set this bit to zero to enable normal HSI operation.",
        30, // LSB
        30, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_CH15",
        "Set this bit to zero to enable normal HSI operation.",
        31, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_IRQSTAT.
static const field_t hw_mipi_hsi_irqstat[] =
{
    {
        "FIFO_THRESHOLD_INT",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_WAKEUP_INT",
        "",
        1, // LSB
        1, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_TIMEOUT_INT",
        "If any bit in the HSI Error Interrupt Status Register is set, then thi"
        "s bit is set.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_INT",
        "This bit is set when a Transmit or Receive Operation is completed for "
        "DMA.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_ERR_INT",
        "If any bit in the DMA Error Interrupt Status Register is set, then thi"
        "s bit is set.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_TIMEOUT_ERR_INT",
        "",
        5, // LSB
        5, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_ERROR_INT",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RX_BREAK_INT",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TX_EMPTY_INT",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_IRQSTAT_EN.
static const field_t hw_mipi_hsi_irqstat_en[] =
{
    {
        "FIFO_THRESHOLD_INT",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_WAKEUP_INT",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_TIMEOUT_INT",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_INT",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_ERR_INT",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_TIMEOUT_ERR_INT",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_ERROR_INT",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_BREAK_INT",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_EMPTY_INT",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_IRQSIG_EN.
static const field_t hw_mipi_hsi_irqsig_en[] =
{
    {
        "FIFO_THRESHOLD_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_WAKEUP_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_TIMEOUT_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_ERR_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_TIMEOUT_ERR_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_ERROR_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_BREAK_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_EMPTY_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_FIFO_THR_IRQSTAT.
static const field_t hw_mipi_hsi_fifo_thr_irqstat[] =
{
    {
        "RX_CH0_INT",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH1_INT",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH2_INT",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH3_INT",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH4_INT",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH5_INT",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH6_INT",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH7_INT",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH8_INT",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH9_INT",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH10_INT",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH11_INT",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH12_INT",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH13_INT",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH14_INT",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH15_INT",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH0_INT",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH1_INT",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH2_INT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH3_INT",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH4_INT",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH5_INT",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH6_INT",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH7_INT",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH8_INT",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH9_INT",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH10_INT",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH11_INT",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH12_INT",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH13_INT",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH14_INT",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CH15_INT",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_FIFO_THR_IRQSTAT_EN.
static const field_t hw_mipi_hsi_fifo_thr_irqstat_en[] =
{
    {
        "RX_CH0_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH1_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH2_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH3_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH4_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH5_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH6_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH7_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH8_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH9_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH10_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH11_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH12_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH13_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH14_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH15_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH0_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH1_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH2_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH3_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH4_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH5_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH6_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH7_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH8_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH9_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH10_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH11_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH12_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH13_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH14_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH15_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_FIFO_THR_IRQSIG_EN.
static const field_t hw_mipi_hsi_fifo_thr_irqsig_en[] =
{
    {
        "RX_CH0_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH1_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH2_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH3_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH4_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH5_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH6_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH7_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH8_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH9_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH10_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH11_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH12_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH13_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH14_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH15_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH0_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH1_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH2_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH3_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH4_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH5_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH6_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH7_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH8_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH9_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH10_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH11_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH12_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH13_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH14_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_CH15_INT",
        "Setting this bit will enable interrupt generation on interrupt line.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH0_DP.
static const field_t hw_mipi_hsi_tx_ch0_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH1_DP.
static const field_t hw_mipi_hsi_tx_ch1_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH2_DP.
static const field_t hw_mipi_hsi_tx_ch2_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH3_DP.
static const field_t hw_mipi_hsi_tx_ch3_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH4_DP.
static const field_t hw_mipi_hsi_tx_ch4_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH5_DP.
static const field_t hw_mipi_hsi_tx_ch5_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH6_DP.
static const field_t hw_mipi_hsi_tx_ch6_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH7_DP.
static const field_t hw_mipi_hsi_tx_ch7_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH8_DP.
static const field_t hw_mipi_hsi_tx_ch8_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH9_DP.
static const field_t hw_mipi_hsi_tx_ch9_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH10_DP.
static const field_t hw_mipi_hsi_tx_ch10_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH11_DP.
static const field_t hw_mipi_hsi_tx_ch11_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH12_DP.
static const field_t hw_mipi_hsi_tx_ch12_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH13_DP.
static const field_t hw_mipi_hsi_tx_ch13_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH14_DP.
static const field_t hw_mipi_hsi_tx_ch14_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_CH15_DP.
static const field_t hw_mipi_hsi_tx_ch15_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Tx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH0_DP.
static const field_t hw_mipi_hsi_rx_ch0_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH1_DP.
static const field_t hw_mipi_hsi_rx_ch1_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH2_DP.
static const field_t hw_mipi_hsi_rx_ch2_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH3_DP.
static const field_t hw_mipi_hsi_rx_ch3_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH4_DP.
static const field_t hw_mipi_hsi_rx_ch4_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH5_DP.
static const field_t hw_mipi_hsi_rx_ch5_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH6_DP.
static const field_t hw_mipi_hsi_rx_ch6_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH7_DP.
static const field_t hw_mipi_hsi_rx_ch7_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH8_DP.
static const field_t hw_mipi_hsi_rx_ch8_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH9_DP.
static const field_t hw_mipi_hsi_rx_ch9_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH10_DP.
static const field_t hw_mipi_hsi_rx_ch10_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH11_DP.
static const field_t hw_mipi_hsi_rx_ch11_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH12_DP.
static const field_t hw_mipi_hsi_rx_ch12_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH13_DP.
static const field_t hw_mipi_hsi_rx_ch13_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH14_DP.
static const field_t hw_mipi_hsi_rx_ch14_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_CH15_DP.
static const field_t hw_mipi_hsi_rx_ch15_dp[] =
{
    {
        "DATA",
        "Software could Write/Read this bits to access Rx Channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_ERR_IRQSTAT.
static const field_t hw_mipi_hsi_err_irqstat[] =
{
    {
        "RX_CH0_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch0 reaches the d"
        "ata timeout counter value.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH1_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch1 reaches the d"
        "ata timeout counter value.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH2_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch2 reaches the d"
        "ata timeout counter value.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH3_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch3 reaches the d"
        "ata timeout counter value.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH4_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch4 reaches the d"
        "ata timeout counter value.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH5_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch5 reaches the d"
        "ata timeout counter value.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH6_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch6 reaches the d"
        "ata timeout counter value.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH7_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch7 reaches the d"
        "ata timeout counter value.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH8_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch8 reaches the d"
        "ata timeout counter value.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH9_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch9 reaches the d"
        "ata timeout counter value.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH10_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch10 reaches the "
        "data timeout counter value.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH11_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch11 reaches the "
        "data timeout counter value.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH12_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch12 reaches the "
        "data timeout counter value.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH13_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch13 reaches the "
        "data timeout counter value.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH14_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch14 reaches the "
        "data timeout counter value.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CH15_TIMEOUT_INT",
        "This status bit is set when data timeout counter for ch15 reaches thed"
        "ata timeout counter value.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_ERR_IRQSTAT_EN.
static const field_t hw_mipi_hsi_err_irqstat_en[] =
{
    {
        "RX_CH0_TIMEOUT_INT_EN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH1_TIMEOUT_INT_EN",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH2_TIMEOUT_INT_EN",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH3_TIMEOUT_INT_EN",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH4_TIMEOUT_INT_EN",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH5_TIMEOUT_INT_EN",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH6_TIMEOUT_INT_EN",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH7_TIMEOUT_INT_EN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH8_TIMEOUT_INT_EN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH9_TIMEOUT_INT_EN",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH10_TIMEOUT_INT_EN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH11_TIMEOUT_INT_EN",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH12_TIMEOUT_INT_EN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH13_TIMEOUT_INT_EN",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH14_TIMEOUT_INT_EN",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH15_TIMEOUT_INT_EN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_ERR_IRQSIG_EN.
static const field_t hw_mipi_hsi_err_irqsig_en[] =
{
    {
        "RX_CH0_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH1_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH2_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH3_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH4_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH5_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH6_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH7_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH8_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH9_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH10_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH11_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH12_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH13_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH14_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_CH15_TIMEOUT_INT_EN",
        "Setting this bit will enable interrupt generation on interrupt line.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA0_CONF.
static const field_t hw_mipi_hsi_tdma0_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA1_CONF.
static const field_t hw_mipi_hsi_tdma1_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA2_CONF.
static const field_t hw_mipi_hsi_tdma2_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA3_CONF.
static const field_t hw_mipi_hsi_tdma3_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA4_CONF.
static const field_t hw_mipi_hsi_tdma4_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA5_CONF.
static const field_t hw_mipi_hsi_tdma5_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA6_CONF.
static const field_t hw_mipi_hsi_tdma6_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA7_CONF.
static const field_t hw_mipi_hsi_tdma7_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA8_CONF.
static const field_t hw_mipi_hsi_tdma8_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA9_CONF.
static const field_t hw_mipi_hsi_tdma9_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA10_CONF.
static const field_t hw_mipi_hsi_tdma10_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA11_CONF.
static const field_t hw_mipi_hsi_tdma11_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA12_CONF.
static const field_t hw_mipi_hsi_tdma12_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA13_CONF.
static const field_t hw_mipi_hsi_tdma13_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA14_CONF.
static const field_t hw_mipi_hsi_tdma14_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA15_CONF.
static const field_t hw_mipi_hsi_tdma15_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Tx DMA channel n.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Tx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Tx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA0_CONF.
static const field_t hw_mipi_hsi_rdma0_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA1_CONF.
static const field_t hw_mipi_hsi_rdma1_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA2_CONF.
static const field_t hw_mipi_hsi_rdma2_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA3_CONF.
static const field_t hw_mipi_hsi_rdma3_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA4_CONF.
static const field_t hw_mipi_hsi_rdma4_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA5_CONF.
static const field_t hw_mipi_hsi_rdma5_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA6_CONF.
static const field_t hw_mipi_hsi_rdma6_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA7_CONF.
static const field_t hw_mipi_hsi_rdma7_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA8_CONF.
static const field_t hw_mipi_hsi_rdma8_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA9_CONF.
static const field_t hw_mipi_hsi_rdma9_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA10_CONF.
static const field_t hw_mipi_hsi_rdma10_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA11_CONF.
static const field_t hw_mipi_hsi_rdma11_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA12_CONF.
static const field_t hw_mipi_hsi_rdma12_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA13_CONF.
static const field_t hw_mipi_hsi_rdma13_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA14_CONF.
static const field_t hw_mipi_hsi_rdma14_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA15_CONF.
static const field_t hw_mipi_hsi_rdma15_conf[] =
{
    {
        "TRANS_LENGTH",
        "Transfer data length for Rx DMA channel 0.",
        5, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_SIZE",
        "Burst size for Rx DMA channel n.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Setting this bit enables the inernal Rx DMA channel n.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA0_STA_ADDR.
static const field_t hw_mipi_hsi_tdma0_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA1_STA_ADDR.
static const field_t hw_mipi_hsi_tdma1_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA2_STA_ADDR.
static const field_t hw_mipi_hsi_tdma2_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA3_STA_ADDR.
static const field_t hw_mipi_hsi_tdma3_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA4_STA_ADDR.
static const field_t hw_mipi_hsi_tdma4_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA5_STA_ADDR.
static const field_t hw_mipi_hsi_tdma5_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA6_STA_ADDR.
static const field_t hw_mipi_hsi_tdma6_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA7_STA_ADDR.
static const field_t hw_mipi_hsi_tdma7_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA8_STA_ADDR.
static const field_t hw_mipi_hsi_tdma8_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA9_STA_ADDR.
static const field_t hw_mipi_hsi_tdma9_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA10_STA_ADDR.
static const field_t hw_mipi_hsi_tdma10_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA11_STA_ADDR.
static const field_t hw_mipi_hsi_tdma11_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA12_STA_ADDR.
static const field_t hw_mipi_hsi_tdma12_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA13_STA_ADDR.
static const field_t hw_mipi_hsi_tdma13_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA14_STA_ADDR.
static const field_t hw_mipi_hsi_tdma14_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TDMA15_STA_ADDR.
static const field_t hw_mipi_hsi_tdma15_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Tx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA0_STA_ADDR.
static const field_t hw_mipi_hsi_rdma0_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA1_STA_ADDR.
static const field_t hw_mipi_hsi_rdma1_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA2_STA_ADDR.
static const field_t hw_mipi_hsi_rdma2_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA3_STA_ADDR.
static const field_t hw_mipi_hsi_rdma3_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA4_STA_ADDR.
static const field_t hw_mipi_hsi_rdma4_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA5_STA_ADDR.
static const field_t hw_mipi_hsi_rdma5_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA6_STA_ADDR.
static const field_t hw_mipi_hsi_rdma6_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA7_STA_ADDR.
static const field_t hw_mipi_hsi_rdma7_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA8_STA_ADDR.
static const field_t hw_mipi_hsi_rdma8_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA9_STA_ADDR.
static const field_t hw_mipi_hsi_rdma9_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA10_STA_ADDR.
static const field_t hw_mipi_hsi_rdma10_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA11_STA_ADDR.
static const field_t hw_mipi_hsi_rdma11_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA12_STA_ADDR.
static const field_t hw_mipi_hsi_rdma12_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA13_STA_ADDR.
static const field_t hw_mipi_hsi_rdma13_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA14_STA_ADDR.
static const field_t hw_mipi_hsi_rdma14_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RDMA15_STA_ADDR.
static const field_t hw_mipi_hsi_rdma15_sta_addr[] =
{
    {
        "DS_ADDR",
        "The Physical Start Address for Rx DMA Channel n.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_DMA_IRQSTAT.
static const field_t hw_mipi_hsi_dma_irqstat[] =
{
    {
        "RDMA0",
        "RDMA Channel 0 interrupt status",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA1",
        "RDMA Channel 1 interrupt status",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA2",
        "RDMA Channel 2 interrupt status",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA3",
        "RDMA Channel 3 interrupt status",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA4",
        "RDMA Channel 4 interrupt status",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA5",
        "RDMA Channel 5 interrupt status",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA6",
        "RDMA Channel 6 interrupt status",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA7",
        "RDMA Channel 7 interrupt status",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA8",
        "RDMA Channel 8 interrupt status",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA9",
        "RDMA Channel 9 interrupt status",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA10",
        "RDMA Channel 10 interrupt status",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA11",
        "RDMA Channel 11 interrupt status",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA12",
        "RDMA Channel 12 interrupt status",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA13",
        "RDMA Channel 13 interrupt status",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA14",
        "RDMA Channel 14 interrupt status",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA15",
        "RDMA Channel 15 interrupt status",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA0",
        "TDMA Channel 0 interrupt status",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA1",
        "TDMA Channel 1 interrupt status",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA2",
        "TDMA Channel 2 interrupt status",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA3",
        "TDMA Channel 3 interrupt status",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA4",
        "TDMA Channel 4 interrupt status",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA5",
        "TDMA Channel 5 interrupt status",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA6",
        "TDMA Channel 6 interrupt status",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA7",
        "TDMA Channel 7 interrupt status",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA8",
        "TDMA Channel 8 interrupt status",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA9",
        "TDMA Channel 9 interrupt status",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA10",
        "TDMA Channel 10 interrupt status",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA11",
        "TDMA Channel 11 interrupt status",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA12",
        "TDMA Channel 12 interrupt status",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA13",
        "TDMA Channel 13 interrupt status",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA14",
        "TDMA Channel 14 interrupt status",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA15",
        "TDMA Channel 15 interrupt status",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_DMA_IRQSTAT_EN.
static const field_t hw_mipi_hsi_dma_irqstat_en[] =
{
    {
        "RDMA0",
        "RDMA Channel 0 interrupt Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA1",
        "RDMA Channel 1 interrupt Enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA2",
        "RDMA Channel 2 interrupt Enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA3",
        "RDMA Channel 3 interrupt Enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA4",
        "RDMA Channel 4 interrupt Enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA5",
        "RDMA Channel 5 interrupt Enable",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA6",
        "RDMA Channel 6 interrupt Enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA7",
        "RDMA Channel 7 interrupt Enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA8",
        "RDMA Channel 8 interrupt Enable",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA9",
        "RDMA Channel 9 interrupt Enable",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA10",
        "RDMA Channel 10 interrupt Enable",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA11",
        "RDMA Channel 11 interrupt Enable",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA12",
        "RDMA Channel 12 interrupt Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA13",
        "RDMA Channel 13 interrupt Enable",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA14",
        "RDMA Channel 14 interrupt Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA15",
        "RDMA Channel 15 interrupt Enable",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA0",
        "TDMA Channel 0 interrupt Enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA1",
        "TDMA Channel 1 interrupt Enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA2",
        "TDMA Channel 2 interrupt Enable",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA3",
        "TDMA Channel 3 interrupt Enable",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA4",
        "TDMA Channel 4 interrupt Enable",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA5",
        "TDMA Channel 5 interrupt Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA6",
        "TDMA Channel 6 interrupt Enable",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA7",
        "TDMA Channel 7 interrupt Enable",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA8",
        "TDMA Channel 8 interrupt Enable",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA9",
        "TDMA Channel 9 interrupt Enable",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA10",
        "TDMA Channel 10 interrupt Enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA11",
        "TDMA Channel 11 interrupt Enable",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA12",
        "TDMA Channel 12 interrupt Enable",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA13",
        "TDMA Channel 13 interrupt Enable",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA14",
        "TDMA Channel 14 interrupt Enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA15",
        "TDMA Channel 15 interrupt Enable",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_DMA_IRQSIG_EN.
static const field_t hw_mipi_hsi_dma_irqsig_en[] =
{
    {
        "RDMA0",
        "RDMA Channel 0 interrupt status enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA1",
        "RDMA Channel 1 interrupt status enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA2",
        "RDMA Channel 2 interrupt status enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA3",
        "RDMA Channel 3 interrupt status enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA4",
        "RDMA Channel 4 interrupt status enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA5",
        "RDMA Channel 5 interrupt status enable",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA6",
        "RDMA Channel 6 interrupt status enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA7",
        "RDMA Channel 7 interrupt status enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA8",
        "RDMA Channel 8 interrupt status enable",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA9",
        "RDMA Channel 9 interrupt status enable",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA10",
        "RDMA Channel 10 interrupt status enable",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA11",
        "RDMA Channel 11 interrupt status enable",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA12",
        "RDMA Channel 12 interrupt status enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA13",
        "RDMA Channel 13 interrupt status enable",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA14",
        "RDMA Channel 14 interrupt status enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA15",
        "RDMA Channel 15 interrupt status enable",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA0",
        "TDMA Channel 0 interrupt status enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA1",
        "TDMA Channel 1 interrupt status enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA2",
        "TDMA Channel 2 interrupt status enable",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA3",
        "TDMA Channel 3 interrupt status enable",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA4",
        "TDMA Channel 4 interrupt status enable",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA5",
        "TDMA Channel 5 interrupt status enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA6",
        "TDMA Channel 6 interrupt status enable",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA7",
        "TDMA Channel 7 interrupt status enable",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA8",
        "TDMA Channel 8 interrupt status enable",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA9",
        "TDMA Channel 9 interrupt status enable",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA10",
        "TDMA Channel 10 interrupt status enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA11",
        "TDMA Channel 11 interrupt status enable",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA12",
        "TDMA Channel 12 interrupt status enable",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA13",
        "TDMA Channel 13 interrupt status enable",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA14",
        "TDMA Channel 14 interrupt status enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA15",
        "TDMA Channel 15 interrupt status enable",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_DMA_ERR_IRQSTAT.
static const field_t hw_mipi_hsi_dma_err_irqstat[] =
{
    {
        "RDMA0",
        "RDMA Channel 0 error interrupt status",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA1",
        "RDMA Channel 1 error interrupt status",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA2",
        "RDMA Channel 2 error interrupt status",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA3",
        "RDMA Channel 3 error interrupt status",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA4",
        "RDMA Channel 4 error interrupt status",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA5",
        "RDMA Channel 5 error interrupt status",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA6",
        "RDMA Channel 6 error interrupt status",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA7",
        "RDMA Channel 7 error interrupt status",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA8",
        "RDMA Channel 8 error interrupt status",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA9",
        "RDMA Channel 9 error interrupt status",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA10",
        "RDMA Channel 10 error interrupt status",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA11",
        "RDMA Channel 11 error interrupt status",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA12",
        "RDMA Channel 12 error interrupt status",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA13",
        "RDMA Channel 13 error interrupt status",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA14",
        "RDMA Channel 14 error interrupt status",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA15",
        "RDMA Channel 15 error interrupt status",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA0",
        "TDMA Channel 0 error interrupt status",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA1",
        "TDMA Channel 1 error interrupt status",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA2",
        "TDMA Channel 2 error interrupt status",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA3",
        "TDMA Channel 3 error interrupt status",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA4",
        "TDMA Channel 4 error interrupt status",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA5",
        "TDMA Channel 5 error interrupt status",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA6",
        "TDMA Channel 6 error interrupt status",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA7",
        "TDMA Channel 7 error interrupt status",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA8",
        "TDMA Channel 8 error interrupt status",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA9",
        "TDMA Channel 9 error interrupt status",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA10",
        "TDMA Channel 10 error interrupt status",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA11",
        "TDMA Channel 11 error interrupt status",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA12",
        "TDMA Channel 12 error interrupt status",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA13",
        "TDMA Channel 13 error interrupt status",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA14",
        "TDMA Channel 14 error interrupt status",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA15",
        "TDMA Channel 15 error interrupt status",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_DMA_ERR_IRQSTAT_EN.
static const field_t hw_mipi_hsi_dma_err_irqstat_en[] =
{
    {
        "RDMA0",
        "RDMA Channel 0 error interrupt enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA1",
        "RDMA Channel 1 error interrupt enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA2",
        "RDMA Channel 2 error interrupt enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA3",
        "RDMA Channel 3 error interrupt enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA4",
        "RDMA Channel 4 error interrupt enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA5",
        "RDMA Channel 5 error interrupt enable",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA6",
        "RDMA Channel 6 error interrupt enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA7",
        "RDMA Channel 7 error interrupt enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA8",
        "RDMA Channel 8 error interrupt enable",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA9",
        "RDMA Channel 9 error interrupt enable",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA10",
        "RDMA Channel 10 error interrupt enable",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA11",
        "RDMA Channel 11 error interrupt enable",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA12",
        "RDMA Channel 12 error interrupt enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA13",
        "RDMA Channel 13 error interrupt enable",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA14",
        "RDMA Channel 14 error interrupt enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA15",
        "RDMA Channel 15 error interrupt enable",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA0",
        "TDMA Channel 0 error interrupt enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA1",
        "TDMA Channel 1 error interrupt enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA2",
        "TDMA Channel 2 error interrupt enable",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA3",
        "TDMA Channel 3 error interrupt enable",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA4",
        "TDMA Channel 4 error interrupt enable",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA5",
        "TDMA Channel 5 error interrupt enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA6",
        "TDMA Channel 6 error interrupt enable",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA7",
        "TDMA Channel 7 error interrupt enable",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA8",
        "TDMA Channel 8 error interrupt enable",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA9",
        "TDMA Channel 9 error interrupt enable",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA10",
        "TDMA Channel 10 error interrupt enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA11",
        "TDMA Channel 11 error interrupt enable",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA12",
        "TDMA Channel 12 error interrupt enable",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA13",
        "TDMA Channel 13 error interrupt enable",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA14",
        "TDMA Channel 14 error interrupt enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA15",
        "TDMA Channel 15 error interrupt enable",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_DMA_ERR_IRQSIG_EN.
static const field_t hw_mipi_hsi_dma_err_irqsig_en[] =
{
    {
        "RDMA0",
        "RDMA Channel 0 error interrupt status enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA1",
        "RDMA Channel 1 error interrupt status enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA2",
        "RDMA Channel 2 error interrupt status enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA3",
        "RDMA Channel 3 error interrupt status enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA4",
        "RDMA Channel 4 error interrupt status enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA5",
        "RDMA Channel 5 error interrupt status enable",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA6",
        "RDMA Channel 6 error interrupt status enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA7",
        "RDMA Channel 7 error interrupt status enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA8",
        "RDMA Channel 8 error interrupt status enable",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA9",
        "RDMA Channel 9 error interrupt status enable",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA10",
        "RDMA Channel 10 error interrupt status enable",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA11",
        "RDMA Channel 11 error interrupt status enable",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA12",
        "RDMA Channel 12 error interrupt status enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA13",
        "RDMA Channel 13 error interrupt status enable",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA14",
        "RDMA Channel 14 error interrupt status enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMA15",
        "RDMA Channel 15 error interrupt status enable",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA0",
        "TDMA Channel 0 error interrupt status enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA1",
        "TDMA Channel 1 error interrupt status enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA2",
        "TDMA Channel 2 error interrupt status enable",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA3",
        "TDMA Channel 3 error interrupt status enable",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA4",
        "TDMA Channel 4 error interrupt status enable",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA5",
        "TDMA Channel 5 error interrupt status enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA6",
        "TDMA Channel 6 error interrupt status enable",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA7",
        "TDMA Channel 7 error interrupt status enable",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA8",
        "TDMA Channel 8 error interrupt status enable",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA9",
        "TDMA Channel 9 error interrupt status enable",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA10",
        "TDMA Channel 10 error interrupt status enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA11",
        "TDMA Channel 11 error interrupt status enable",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA12",
        "TDMA Channel 12 error interrupt status enable",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA13",
        "TDMA Channel 13 error interrupt status enable",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA14",
        "TDMA Channel 14 error interrupt status enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMA15",
        "TDMA Channel 15 error interrupt status enable",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_DMA_SINGLE_REQ_EN.
static const field_t hw_mipi_hsi_dma_single_req_en[] =
{
    {
        "RDMA0",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 0, this bit will be set automatically",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA1",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 1, this bit will be set automatically",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA2",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 2, this bit will be set automatically",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA3",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 3, this bit will be set automatically",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA4",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 4, this bit will be set automatically",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA5",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 5, this bit will be set automatically",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA6",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 6, this bit will be set automatically",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA7",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 7, this bit will be set automatically",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA8",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 8, this bit will be set automatically",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA9",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 9, this bit will be set automatically",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA10",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 10, this bit will be set automatically",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA11",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 11, this bit will be set automatically",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA12",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 12, this bit will be set automatically",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA13",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 13, this bit will be set automatically",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA14",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 14, this bit will be set automatically",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDMA15",
        "When the remain DMA data less than one DMA burst size in Rx Dma Channl"
        "e 15, this bit will be set automatically",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA0",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 0, this bit will be set automatically",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA1",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 1, this bit will be set automatically",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA2",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 2, this bit will be set automatically",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA3",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 3, this bit will be set automatically",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA4",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 4, this bit will be set automatically",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA5",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 5, this bit will be set automatically",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA6",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 6, this bit will be set automatically",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA7",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 7, this bit will be set automatically",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA8",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 8, this bit will be set automatically",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA9",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 9, this bit will be set automatically",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA10",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 10, this bit will be set automatically",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA11",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 11, this bit will be set automatically",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA12",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 12, this bit will be set automatically",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA13",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 13, this bit will be set automatically",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA14",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 14, this bit will be set automatically",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDMA15",
        "When the remain DMA data less than one DMA burst size in Tx Dma Channl"
        "e 15, this bit will be set automatically",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_FIFO_SIZE_CONF0.
static const field_t hw_mipi_hsi_tx_fifo_size_conf0[] =
{
    {
        "CH8",
        "This field is used to set the buffer size for channel 8.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9",
        "This field is used to set the buffer size for channel 9.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10",
        "This field is used to set the buffer size for channel 10.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11",
        "This field is used to set the buffer size for channel 11.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12",
        "This field is used to set the buffer size for channel 12.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13",
        "This field is used to set the buffer size for channel 13.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14",
        "This field is used to set the buffer size for channel 14.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15",
        "This field is used to set the buffer size for channel 15.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_FIFO_SIZE_CONF1.
static const field_t hw_mipi_hsi_tx_fifo_size_conf1[] =
{
    {
        "CH0",
        "This field is used to set the buffer size for channel 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1",
        "This field is used to set the buffer size for channel 1.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2",
        "This field is used to set the buffer size for channel 2.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3",
        "This field is used to set the buffer size for channel 3.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4",
        "This field is used to set the buffer size for channel 4.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5",
        "This field is used to set the buffer size for channel 5.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6",
        "This field is used to set the buffer size for channel 6.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7",
        "This field is used to set the buffer size for channel 7.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_FIFO_SIZE_CONF0.
static const field_t hw_mipi_hsi_rx_fifo_size_conf0[] =
{
    {
        "CH8",
        "This field is used to set the buffer size for channel 8.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9",
        "This field is used to set the buffer size for channel 9.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10",
        "This field is used to set the buffer size for channel 10.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11",
        "This field is used to set the buffer size for channel 11.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12",
        "This field is used to set the buffer size for channel 12.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13",
        "This field is used to set the buffer size for channel 13.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14",
        "This field is used to set the buffer size for channel 14.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15",
        "This field is used to set the buffer size for channel 15.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_FIFO_SIZE_CONF1.
static const field_t hw_mipi_hsi_rx_fifo_size_conf1[] =
{
    {
        "CH0",
        "This field is used to set the buffer size for channel 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1",
        "This field is used to set the buffer size for channel 1.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2",
        "This field is used to set the buffer size for channel 2.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3",
        "This field is used to set the buffer size for channel 3.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4",
        "This field is used to set the buffer size for channel 4.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5",
        "This field is used to set the buffer size for channel 5.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6",
        "This field is used to set the buffer size for channel 6.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7",
        "This field is used to set the buffer size for channel 7.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_FIFO_STAT.
static const field_t hw_mipi_hsi_tx_fifo_stat[] =
{
    {
        "CH0",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH1",
        "",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH2",
        "",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH3",
        "",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH4",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH5",
        "",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH6",
        "",
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH7",
        "",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH8",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH9",
        "",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH10",
        "",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH11",
        "",
        22, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH12",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH13",
        "",
        26, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH14",
        "",
        28, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH15",
        "",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_RX_FIFO_STAT.
static const field_t hw_mipi_hsi_rx_fifo_stat[] =
{
    {
        "CH0",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH1",
        "",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH2",
        "",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH3",
        "",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH4",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH5",
        "",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH6",
        "",
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH7",
        "",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH8",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH9",
        "",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH10",
        "",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH11",
        "",
        22, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH12",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH13",
        "",
        26, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH14",
        "",
        28, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH15",
        "",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_AHB_MASTER_CONF.
static const field_t hw_mipi_hsi_ahb_master_conf[] =
{
    {
        "DMA_INSERT_IDLE_NUM",
        "These bits used to set the number of \"IDLE\" cycles when DMA_MODE == "
        "2'b0x.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_MODE",
        "",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_HOLD_CYCLE",
        "These bits used to set the number of cycles for DP access fifo.",
        6, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_HSI_TX_BREAK_LEN.
static const field_t hw_mipi_hsi_tx_break_len[] =
{
    {
        "COUNT",
        "The tx break length count.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MIPI_HSI module.
static const reg_t hw_mipi_hsi[] =
{
    {
        "CTRL",
        "This register contains module soft reset, clock gating, clock divisor "
        "and so on.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mipi_hsi_ctrl
    },
    {
        "TX_CONF",
        "This register contains the configurations of tx channel enable/disable"
        ", tx wakup and tx trans mode.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_mipi_hsi_tx_conf
    },
    {
        "RX_CONF",
        "This register contains the configurations of rx channel enable/disable"
        ", rx wakup and rx trans mode, rx data flow.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_mipi_hsi_rx_conf
    },
    {
        "CAP",
        "This register contains the HSI controller Capability information.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_mipi_hsi_cap
    },
    {
        "TX_WML0",
        "This register contains HSI controller Tx channel Water Mark Level info"
        "rmation.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_tx_wml0
    },
    {
        "TX_TML1",
        "This register contains HSI controller Tx channel Water Mark Level info"
        "rmation.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_tx_tml1
    },
    {
        "TX_ARB_PRI0",
        "This is HSI Tx Arbiter Priority Register.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_tx_arb_pri0
    },
    {
        "TX_ARB_PRI1",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_tx_arb_pri1
    },
    {
        "LINE_ST",
        "This register contains the HSI controller line status for debug.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_line_st
    },
    {
        "ID_BIT",
        "This register contains the configurations of tx channel enable/disable"
        ", , tx wakup and tx trans mode.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mipi_hsi_id_bit
    },
    {
        "FIFO_THR_CONF",
        "This register sets the threshold level for each Tx and Rx channel fifo",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_fifo_thr_conf
    },
    {
        "CH_SFTRST",
        "This register is used to reset each Tx and Rx Channel",
        4, // Width in bytes
        0x0000002c, // Base address offset
        false, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_ch_sftrst
    },
    {
        "IRQSTAT",
        "This is HSI controller Interrupt Status Register.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mipi_hsi_irqstat
    },
    {
        "IRQSTAT_EN",
        "This register contains the HSI controller Interrupt Status Enable.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mipi_hsi_irqstat_en
    },
    {
        "IRQSIG_EN",
        "This register contains the HSI controller Interrupt Signal Enable.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mipi_hsi_irqsig_en
    },
    {
        "FIFO_THR_IRQSTAT",
        "This register contains the HSI controller FIFO Threshold Interrupt Sta"
        "tus.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_fifo_thr_irqstat
    },
    {
        "FIFO_THR_IRQSTAT_EN",
        "This register contains the HSI controller FIFO Threshold Interrupt Sta"
        "tus Enable.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_fifo_thr_irqstat_en
    },
    {
        "FIFO_THR_IRQSIG_EN",
        "This register contains the HSI controller FIFO Threshold Interrupt Ena"
        "ble.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_fifo_thr_irqsig_en
    },
    {
        "TX_CH0_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch0_dp
    },
    {
        "TX_CH1_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch1_dp
    },
    {
        "TX_CH2_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch2_dp
    },
    {
        "TX_CH3_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch3_dp
    },
    {
        "TX_CH4_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch4_dp
    },
    {
        "TX_CH5_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch5_dp
    },
    {
        "TX_CH6_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch6_dp
    },
    {
        "TX_CH7_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch7_dp
    },
    {
        "TX_CH8_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch8_dp
    },
    {
        "TX_CH9_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch9_dp
    },
    {
        "TX_CH10_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch10_dp
    },
    {
        "TX_CH11_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch11_dp
    },
    {
        "TX_CH12_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch12_dp
    },
    {
        "TX_CH13_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch13_dp
    },
    {
        "TX_CH14_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch14_dp
    },
    {
        "TX_CH15_DP",
        "This Register is connected to fifo data port for Tx Channel n.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_ch15_dp
    },
    {
        "RX_CH0_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch0_dp
    },
    {
        "RX_CH1_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch1_dp
    },
    {
        "RX_CH2_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch2_dp
    },
    {
        "RX_CH3_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch3_dp
    },
    {
        "RX_CH4_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch4_dp
    },
    {
        "RX_CH5_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch5_dp
    },
    {
        "RX_CH6_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch6_dp
    },
    {
        "RX_CH7_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch7_dp
    },
    {
        "RX_CH8_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch8_dp
    },
    {
        "RX_CH9_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch9_dp
    },
    {
        "RX_CH10_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch10_dp
    },
    {
        "RX_CH11_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch11_dp
    },
    {
        "RX_CH12_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch12_dp
    },
    {
        "RX_CH13_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch13_dp
    },
    {
        "RX_CH14_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch14_dp
    },
    {
        "RX_CH15_DP",
        "This Register is connected to fifo data port for Rx Channel n.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rx_ch15_dp
    },
    {
        "ERR_IRQSTAT",
        "This register contains the HSI controller Error Interrupt Status.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        false, // Writable
        16, // Number of bitfields
        hw_mipi_hsi_err_irqstat
    },
    {
        "ERR_IRQSTAT_EN",
        "This register contains the HSI controller Error Interrupt Status Enabl"
        "e.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_mipi_hsi_err_irqstat_en
    },
    {
        "ERR_IRQSIG_EN",
        "This register contains the HSI controller Error Interrupt Signal Enabl"
        "e.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_mipi_hsi_err_irqsig_en
    },
    {
        "TDMA0_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma0_conf
    },
    {
        "TDMA1_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma1_conf
    },
    {
        "TDMA2_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma2_conf
    },
    {
        "TDMA3_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma3_conf
    },
    {
        "TDMA4_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma4_conf
    },
    {
        "TDMA5_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma5_conf
    },
    {
        "TDMA6_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma6_conf
    },
    {
        "TDMA7_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma7_conf
    },
    {
        "TDMA8_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma8_conf
    },
    {
        "TDMA9_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma9_conf
    },
    {
        "TDMA10_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma10_conf
    },
    {
        "TDMA11_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma11_conf
    },
    {
        "TDMA12_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma12_conf
    },
    {
        "TDMA13_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma13_conf
    },
    {
        "TDMA14_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma14_conf
    },
    {
        "TDMA15_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Tx DMA channel n.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_tdma15_conf
    },
    {
        "RDMA0_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma0_conf
    },
    {
        "RDMA1_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma1_conf
    },
    {
        "RDMA2_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma2_conf
    },
    {
        "RDMA3_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma3_conf
    },
    {
        "RDMA4_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma4_conf
    },
    {
        "RDMA5_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma5_conf
    },
    {
        "RDMA6_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma6_conf
    },
    {
        "RDMA7_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma7_conf
    },
    {
        "RDMA8_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma8_conf
    },
    {
        "RDMA9_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma9_conf
    },
    {
        "RDMA10_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma10_conf
    },
    {
        "RDMA11_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma11_conf
    },
    {
        "RDMA12_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma12_conf
    },
    {
        "RDMA13_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma13_conf
    },
    {
        "RDMA14_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma14_conf
    },
    {
        "RDMA15_CONF",
        "This register contains the configurations of enable/disable, burst siz"
        "e and transfer count for Rx DMA channel n.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_rdma15_conf
    },
    {
        "TDMA0_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma0_sta_addr
    },
    {
        "TDMA1_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma1_sta_addr
    },
    {
        "TDMA2_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma2_sta_addr
    },
    {
        "TDMA3_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma3_sta_addr
    },
    {
        "TDMA4_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma4_sta_addr
    },
    {
        "TDMA5_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma5_sta_addr
    },
    {
        "TDMA6_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma6_sta_addr
    },
    {
        "TDMA7_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma7_sta_addr
    },
    {
        "TDMA8_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma8_sta_addr
    },
    {
        "TDMA9_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma9_sta_addr
    },
    {
        "TDMA10_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma10_sta_addr
    },
    {
        "TDMA11_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma11_sta_addr
    },
    {
        "TDMA12_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma12_sta_addr
    },
    {
        "TDMA13_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma13_sta_addr
    },
    {
        "TDMA14_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma14_sta_addr
    },
    {
        "TDMA15_STA_ADDR",
        "This Register containts the physical Start Address HSI for Tx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tdma15_sta_addr
    },
    {
        "RDMA0_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma0_sta_addr
    },
    {
        "RDMA1_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma1_sta_addr
    },
    {
        "RDMA2_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma2_sta_addr
    },
    {
        "RDMA3_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma3_sta_addr
    },
    {
        "RDMA4_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma4_sta_addr
    },
    {
        "RDMA5_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma5_sta_addr
    },
    {
        "RDMA6_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma6_sta_addr
    },
    {
        "RDMA7_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma7_sta_addr
    },
    {
        "RDMA8_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma8_sta_addr
    },
    {
        "RDMA9_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma9_sta_addr
    },
    {
        "RDMA10_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma10_sta_addr
    },
    {
        "RDMA11_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma11_sta_addr
    },
    {
        "RDMA12_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma12_sta_addr
    },
    {
        "RDMA13_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma13_sta_addr
    },
    {
        "RDMA14_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma14_sta_addr
    },
    {
        "RDMA15_STA_ADDR",
        "This Register containts the physical Start Address HSI for Rx DMA Chan"
        "nel n.",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_rdma15_sta_addr
    },
    {
        "DMA_IRQSTAT",
        "This register contains all the interrupt status for HSI internal DMA",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_dma_irqstat
    },
    {
        "DMA_IRQSTAT_EN",
        "This Register is used to select which DMA interrupt could send to HIS "
        "Interrupt Status Register",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_dma_irqstat_en
    },
    {
        "DMA_IRQSIG_EN",
        "This Register is used to select which DMA interrupt status could send "
        "to HIS Interrupt Status Register",
        4, // Width in bytes
        0x000001e4, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_dma_irqsig_en
    },
    {
        "DMA_ERR_IRQSTAT",
        "This register contains all the error interrupt status for HSI internal"
        " DMA",
        4, // Width in bytes
        0x000001e8, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_dma_err_irqstat
    },
    {
        "DMA_ERR_IRQSTAT_EN",
        "This register is used to select which DMA error interrupt could send t"
        "o HIS Interrupt Status Register",
        4, // Width in bytes
        0x000001ec, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_dma_err_irqstat_en
    },
    {
        "DMA_ERR_IRQSIG_EN",
        "This Register is used to select which DMA error interrupt status could"
        " send to HIS Interrupt Status Register",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_dma_err_irqsig_en
    },
    {
        "DMA_SINGLE_REQ_EN",
        "This Register is used to debug",
        4, // Width in bytes
        0x000001f4, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_mipi_hsi_dma_single_req_en
    },
    {
        "TX_FIFO_SIZE_CONF0",
        "This register is used to config each Tx fifo size",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_tx_fifo_size_conf0
    },
    {
        "TX_FIFO_SIZE_CONF1",
        "This register is used to config each Tx fifo size",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_tx_fifo_size_conf1
    },
    {
        "RX_FIFO_SIZE_CONF0",
        "This register is used to config each Rx fifo size",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_rx_fifo_size_conf0
    },
    {
        "RX_FIFO_SIZE_CONF1",
        "This register is used to config each Rx fifo size",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mipi_hsi_rx_fifo_size_conf1
    },
    {
        "TX_FIFO_STAT",
        "This register containts full and empty status for each Tx channel fifo",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        16, // Number of bitfields
        hw_mipi_hsi_tx_fifo_stat
    },
    {
        "RX_FIFO_STAT",
        "This register containts full and empty status for each Rx channel fifo",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        16, // Number of bitfields
        hw_mipi_hsi_rx_fifo_stat
    },
    {
        "AHB_MASTER_CONF",
        "This register used to config hsi internal ahb master",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mipi_hsi_ahb_master_conf
    },
    {
        "TX_BREAK_LEN",
        "This register used to set tx break length",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_hsi_tx_break_len
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MLB150
#endif

// Bitfields in register MLB150_MLBC0.
static const field_t hw_mlb150_mlbc0[] =
{
    {
        "MLBEN",
        "MediaLB enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLBCLK",
        "MediaLB clock speed select.",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLBPEN",
        "MediaLB 6-pin enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLBLK",
        "MediaLB lock status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASYRETRY",
        "Asynchronous Tx packet retry.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTLRETRY",
        "Control Tx packet retry.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCNT",
        "The number of frames per sub-buffer for synchronous channels.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MLBPC0.
static const field_t hw_mlb150_mlbpc0[] =
{
    {
        "MCLKHYS",
        "MediaLB (6-pin) hysteresis enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MS0.
static const field_t hw_mlb150_ms0[] =
{
    {
        "MCS",
        "MediaLB channel status.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MLBPC2.
static const field_t hw_mlb150_mlbpc2[] =
{
    {
        "SDOPC",
        "MLB 3-pin interface: Signal/Data output phase control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDRTO",
        "MLB 6-pin interface: Signal/Data receiver threshold offset control.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MS1.
static const field_t hw_mlb150_ms1[] =
{
    {
        "MCS",
        "MediaLB channel status.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MSS.
static const field_t hw_mlb150_mss[] =
{
    {
        "RSTSYSCMD",
        "Reset system command detected (in the system quadlet).",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LKSYSCMD",
        "Network lock system command detected (in the system quadlet).",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ULKSYSCMD",
        "Network unlock system command detected (in the system quadlet).",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSSYSCMD",
        "Channel scan system command detected (in the system quadlet).",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWSYSCMD",
        "Software system command detected (in the system quadlet).",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SERVREQ",
        "Service request enabled.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MSD.
static const field_t hw_mlb150_msd[] =
{
    {
        "SD0",
        "System data (byte 0).",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SD1",
        "System data (byte 1).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SD2",
        "System data (byte 2).",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SD3",
        "System data (byte 3).",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MIEN.
static const field_t hw_mlb150_mien[] =
{
    {
        "ISOC_PE",
        "Isochronous Rx protocol error enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISOC_BUFO",
        "Isochronous Rx buffer overflow enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_PE",
        "Synchronous protocol error enable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARX_DONE",
        "Asynchronous Rx done enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARX_PE",
        "Asynchronous Rx protocol error enable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARX_BREAK",
        "Asynchronous Rx break enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATX_DONE",
        "Asynchronous Tx packet done enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATX_PE",
        "Asynchronous Tx protocol error enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATX_BREAK",
        "Asynchronous Tx break enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRX_DONE",
        "Control Rx packet done enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRX_PE",
        "Control Rx protocol error enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRX_BREAK",
        "Control Rx break enable.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTX_DONE",
        "Control Tx packet done enable.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTX_PE",
        "Control Tx protocol error enable.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTX_BREAK",
        "Control Tx break enable.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MLBPC1.
static const field_t hw_mlb150_mlbpc1[] =
{
    {
        "SDRCVBIAS",
        "Signal/Data receiver bias control (for MediaLB 6-pin interface).",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDXMTBIAS",
        "Signal/Data transmitter bias control (for MediaLB 6-pin interface).",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CKRCVBIAS",
        "Clock receiver bias control (for MediaLB 6-pin interface).",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MLBC1.
static const field_t hw_mlb150_mlbc1[] =
{
    {
        "LOCK",
        "MediaLB lock error status.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKM",
        "MediaLB clock missing status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NDA",
        "Node device address.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_HCTL.
static const field_t hw_mlb150_hctl[] =
{
    {
        "RST0",
        "AGU0 software reset",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST1",
        "AGU1 software reset",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN",
        "HBI enable",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_HCMR0.
static const field_t hw_mlb150_hcmr0[] =
{
    {
        "CHM",
        "Bitwise channel mask bit",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_HCMR1.
static const field_t hw_mlb150_hcmr1[] =
{
    {
        "CHM",
        "Bitwise channel mask bit",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_HCER0.
static const field_t hw_mlb150_hcer0[] =
{
    {
        "CERR",
        "Bitwise channel error bit",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_HCER1.
static const field_t hw_mlb150_hcer1[] =
{
    {
        "CERR",
        "Bitwise channel error bit",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_HCBR0.
static const field_t hw_mlb150_hcbr0[] =
{
    {
        "CHB",
        "Bitwise channel busy bit",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_HCBR1.
static const field_t hw_mlb150_hcbr1[] =
{
    {
        "CHB",
        "Bitwise channel busy bit",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MDAT0.
static const field_t hw_mlb150_mdat0[] =
{
    {
        "DATA",
        "CTR data - bits[31:0] of 128-bit entry or  DBR data - bits[7:0] of 8-b"
        "it entry",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MDAT1.
static const field_t hw_mlb150_mdat1[] =
{
    {
        "DATA",
        "CTR data - bits[63:32] of 128-bit entry",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MDAT2.
static const field_t hw_mlb150_mdat2[] =
{
    {
        "DATA",
        "CTR data - bits[95:64] of 128-bit entry",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MDAT3.
static const field_t hw_mlb150_mdat3[] =
{
    {
        "DATA",
        "CTR data - bits[127:96] of 128-bit entry",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MDWE0.
static const field_t hw_mlb150_mdwe0[] =
{
    {
        "MASK",
        "Bitwise write enable for CTR data - bits[31:0]",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MDWE1.
static const field_t hw_mlb150_mdwe1[] =
{
    {
        "MASK",
        "Bitwise write enable for CTR data - bits[63:32]",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MDWE2.
static const field_t hw_mlb150_mdwe2[] =
{
    {
        "MASK",
        "Bitwise write enable for CTR data - bits[95:64]",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MDWE3.
static const field_t hw_mlb150_mdwe3[] =
{
    {
        "MASK",
        "Bitwise write enable for CTR data - bits[127:96]",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MCTL.
static const field_t hw_mlb150_mctl[] =
{
    {
        "XCMP",
        "Transfer complete (write 0 to clear)",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_MADR.
static const field_t hw_mlb150_madr[] =
{
    {
        "ADDR1",
        "CTR address of 128-bit entry or  DBR address of 8-bit entry - bits[7:0"
        "]",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR",
        "DBR address of 8-bit entry - bits[13:8]",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TB",
        "Target location bit",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNR",
        "Write-Not-Read selection",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_ACTL.
static const field_t hw_mlb150_actl[] =
{
    {
        "SCE",
        "Software clear enable:",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMX",
        "AHB interrupt mux enable:",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_MODE",
        "DMA Mode:",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPB",
        "DMA Packet buffering mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_ACSR0.
static const field_t hw_mlb150_acsr0[] =
{
    {
        "CHS",
        "Interrupt status for logical channels 31 to 0:",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_ACSR1.
static const field_t hw_mlb150_acsr1[] =
{
    {
        "CHS",
        "Interrupt status for logical channels 63 to 32:",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_ACMR0.
static const field_t hw_mlb150_acmr0[] =
{
    {
        "CHM",
        "Bitwise channel mask bit:",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB150_ACMR1.
static const field_t hw_mlb150_acmr1[] =
{
    {
        "CHM",
        "Bitwise channel mask bit:",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MLB150 module.
static const reg_t hw_mlb150[] =
{
    {
        "MLBC0",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mlb150_mlbc0
    },
    {
        "MLBPC0",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mlbpc0
    },
    {
        "MS0",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_ms0
    },
    {
        "MLBPC2",
        "",
        4, // Width in bytes
        0x0000000d, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mlb150_mlbpc2
    },
    {
        "MS1",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_ms1
    },
    {
        "MSS",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_mlb150_mss
    },
    {
        "MSD",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mlb150_msd
    },
    {
        "MIEN",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_mlb150_mien
    },
    {
        "MLBPC1",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mlb150_mlbpc1
    },
    {
        "MLBC1",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_mlb150_mlbc1
    },
    {
        "HCTL",
        "The HC can control and monitor general operation of the HBI block by r"
        "eading and writing the HBI Control Register (HCTL) through the I/O int"
        "erface.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mlb150_hctl
    },
    {
        "HCMR0",
        "The HC can control which channel(s) are able to generate an HBI interr"
        "upt by writing the HBI Channel Mask Registers (HCMRn).",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_hcmr0
    },
    {
        "HCMR1",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_hcmr1
    },
    {
        "HCER0",
        "The HBI Channel Error Registers (HCERn) indicate which channel(s) have"
        " encountered fatal errors.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_hcer0
    },
    {
        "HCER1",
        "HCERn status bits are set when hardware detects hardware errors on the"
        " given logical channel, including:   Channel opened, but not enabled, "
        " Channel programmed with invalid channel type, or  Out-of-range PML fo"
        "r asynchronous or control Tx channels",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_hcer1
    },
    {
        "HCBR0",
        "The HC can determine which channel(s) are busy by reading the HBI Chan"
        "nel Busy Registers (HCBRn).",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_hcbr0
    },
    {
        "HCBR1",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_hcbr1
    },
    {
        "MDAT0",
        "",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mdat0
    },
    {
        "MDAT1",
        "",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mdat1
    },
    {
        "MDAT2",
        "",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mdat2
    },
    {
        "MDAT3",
        "",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mdat3
    },
    {
        "MDWE0",
        "",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mdwe0
    },
    {
        "MDWE1",
        "",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mdwe1
    },
    {
        "MDWE2",
        "",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mdwe2
    },
    {
        "MDWE3",
        "",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_mdwe3
    },
    {
        "MCTL",
        "",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_mctl
    },
    {
        "MADR",
        "",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mlb150_madr
    },
    {
        "ACTL",
        "The AHB Control (ACTL) register is written by the HC to configure the "
        "AMBA AHB block for channel interrupts.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mlb150_actl
    },
    {
        "ACSR0",
        "The AHB Channel Status (ACSRn) registers contain interrupt bits for ea"
        "ch of the 64 physical channels.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_acsr0
    },
    {
        "ACSR1",
        "",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb150_acsr1
    },
    {
        "ACMR0",
        "Using the AHB Channel Mask (ACMRn) register, the HC can control which "
        "channel(s) generate interrupts on ahb_int[1:0] .",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_acmr0
    },
    {
        "ACMR1",
        "",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb150_acmr1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MMDC
#endif

// Bitfields in register MMDC_MDCTL.
static const field_t hw_mmdc_mdctl[] =
{
    {
        "DSIZ",
        "DDR data bus size.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COL",
        "Column Address Width.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROW",
        "Row Address Width.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_1",
        "MMDC Enable CS1.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_0",
        "MMDC Enable CS0.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDPDC.
static const field_t hw_mmdc_mdpdc[] =
{
    {
        "TCKSRE",
        "Valid clock cycles after self-refresh entry.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKSRX",
        "Valid clock cycles before self-refresh exit.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOTH_CS_PD",
        "Parallel power down entry to both chip selects.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOW_PD",
        "Slow/fast power down.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_0",
        "Power Down Timer - Chip Select 0.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_1",
        "Power Down Timer - Chip Select 1.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKE",
        "CKE minimum pulse width.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_0",
        "Precharge Timer - Chip Select 0.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_1",
        "Precharge Timer - Chip Select 1.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOTC.
static const field_t hw_mmdc_mdotc[] =
{
    {
        "TODT_IDLE_OFF",
        "ODT turn off latency.",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TODTLON",
        "ODT turn on latency.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAXPD",
        "Asynchronous ODT to power down exit delay.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TANPD",
        "Asynchronous ODT to power down entry delay.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAONPD",
        "Asynchronous RTT turn-on delay (power down with DLL frozen).",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAOFPD",
        "Asynchronous RTT turn-off delay (power down with DLL frozen).",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG0.
static const field_t hw_mmdc_mdcfg0[] =
{
    {
        "TCL",
        "CAS Read Latency.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFAW",
        "Four Active Window (all banks).",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPDLL",
        "Exit precharge power down with DLL frozen to commands requiring DLL.",
        9, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXP",
        "Exit power down with DLL-on to any valid command.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "Exit self refresh to non READ command.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRFC",
        "Refresh command to Active or Refresh command time.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG1.
static const field_t hw_mmdc_mdcfg1[] =
{
    {
        "TCWL",
        "CAS Write Latency.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMRD",
        "Mode Register Set command cycle (all banks).",
        5, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWR",
        "WRITE recovery time (same bank).",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPA",
        "Precharge-all command period.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS",
        "Active to Precharge command period (same bank).",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC",
        "Active to Active or Refresh command period (same bank).",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP",
        "Precharge command period (same bank).",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD",
        "Active command to internal read or write delay time (same bank).",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG2.
static const field_t hw_mmdc_mdcfg2[] =
{
    {
        "TRRD",
        "Active to Active command period (all banks).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWTR",
        "Internal WRITE to READ command delay (same bank).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRTP",
        "Internal READ command to Precharge command delay (same bank).",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDLLK",
        "DLL locking time.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMISC.
static const field_t hw_mmdc_mdmisc[] =
{
    {
        "RST",
        "Software Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPDDR2_2CH",
        "LPDDR2 2-channels mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TYPE",
        "DDR TYPE.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_4_BANK",
        "Number of banks per DDR device.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RALAT",
        "Read Additional Latency.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIF3_MODE",
        "Command prediction working mode.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPDDR2_S2",
        "LPDDR2 S2 device type indication.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BI_ON",
        "Bank Interleaving On.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WALAT",
        "Write Additional latency.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LHD",
        "Latency hiding disable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_MIRROR",
        "Address mirroring.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CALIB_PER_CS",
        "Number of chip-select for calibration process.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_RDY",
        "External status device on CS1.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CS0_RDY",
        "External status device on CS0.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDSCR.
static const field_t hw_mmdc_mdscr[] =
{
    {
        "CMD_BA",
        "Bank Address.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_CS",
        "Chip Select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD",
        "Command.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_EN",
        "DQS pads direction.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRR_READ_DATA_VALID",
        "MRR read data valid.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_ACK",
        "Configuration acknowledge.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_REQ",
        "Configuration request.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_LSB",
        "Command/Address LSB.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_MSB",
        "Command/Address MSB.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDREF.
static const field_t hw_mmdc_mdref[] =
{
    {
        "START_REF",
        "Manual start of refresh cycle.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFR",
        "Refresh Rate.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_SEL",
        "Refresh Selector.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_CNT",
        "Refresh Counter at DDR clock period  If REF_SEL equals '2' a refresh c"
        "ycle will begin every amount of DDR cycles configured in this field.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDRWD.
static const field_t hw_mmdc_mdrwd[] =
{
    {
        "RTR_DIFF",
        "Read to read delay for different chip-select.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_DIFF",
        "Read to write delay for different chip-select.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTW_DIFF",
        "Write to write delay for different chip-select.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTR_DIFF",
        "Write to read delay for different chip-select.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_SAME",
        "Read to write delay for the same chip-select.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDAI",
        "Device auto initialization period.(maximum)  This field is relevant on"
        "ly to LPDDR2 mode",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOR.
static const field_t hw_mmdc_mdor[] =
{
    {
        "RST_TO_CKE",
        "DDR3: Time from SDE enable to CKE rise.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_TO_RST",
        "DDR3: Time from SDE enable until DDR reset# is high.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPR",
        "DDR3: CKE HIGH to a valid command.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMRR.
static const field_t hw_mmdc_mdmrr[] =
{
    {
        "MRR_READ_DATA0",
        "MRR DATA that arrived on DQ[7:0]",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA1",
        "MRR DATA that arrived on DQ[15:8]",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA2",
        "MRR DATA that arrived on DQ[23:16]",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA3",
        "MRR DATA that arrived on DQ[31:24]",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG3LP.
static const field_t hw_mmdc_mdcfg3lp[] =
{
    {
        "TRPAB_LP",
        "Precharge (all banks) command period.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPPB_LP",
        "Precharge (per bank) command period (same bank).",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD_LP",
        "Active command to internal read or write delay time (same bank).",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_LP",
        "Active to Active or Refresh command period (same bank).",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMR4.
static const field_t hw_mmdc_mdmr4[] =
{
    {
        "UPDATE_DE_REQ",
        "Update Derated Values Request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DE_ACK",
        "Update Derated Values Acknowledge.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRCD_DE",
        "tRCD derating value.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC_DE",
        "tRC derating value.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS_DE",
        "tRAS derating value.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP_DE",
        "tRP derating value.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRRD_DE",
        "tRRD derating value.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDASP.
static const field_t hw_mmdc_mdasp[] =
{
    {
        "CS0_END",
        "CS0_END.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAARCR.
static const field_t hw_mmdc_maarcr[] =
{
    {
        "ARCR_GUARD",
        "ARCR Guard.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_MAX",
        "ARCR Dynamic Maximum.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_JMP",
        "ARCR Dynamic Jump.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_ACC_HIT",
        "ARCR Access Hit Rate.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_PAG_HIT",
        "ARCR Page Hit Rate.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_RCH_EN",
        "This bit defines whether Real time channel is activated and bypassed a"
        "ll other pending accesses, So accesses with QoS=='F' will be granted t"
        "he highest prioritiy in the optimization/reordering mechanism  Default"
        " value is 0x1 - encoding 1 (Enabled)",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_EXC_ERR_EN",
        "This bit defines whether exclusive read/write access violation of AXI "
        "6.2.4 rule result in SLV Error response or in OKAY response  Default v"
        "alue is 0x1 - encoding 1(response is SLV Error)",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_EN",
        "This bit defines whether security read/write access violation result i"
        "n SLV Error response or in OKAY response  Default value is 0x1 - encod"
        "ing 1(response is SLV Error, rresp/bresp=2'b10)",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_LOCK",
        "Once set, this bit locks ARCR_SEC_ERR_EN and prevents from its updatin"
        "g.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAPSR.
static const field_t hw_mmdc_mapsr[] =
{
    {
        "PSD",
        "Automatic Power Saving Disable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSS",
        "Power Saving Status.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIS",
        "Read Idle Status.This read only bit indicates whether read request buf"
        "fer is idle (empty) or not.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WIS",
        "Write Idle Status.This read only bit indicates whether write request b"
        "uffer is idle (empty) or not.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "Automatic Power saving timer.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPMD",
        "General LPMD request.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS",
        "General DVFS request.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPACK",
        "General low-power acknowledge.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DVACK",
        "General DVFS acknowledge.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR0.
static const field_t hw_mmdc_maexidr0[] =
{
    {
        "EXC_ID_MONITOR0",
        "This feild defines ID for Exclusive monitor#0.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR1",
        "This feild defines ID for Exclusive monitor#1.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR1.
static const field_t hw_mmdc_maexidr1[] =
{
    {
        "EXC_ID_MONITOR2",
        "This feild defines ID for Exclusive monitor#2.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR3",
        "This feild defines ID for Exclusive monitor#3.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR0.
static const field_t hw_mmdc_madpcr0[] =
{
    {
        "DBG_EN",
        "Debug and Profiling Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST",
        "Debug and Profiling Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_FRZ",
        "Profiling freeze.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CYC_OVF",
        "Total Profiling Cycles Count Overflow.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS_EN",
        "Step By Step debug Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS",
        "Step By Step trigger.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR1.
static const field_t hw_mmdc_madpcr1[] =
{
    {
        "PRF_AXI_ID",
        "Profiling AXI ID.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_AXI_ID_MASK",
        "Profiling AXI ID Mask.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR0.
static const field_t hw_mmdc_madpsr0[] =
{
    {
        "CYC_COUNT",
        "Total Profiling cycle Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR1.
static const field_t hw_mmdc_madpsr1[] =
{
    {
        "BUSY_COUNT",
        "Profiling Busy Cycles Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR2.
static const field_t hw_mmdc_madpsr2[] =
{
    {
        "RD_ACC_COUNT",
        "Profiling Read Access Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR3.
static const field_t hw_mmdc_madpsr3[] =
{
    {
        "WR_ACC_COUNT",
        "Profiling Write Access Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR4.
static const field_t hw_mmdc_madpsr4[] =
{
    {
        "RD_BYTES_COUNT",
        "Profiling Read Bytes Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR5.
static const field_t hw_mmdc_madpsr5[] =
{
    {
        "WR_BYTES_COUNT",
        "Profiling Write Bytes Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS0.
static const field_t hw_mmdc_masbs0[] =
{
    {
        "SBS_ADDR",
        "Step By Step Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS1.
static const field_t hw_mmdc_masbs1[] =
{
    {
        "SBS_VLD",
        "Step By Step Valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_TYPE",
        "Step By Step Request Type.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LOCK",
        "Step By Step Lock.",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_PROT",
        "Step By Step Protection.",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_SIZE",
        "Step By Step Size.",
        7, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BURST",
        "Step By Step Burst.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BUFF",
        "Step By Step Buffered.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LEN",
        "Step By Step Length.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_AXI_ID",
        "Step By Step AXI ID.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAGENP.
static const field_t hw_mmdc_magenp[] =
{
    {
        "GP31_GP0",
        "General purpose read/write bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQHWCTRL.
static const field_t hw_mmdc_mpzqhwctrl[] =
{
    {
        "ZQ_MODE",
        "ZQ calibration mode:",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PER",
        "ZQ periodic calibration time.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PU_RES",
        "ZQ automatic calibration pull-up result.",
        6, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_PD_RES",
        "ZQ HW calibration pull-down result.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_FOR",
        "Force ZQ automatic calibration process with the i.MX ZQ calibration pa"
        "d.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_INIT",
        "Device ZQ long/init time.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_OPER",
        "Device ZQ long/oper time.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_CS",
        "Device ZQ short time.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_EARLY_COMPARATOR_EN_TIMER",
        "ZQ early comparator enable timer.",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQSWCTRL.
static const field_t hw_mmdc_mpzqswctrl[] =
{
    {
        "ZQ_SW_FOR",
        "ZQ SW calibration enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_RES",
        "ZQ software calibration result.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_SW_PU_VAL",
        "ZQ software pull-up resistence.This field determines the value of the "
        "PU resistor during SW ZQ calibration.",
        2, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD_VAL",
        "ZQ software pull-down resistence.This field determines the value of th"
        "e PD resistor during SW ZQ calibration.",
        7, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD",
        "ZQ software PU/PD calibration.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_ZQ_SW_VAL",
        "Use SW ZQ configured value for I/O pads resistor controls.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_CMP_OUT_SMP",
        "Defines the amount of cycles between driving the ZQ signals to the ZQ "
        "pad and till sampling the comparator enable output while performing ZQ"
        " calibration process with the i.MX ZQ calibration pad",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLGCR.
static const field_t hw_mmdc_mpwlgcr[] =
{
    {
        "HW_WL_EN",
        "Write-Leveling HW (automatic) enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_WL_EN",
        "Write-Leveling SW enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_WL_CNT_EN",
        "SW write-leveling count down enable.This bit when asserted set a certa"
        "in delay of (25+15) cycles from the setting of SW_WL_EN and before dri"
        "ving the DQS to the DDR device.This bit should be asserted before the "
        "first SW write-leveling request and after issuing the write leveling M"
        "RS command",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_SW_RES0",
        "Byte0 write-leveling software result.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES1",
        "Byte1 write-leveling software result.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES2",
        "Byte2 write-leveling software result.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES3",
        "Byte3 write-leveling software result.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR0",
        "Byte0 write-leveling HW calibration error.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR1",
        "Byte1 write-leveling HW calibration error.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR2",
        "Byte2 write-leveling HW calibration error.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR3",
        "Byte3 write-leveling HW calibration error.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDECTRL0.
static const field_t hw_mmdc_mpwldectrl0[] =
{
    {
        "WL_DL_ABS_OFFSET0",
        "Absolute write-leveling delay offset for Byte 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL0",
        "Write leveling half cycle delay for Byte 0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL0",
        "Write leveling cycle delay for Byte 0.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_DL_ABS_OFFSET1",
        "Absolute write-leveling delay offset for Byte 1.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL1",
        "Write leveling half cycle delay for Byte 1.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL1",
        "Write leveling cycle delay for Byte 1.",
        25, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDECTRL1.
static const field_t hw_mmdc_mpwldectrl1[] =
{
    {
        "WL_DL_ABS_OFFSET2",
        "Absolute write-leveling delay offset for Byte 2.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL2",
        "Write leveling half cycle delay for Byte 2.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL2",
        "Write leveling cycle delay for Byte 2.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_DL_ABS_OFFSET3",
        "Absolute write-leveling delay offset for Byte 3.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL3",
        "Write leveling half cycle delay for Byte 3.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL3",
        "Write leveling cycle delay for Byte 3.",
        25, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDLST.
static const field_t hw_mmdc_mpwldlst[] =
{
    {
        "WL_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPODTCTRL.
static const field_t hw_mmdc_mpodtctrl[] =
{
    {
        "ODT_WR_PAS_EN",
        "Inactive write CS ODT enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_WR_ACT_EN",
        "Active write CS ODT enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_RD_PAS_EN",
        "Inactive read CS ODT enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_RD_ACT_EN",
        "Active read CS ODT enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT0_INT_RES",
        "On chip ODT byte0 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte0 resistor during read accesses.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT1_INT_RES",
        "On chip ODT byte1 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte1 resistor during read accesses.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT2_INT_RES",
        "On chip ODT byte2 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte2 resistor during read accesses.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT3_INT_RES",
        "On chip ODT byte3 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte3 resistor during read accesses.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY0DL.
static const field_t hw_mmdc_mprddqby0dl[] =
{
    {
        "RD_DQ0_DEL",
        "Read dqs0 to dq0 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ1_DEL",
        "Read dqs0 to dq1 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ2_DEL",
        "Read dqs0 to dq2 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ3_DEL",
        "Read dqs0 to dq3 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ4_DEL",
        "Read dqs0 to dq4 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ5_DEL",
        "Read dqs0 to dq5 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ6_DEL",
        "Read dqs0 to dq6 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ7_DEL",
        "Read dqs0 to dq7 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY1DL.
static const field_t hw_mmdc_mprddqby1dl[] =
{
    {
        "RD_DQ8_DEL",
        "Read dqs1 to dq8 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ9_DEL",
        "Read dqs1 to dq9 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ10_DEL",
        "Read dqs1 to dq10 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ11_DEL",
        "Read dqs1 to dq11 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ12_DEL",
        "Read dqs1 to dq12 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ13_DEL",
        "Read dqs1 to dq13 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ14_DEL",
        "Read dqs1 to dq14 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ15_DEL",
        "Read dqs1 to dq15 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY2DL.
static const field_t hw_mmdc_mprddqby2dl[] =
{
    {
        "RD_DQ16_DEL",
        "Read dqs2 to dq16 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ17_DEL",
        "Read dqs2 to dq17 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ18_DEL",
        "Read dqs2 to dq18 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ19_DEL",
        "Read dqs2 to dq19 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ20_DEL",
        "Read dqs2 to dq20 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ21_DEL",
        "Read dqs2 to dq21 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ22_DEL",
        "Read dqs2 to dq22 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ23_DEL",
        "Read dqs2 to dq23 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY3DL.
static const field_t hw_mmdc_mprddqby3dl[] =
{
    {
        "RD_DQ24_DEL",
        "Read dqs3 to dq24 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ25_DEL",
        "Read dqs3 to dq25 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ26_DEL",
        "Read dqs3 to dq26 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ27_DEL",
        "Read dqs3 to dq27 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ28_DEL",
        "Read dqs3 to dq28 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ29_DEL",
        "Read dqs3 to dq29 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ30_DEL",
        "Read dqs3 to dq30 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ31_DEL",
        "Read dqs3 to dq31 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY0DL.
static const field_t hw_mmdc_mpwrdqby0dl[] =
{
    {
        "WR_DQ0_DEL",
        "Write dq0 delay fine-tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ1_DEL",
        "Write dq1 delay fine-tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ2_DEL",
        "Write dq2 delay fine-tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ3_DEL",
        "Write dq3 delay fine-tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ4_DEL",
        "Write dq4 delay fine-tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ5_DEL",
        "Write dq5 delay fine-tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ6_DEL",
        "Write dq6 delay fine-tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ7_DEL",
        "Write dq7 delay fine-tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM0_DEL",
        "Write dm0 delay fine-tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY1DL.
static const field_t hw_mmdc_mpwrdqby1dl[] =
{
    {
        "WR_DQ8_DEL",
        "Write dq8 delay fine-tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ9_DEL",
        "Write dq9 delay fine-tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ10_DEL",
        "Write dq10 delay fine-tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ11_DEL",
        "Write dq11 delay fine-tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ12_DEL",
        "Write dq12 delay fine-tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ13_DEL",
        "Write dq13 delay fine-tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ14_DEL",
        "Write dq14 delay fine-tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ15_DEL",
        "Write dq15 delay fine-tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM1_DEL",
        "Write dm1 delay fine-tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY2DL.
static const field_t hw_mmdc_mpwrdqby2dl[] =
{
    {
        "WR_DQ16_DEL",
        "Write dq16 delay fine tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ17_DEL",
        "Write dq17 delay fine tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ18_DEL",
        "Write dq18 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ19_DEL",
        "Write dq19 delay fine tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ20_DEL",
        "Write dq20 delay fine tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ21_DEL",
        "Write dq21 delay fine tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ22_DEL",
        "Write dq22 delay fine tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ23_DEL",
        "Write dq23 delay fine tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM2_DEL",
        "Write dm2 delay fine-tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY3DL.
static const field_t hw_mmdc_mpwrdqby3dl[] =
{
    {
        "WR_DQ24_DEL",
        "Write dq24 delay fine tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ25_DEL",
        "Write dq25 delay fine tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ26_DEL",
        "Write dq26 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ27_DEL",
        "Write dq27 delay fine tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ28_DEL",
        "Write dq28 delay fine tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ29_DEL",
        "Write dq29 delay fine tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ30_DEL",
        "Write dq30 delay fine tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ31_DEL",
        "Write dq31 delay fine tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM3_DEL",
        "Write dm3 delay fine tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL0.
static const field_t hw_mmdc_mpdgctrl0[] =
{
    {
        "DG_DL_ABS_OFFSET0",
        "Absolute read DQS gating delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL0",
        "Read DQS gating half cycles delay for Byte0  (Channel 0 register) and "
        "Byte4 in 64-bit mode (Channel 1 register) .",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_ERR",
        "HW DQS gating error.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_ABS_OFFSET1",
        "Absolute read DQS gating delay offset for Byte1.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_EXT_UP",
        "DG extend upper boundary.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL1",
        "Read DQS gating half cycles delay for Byte1 (channel 0 register) and B"
        "yte5 in 64-bit mode (channel 1 register) .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_EN",
        "Enable automatic read DQS gating calibration.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DIS",
        "Read DQS gating disable.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_CMP_CYC",
        "Read DQS gating sample cycle.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RST_RD_FIFO",
        "Reset Read Data FIFO and associated pointers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL1.
static const field_t hw_mmdc_mpdgctrl1[] =
{
    {
        "DG_DL_ABS_OFFSET2",
        "Absolute read DQS gating delay offset for Byte2.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL2",
        "Read DQS gating half cycles delay for Byte2 (Channel 0 register) and B"
        "yte6 for 64-bit mode(channel 1 register) .",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DL_ABS_OFFSET3",
        "Absolute read DQS gating delay offset for Byte3.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL3",
        "Read DQS gating half cycles delay for Byte3 (Channel 0 register) and B"
        "yte7 for 64-bit data (Channel 1 register) .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGDLST0.
static const field_t hw_mmdc_mpdgdlst0[] =
{
    {
        "DG_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLCTL.
static const field_t hw_mmdc_mprddlctl[] =
{
    {
        "RD_DL_ABS_OFFSET0",
        "Absolute read delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET1",
        "Absolute read delay offset for Byte1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET2",
        "Absolute read delay offset for Byte2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET3",
        "Absolute read delay offset for Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLST.
static const field_t hw_mmdc_mprddlst[] =
{
    {
        "RD_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLCTL.
static const field_t hw_mmdc_mpwrdlctl[] =
{
    {
        "WR_DL_ABS_OFFSET0",
        "Absolute write delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET1",
        "Absolute write delay offset for Byte1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET2",
        "Absolute write delay offset for Byte2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET3",
        "Absolute write delay offset for Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLST.
static const field_t hw_mmdc_mpwrdlst[] =
{
    {
        "WR_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSDCTRL.
static const field_t hw_mmdc_mpsdctrl[] =
{
    {
        "SDCLK0_DEL",
        "DDR clock0 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQLP2CTL.
static const field_t hw_mmdc_mpzqlp2ctl[] =
{
    {
        "ZQ_LP2_HW_ZQINIT",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a Init ZQ calibration.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCL",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a long ZQ calibration.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCS",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a Short ZQ calibration.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWCTL.
static const field_t hw_mmdc_mprddlhwctl[] =
{
    {
        "HW_RD_DL_ERR0",
        "Automatic (HW) read calibration error of Byte0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR1",
        "Automatic (HW) read calibration error of Byte1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR2",
        "Automatic (HW) read calibration error of Byte2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR3",
        "Automatic (HW) read calibration error of Byte3.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_EN",
        "Enable automatic (HW) read calibration.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_RD_DL_CMP_CYC",
        "Automatic (HW) read sample cycle.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWCTL.
static const field_t hw_mmdc_mpwrdlhwctl[] =
{
    {
        "HW_WR_DL_ERR0",
        "Automatic (HW) write calibration error of Byte0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR1",
        "Automatic (HW) write calibration error of Byte1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR2",
        "Automatic (HW) write calibration error of Byte2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR3",
        "Automatic (HW) write calibration error of Byte3.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_EN",
        "Enable automatic (HW) write calibration.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_WR_DL_CMP_CYC",
        "Write sample cycle.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST0.
static const field_t hw_mmdc_mprddlhwst0[] =
{
    {
        "HW_RD_DL_LOW0",
        "Automatic (HW) read calibration result of the lower boundary of Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP0",
        "Automatic (HW) read calibration result of the upper boundary of Byte0.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW1",
        "Automatic (HW) read calibration result of the lower boundary of Byte1.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP1",
        "Automatic (HW) read calibration result of the upper boundary of Byte1.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST1.
static const field_t hw_mmdc_mprddlhwst1[] =
{
    {
        "HW_RD_DL_LOW2",
        "Automatic (HW) read calibration result of the lower boundary of Byte2.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP2",
        "Automatic (HW) read calibration result of the upper boundary of Byte2.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW3",
        "Automatic (HW) read calibration result of the lower boundary of Byte3.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP3",
        "Automatic (HW) read calibration result of the upper boundary of Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST0.
static const field_t hw_mmdc_mpwrdlhwst0[] =
{
    {
        "HW_WR_DL_LOW0",
        "Automatic (HW) write calibration result of the lower boundary of Byte0"
        ".",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP0",
        "Automatic (HW) write calibration result of the upper boundary of Byte0"
        ".",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW1",
        "Automatic (HW) write calibration result of the lower boundary of Byte1"
        ".",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP1",
        "Aautomatic (HW) write utomatic (HW) write calibration result of the up"
        "per boundary of Byte1.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST1.
static const field_t hw_mmdc_mpwrdlhwst1[] =
{
    {
        "HW_WR_DL_LOW2",
        "Automatic (HW) write calibration result of the lower boundary of Byte2"
        ".",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP2",
        "Automatic (HW) write calibration result of the upper boundary of Byte2"
        ".",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW3",
        "Automatic (HW) write calibration result of the lower boundary of Byte3"
        ".",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP3",
        "Automatic (HW) write calibration result of the upper boundary of Byte3"
        ".",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLHWERR.
static const field_t hw_mmdc_mpwlhwerr[] =
{
    {
        "HW_WL0_DQ",
        "HW write-leveling calibration result of Byte0.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL1_DQ",
        "HW write-leveling calibration result of Byte1.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL2_DQ",
        "HW write-leveling calibration result of Byte2.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL3_DQ",
        "HW write-leveling calibration result of Byte3.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST0.
static const field_t hw_mmdc_mpdghwst0[] =
{
    {
        "HW_DG_LOW0",
        "HW DQS gating calibration result of the lower boundary of Byte0.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP0",
        "HW DQS gating calibration result of the upper boundary of Byte0.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST1.
static const field_t hw_mmdc_mpdghwst1[] =
{
    {
        "HW_DG_LOW1",
        "HW DQS gating calibration result of the lower boundary of Byte1.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP1",
        "HW DQS gating calibration result of the upper boundary of Byte1.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST2.
static const field_t hw_mmdc_mpdghwst2[] =
{
    {
        "HW_DG_LOW2",
        "HW DQS gating calibration result of the lower boundary of Byte2.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP2",
        "HW DQS gating calibration result of the upper boundary of Byte2.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST3.
static const field_t hw_mmdc_mpdghwst3[] =
{
    {
        "HW_DG_LOW3",
        "HW DQS gating calibration result of the lower boundary of Byte3.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP3",
        "HW DQS gating calibration result of the upper boundary of Byte3.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR1.
static const field_t hw_mmdc_mppdcmpr1[] =
{
    {
        "PDV1",
        "MMDC Pre defined comapre value2.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDV2",
        "MMDC Pre defined comapre value2.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR2.
static const field_t hw_mmdc_mppdcmpr2[] =
{
    {
        "MPR_CMP",
        "MPR(DDR3)/DQ calibration (LPDDR2) comapre enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPR_FULL_CMP",
        "MPR(DDR3)/DQ calibration (LPDDR2) full compare enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_LEVEL_PATTERN",
        "MPR(DDR3)/DQ calibration(LPDDR2) read compare pattern.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CA_DL_ABS_OFFSET",
        "Absolute CA (Command/Address of LPDDRR2) offset.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_CA_DL_UNIT",
        "This field reflects the number of delay units that are actually used b"
        "y CA (Command/Address of LPDDR2) delay-line",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDAR0.
static const field_t hw_mmdc_mpswdar0[] =
{
    {
        "SW_DUMMY_WR",
        "SW dummy write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUMMY_RD",
        "SW dummy read.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUM_CMP0",
        "SW dummy read byte0 compare results.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP1",
        "SW dummy read byte1 compare results.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP2",
        "SW dummy read byte2 compare results.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP3",
        "SW dummy read byte3 compare results.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR0.
static const field_t hw_mmdc_mpswdrdr0[] =
{
    {
        "DUM_RD0",
        "Dummy read data0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR1.
static const field_t hw_mmdc_mpswdrdr1[] =
{
    {
        "DUM_RD1",
        "Dummy read data1.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR2.
static const field_t hw_mmdc_mpswdrdr2[] =
{
    {
        "DUM_RD2",
        "Dummy read data2.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR3.
static const field_t hw_mmdc_mpswdrdr3[] =
{
    {
        "DUM_RD3",
        "Dummy read data3.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR4.
static const field_t hw_mmdc_mpswdrdr4[] =
{
    {
        "DUM_RD4",
        "Dummy read data4.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR5.
static const field_t hw_mmdc_mpswdrdr5[] =
{
    {
        "DUM_RD5",
        "Dummy read data5.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR6.
static const field_t hw_mmdc_mpswdrdr6[] =
{
    {
        "DUM_RD6",
        "Dummy read data6.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR7.
static const field_t hw_mmdc_mpswdrdr7[] =
{
    {
        "DUM_RD7",
        "Dummy read data7.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPMUR0.
static const field_t hw_mmdc_mpmur0[] =
{
    {
        "MU_BYP_VAL",
        "Number of delay units for measurement bypass.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_BYP_EN",
        "Measure unit bypass enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_MSR",
        "Force measuement on delay-lines.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_UNIT_DEL_NUM",
        "Number of delay units measured per cycle.",
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRCADL.
static const field_t hw_mmdc_mpwrcadl[] =
{
    {
        "WR_CA0_DEL",
        "CA (Command/Address LPDDR2 bus) bit 0 delay fine tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA1_DEL",
        "CA (Command/Address LPDDR2 bus) bit 1 delay fine tuning.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA2_DEL",
        "CA (Command/Address LPDDR2 bus) bit 2 delay fine tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA3_DEL",
        "CA (Command/Address LPDDR2 bus) bit 3 delay fine tuning.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA4_DEL",
        "CA (Command/Address LPDDR2 bus) bit 4 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA5_DEL",
        "CA (Command/Address LPDDR2 bus) bit 5 delay fine tuning.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA6_DEL",
        "CA (Command/Address LPDDR2 bus) bit 6 delay fine tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA7_DEL",
        "CA (Command/Address LPDDR2 bus) bit 7 delay fine tuning.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA8_DEL",
        "CA (Command/Address LPDDR2 bus) bit 8 delay fine tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA9_DEL",
        "CA (Command/Address LPDDR2 bus) bit 9 delay fine tuning.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDCCR.
static const field_t hw_mmdc_mpdccr[] =
{
    {
        "WR_DQS0_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte0.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS1_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte1.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS2_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte1.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS3_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte0.",
        9, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CK_FT0_DCC",
        "Primary duty cycle fine tuning control of DDR clock.",
        12, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CK_FT1_DCC",
        "Secondary duty cycle fine tuning control of DDR clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS0_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte0.",
        19, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS1_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte1.",
        22, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS2_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte2.",
        25, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS3_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte3.",
        28, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a MMDC module.
static const reg_t hw_mmdc[] =
{
    {
        "MDCTL",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdctl
    },
    {
        "MDPDC",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32   PRCT field encoding        PRCT[2:0]    Prechar"
        "ge Timer        000    Disabled (Bit field reset value)      001    2 "
        "clocks      010    4 clocks      011    8 clocks      100    16 clocks"
        "      101    32 clocks      110    64 clocks      111    128 clocks   "
        "      PWDT field encoding        PWDT[3:0]    Power Down Time-out     "
        "   0000    Disabled (bit field reset value)      0001    16 cycles    "
        "  0010    32 cycles      0011    64 cycles      0100    128 cycles    "
        "  0101    256 cycles      0110    512 cycles      0111    1024 cycles "
        "     1000    2048 cycles      1001    4096 cycles      1010    8196 cy"
        "cles      1011    16384 cycles      1100    32768 cycles      1101-111"
        "1    Reserved",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdpdc
    },
    {
        "MDOTC",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32  For further information see .",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdotc
    },
    {
        "MDCFG0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdcfg0
    },
    {
        "MDCFG1",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mdcfg1
    },
    {
        "MDCFG2",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg2
    },
    {
        "MDMISC",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_mmdc_mdmisc
    },
    {
        "MDSCR",
        "This register is used to issue special commands manually toward the ex"
        "ternal DDR device (such as load mode register, manual self refresh, ma"
        "nual precharge and so on).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdscr
    },
    {
        "MDREF",
        "This register determines the refresh scheme that will be executed towa"
        "rd the DDR device.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdref
    },
    {
        "MDRWD",
        "This register determines the delay between back to back read and write"
        " accesses.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdrwd
    },
    {
        "MDOR",
        "This register defines delays that must be kept when MMDC exits reset.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mdor
    },
    {
        "MDMRR",
        "This register contains data that was collected after issuing MRR comma"
        "nd.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mdmrr
    },
    {
        "MDCFG3LP",
        "This register is relevant only for LPDDR2 mode.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg3lp
    },
    {
        "MDMR4",
        "This register is relevant only for LPDDR2 mode.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mdmr4
    },
    {
        "MDASP",
        "This register defines the partitioning between chip select 0 and chip "
        "select 1.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_mdasp
    },
    {
        "MAARCR",
        "This register determines the values of the weights used for the re-ord"
        "ering arbitration engine.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_maarcr
    },
    {
        "MAPSR",
        "The MAPSR determines the power saving features of MMDC.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mapsr
    },
    {
        "MAEXIDR0",
        "This register defines the ID to be monitored for exclusive accesses of"
        " monitor0 and monitor1.",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr0
    },
    {
        "MAEXIDR1",
        "This register defines the ID to be monitored for exclusive accesses of"
        " monitor2 and monitor3.",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr1
    },
    {
        "MADPCR0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_madpcr0
    },
    {
        "MADPCR1",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_madpcr1
    },
    {
        "MADPSR0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr0
    },
    {
        "MADPSR1",
        "The register reflects the total cycles during which the MMDC state mac"
        "hines were busy (both writes and reads).",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr1
    },
    {
        "MADPSR2",
        "This register reflects the total number of read accesses (per AXI ID) "
        "toward MMDC.",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr2
    },
    {
        "MADPSR3",
        "This register reflects the total number of write accesses (per AXI ID)"
        " toward MMDC.",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr3
    },
    {
        "MADPSR4",
        "This register reflects the total number of bytes that were transferred"
        " during read access (per AXI ID) toward MMDC.",
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr4
    },
    {
        "MADPSR5",
        "This register reflects the total number of bytes that were transferred"
        " during write access (per AXI ID) toward MMDC.",
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr5
    },
    {
        "MASBS0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_masbs0
    },
    {
        "MASBS1",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_mmdc_masbs1
    },
    {
        "MAGENP",
        "This register is a general 32 bit read/write register.",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_magenp
    },
    {
        "MPZQHWCTRL",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: This"
        " register is reserved for channel 1.",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpzqhwctrl
    },
    {
        "MPZQSWCTRL",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: This"
        " register is reserved.",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mpzqswctrl
    },
    {
        "MPWLGCR",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_mmdc_mpwlgcr
    },
    {
        "MPWLDECTRL0",
        "Supported Mode OF Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwldectrl0
    },
    {
        "MPWLDECTRL1",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x32",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwldectrl1
    },
    {
        "MPWLDLST",
        "This register holds the status of the four write leveling delay-lines.",
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwldlst
    },
    {
        "MPODTCTRL",
        "In LPDDR2 mode this register should be cleared, so no termination will"
        " be activated  Supported Mode Of Operations:  For Channel 0: DDR3_x16,"
        " DDR3_x32, DDR3_x64  For Channel 1: DDR3_x64",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mpodtctrl
    },
    {
        "MPRDDQBY0DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte0 relative to the read DQS.",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby0dl
    },
    {
        "MPRDDQBY1DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte1 relative to the read DQS  Supported Mode Of Operations"
        ":  For Channel 0: All  For Channel 1: DDR3_x64, LP2_2ch_x16, LP2_2ch_x"
        "32",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby1dl
    },
    {
        "MPRDDQBY2DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte2 relative to the read DQS  Supported Mode Of Operations"
        ":  For Channel 0: All  For Channel 1: DDR3_x64, LP2_2ch_x32",
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby2dl
    },
    {
        "MPRDDQBY3DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte3 relative to the read DQS.",
        4, // Width in bytes
        0x00000828, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby3dl
    },
    {
        "MPWRDQBY0DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte0 relative to the write DQS  Supported Mode Of Operatio"
        "ns:  For Channel 0: All  For Channel 1: DDR3_x64, LP2_2ch_x16, LP2_2ch"
        "_x32",
        4, // Width in bytes
        0x0000082c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby0dl
    },
    {
        "MPWRDQBY1DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte1 relative to the write DQS  Supported Mode Of Operatio"
        "ns:  For Channel 0: All  For Channel 1: DDR3_x64, LP2_2ch_x16, LP2_2ch"
        "_x32",
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby1dl
    },
    {
        "MPWRDQBY2DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte2 relative to the write DQS  Supported Mode Of Operatio"
        "ns:  For Channel 0: All  For Channel 1: DDR3_x64, LP2_2ch_x32",
        4, // Width in bytes
        0x00000834, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby2dl
    },
    {
        "MPWRDQBY3DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte3 relative to the write DQS  Supported Mode Of Operatio"
        "ns:  For Channel 0: All  For Channel 1: DDR3_x64, LP2_2ch_x32",
        4, // Width in bytes
        0x00000838, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby3dl
    },
    {
        "MPDGCTRL0",
        "Supported Mode Of Operations:  For Channel 0: DDR3_x16, DDR3_x32, DDR3"
        "_x64  For Channel 1: DDR3_x64",
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdgctrl0
    },
    {
        "MPDGCTRL1",
        "Supported Mode Of Operations:  For Channel 0: DDR3_x16, DDR3_x32, DDR3"
        "_x64  For Channel 1: DDR3_x64",
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpdgctrl1
    },
    {
        "MPDGDLST0",
        "This register holds the status of the 4 dqs gating delay-lines.",
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpdgdlst0
    },
    {
        "MPRDDLCTL",
        "This register controls read delay-lines functionality; it determines D"
        "QS delay relative to the associated DQ read access.",
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlctl
    },
    {
        "MPRDDLST",
        "This register holds the status of the 4 read delay-lines.",
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlst
    },
    {
        "MPWRDLCTL",
        "This register controls write delay-lines functionality, it determines "
        "DQ/DM delay relative to the associated DQS in write access.",
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlctl
    },
    {
        "MPWRDLST",
        "This register holds the status of the 4 write delay-line.",
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlst
    },
    {
        "MPSDCTRL",
        "This register controls the fine tuning of the primary clock (CK0).",
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_mpsdctrl
    },
    {
        "MPZQLP2CTL",
        "This register controls the idle time that takes the LPDDR2 device to p"
        "erform ZQ calibration  Supported Mode Of Operations:  For Channel 0: L"
        "P2_2ch_x16, LP2_2ch_x32  For Channel 1: LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mpzqlp2ctl
    },
    {
        "MPRDDLHWCTL",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mprddlhwctl
    },
    {
        "MPWRDLHWCTL",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwrdlhwctl
    },
    {
        "MPRDDLHWST0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst0
    },
    {
        "MPRDDLHWST1",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x0000086c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst1
    },
    {
        "MPWRDLHWST0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst0
    },
    {
        "MPWRDLHWST1",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x32",
        4, // Width in bytes
        0x00000874, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst1
    },
    {
        "MPWLHWERR",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000878, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwlhwerr
    },
    {
        "MPDGHWST0",
        "Supported Mode Of Operations:  For Channel 0: DDR3_x16, DDR3_x32, DDR3"
        "_x64  For Channel 1: DDR3_x64",
        4, // Width in bytes
        0x0000087c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst0
    },
    {
        "MPDGHWST1",
        "Supported Mode Of Operations:  For Channel 0: DDR3_x16, DDR3_x32, DDR3"
        "_x64  For Channel 1: DDR3_x64",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst1
    },
    {
        "MPDGHWST2",
        "Supported Mode Of Operations:  For Channel 0: DDR3_x16, DDR3_x32, DDR3"
        "_x64  For Channel 1: DDR3_x64",
        4, // Width in bytes
        0x00000884, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst2
    },
    {
        "MPDGHWST3",
        "Supported Mode Of Operations:  For Channel 0: DDR3_x16, DDR3_x32, DDR3"
        "_x64  For Channel 1: DDR3_x64",
        4, // Width in bytes
        0x00000888, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst3
    },
    {
        "MPPDCMPR1",
        "This register holds the MMDC pre-defined compare value that will be us"
        "ed during automatic read, read DQS gating and write calibration proces"
        "s.",
        4, // Width in bytes
        0x0000088c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mppdcmpr1
    },
    {
        "MPPDCMPR2",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_mmdc_mppdcmpr2
    },
    {
        "MPSWDAR0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000894, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpswdar0
    },
    {
        "MPSWDRDR0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x00000898, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr0
    },
    {
        "MPSWDRDR1",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x0000089c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr1
    },
    {
        "MPSWDRDR2",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr2
    },
    {
        "MPSWDRDR3",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x000008a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr3
    },
    {
        "MPSWDRDR4",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x000008a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr4
    },
    {
        "MPSWDRDR5",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x000008ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr5
    },
    {
        "MPSWDRDR6",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x000008b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr6
    },
    {
        "MPSWDRDR7",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: DDR3"
        "_x64, LP2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x000008b4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr7
    },
    {
        "MPMUR0",
        "Supported Mode Of Operations:  For Channel 0: All  For Channel 1: LP2_"
        "2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x000008b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpmur0
    },
    {
        "MPWRCADL",
        "This register is used to add fine-tuning adjustment to the CA (command"
        "/Address of LPDDR2 bus) relative to the DDR clock  Supported Mode Of O"
        "perations:  For Channel 0: LP2_2ch_x16, LP2_2ch_x32  For Channel 1: LP"
        "2_2ch_x16, LP2_2ch_x32",
        4, // Width in bytes
        0x000008bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpwrcadl
    },
    {
        "MPDCCR",
        "This register is used to control the duty cycle of the DQS and the pri"
        "mary clock (CK0) .",
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark OCOTP
#endif

// Bitfields in register OCOTP_CTRL.
static const field_t hw_ocotp_ctrl[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_TIMING.
static const field_t hw_ocotp_timing[] =
{
    {
        "STROBE_PROG",
        "This count value specifies the strobe period in one time write OTP.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELAX",
        "This count value specifies the time to add to all default timing param"
        "eters other than the Tpgm and Trd.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_READ",
        "This count value specifies the strobe period in one time read OTP.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT",
        "This count value specifies time interval between auto read and write a"
        "ccess in one time program.",
        22, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DATA.
static const field_t hw_ocotp_data[] =
{
    {
        "DATA",
        "Used to initiate a write to OTP.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_READ_CTRL.
static const field_t hw_ocotp_read_ctrl[] =
{
    {
        "READ_FUSE",
        "Used to initiate a read to OTP.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_READ_FUSE_DATA.
static const field_t hw_ocotp_read_fuse_data[] =
{
    {
        "DATA",
        "The data read from OTP",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_STICKY.
static const field_t hw_ocotp_sw_sticky[] =
{
    {
        "SRK_REVOKE_LOCK",
        "Shadow register write and OTP write lock for SRK_REVOKE, MC_ERA and AP"
        "_BI_VER regions.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_RETURN_LOCK",
        "Shadow register write and OTP write lock for FIELD_RETURN region.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS.
static const field_t hw_ocotp_scs[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_VERSION.
static const field_t hw_ocotp_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_LOCK.
static const field_t hw_ocotp_lock[] =
{
    {
        "TESTER",
        "Status of shadow register and OTP write lock for tester region.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG",
        "Status of shadow register and OTP write lock for boot_cfg region.",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEM_TRIM",
        "Status of shadow register and OTP write lock for mem_trim region.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SJC_RESP",
        "Status of shadow register read and write, OTP read and write lock for "
        "sjc_resp region.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAC_ADDR",
        "Status of shadow register and OTP write lock for mac_addr region.",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP1",
        "Status of shadow register and OTP write lock for gp2 region.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP2",
        "Status of shadow register and OTP write lock for gp2 region.",
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRK",
        "Status of shadow register and OTP write lock for srk region.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ANALOG",
        "Status of shadow register and OTP write lock for analog region.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MISC_CONF",
        "Status of shadow register and OTP write lock for misc_conf region.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNALLOCATED",
        "Value of un-used portion of LOCK word",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG0.
static const field_t hw_ocotp_cfg0[] =
{
    {
        "BITS",
        "This register contains 32 bits of the Unique ID and SJC_CHALLENGE fiel"
        "d.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG1.
static const field_t hw_ocotp_cfg1[] =
{
    {
        "BITS",
        "This register contains 32 bits of the Unique ID and SJC_CHALLENGE fiel"
        "d.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG2.
static const field_t hw_ocotp_cfg2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 3 (ADDR = 0x03).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG3.
static const field_t hw_ocotp_cfg3[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 4 (ADDR = 0x04).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG4.
static const field_t hw_ocotp_cfg4[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 5 (ADDR = 0x05).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG5.
static const field_t hw_ocotp_cfg5[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 6 (ADDR = 0x06).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG6.
static const field_t hw_ocotp_cfg6[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 7 (ADDR = 0x07).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM0.
static const field_t hw_ocotp_mem0[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 0 (ADDR = 0x08).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM1.
static const field_t hw_ocotp_mem1[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 1 (ADDR = 0x09).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM2.
static const field_t hw_ocotp_mem2[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 2 (ADDR = 0x0A).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM3.
static const field_t hw_ocotp_mem3[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 3 (ADDR = 0x0B).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM4.
static const field_t hw_ocotp_mem4[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 4 (ADDR = 0x0C).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA0.
static const field_t hw_ocotp_ana0[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 5 (ADDR = 0x0D).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA1.
static const field_t hw_ocotp_ana1[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 6 (ADDR = 0x0E).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA2.
static const field_t hw_ocotp_ana2[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 7 (ADDR = 0x0F).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK0.
static const field_t hw_ocotp_srk0[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word0 (Copy of OTP "
        "Bank 3, word 0 (ADDR = 0x1C)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK1.
static const field_t hw_ocotp_srk1[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word1 (Copy of OTP "
        "Bank 3, word 1 (ADDR = 0x1D)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK2.
static const field_t hw_ocotp_srk2[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word2 (Copy of OTP "
        "Bank 3, word 2 (ADDR = 0x1E)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK3.
static const field_t hw_ocotp_srk3[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word3 (Copy of OTP "
        "Bank 3, word 3 (ADDR = 0x1F)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK4.
static const field_t hw_ocotp_srk4[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word4 (Copy of OTP "
        "Bank 3, word 4 (ADDR = 0x20)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK5.
static const field_t hw_ocotp_srk5[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word5 (Copy of OTP "
        "Bank 3, word 5 (ADDR = 0x21)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK6.
static const field_t hw_ocotp_srk6[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word6 (Copy of OTP "
        "Bank 3, word 6 (ADDR = 0x22)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK7.
static const field_t hw_ocotp_srk7[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word7 (Copy of OTP "
        "Bank 3, word 7 (ADDR = 0x23)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_RESP0.
static const field_t hw_ocotp_resp0[] =
{
    {
        "BITS",
        "Shadow register for the SJC_RESP Key word0 (Copy of OTP Bank 4, word 0"
        " (ADDR = 0x20)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_HSJC_RESP1.
static const field_t hw_ocotp_hsjc_resp1[] =
{
    {
        "BITS",
        "Shadow register for the SJC_RESP Key word1 (Copy of OTP Bank 4, word 1"
        " (ADDR = 0x21)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC0.
static const field_t hw_ocotp_mac0[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 2 (ADDR = 0x22).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC1.
static const field_t hw_ocotp_mac1[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 3 (ADDR = 0x23).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP1.
static const field_t hw_ocotp_gp1[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 6 (ADDR = 0x26).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP2.
static const field_t hw_ocotp_gp2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 7 (ADDR = 0x27).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MISC_CONF.
static const field_t hw_ocotp_misc_conf[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 5 (ADDR = 0x2d).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_FIELD_RETURN.
static const field_t hw_ocotp_field_return[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 6 (ADDR = 0x2e).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK_REVOKE.
static const field_t hw_ocotp_srk_revoke[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 7 (ADDR = 0x2f).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a OCOTP module.
static const reg_t hw_ocotp[] =
{
    {
        "CTRL",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 The OCOTP Control and Status Register provides the necessary"
        " software interface for performing read and write operations to the On"
        "-Chip OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ocotp_ctrl
    },
    {
        "TIMING",
        "The OCOTP Data Register is used for OTP Programming This register spec"
        "ifies timing parameters for programming and reading the OCOTP fuse arr"
        "ay.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ocotp_timing
    },
    {
        "DATA",
        "The OCOTP Data Register is used for OTP Programming This register is u"
        "sed in conjuction with HW_OCOTP_CTRL to perform one-time writes to the"
        " OTP.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_data
    },
    {
        "READ_CTRL",
        "The OCOTP Register is used for OTP Read This register is used in conju"
        "ction with HW_OCOTP_CTRL to perform one time read to the OTP.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_read_ctrl
    },
    {
        "READ_FUSE_DATA",
        "The OCOTP Data Register is used for OTP Read The data read from OTP EX"
        "AMPLE Empty Example.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_read_fuse_data
    },
    {
        "SW_STICKY",
        "Some SW sticky bits .",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ocotp_sw_sticky
    },
    {
        "SCS",
        "HW_OCOTP_SCS: 0x060 This register holds volatile configuration values "
        "that can be set and locked by trusted software.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs
    },
    {
        "VERSION",
        "This register always returns a known read value for debug purposes it "
        "indicates the version of the block.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_ocotp_version
    },
    {
        "LOCK",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        11, // Number of bitfields
        hw_ocotp_lock
    },
    {
        "CFG0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg0
    },
    {
        "CFG1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg1
    },
    {
        "CFG2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg2
    },
    {
        "CFG3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg3
    },
    {
        "CFG4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg4
    },
    {
        "CFG5",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg5
    },
    {
        "CFG6",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg6
    },
    {
        "MEM0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem0
    },
    {
        "MEM1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem1
    },
    {
        "MEM2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem2
    },
    {
        "MEM3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem3
    },
    {
        "MEM4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem4
    },
    {
        "ANA0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana0
    },
    {
        "ANA1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana1
    },
    {
        "ANA2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana2
    },
    {
        "SRK0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk0
    },
    {
        "SRK1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk1
    },
    {
        "SRK2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk2
    },
    {
        "SRK3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk3
    },
    {
        "SRK4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk4
    },
    {
        "SRK5",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk5
    },
    {
        "SRK6",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk6
    },
    {
        "SRK7",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk7
    },
    {
        "RESP0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_resp0
    },
    {
        "HSJC_RESP1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_hsjc_resp1
    },
    {
        "MAC0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac0
    },
    {
        "MAC1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac1
    },
    {
        "GP1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp1
    },
    {
        "GP2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp2
    },
    {
        "MISC_CONF",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_misc_conf
    },
    {
        "FIELD_RETURN",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_field_return
    },
    {
        "SRK_REVOKE",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk_revoke
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PCIE
#endif

// Bitfields in register PCIE_DEVICEID.
static const field_t hw_pcie_deviceid[] =
{
    { 0 } // Terminator
};

// Bitfields in register PCIE_COMMAND.
static const field_t hw_pcie_command[] =
{
    {
        "I_O_SPACE_ENABLE",
        "I/O Space Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEMORY_SPACE_ENABLE",
        "Memory Space Enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUS_MASTER_ENABLE",
        "Bus Master Enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPECIAL_CYCLE_ENABLE",
        "Special Cycle Enable  Not applicable for PCI Express.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEMORY_WRITE_AND_INVALIDATE",
        "Memory Write and Invalidate  Not applicable for PCI Express.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VGA_PALETTE_SNOOP",
        "VGA Palette Snoop  Not applicable for PCI Express.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARITY_ERROR_RESPONSE",
        "Parity Error Response",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDSEL_STEPPING",
        "IDSEL Stepping/Wait Cycle Control  Not applicable for PCI Express.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SERR_ENABLE",
        "SERR# Enable",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FAST_BACK_TO_BACK_ENABLE",
        "Fast Back-to-Back Enable  Not applicable for PCI Express.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTX_ASSERTION_DISABLE",
        "INTx Assertion Disable",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTX_STATUS",
        "INTx Status",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAPABILITIES_LIST",
        "Capabilities List  Indicates presence of an extended capability item.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIXTYSIX_MHZ_CAPABLE",
        "66 MHz Capable  Not applicable for PCI Express.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FAST_BACK_TO_BACK_CAPABLE",
        "Fast Back-to-Back Capable  Not applicable for PCI Express.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASTER_DATA_PARITY_ERROR",
        "Master Data Parity Error",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVSEL_TIMING",
        "DEVSEL Timing  Not applicable for PCI Express.",
        25, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIGNALED_TARGET_ABORT",
        "Signaled Target Abort",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECEIVED_TARGET_ABORT",
        "Received Target Abort",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECEIVED_MASTER_ABORT",
        "Received Master Abort",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DETECTED_PARITY_ERROR",
        "Detected Parity Error",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIGNALED_SYSTEM_ERROR",
        "Signaled System Error",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_REVID.
static const field_t hw_pcie_revid[] =
{
    {
        "CX_REVISION_ID_N",
        "Revision ID, writable through the DBI",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IF_CODE_N",
        "Programming Interface, writable through the DBI",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SUB_CLASS_CODE_N",
        "Subclass Code, writable through the DBI",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BASE_CLASS_CODE_N",
        "Base Class Code, writable through the DBI",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_BIST.
static const field_t hw_pcie_bist[] =
{
    {
        "CACHE_LINE_SIZE",
        "Cache Line Size  The Cache Line Size register is RW for legacy compati"
        "bility purposes and is not applicable to PCI Express device functional"
        "ity.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASTER_LATENCY_TIMER",
        "Master Latency Timer  Not applicable for PCI Express, hardwired to 0.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONFIGURATION_HEADER_FORMAT",
        "Configuration Header Format  Hardwired to 0 for type 0.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULTI_FUNCTION_DEVICE",
        "Multi Function Device  The default value is 0 (single function device)"
        ".",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NOT_SUPPORTED_BY__CORE",
        "The BIST register functions are not supported by the core.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_BAR0.
static const field_t hw_pcie_bar0[] =
{
    {
        "MEM_I_O",
        "Bits [3:0] are writable through the DBI.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TYPE",
        "If BAR 0 is an I/O BAR, bit 2 the least significant bit of the base ad"
        "dress and bit 1 is 0.",
        1, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PREF",
        "If BAR 0 is an I/O BAR, bit 3 is the second least significant bit of t"
        "he base address.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDRESS",
        "BAR 0 base address bits (for a 64-bit BAR, the remaining upper address"
        " bits are in BAR 1).",
        4, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_BAR1.
static const field_t hw_pcie_bar1[] =
{
    {
        "ADDRESS",
        "BAR 1 contains the upper 32 bits of the  BAR 0 base address (bits [63:"
        "32]).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_BAR2.
static const field_t hw_pcie_bar2[] =
{
    {
        "MEM_I_O",
        "Bits [3:0] are writable through the DBI.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TYPE",
        "If BAR 2 is an I/O BAR, bit 2 the least significant bit of the base ad"
        "dress and bit 1 is 0.",
        1, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PREF",
        "If BAR 2 is an I/O BAR, bit 3 is the second least significant bit of t"
        "he base address.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDRESS",
        "BAR 2 base address bits (for a 64-bit BAR, the remaining upper address"
        " bits are in BAR 3).",
        4, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_BAR3.
static const field_t hw_pcie_bar3[] =
{
    {
        "ADDRESS",
        "BAR 3 bit definitions are the same as the BAR 2 bit definitions.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_CISP.
static const field_t hw_pcie_cisp[] =
{
    {
        "CARDBUS_CIS_POINTER",
        "CardBus CIS Pointer optional, writable through the DBI reset 0x0",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_SSID.
static const field_t hw_pcie_ssid[] =
{
    { 0 } // Terminator
};

// Bitfields in register PCIE_EROMBAR.
static const field_t hw_pcie_erombar[] =
{
    {
        "ENABLE",
        "Expansion ROM Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Expansion ROM Address",
        11, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_CAPPR.
static const field_t hw_pcie_cappr[] =
{
    {
        "CFG_NEXT_PTR",
        "First Capability Pointer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_ILR.
static const field_t hw_pcie_ilr[] =
{
    {
        "INTERRUPT_LINE",
        "Interrupt Line  Value in this register is system architecture specific"
        ".",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_PIN_MAPPING_N",
        "Interrupt Pin  Identifies the legacy interrupt Message that the device"
        " (or device function) uses.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_PMCR.
static const field_t hw_pcie_pmcr[] =
{
    {
        "POWER_MANAGEMENT_CAPABILITY_ID",
        "Power Management Capability ID",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXT_CAPABILITY_POINTER",
        "Next Capability Pointer  See and .",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POWER_MANAGEMENT_SPECIFICATION_VERSION",
        "Power Management specification version, writable through the DBI",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PME_CLOCK",
        "PME Clock, hardwired to 0",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSI",
        "Device Specific Initialization (DSI), writable through the DBI",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUX_CURRENT",
        "AUX Current, writable through the DBI",
        22, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "D1_SUPPORT",
        "D1 Support, writable through the DBI",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "D2_SUPPORT",
        "D2 Support, writable through the DBI",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PME_SUPPORT",
        "PME_Support  Identifies the power states from which the core can gener"
        "ate PME Messages.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_PMCSR.
static const field_t hw_pcie_pmcsr[] =
{
    {
        "POWER_STATE",
        "Power State  The written value is ignored if the specific state is not"
        " supported.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NO_SOFT_RESET",
        "No Soft Reset, writable through the DBI",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PME_ENABLE",
        "PME Enable (sticky bit)  A value of 1 indicates that the device is ena"
        "bled to generate PME.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Data Select (not supported)",
        9, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SCALE",
        "Data Scale (not supported)",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PME_STATUS",
        "PME Status  Indicates if a previously enabled PME event occurred or no"
        "t.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "B2_B3_SUPPORT",
        "B2/B3 Support, hardwired to 0",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUS_POWER_CLOCK_CONTROL_ENABLE",
        "Bus Power/Clock Control Enable, hardwired to 0",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_REGISTER_FOR_ADDITIONAL_INFORMATION",
        "Data register for additional information  (not supported)",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_CIDR.
static const field_t hw_pcie_cidr[] =
{
    {
        "PCI_EXPRESS_CAPABILITY_ID",
        "PCI Express Capability ID",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXT_CAPABILITY_POINTER",
        "Next Capability Pointer  See Tables 5-214 and 5-215 on page 638.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PCI_EXPRESS_CAPABILITY_VERSION",
        "PCI Express Capability Version",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVICE_PORT_TYPE",
        "Device/Port Type  Indicates the specific type of this PCI Express Func"
        "tion.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLOT_IMPLEMENTED",
        "Slot Implemented, writable through the DBI",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTERRUPT_MESSAGE_NUMBER",
        "Interrupt Message Number  Updated by hardware, writable through the  D"
        "BI.",
        25, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_DCR.
static const field_t hw_pcie_dcr[] =
{
    {
        "MAX_PAYLOAD_SIZE_SUPPORTED",
        "Max_Payload_Size Supported, writable through the DBI",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHANTOM_FUNCTION_SUPPORTED",
        "Phantom Function Supported  This field is writable through the DBI.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTENDED_TAG_FIELD_SUPPORTED",
        "Extended Tag Field Supported  This bit is writable through the DBI.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPOINT_L0S_ACCEPTABLE_LATENCY",
        "Endpoint L0s Acceptable Latency  Must be 0x0 for non-Endpoint devices.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPOINT_L1_ACCEPTABLE_LATENCY",
        "Endpoint L1 Acceptable Latency  Must be 0x0 for non-Endpoint devices.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROLE_BASED_ERROR_REPORTING",
        "Role-Based Error Reporting, writable through the DBI.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAPTURED_SLOT_POWER_LIMIT_VALUE",
        "Captured Slot Power Limit Value  Upstream port only.",
        18, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAPTURED_SLOT_POWER_LIMIT_SCALE",
        "Captured Slot Power Limit Scale  Upstream port only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_DCONR.
static const field_t hw_pcie_dconr[] =
{
    {
        "CORRECTABLE_ERROR_REPORTING_ENABLE",
        "Correctable Error Reporting Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_FATAL_ERROR_REPORTING_ENABLE",
        "Non-Fatal Error Reporting Enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FATAL_ERROR_REPORTING_ENABLE",
        "Fatal Error Reporting Enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNSUPPORTED_REQUEST_REPORTING_ENABLE",
        "Unsupported Request Reporting Enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_RELAXED_ORDERING",
        "Enable Relaxed Ordering",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAX_PAYLOAD_SIZE",
        "Max_Payload_Size",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTENDED_TAG_FIELD_ENABLE",
        "Extended Tag Field Enable",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHANTOM_FUNCTION_ENABLE",
        "Phantom Function Enable",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUX_POWER_PM_ENABLE",
        "AUX Power PM Enable",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_NO_SNOOP",
        "Enable No Snoop",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAX_READ_REQUEST_SIZE",
        "Max_Read_Request_Size",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORRECTABLE_ERROR_DETECTED",
        "Correctable Error Detected  Errors are logged in this register regardl"
        "ess of whether error reporting is enabled in the Device Control regist"
        "er.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_FATAL_ERROR_DETECTED",
        "Non-Fatal Error detected  Errors are logged in this register regardles"
        "s of whether error reporting is enabled in the Device Control register"
        ".",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FATAL_ERROR_DETECTED",
        "Fatal Error Detected  Errors are logged in this register regardless of"
        " whether error reporting is enabled in the Device Control register.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNSUPPORTED_REQUEST_DETECTED",
        "Unsupported Request Detected  Errors are logged in this register regar"
        "dless of whether error reporting is enabled in the Device Control regi"
        "ster.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUX_POWER_DETECTED",
        "Aux Power Detected  From sys_aux_pwr_det input port.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRANSACTION_PENDING",
        "Transaction Pending  Hard-wired to 0.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_LCR.
static const field_t hw_pcie_lcr[] =
{
    {
        "MAX_LINK_SPEEDS",
        "Max Link Speeds  Indicates the supported maximum Link speeds of the as"
        "sociated Port.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAXIMUM_LINK_WIDTH",
        "Maximum Link Width  Writable through the DBI.",
        4, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ACTIVE_STATE_LINK_PM_SUPPORT",
        "Active State Link PM Support  The default value is the value you speci"
        "fy during core configuration, writable through the DBI.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "L0S_EXIT_LATENCY",
        "L0s Exit Latency  Writable through the DBI.",
        12, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "L1_EXIT_LATENCY",
        "L1 Exit Latency  Writable through the DBI.",
        15, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLOCK_POWER_MANAGEMENT",
        "Clock Power Management  Component can tolerate the removal of refclk v"
        "ia CLKREQ# (if supported).",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SURPRISE_DOWN_ERROR_REPORTING_CAPABLE",
        "Surprise Down Error Reporting Capable  Not supported, hardwired to 0x0"
        ".",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DATA_LINK_LAYER_ACTIVE_REPORTING_CAPABLE",
        "Data Link Layer Active Reporting Capable Hardwired to 1 for Downstream"
        " Ports and 0 for Upstream Ports.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LINK_BANDWIDTH_NOTIFICATION_CAPABILITY",
        "Link Bandwidth Notification Capability Hardwired to 1 for Downstream P"
        "orts and 0 for Upstream Ports.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PORT_NUMBER",
        "Port Number",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_LCSR.
static const field_t hw_pcie_lcsr[] =
{
    {
        "ACTIVE_STATE_LINK_PM_CONTROL",
        "Active State Link PM Control",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCB",
        "Read Completion Boundary (RCB) RC: Writable through DBI",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINK_DISABLE",
        "Link Disable  This bit is reserved for PCI Express-to-PCI/PCI-X  bridg"
        "es .",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RETRAIN_LINK",
        "Retrain Link  This bit is reserved for PCI Express-to-PCI/PCI-X  bridg"
        "es .",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMON_CLOCK_CONFIGURATION",
        "Common Clock Configuration",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTENDED_SYNCH",
        "Extended Synch",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_CLOCK_POWER_MANAGEMENT",
        "Enable Clock Power Management  Hardwired to 0 if Clock Power Managemen"
        "t is disabled in the Link Capabilities register.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HARDWARE_AUTONOMOUS_WIDTH_DISABLE",
        "Hardware Autonomous Width Disable  Not supported, hardwired to 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINK_BANDWIDTH_MANAGEMENT_INTERRUPT_ENABLE",
        "Link Bandwidth Management Interrupt Enable When set, this bit enables "
        "the generation of an interrupt to indicate that the Link Bandwidth  Ma"
        "nagement Status bit has been set.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINK_AUTONOMOUS_BANDWIDTH_INTERRUPT_ENABLE",
        "Link Autonomous Bandwidth Interrupt Enable When set, this bit enables "
        "the generation of an interrupt to indicate that the Link Autonomous  B"
        "andwidth Status bit has been set.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINK_SPEED",
        "Link Speed  Indicates the negotiated Link speed.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEGOTIATED_LINK_WIDTH",
        "Negotiated Link Width  Set automatically by hardware after Link initia"
        "lization.",
        20, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINK_TRAINING",
        "Link Training  This bit is not applicable and is reserved for Endpoint"
        "s, PCI Express to PCI/PCI-X bridges .",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOT_CLOCK_CONFIGURATION",
        "Slot Clock Configuration  Indicates that the component uses the same p"
        "hysical reference clock that the platform provides on the connector.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_LINK_LAYER_ACTIVE",
        "Data Link Layer Active  This bit must be implemented if the correspond"
        "ing Data Link Layer Link Active Reporting capability bit is implemente"
        "d.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINK_BANDWIDTH_MANAGEMENT_STATUS",
        "Link Bandwidth Management Status  This bit is set by hardware to indic"
        "ate that either of the following has occurred without the Port transit"
        "ioning through DL_Down status:  A Link retraining has completed follo"
        "wing a write of 1b to the Retrain Link bit.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINK_AUTONOMOUS_BANDWIDTH_STATUS",
        "Link Autonomous Bandwidth Status  This bit is set by hardware to indic"
        "ate that hardware has autonomously changed Link speed or width, withou"
        "t the Port transitioning through DL_Down status, for reasons other tha"
        "n to attempt to correct unreliable Link operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_SCR.
static const field_t hw_pcie_scr[] =
{
    {
        "ATTENTION_INDICATOR_PRESENT",
        "Attention Indicator Present, writable through the DBI",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POWER_CONTROLLER_PRESENT",
        "Power Controller Present, writable through the DBI",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRL_SENSOR_PRESENT",
        "MRL Sensor Present, writable through the DBI",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ATTENTION_INDICATOR_PRESENT1",
        "Attention Indicator Present, writable through the DBI",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POWER_INDICATOR_PRESENT",
        "Power Indicator Present, writable through the DBI",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOT_PLUG_SURPRISE",
        "Hot-Plug Surprise, writable through the  DBI",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOT_PLUG_CAPABLE",
        "Hot-Plug Capable, writable through the  DBI",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLOT_POWER_LIMIT_VALUE",
        "Slot Power Limit Value, writable through the DBI",
        7, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLOT_POWER_LIMIT_SCALE",
        "Slot Power Limit Scale, writable through the DBI",
        15, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELECTROMECHANICAL_INTERLOCK_PRESENT",
        "Electromechanical Interlock Present, writable through the DBI",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO_COMMAND_COMPLETE_SUPPORT",
        "No Command Complete Support, writable through the DBI",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYSICAL_SLOT_NUMBER",
        "Physical Slot Number, writable through the DBI",
        19, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_SCSR.
static const field_t hw_pcie_scsr[] =
{
    {
        "ATTENTION_BUTTON_PRESSED_ENABLE",
        "Attention Button Pressed Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER_FAULT_DETECTED_ENABLE",
        "Power Fault Detected Enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRL_SENSOR_CHANGED_ENABLE",
        "MRL Sensor Changed Enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESENCE_DETECT_CHANGED_ENABLE",
        "Presence Detect Changed Enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_COMPLETED_INTERRUPT_ENABLE",
        "Command Completed Interrupt Enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOT_PLUG_INTERRUPT_ENABLE",
        "Hot-Plug Interrupt Enable",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATTENTION_INDICATOR_CONTROL",
        "Attention Indicator Control",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER_INDICATOR_CONTROL",
        "Power Indicator Control",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER_CONTROLLER_CONTROL",
        "Power Controller Control",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELECTROMECHANICAL_INTERLOCK_CONTROL",
        "Electromechanical Interlock Control",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_LINK_LAYER_STATE_CHANGED_ENABLE",
        "Data Link Layer State Changed Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATTENTION_BUTTON_PRESSED",
        "Attention Button Pressed",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER_FAULT_DETECTED",
        "Power Fault Detected",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRL_SENSOR_CHANGED",
        "MRL Sensor Changed",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESENCE_DETECT_CHANGED",
        "Presence Detect Changed",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_COMPLETED",
        "Command Completed",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRL_SENSOR_STATE",
        "MRL Sensor State",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESENCE_DETECT_STATE",
        "Presence Detect State",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELECTROMECHANICAL_INTERLOCK_STATUS",
        "Electromechanical Interlock Status",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_LINK_LAYER_STATE_CHANGED",
        "Data Link Layer State Changed",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_RCCR.
static const field_t hw_pcie_rccr[] =
{
    {
        "SYSTEM_ERROR_ON_CORRECTABLE_ERROR_ENABLE",
        "System Error on Correctable Error Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYSTEM_ERROR_ON_NON_FATAL_ERROR_ENABLE",
        "System Error on Non-fatal Error Enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYSTEM_ERROR_ON_FATAL_ERROR_ENABLE",
        "System Error on Fatal Error Enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PME_INTERRUPT_ENABLE",
        "PME Interrupt Enable",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRS_SOFTWARE_VISIBILITY_ENABLE",
        "CRS Software Visibility Enable  Not supported, hardwired to 0x0.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRS_SOFTWARE_VISIBILITY",
        "CRS Software Visibility  Not supported, hardwired to 0x0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_RSR.
static const field_t hw_pcie_rsr[] =
{
    {
        "PME_REQUESTER_ID",
        "PME Requester ID",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PME_STATUS",
        "PME Status",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PME_PENDING",
        "PME Pending",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_DCR2.
static const field_t hw_pcie_dcr2[] =
{
    {
        "COMPLETION_TIMEOUT_RANGES_SUPPORTED",
        "Completion Timeout Ranges Supported  This field is applicable only to "
        "Root Ports, Endpoints that issue Requests on their own behalf, and PCI"
        " Express to PCI/PCI-X Bridges that take ownership of Requests issued o"
        "n PCI Express.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETION_TIMEOUT_DISABLE_SUPPORTED",
        "Completion Timeout Disable Supported",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_DCSR2.
static const field_t hw_pcie_dcsr2[] =
{
    {
        "COMPLETION_TIMEOUT_VALUE",
        "Completion Timeout Value  If the default range is chosen, the core wil"
        "l have a timeout in the range of 16ms to 55ms.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLETION_TIMEOUT_DISABLE",
        "Completion Timeout Disable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_LCR2.
static const field_t hw_pcie_lcr2[] =
{
    {
        "SUPPORTED_LINK_SPEEDS_VECTOR",
        "Supported Link Speeds Vector  Indicates the supported Link speeds of t"
        "he associated Port.",
        1, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CROSSLINK_SUPPORTED",
        "Crosslink Supported",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_LCSR2.
static const field_t hw_pcie_lcsr2[] =
{
    {
        "TARGET_LINK_SPEED",
        "Target Link Speed  For Downstream ports, this field sets an upper limi"
        "t on link operational speed by restricting the values advertised by th"
        "e upstream component in its training sequences:  The encoding is the b"
        "inary value of the bit in the Supported Link Speeds Vector (in the Lin"
        "k Capabilities 2 register) that corresponds to the desired target Link"
        " speed.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTER_COMPLIANCE",
        "Enter Compliance  Software is permitted to force a link to enter Compl"
        "iance mode at the speed indicated in the Target Link Speed field by se"
        "tting this bit to 1b in both components on a link and then initiating "
        "a hot reset on the link.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HARDWARE_AUTONOMOUS_SPEED_DISABLE",
        "Hardware Autonomous Speed Disable  When cfg_hw_auto_sp_dis signal is a"
        "sserted, the application must disable hardware from changing the Link "
        "speed for device-specific reasons other than attempting to correct unr"
        "eliable Link operation by reducing Link speed.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SELECTABLE_DEEMPHASIS",
        "Selectable De-emphasis  When the Link is operating at 2.5 GT/s speed, "
        "the setting of this bit has no effect.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRANSMIT_MARGIN",
        "Transmit Margin  This field is reset to 000b on entry to the LTSSM Pol"
        "ling.",
        7, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTER_MODIFIED_COMPLIANCE",
        "Enter Modified Compliance  When this bit is set to 1b, the device tran"
        "smits modified compliance pattern if the LTSSM enters Polling.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLIANCE_SOS",
        "Compliance SOS  When set to 1b, the LTSSM is required to send SKP Orde"
        "red Sets periodically in between the (modified) compliance patterns.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLIANCE_PRE_SET_DEEMPHASIS",
        "Compliance Pre-set/ De-emphasis",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CURRENT_DEEMPHASIS_LEVEL",
        "Current De-emphasis Level",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EQUALIZATION_COMPLETE",
        "Equalization Complete",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EQUALIZATION_PHASE_1_SUCCESSFUL",
        "Equalization Phase 1 Successful",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EQUALIZATION_PHASE_2_SUCCESSFUL",
        "Equalization Phase 2 Successful",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EQUALIZATION_PHASE_3_SUCCESSFUL",
        "Equalization Phase 3 Successful",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINK_EQUALIZATION_REQUEST",
        "Link Equalization Request",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_AER.
static const field_t hw_pcie_aer[] =
{
    {
        "PCI_EXPRESS_EXTENDED_CAPABILITY_ID",
        "PCI Express Extended Capability ID  Value is 0x1 for Advanced Error Re"
        "porting.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAPABILITY_VERSION",
        "Capability Version",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT_CAPABILITY_OFFSET",
        "Next Capability Offset  See Table 5-222 on page 641.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_UESR.
static const field_t hw_pcie_uesr[] =
{
    {
        "DATA_LINK_PROTOCOL_ERROR_STATUS",
        "Data Link Protocol Error Status",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SURPRISE_DOWN_ERROR_STATUS",
        "Surprise Down Error Status (not supported)",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POISONED_TLP_STATUS",
        "Poisoned TLP Status",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLOW_CONTROL_PROTOCOL_ERROR_STATUS",
        "Flow Control Protocol Error Status",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLETION_TIMEOUT_STATUS",
        "Completion Timeout Status",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLETER_ABORT_STATUS",
        "Completer Abort Status",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNEXPECTED_COMPLETION_STATUS",
        "Unexpected Completion Status",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECEIVER_OVERFLOW_STATUS",
        "Receiver Overflow Status",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MALFORMED_TLP_STATUS",
        "Malformed TLP Status",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECRC_ERROR_STATUS",
        "ECRC Error Status",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNSUPPORTED_REQUEST_ERROR_STATUS",
        "Unsupported Request Error Status",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_UEMR.
static const field_t hw_pcie_uemr[] =
{
    {
        "DATA_LINK_PROTOCOL_ERROR_MASK",
        "Data Link Protocol Error Mask",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SURPRISE_DOWN_ERROR_MASK",
        "Surprise Down Error Mask (not supported)",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POISONED_TLP_MASK",
        "Poisoned TLP Mask",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLOW_CONTROL_PROTOCOL_ERROR_MASK",
        "Flow Control Protocol Error Mask",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLETION_TIMEOUT_MASK",
        "Completion Timeout Mask",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLETER_ABORT_MASK",
        "Completer Abort Mask",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNEXPECTED_COMPLETION_MASK",
        "Unexpected Completion Mask",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECEIVER_OVERFLOW_MASK",
        "Receiver Overflow Mask",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MALFORMED_TLP_MASK",
        "Malformed TLP Mask",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECRC_ERROR_MASK",
        "ECRC Error Mask",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNSUPPORTED_REQUEST_ERROR_MASK",
        "Unsupported Request Error Mask",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_UESEVR.
static const field_t hw_pcie_uesevr[] =
{
    {
        "DATA_LINK_PROTOCOL_ERROR_SEVERITY",
        "Data Link Protocol Error Severity",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SURPRISE_DOWN_ERROR_SEVERITY",
        "Surprise Down Error Severity (not supported)",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POISONED_TLP_SEVERITY",
        "Poisoned TLP Severity",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLOW_CONTROL_PROTOCOL_ERROR_SEVERITY",
        "Flow Control Protocol Error Severity",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLETION_TIMEOUT_SEVERITY",
        "Completion Timeout Severity",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMPLETER_ABORT_SEVERITY",
        "Completer Abort Severity",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNEXPECTED_COMPLETION_SEVERITY",
        "Unexpected Completion Severity",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECEIVER_OVERFLOW_SEVERITY",
        "Receiver Overflow Severity",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MALFORMED_TLP_SEVERITY",
        "Malformed TLP Severity",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECRC_ERROR_SEVERITY",
        "ECRC Error Severity",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNSUPPORTED_REQUEST_ERROR_SEVERITY",
        "Unsupported Request Error Severity",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_CESR.
static const field_t hw_pcie_cesr[] =
{
    {
        "RECEIVER_ERROR_STATUS",
        "Receiver Error Status",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAD_TLP_STATUS",
        "Bad TLP Status",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAD_DLLP_STATUS",
        "Bad DLLP Status",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REPLAY_NUM_ROLLOVER_STATUS",
        "REPLAY_NUM Rollover Status",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REPLY_TIMER_TIMEOUT_STATUS",
        "Reply Timer Timeout Status",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADVISORY_NON_FATAL_ERROR_STATUS",
        "Advisory Non-Fatal Error Status",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_CEMR.
static const field_t hw_pcie_cemr[] =
{
    {
        "RECEIVER_ERROR_MASK",
        "Receiver Error Mask",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAD_TLP_MASK",
        "Bad TLP Mask",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAD_DLLP_MASK",
        "Bad DLLP Mask",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REPLAY_NUM_ROLLOVER_MASK",
        "REPLAY_NUM Rollover Mask",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REPLY_TIMER_TIMEOUT_MASK",
        "Reply Timer Timeout Mask",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADVISORY_NON_FATAL_ERROR_MASK",
        "Advisory Non-Fatal Error Mask",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_ACCR.
static const field_t hw_pcie_accr[] =
{
    {
        "FIRST_ERROR_POINTER",
        "First Error Pointer",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECRC_GENERATION_CAPABILITY",
        "ECRC Generation Capability",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECRC_GENERATION_ENABLE",
        "ECRC Generation Enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECRC_CHECK_CAPABLE",
        "ECRC Check Capable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECRC_CHECK_ENABLE",
        "ECRC Check Enable",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_HLR.
static const field_t hw_pcie_hlr[] =
{
    { 0 } // Terminator
};

// Bitfields in register PCIE_RECR.
static const field_t hw_pcie_recr[] =
{
    {
        "CORRECTABLE_ERROR_REPORTING_ENABLE",
        "Correctable Error Reporting Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_FATAL_ERROR_REPORTING_ENABLE",
        "Non-Fatal Error Reporting Enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FATAL_ERROR_REPORTING_ENABLE",
        "Fatal Error Reporting Enable",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_RESR.
static const field_t hw_pcie_resr[] =
{
    {
        "ERR_COR_RECEIVED",
        "ERR_COR Received",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULTIPLE_ERR_COR_RECEIVED",
        "Multiple ERR_COR Received",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR_FATAL_NONFATAL_RECEIVED",
        "ERR_FATAL/NONFATAL Received",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULTIPLE_ERR_FATAL_NONFATAL_RECEIVED",
        "Multiple ERR_FATAL/NONFATAL Received",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRST_UNCORRECTABLE_FATAL",
        "First Uncorrectable Fatal",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_FATAL_ERROR_MESSAGES_RECEIVED",
        "Non-Fatal Error Messages Received",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FATAL_ERROR_MESSAGES_RECEIVED",
        "Fatal Error Messages Received",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADVANCED_ERROR_INTERRUPT_MESSAGE_NUMBER",
        "Advanced Error Interrupt Message Number, writable through the DBI",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_ESIR.
static const field_t hw_pcie_esir[] =
{
    {
        "ERR_COR_SID",
        "ERR_COR Source Identification",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_FATAL_NONFATAL_SID",
        "ERR_FATAL/NONFATAL Source Identification",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_VCECHR.
static const field_t hw_pcie_vcechr[] =
{
    {
        "EXTENDED_CAPABILITY",
        "PCI Express Extended Capability  The default value is 0x2 for VC Capab"
        "ility.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAPABILITY_VERSION",
        "Capability Version",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXT_CAPABILITY_OFFSET",
        "Next Capability Offset  See Table 5-222 on page 641.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_PVCCR1.
static const field_t hw_pcie_pvccr1[] =
{
    {
        "EXTENDED_VC_COUNT",
        "Extended VC Count  The default value is the one less than the number o"
        "f VCs that",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOW_PRIORITY_EXTENDED_VC_COUNT",
        "Low Priority Extended VC Count, writable through the DBI",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REFERENCE_CLOCK",
        "Reference Clock",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PORT_ARBITRATION_TABLE_ENTRY_SIZE",
        "Port Arbitration Table Entry Size",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_PVCCR2.
static const field_t hw_pcie_pvccr2[] =
{
    {
        "VC_ARBITRATION_CAPABILITY",
        "VC Arbitration Capability  Indicates which VC arbitration mode(s) the "
        "device supports, writable through the DBI:  Bit 0: Device supports ha"
        "rdware fixed arbitration scheme.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC_ARBITRATION_TABLE_OFFSET",
        "VC Arbitration Table Offset (not supported) The default value is 0x00 "
        "(no arbitration table present).",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_PVCCSR.
static const field_t hw_pcie_pvccsr[] =
{
    {
        "LOAD_VC_ARBITRATION_TABLE",
        "Load VC Arbitration Table",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC_ARBITRATION_SELECT",
        "VC Arbitration Select",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARBITRATION_TABLE_STATUS",
        "Arbitration Table Status",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_VCRCR.
static const field_t hw_pcie_vcrcr[] =
{
    {
        "PORT_ARBITRATION_CAPABILITY",
        "Port Arbitration Capability",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REJECT_SNOOP_TRANSACTIONS",
        "Reject Snoop Transactions",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAXIMUM_TIME_SLOTS",
        "Maximum Time Slots",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PORT_ARBITRATION_TABLE_OFFSET",
        "Port Arbitration Table Offset",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_VCRCONR.
static const field_t hw_pcie_vcrconr[] =
{
    {
        "TC_VC_MAP",
        "TC/VC Map  Bit 0 is hardwired to 1; bits 7:1 are RW.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOAD_PORT_ARBITRATION_TABLE",
        "Load Port Arbitration Table",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PORT_ARBITRATION_SELECT",
        "Port Arbitration Select",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC_ID",
        "VC ID  Hardwired to 0 for VC0.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC_ENABLE",
        "VC Enable  Hardwired to 1 for the first VC.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCIE_VCRSR.
static const field_t hw_pcie_vcrsr[] =
{
    {
        "PORT_ARBITRATION_TABLE_STATUS",
        "Port Arbitration Table Status",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VC_NEGOTIATION_PENDING",
        "VC Negotiation Pending",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PCIE module.
static const reg_t hw_pcie[] =
{
    {
        "DEVICEID",
        "Offset : 0x00  The default values of both Device ID and Vendor ID are "
        "hardware configuration parameters.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_pcie_deviceid
    },
    {
        "COMMAND",
        "Offset : 0x04  Bytes : 0-1",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_pcie_command
    },
    {
        "REVID",
        "Offset: 0x08  Byte: 0",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_pcie_revid
    },
    {
        "BIST",
        "Offset: 0x0C  Byte: 0",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pcie_bist
    },
    {
        "BAR0",
        "Offset: 0x10-0x24  The core provides three pairs of 32-bit BARs for ea"
        "ch implemented function.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_pcie_bar0
    },
    {
        "BAR1",
        "Address: 0x14",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_pcie_bar1
    },
    {
        "BAR2",
        "Offset: 0x18 (if included in the core hardware configuration)",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_pcie_bar2
    },
    {
        "BAR3",
        "Address: 0x1C (if included in the core hardware configuration)",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_pcie_bar3
    },
    {
        "CISP",
        "Offset: 0x28",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_pcie_cisp
    },
    {
        "SSID",
        "Offset: 0x2C",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_pcie_ssid
    },
    {
        "EROMBAR",
        "Offset: 0x30",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pcie_erombar
    },
    {
        "CAPPR",
        "Offset: 0x34  Byte: 0",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_pcie_cappr
    },
    {
        "ILR",
        "Offset: 0x3C  Byte: 0",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pcie_ilr
    },
    {
        "PMCR",
        "The core implements power management capabilities.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_pcie_pmcr
    },
    {
        "PMCSR",
        "Offset: 0x40 + 0x04",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_pcie_pmcsr
    },
    {
        "CIDR",
        "The core implements the PCI Express Capability Structure as defined in"
        " the PCI Express 3.0 Specification.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_pcie_cidr
    },
    {
        "DCR",
        "Offset: 0x70 + 0x04",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pcie_dcr
    },
    {
        "DCONR",
        "Offset: 0x70 + 0x08",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pcie_dconr
    },
    {
        "LCR",
        "Offset: 0x70 + 0x0C",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_pcie_lcr
    },
    {
        "LCSR",
        "Offset: 0x70 + 0x10",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pcie_lcsr
    },
    {
        "SCR",
        "This section applies only to Downstream Ports (for example, RC .",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        false, // Writable
        12, // Number of bitfields
        hw_pcie_scr
    },
    {
        "SCSR",
        "This section applies only to Downstream Ports (for example, RC .",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        20, // Number of bitfields
        hw_pcie_scsr
    },
    {
        "RCCR",
        "Offset: 0x70 + 0x1C",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcie_rccr
    },
    {
        "RSR",
        "Offset: 0x70 + 0x20",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcie_rsr
    },
    {
        "DCR2",
        "Offset: 0x70 + 0x24",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_pcie_dcr2
    },
    {
        "DCSR2",
        "Offset: 0x70 + 0x28",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pcie_dcsr2
    },
    {
        "LCR2",
        "Offset: 0x70 + 0x2C",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_pcie_lcr2
    },
    {
        "LCSR2",
        "Offset: 0x70 + 30",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_pcie_lcsr2
    },
    {
        "AER",
        "The core implements the following PCI Express Extended Capabilities re"
        "gisters:  ?",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcie_aer
    },
    {
        "UESR",
        "Offset: 0x04",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_pcie_uesr
    },
    {
        "UEMR",
        "Offset: 0x08",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_pcie_uemr
    },
    {
        "UESEVR",
        "Offset: 0x0C",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_pcie_uesevr
    },
    {
        "CESR",
        "Offset: 0x10",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcie_cesr
    },
    {
        "CEMR",
        "Offset: 0x14",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcie_cemr
    },
    {
        "ACCR",
        "Offset: 0x18",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pcie_accr
    },
    {
        "HLR",
        "Offset: 0x1C  The Header Log registers collect the header for the TLP "
        "corresponding to a detected error.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_pcie_hlr
    },
    {
        "RECR",
        "Offset: 0x100 + 0x2C",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcie_recr
    },
    {
        "RESR",
        "Offset: 0x100 + 0x30",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pcie_resr
    },
    {
        "ESIR",
        "Offset: 0x100 + 0x34",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_pcie_esir
    },
    {
        "VCECHR",
        "Offset: 0x140",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_pcie_vcechr
    },
    {
        "PVCCR1",
        "Offset: 0x140 + 0x4",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_pcie_pvccr1
    },
    {
        "PVCCR2",
        "Offset: 0x140 + 0x8",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_pcie_pvccr2
    },
    {
        "PVCCSR",
        "Offset: 0x140 + 0xC  Bytes: 0-1",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcie_pvccsr
    },
    {
        "VCRCR",
        "Offset: 0x140 + 0x10",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_pcie_vcrcr
    },
    {
        "VCRCONR",
        "Offset: 0x140 + 0x14",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pcie_vcrconr
    },
    {
        "VCRSR",
        "Offset: 0x140 + 0x18",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_pcie_vcrsr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PGC
#endif

// Bitfields in register PGC_DISPLAY_CTRL.
static const field_t hw_pgc_display_ctrl[] =
{
    {
        "PCR",
        "Power Control  PCR must not change from power-down request (pdn_req) a"
        "ssertion until the target subsystem is completely powered up.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_DISPLAY_PUPSCR.
static const field_t hw_pgc_display_pupscr[] =
{
    {
        "SW",
        "After a power-up request (pup_req assertion), the PGC waits a number o"
        "f clocks equal to the value of SW before asserting switch_b.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        "After asserting switch_b, the PGC waits a number of clocks equal to th"
        "e value of SW2ISO before negating isolation.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_DISPLAY_PDNSCR.
static const field_t hw_pgc_display_pdnscr[] =
{
    {
        "ISO",
        "After a power-down request (pdn_req assertion), the PGC waits a number"
        " of clocks equal to the value of ISO before asserting isolation.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        "After asserting isolation, the PGC waits a number of clocks equal to t"
        "he value of ISO2SW before negating switch_b.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_DISPLAY_SR.
static const field_t hw_pgc_display_sr[] =
{
    {
        "PSR",
        "Power status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_GPU_CTRL.
static const field_t hw_pgc_gpu_ctrl[] =
{
    {
        "PCR",
        "Power Control  PCR must not change from power-down request (pdn_req) a"
        "ssertion until the target subsystem is completely powered up.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_GPU_PUPSCR.
static const field_t hw_pgc_gpu_pupscr[] =
{
    {
        "SW",
        "After a power-up request (pup_req assertion), the PGC waits a number o"
        "f clocks equal to the value of SW before asserting switch_b.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        "After asserting switch_b, the PGC waits a number of clocks equal to th"
        "e value of SW2ISO before negating isolation.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_GPU_PDNSCR.
static const field_t hw_pgc_gpu_pdnscr[] =
{
    {
        "ISO",
        "After a power-down request (pdn_req assertion), the PGC waits a number"
        " of clocks equal to the value of ISO before asserting isolation.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        "After asserting isolation, the PGC waits a number of clocks equal to t"
        "he value of ISO2SW before negating switch_b.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_GPU_SR.
static const field_t hw_pgc_gpu_sr[] =
{
    {
        "PSR",
        "Power status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_CPU_CTRL.
static const field_t hw_pgc_cpu_ctrl[] =
{
    {
        "PCR",
        "Power Control  PCR must not change from power-down request (pdn_req) a"
        "ssertion until the target subsystem is completely powered up.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_CPU_PUPSCR.
static const field_t hw_pgc_cpu_pupscr[] =
{
    {
        "SW",
        "After a power-up request (pup_req assertion), the PGC waits a number o"
        "f clocks equal to the value of SW before asserting switch_b.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        "After asserting switch_b, the PGC waits a number of clocks equal to th"
        "e value of SW2ISO before negating isolation.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_CPU_PDNSCR.
static const field_t hw_pgc_cpu_pdnscr[] =
{
    {
        "ISO",
        "After a power-down request (pdn_req assertion), the PGC waits a number"
        " of clocks equal to the value of ISO before asserting isolation.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        "After asserting isolation, the PGC waits a number of clocks equal to t"
        "he value of ISO2SW before negating switch_b.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_CPU_SR.
static const field_t hw_pgc_cpu_sr[] =
{
    {
        "PSR",
        "Power status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PGC module.
static const reg_t hw_pgc[] =
{
    {
        "DISPLAY_CTRL",
        "The PGCR enables the response to a power-down request.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_display_ctrl
    },
    {
        "DISPLAY_PUPSCR",
        "The PUPSCR contains the power-up timing parameters.",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_display_pupscr
    },
    {
        "DISPLAY_PDNSCR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_display_pdnscr
    },
    {
        "DISPLAY_SR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_display_sr
    },
    {
        "GPU_CTRL",
        "The PGCR enables the response to a power-down request.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_gpu_ctrl
    },
    {
        "GPU_PUPSCR",
        "The PUPSCR contains the power-up timing parameters.",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_gpu_pupscr
    },
    {
        "GPU_PDNSCR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_gpu_pdnscr
    },
    {
        "GPU_SR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_gpu_sr
    },
    {
        "CPU_CTRL",
        "The PGCR enables the response to a power-down request.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_cpu_ctrl
    },
    {
        "CPU_PUPSCR",
        "The PUPSCR contains the power-up timing parameters.",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_cpu_pupscr
    },
    {
        "CPU_PDNSCR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_cpu_pdnscr
    },
    {
        "CPU_SR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_cpu_sr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PMU
#endif

// Bitfields in register PMU_REG_1P1.
static const field_t hw_pmu_reg_1p1[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brown-out circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PULLDOWN",
        "Control bit to enable the pull-down circuitry in the regulator",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brown-out offset voltage in 25mV "
        "steps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD1P1",
        "Status bit that signals when a brown-out is detected on the regulator "
        "output.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD1P1",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_3P0.
static const field_t hw_pmu_reg_3p0[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brown-out circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brown-out offset voltage in 25mV "
        "steps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_SEL",
        "Select input voltage source for LDO_3P0 from either USB OTG1 or USB OT"
        "G2.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD3P0",
        "Status bit that signals when a brown-out is detected on the regulator "
        "output.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD3P0",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_2P5.
static const field_t hw_pmu_reg_2p5[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brown-out circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PULLDOWN",
        "Control bit to enable the pull-down circuitry in the regulator",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brown-out offset voltage in 25mV "
        "steps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD2P5",
        "Status bit that signals when a brown-out is detected on the regulator "
        "output.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD2P5",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_WEAK_LINREG",
        "Enables the weak 2p5 regulator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_CORE.
static const field_t hw_pmu_reg_core[] =
{
    {
        "REG0_TARG",
        "This bitfield defines the target voltage for the arm core power domain"
        ".",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_ADJ",
        "This bitfield defines the adjustment bits to calibrate the target valu"
        "e of REG1 (ARM_CORE).",
        5, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_TARG",
        "This bitfield defines the target voltage for the VPU/GPU power domain.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_ADJ",
        "This bitfield defines the adjustment bits to calibrate the target valu"
        "e of REG1 (REG_PU).",
        14, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_TARG",
        "This bitfield defines the target voltage for the SOC power domain.",
        18, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_ADJ",
        "This bitfield defines the adjustment bits to calibrate the target valu"
        "e of REG2 (REG_SOC).",
        23, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FET_ODRIVE",
        "If set, increases the gate drive on power gating fets to reduce leakag"
        "e in the off state.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC0.
static const field_t hw_pmu_misc0[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit which signals that the analog bandgap voltage is up and sta"
        "ble.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This bit field determines the bias current in the 24MHz oscillator.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit which signals that the output of the 24MHz crystal oscillat"
        "or is stable.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit is asserted when the 24MHz oscillator is close to its operati"
        "ng frequency.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBCP_VPW_THRESH",
        "This signal alters the voltage that the pwell is charged pumped to.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always un-gated) for the xta"
        "l 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and release the clock to the digital logic inside the analog block.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1.
static const field_t hw_pmu_misc1[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the lvds output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the lvds output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the lvds input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the lvds input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPSENSE",
        "This status bit is set to one when when the temperature sensor interru"
        "pt asserts.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2.
static const field_t hw_pmu_misc2[] =
{
    {
        "REG0_BO_OFFSET",
        "This bit field defines the brown out voltage offset for the CORE power"
        " domain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This bit field defines the brown out voltage offset for the xPU power "
        "domain.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This bit field defines the brown out voltage offset for the xPU power "
        "domain.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video PLL.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PMU module.
static const reg_t hw_pmu[] =
{
    {
        "REG_1P1",
        "This register defines the control and status bits for the 1.1V regulat"
        "or.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pmu_reg_1p1
    },
    {
        "REG_3P0",
        "This register defines the control and status bits for the 3.0V regulat"
        "or powered by the host USB VBUS pin.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pmu_reg_3p0
    },
    {
        "REG_2P5",
        "This register defines the control and status bits for the 2.5V regulat"
        "or.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_pmu_reg_2p5
    },
    {
        "REG_CORE",
        "This register defines the function of the digital regulators",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmu_reg_core
    },
    {
        "MISC0",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_pmu_misc0
    },
    {
        "MISC1",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_pmu_misc1
    },
    {
        "MISC2",
        "This register defines the control and status bits for the digital regu"
        "lators, as well as some miscellaneous analog controls.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_pmu_misc2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PWM
#endif

// Bitfields in register PWM_PWMCR.
static const field_t hw_pwm_pwmcr[] =
{
    {
        "EN",
        "PWM Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REPEAT",
        "Sample Repeat.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software Reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER",
        "Counter Clock Prescaler Value.",
        4, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Select Clock Source.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POUTC",
        "PWM Output Configuration.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCTR",
        "Half-word Data Swap Control.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCTR",
        "Byte Data Swap Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "Debug Mode Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "Wait Mode Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        "Doze Mode Enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "Stop Mode Enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWM",
        "FIFO Water Mark.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMSR.
static const field_t hw_pwm_pwmsr[] =
{
    {
        "FIFOAV",
        "FIFO Available.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FE",
        "FIFO Empty Status Bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROV",
        "Roll-over Status.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP",
        "Compare Status.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWE",
        "FIFO Write Error Status.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMIR.
static const field_t hw_pwm_pwmir[] =
{
    {
        "FIE",
        "FIFO Empty Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "Roll-over Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        "Compare Interrupt Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMSAR.
static const field_t hw_pwm_pwmsar[] =
{
    {
        "SAMPLE",
        "Sample Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMPR.
static const field_t hw_pwm_pwmpr[] =
{
    {
        "PERIOD",
        "Period Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMCNR.
static const field_t hw_pwm_pwmcnr[] =
{
    {
        "COUNT",
        "Counter Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PWM module.
static const reg_t hw_pwm[] =
{
    {
        "PWMCR",
        "The PWM control register (PWM_PWMCR) is used to configure the operatin"
        "g settings of the PWM.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pwm_pwmcr
    },
    {
        "PWMSR",
        "The PWM status register (PWM_PWMSR) contains seven bits which display "
        "the state of the FIFO and the occurrence of rollover and compare event"
        "s.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pwm_pwmsr
    },
    {
        "PWMIR",
        "The PWM Interrupt register (PWM_PWMIR) contains three bits which contr"
        "ol the generation of the compare, rollover and FIFO empty interrupts.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pwm_pwmir
    },
    {
        "PWMSAR",
        "The PWM sample register (PWM_PWMSAR) is the input to the FIFO.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pwm_pwmsar
    },
    {
        "PWMPR",
        "The PWM period register (PWM_PWMPR) determines the period of the PWM o"
        "utput signal.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pwm_pwmpr
    },
    {
        "PWMCNR",
        "The read-only pulse-width modulator counter register (PWM_PWMCNR) cont"
        "ains the current count value and can be read at any time without distu"
        "rbing the counter.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_pwm_pwmcnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ROMC
#endif

// Bitfields in register ROMC_ROMPATCH0D.
static const field_t hw_romc_rompatch0d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1D.
static const field_t hw_romc_rompatch1d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2D.
static const field_t hw_romc_rompatch2d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3D.
static const field_t hw_romc_rompatch3d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4D.
static const field_t hw_romc_rompatch4d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5D.
static const field_t hw_romc_rompatch5d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6D.
static const field_t hw_romc_rompatch6d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7D.
static const field_t hw_romc_rompatch7d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHCNTL.
static const field_t hw_romc_rompatchcntl[] =
{
    {
        "DATAFIX",
        "Data Fix Enable - Controls the use of the first 8 address comparators "
        "for 1-word data fix or for code patch routine.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS",
        "ROMC Disable -- This bit, when set, disables all ROMC operations.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENH.
static const field_t hw_romc_rompatchenh[] =
{
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENL.
static const field_t hw_romc_rompatchenl[] =
{
    {
        "ENABLE",
        "Enable Address Comparator - This bit enables the corresponding address"
        " comparator to trigger an event.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH0A.
static const field_t hw_romc_rompatch0a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1A.
static const field_t hw_romc_rompatch1a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2A.
static const field_t hw_romc_rompatch2a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3A.
static const field_t hw_romc_rompatch3a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4A.
static const field_t hw_romc_rompatch4a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5A.
static const field_t hw_romc_rompatch5a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6A.
static const field_t hw_romc_rompatch6a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7A.
static const field_t hw_romc_rompatch7a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH8A.
static const field_t hw_romc_rompatch8a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH9A.
static const field_t hw_romc_rompatch9a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH10A.
static const field_t hw_romc_rompatch10a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH11A.
static const field_t hw_romc_rompatch11a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH12A.
static const field_t hw_romc_rompatch12a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH13A.
static const field_t hw_romc_rompatch13a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH14A.
static const field_t hw_romc_rompatch14a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH15A.
static const field_t hw_romc_rompatch15a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHSR.
static const field_t hw_romc_rompatchsr[] =
{
    {
        "SOURCE",
        "ROMC Source Number - Binary encoding of the number of the address comp"
        "arator which has an address match in the most recent patch event on RO"
        "MC AHB.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW",
        "ROMC AHB Multiple Address Comparator matches Indicator - Indicates tha"
        "t multiple address comparator matches occurred.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ROMC module.
static const reg_t hw_romc[] =
{
    {
        "ROMPATCH0D",
        "The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch0d
    },
    {
        "ROMPATCH1D",
        "The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch1d
    },
    {
        "ROMPATCH2D",
        "The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch2d
    },
    {
        "ROMPATCH3D",
        "The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch3d
    },
    {
        "ROMPATCH4D",
        "The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch4d
    },
    {
        "ROMPATCH5D",
        "The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch5d
    },
    {
        "ROMPATCH6D",
        "The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch6d
    },
    {
        "ROMPATCH7D",
        "The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch7d
    },
    {
        "ROMPATCHCNTL",
        "The ROMC control register (ROMC_ROMPATCHCNTL) contains the block disab"
        "le bit and the data fix enable bits.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchcntl
    },
    {
        "ROMPATCHENH",
        "The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_romc_rompatchenh
    },
    {
        "ROMPATCHENL",
        "The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatchenl
    },
    {
        "ROMPATCH0A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch0a
    },
    {
        "ROMPATCH1A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch1a
    },
    {
        "ROMPATCH2A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch2a
    },
    {
        "ROMPATCH3A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch3a
    },
    {
        "ROMPATCH4A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch4a
    },
    {
        "ROMPATCH5A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch5a
    },
    {
        "ROMPATCH6A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch6a
    },
    {
        "ROMPATCH7A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch7a
    },
    {
        "ROMPATCH8A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch8a
    },
    {
        "ROMPATCH9A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch9a
    },
    {
        "ROMPATCH10A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch10a
    },
    {
        "ROMPATCH11A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch11a
    },
    {
        "ROMPATCH12A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch12a
    },
    {
        "ROMPATCH13A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch13a
    },
    {
        "ROMPATCH14A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch14a
    },
    {
        "ROMPATCH15A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch15a
    },
    {
        "ROMPATCHSR",
        "The ROMC status register (ROMC_ROMPATCHSR) indicates the current state"
        " of the ROMC and the source number of the most recent address comparat"
        "or event.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchsr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SATA
#endif

// Bitfields in register SATA_CAP.
static const field_t hw_sata_cap[] =
{
    {
        "NP",
        "Number of Ports.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SXS",
        "Supports External SATA.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EMS",
        "Enclosure Management Support.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CCCS",
        "Command Completion Coalescing Support.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCS",
        "Number of Command Slots.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PSC",
        "Partial State Capable.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SSC",
        "Slumber State Capable.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PMD",
        "PIO Multiple DRQ Block.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SMP",
        "Supports Port Multiplier.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAM",
        "Supports AHCI Mode Only.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ISS",
        "Interface Speed Support.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SCLO",
        "Supports Command List Override.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAL",
        "Supports Activity LED.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SALP",
        "Supports Aggressive Link Power Management.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SSS",
        "Supports Staggered Spin-up.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SMPS",
        "Supports Mechanical Presence Switch.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SSNTF",
        "Supports SNotification Register.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SNCQ",
        "Supports Native Command Queuing.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S64A",
        "Supports 64-bit Addressing  SATA block supports 64-bit addressable dat"
        "a structures by utilizing  PFFBU and P#CLBU registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_GHC.
static const field_t hw_sata_ghc[] =
{
    {
        "HR",
        "HBA Reset.",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    {
        "IE",
        "Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AE",
        "AHCI Enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_IS.
static const field_t hw_sata_is[] =
{
    {
        "IPS",
        "Interrupt Pending Status.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_PI.
static const field_t hw_sata_pi[] =
{
    {
        "PI",
        "Ports Implemented.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_VS.
static const field_t hw_sata_vs[] =
{
    {
        "MNR",
        "Minor Version Number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MJR",
        "Major Version Number.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_CCC_CTL.
static const field_t hw_sata_ccc_ctl[] =
{
    {
        "EN",
        "Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT",
        "Interrupt.",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CC",
        "Command Completions.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TV",
        "Time-out Value.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_CCC_PORTS.
static const field_t hw_sata_ccc_ports[] =
{
    {
        "PRT",
        "Ports.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_CAP2.
static const field_t hw_sata_cap2[] =
{
    {
        "APST",
        "Automatic Partial to Slumber Transitions.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_BISTAFR.
static const field_t hw_sata_bistafr[] =
{
    {
        "PD",
        "Pattern Definition  Indicates the pattern definition field of the rece"
        "ived BIST Activate FIS - bits [23:16] of the first DWORD.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCP",
        "Least significant byte of the received BIST Activate FIS second DWORD "
        "(bits [7:0]).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_BISTCR.
static const field_t hw_sata_bistcr[] =
{
    {
        "PATTERN",
        "This field defines one of the following SATA compliant patterns for fa"
        "r-end retimed/ far-end analog/ near-end analog initiator modes, or non"
        "-compliant patterns for transmit-only responder mode when initiated by"
        " the software writing to the SATA_BISTCR[TXO] bit.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PV",
        "Pattern Version  This bit is used to select either short or long versi"
        "on of the SSOP, HTDP, LTDP, LFSCP, COMP patterns.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLIP",
        "Flip Disparity  This bit is used to change disparity of the current te"
        "st pattern to the opposite every time its state is changed by the soft"
        "ware.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERREN",
        "Error Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LLC",
        "Link Layer Control  This field controls the Port Link Layer functions:"
        " scrambler, descrambler, and repeat primitive drop.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDFE",
        "Signal Detect Feature Enable  Reset: PHY_INTERFACE_TYPE 1: Link layer "
        "feature to handle unstable/absent phy_sig_det signal is enabled 0: Lin"
        "k layer feature to handle unstable/absent phy_sig_det signal is disabl"
        "ed.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QPHYINIT",
        "When set, this bit enables quick PHY initialization feature.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEALB",
        "Near-End Analog Loopback  This mode should be initiated either in the "
        "PARTIAL or SLUMBER power mode, or with the device disconnected from th"
        "e Port PHY (Link NOCOMM state).",
        16, // LSB
        16, // MSB
        false, // Readable
        true // Writable
    },
    {
        "CNTCLR",
        "Counter Clear  This bit clears BIST error count registers.",
        17, // LSB
        17, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TXO",
        "Transmit Only.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FERLB",
        "Far-end Retimed Loopback.",
        20, // LSB
        20, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_BISTFCTR.
static const field_t hw_sata_bistfctr[] =
{
    { 0 } // Terminator
};

// Bitfields in register SATA_BISTSR.
static const field_t hw_sata_bistsr[] =
{
    {
        "FRAMERR",
        "Frame Error.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BRSTERR",
        "Burst Error.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_OOBR.
static const field_t hw_sata_oobr[] =
{
    {
        "CIMAX",
        "COMINIT Maximum Value  This field is RW when WE=1 and RO when WE=0.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIMIN",
        "COMINIT Minimum Value  This field is RW when WE=1 and RO when WE=0.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CWMAX",
        "COMWAKE Maximum Value  This field is RW when WE=1 and RO when WE=0.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CWMIN",
        "COMWAKE Minimum Value  This field is RW when WE=1 and RO when WE=0.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WE",
        "Write Enable  This bit is cleared when COMRESET is detected.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_GPCR.
static const field_t hw_sata_gpcr[] =
{
    {
        "GP_CONTROL",
        "General Purpose Control.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_GPSR.
static const field_t hw_sata_gpsr[] =
{
    {
        "GP_STATUS",
        "General Purpose Status.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_TIMER1MS.
static const field_t hw_sata_timer1ms[] =
{
    {
        "TIMV",
        "1ms Timer Value  This field contains the following value for the inter"
        "nal timer to generate 1-ms tick:  Fhclk*1000  where Fhclk = AHB clock "
        "frequency in MHz  The options for this field are:   RW when SATA_CCC_"
        "CTL[EN]==0   RO when SATA_CCC_CTL[EN]==1.",
        0, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_TESTR.
static const field_t hw_sata_testr[] =
{
    {
        "TEST_IF",
        "TEST_IF: Test Interface  Normal operation is disabled.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSEL",
        "Port Select  This field is used to select a Port for BIST operation: T"
        "he options for this field are:",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_VERSIONR.
static const field_t hw_sata_versionr[] =
{
    { 0 } // Terminator
};

// Bitfields in register SATA_P0CLB.
static const field_t hw_sata_p0clb[] =
{
    {
        "CLB",
        "Command List Base Address  Indicates the 32-bit base physical address "
        "for the command list for this Port.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0FB.
static const field_t hw_sata_p0fb[] =
{
    {
        "FB",
        "FIS Base Address.",
        8, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0IS.
static const field_t hw_sata_p0is[] =
{
    {
        "DHRS",
        "Device to Host Register FIS Interrupt  A D2H Register FIS has been rec"
        "eived with the 'I' bit set, and has been copied into system memory.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PSS",
        "PIO Setup FIS Interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSS",
        "DMA Setup FIS Interrupt  A DMA Setup FIS has been received with the 'I"
        "' bit set and has been copied into system memory.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDBS",
        "Set Device Bits Interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UFS",
        "Unknown FIS Interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        "Descriptor Processed  A PRD with the I bit set has transferred all of "
        "its data.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PCS",
        "Port Connect Change Status  This bit is cleared only when SATA_P 0 SER"
        "R[DIAG_X] is cleared.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRCS",
        "PHY Ready Change Status  This bit reflects the state of the SATA_P 0 S"
        "ERR[DIAG_N] bit.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPMS",
        "Incorrect Port Multiplier Status.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OFS",
        "Overflow Status  This bit is set when command list overflow is detecte"
        "d during read or write operation when the software builds command tabl"
        "e that has fever total bytes than the transaction given to the device.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INFS",
        "Interface Non-fatal Error Status  This bit is set when any of the foll"
        "owing conditions is detected:   One or more of the following errors a"
        "re detected during non-data FIS  transfer  - 10B to 8B Decode Error (S"
        "ATA_P 0 SERR[DIAG_B])  - Protocol (SATA_P 0 SERR[ERR_P])  - CRC (SATA_"
        "P 0 SERR[DIAG_C]),  - Handshake (SATA_P 0 SERR[DIAG_H])  - PHY Not Rea"
        "dy (SATA_P 0 SERR[ERR_C]);   Command list underflow during read opera"
        "tion (i.e.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IFS",
        "Interface Fatal Error Status  This bit is set when any of the followin"
        "g conditions is detected:   SYNC escape is received from the device d"
        "uring H2D Register or Data FIS  transmission;   One or more of the fo"
        "llowing errors are detected during Data FIS transfer:  - 10B to 8B Dec"
        "ode Error (SATA_P 0 SERR[DIAG_B])  - Protocol (SATA_P 0 SERR[ERR_P])  "
        "- CRC (SATA_P 0 SERR[DIAG_C])  - Handshake (SATA_P 0 SERR[DIAG_H])  - "
        "PHY Not Ready (SATA_P 0 SERR[ERR_C])   Unknown FIS is received with g"
        "ood CRC, but the length exceeds 64 bytes;   PRD table byte count is z"
        "ero.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HBDS",
        "Host Bus Data Error Status.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HBFS",
        "Host Bus Fatal Error Status.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFES",
        "Task File Error Status.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0IE.
static const field_t hw_sata_p0ie[] =
{
    {
        "DHRE",
        "Device to Host Register FIS Interrupt  Dependencies: when the followin"
        "g conditions are true, the intrq output signal is asserted:   This bi"
        "t=1   SATA_GHC[IE]=1   SATA_P 0 IS[DHRS]=1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "PIO Setup FIS Interrupt Enable  Dependencies: when the following condi"
        "tions are true, the intrq output signal is asserted:   This bit=1   "
        "SATA_GHC[IE]=1   SATA_P 0 IS[PSS]=1",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "DMA Setup FIS Interrupt Enable  Dependencies: when the following condi"
        "tions are true, the intrq output signal is asserted:   This bit=1   "
        "SATA_GHC[IE]=1   SATA_P 0 IS[DSS]=1",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDBE",
        "Set Device Bits FIS Interrupt Enable  Dependencies: when the following"
        " conditions are true, the intrq output signal is asserted:   This bit"
        "=1   SATA_GHC[IE]=1   SATA_P 0 IS[SDBS]=1",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UFE",
        "Unknown FIS Interrupt Enable  Dependencies: when the following conditi"
        "ons are true, the intrq output signal is asserted:   This bit=1   SA"
        "TA_GHC[IE]=1   SATA_P 0 IS[UFS]=1",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPE",
        "Descriptor Processed Interrupt Enable  Dependencies: when the followin"
        "g conditions are true, the intrq output signal is asserted:   This bi"
        "t=1   SATA_GHC[IE]=1   SATA_P 0 IS[DPS]=1",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Interrupt Enable  Dependencies: when the following conditi"
        "ons are true, the intrq output signal is asserted:   This bit=1   SA"
        "TA_GHC[IE]=1   SATA_P 0 IS[PCS]=1",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCE",
        "PHY Ready Change Enable  Dependencies: when the following conditions a"
        "re true, the intrq output signal is asserted:   This bit=1   SATA_GH"
        "C[IE]=1   SATA_P 0 IS[PRCS]=1",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPME",
        "Incorrect Port Multiplier Enable  Dependencies: when the following con"
        "ditions are true, the intrq output signal is asserted:   This bit=1  "
        " SATA_GHC[IE]=1   SATA_P 0 IS[IPMS]=1",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFE",
        "Overflow Enable  Dependencies: when the following conditions are true,"
        " the intrq output signal is asserted:   This bit=1   SATA_GHC[IE]=1 "
        "  SATA_P 0 IS[OFS]=1",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INFE",
        "Interface Non-Fatal Error Enable  Dependencies: when the following con"
        "ditions are true, the intrq output signal is asserted:   This bit=1  "
        " SATA_GHC[IE]=1   SATA_P 0 IS[INFS]=1",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IFE",
        "Dependencies: when the following conditions are true, the intrq output"
        " signal is asserted:   This bit=1   SATA_GHC[IE]=1   SATA_P 0 IS[IF"
        "S]=1",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBDE",
        "Host Bus Data Error Enable  Dependencies: when the following condition"
        "s are true, the intrq output signal is asserted:   This bit=1   SATA"
        "_GHC[IE]=1   SATA_P 0 IS[HBDS]=1",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBFE",
        "Host Bus Fatal Error Enable  Dependencies: when the following conditio"
        "ns are true, the intrq output signal is asserted:   This bit=1   SAT"
        "A_GHC[IE]=1   SATA_P 0 IS[HBFS]=1",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEE",
        "Task File Error Enable  Dependencies: when the following conditions ar"
        "e true, the intrq output signal is asserted:   This bit=1   SATA_GHC"
        "[IE]=1   SATA_P 0 IS[TFES]=1",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPDE",
        "Cold Port Detect Enable  Read-only.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0CMD.
static const field_t hw_sata_p0cmd[] =
{
    {
        "ST",
        "Start  When set to 1, the Port processes the command list.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUD",
        "Spin-Up Device  This bit is read/write when staggered spin-up is suppo"
        "rted as indicated by the SATA_CAP[SSS]=1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POD",
        "Power On Device  This bit is read/write when cold presence detection i"
        "s supported on this Port as indicated by SATA_P 0 CMD[CPD]=1.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLO",
        "Command List Override  Setting this bit to 1 causes the SATA_P 0 TFD[S"
        "TS] field BSY bit and the SATA_P 0 TFD[STS] field DRQ bit to be cleare"
        "d.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "FIS Receive Enable  When set to 1, the Port may post received FISes in"
        "to the FIS receive area pointed to by SATA_P 0 FB .",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCS",
        "Current Command Slot  This field is set to the command slot value valu"
        "e of the command that is currently being issued by the Port.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPSS",
        "Mechanical Presence Switch State  The software must use this bit only "
        "when both SATA_CAP[SMPS] and SATA_P 0 CMD[MPSP] are set.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "FIS Receive Running  When set to '1', the FIS Receive DMA engine for t"
        "he Port is running.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CR",
        "Command List Running  When this bit is set to '1', the command list DM"
        "A engine for this Port is running.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPS",
        "Cold Presence State  This bit reports whether a device is currently de"
        "tected on this Port as indicated by the p 0 _cp_det input state (assum"
        "ing SATA_P 0 CMD[CPD]=1).",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PMA",
        "Port Multiplier Attached  The software is responsible for detecting wh"
        "ether a Port Multiplier is present; the SATA block Port does not auto-"
        "detect the presence of a Port Multiplier.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPCP",
        "Hot Plug Capable Port  The HPCP bit is mutually exclusive with SATA_P "
        "0 CMD[ESP].",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESP",
        "External SATA Port  When set to 1, indicates that this Port's signal o"
        "nly connector is externally accessible.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APSTE",
        "Device is ATAPI  This bit is used by the Port to control whether to as"
        "sert p 0 _act_led output when commands are active.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATAPI",
        "ATAPI Device is ATAPI  This bit is used by the Port to control whether"
        " to assert p 0 _act_led output when commands are active.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLAE",
        "Drive LED on ATAPI Enable  When set to 1, SATA_P 0 CMD[ATAPI]=1, and c"
        "ommands are active, the Port asserts p 0 _act_led output.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPE",
        "Aggressive Link Power Management Enable  When set to 1, the Port aggre"
        "ssively enters a lower link power state (PARTIAL or SLUMBER) based on "
        "the setting of the SATA_P 0 CMD[ASP] bit.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Aggressive Slumber/ Partial  The options for this field are:   When s"
        "et to 1, and SATA_P 0 CMD[ALPE]=1, the Port aggressively enters the SL"
        "UMBER state when one of the following conditions is true:  - The Port "
        "clears the SATA_P 0 CI and the SATA_P 0 SACT register is cleared.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICC",
        "Interface Communication Control  This field is used to control power m"
        "anagement states of the interface.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0TFD.
static const field_t hw_sata_p0tfd[] =
{
    {
        "STS",
        "Status  This field contains the latest copy of the task file status re"
        "gister.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR",
        "Error  This field contains the latest copy of the task file error regi"
        "ster.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0SIG.
static const field_t hw_sata_p0sig[] =
{
    {
        "SIG",
        "Signature  This field contains the signature received from a device on"
        " the first D2H Register FIS.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0SSTS.
static const field_t hw_sata_p0ssts[] =
{
    {
        "DET",
        "Indicates the interface device detection and PHY state.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPD",
        "Current Interface Speed  Indicates the negotiated interface communicat"
        "ion speed.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPM",
        "Interface Power Management  Indicates the current interface state.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0SCTL.
static const field_t hw_sata_p0sctl[] =
{
    {
        "DET",
        "Device Detection Initialization  Controls the Port's device detection "
        "and interface initialization.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD",
        "Speed Allowed  This field indicates the highest allowable speed of the"
        " Port PHY interface.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPM",
        "Interface Power Management Transitions Allowed  This field indicates w"
        "hich power states the Port PHY interface is allowed to transition to.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0SERR.
static const field_t hw_sata_p0serr[] =
{
    {
        "ERR_I",
        "This bit is set when any of the following SATA_P 0 SERR register bits "
        "is set during non- Data FIS transfer:   DIAG_C (CRC)   DIAG_H (Hands"
        "hake)   ERR_C (\"PHY Ready\" negation)",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_M",
        "Recovered Communication Error  This bit is set to 1 when PHY Ready con"
        "dition is detected after interface initialization, but not after trans"
        "ition from Partial or Slumber power management state to active state.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_T",
        "Non-Recovered Transient Data Integrity Error  This bit is set when any"
        " of the following SATA_P 0 SERR register bits is set during Data  FIS "
        "transfer: ERR_P (Protocol)   DIAG_C (CRC)   DIAG_H (Handshake)   ER"
        "R_C (\"PHY Ready\" negation)",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_C",
        "Non-Recovered Persistent Communication Error  This bit is set to 1 whe"
        "n PHY Ready signal is negated due to the loss of communication with th"
        "e device or problems with interface, but not after transition from act"
        "ive to Partial or Slumber power management state.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_P",
        "Protocol Error  This bit is set to 1 when any of the following conditi"
        "ons are detected.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR_E",
        "Internal Error  This bit is set to 1 when one or more AHB bus ERROR re"
        "sponses are detected on the master interface.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_N",
        "PHY Ready Change  This bit indicates that the PHY Ready signal changed"
        " state.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_I",
        "PHY Internal Error  This bit is set when the PHY detects some internal"
        " error as indicated by the assertion of the p 0 _phy_rx_err input.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_W",
        "Comm Wake  This bit is set when PHY COMWAKE signal is detected.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_B",
        "10B to 8B Decode Error  This bit indicates errors were detected by 10b"
        "8b decoder.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_D",
        "Disparity Error  This bit is always cleared to 0 since it is not used "
        "by the AHCI specification.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_C",
        "CRC Error",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_H",
        "Handshake Error  This bit indicates that one or more R_ERRp was receiv"
        "ed in response to frame transmission.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_S",
        "Link Sequence Error  This bit indicates that one or more Link state ma"
        "chine error conditions was encountered.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_T",
        "Transport State Transition Error  This bit indicates that a Transport "
        "Layer protocol violation was detected since the last time this bit was"
        " cleared.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_F",
        "Unknown FIS Type  This bit indicates that one or more FISes were recei"
        "ved by the Transport layer with good CRC, but had a type field that wa"
        "s not recognized/known and the length was less than or equal to 64byte"
        "s.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIAG_X",
        "Exchanged  This bit is set to 1 when PHY COMINIT signal is detected.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0SACT.
static const field_t hw_sata_p0sact[] =
{
    {
        "DS",
        "Device Status  This field is bit significant.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0CI.
static const field_t hw_sata_p0ci[] =
{
    {
        "CI",
        "Command Issued  This field is bit significant.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0SNTF.
static const field_t hw_sata_p0sntf[] =
{
    {
        "PMN",
        "PM Notify  This field indicates whether a particular device with the c"
        "orresponding PM Port number issued a Set Device Bits FIS to the SATA b"
        "lock Port with the Notification bit set:   PM Port 0h sets bit 0,   "
        "PM Port 1h sets bit 1,  ...",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0DMACR.
static const field_t hw_sata_p0dmacr[] =
{
    {
        "TXTS",
        "Transmit Transaction Size  This field defines the DMA transaction size"
        " in DWORDs for transmit (system bus read, device write) operation.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXTS",
        "Receive Transaction Size  This field defines the Port DMA transaction "
        "size in DWORDs for receive (system bus write, device read) operation.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0PHYCR.
static const field_t hw_sata_p0phycr[] =
{
    {
        "CR_DATA_IN",
        "CR Address and Write Data Input Bus.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CR_CAP_ADDR",
        "CR Capture Address.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CR_CAP_DATA",
        "CR Capture Data.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CR_WRITE",
        "CR Write.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CR_READ",
        "CR Read.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_PDDQ",
        "Test IDDQ",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SATA_P0PHYSR.
static const field_t hw_sata_p0physr[] =
{
    {
        "CR_DATA_OUT",
        "CR Data Output Bus.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CR_ACK",
        "CR Acknowledgement.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SATA module.
static const reg_t hw_sata[] =
{
    {
        "CAP",
        "This register indicates basic capabilities of the SATA block to the so"
        "ftware.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_sata_cap
    },
    {
        "GHC",
        "This register controls various global actions of the SATA block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sata_ghc
    },
    {
        "IS",
        "This register indicates which of the Ports within the SATA block have "
        "an interrupt pending and require service.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_is
    },
    {
        "PI",
        "This register indicates which Ports are exposed by the SATA block and "
        "are available for the software to use.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sata_pi
    },
    {
        "VS",
        "This register indicates the major and minor version of the AHCI specif"
        "ication that the SATA block implementation supports.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sata_vs
    },
    {
        "CCC_CTL",
        "This register is used to configure the command completion coalescing ("
        "CCC) feature for the SATA block core.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_sata_ccc_ctl
    },
    {
        "CCC_PORTS",
        "This register specifies the Ports that are coalesced as part of the co"
        "mmand completion coalescing (CCC) feature when SATA_CCC_CTL[EN]==1.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_ccc_ports
    },
    {
        "CAP2",
        "This register indicates capabilites of the SATA block core to the soft"
        "ware.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sata_cap2
    },
    {
        "BISTAFR",
        "This register contains the pattern definition (bits [23:16] of the fir"
        "st DWORD) and data pattern (bits [7:0] of the second DWORD) fields of "
        "the received BIST Activate FIS.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sata_bistafr
    },
    {
        "BISTCR",
        "This register is used in BIST initiator modes.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_sata_bistcr
    },
    {
        "BISTFCTR",
        "This register contains the received BIST FIS count in the loopback ini"
        "tiator far-end retimed, far-end analog and near-end analog modes.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_sata_bistfctr
    },
    {
        "BISTSR",
        "This register contains errors detected in the received BIST FIS in the"
        " loopback initiator far-end retimed, far- end analog and near-end anal"
        "og modes.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sata_bistsr
    },
    {
        "OOBR",
        "This register controls the Link layer OOB detection counters.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_sata_oobr
    },
    {
        "GPCR",
        "This 32-bit register is used for general purpose control.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_gpcr
    },
    {
        "GPSR",
        "This 32-bit register is used to monitor the general purpose status.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_gpsr
    },
    {
        "TIMER1MS",
        "This register is used to generate a 1-ms tick for the command completi"
        "on coalescing (CCC) logic, based on the AHB bus clock frequency.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_timer1ms
    },
    {
        "TESTR",
        "This register is used to put the SATA block slave interface into a tes"
        "t mode and to select a Port for BIST operation.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sata_testr
    },
    {
        "VERSIONR",
        "This 32-bit read-only register contains a hard-coded ASCII string that"
        " represents the version level of the SATA block.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_sata_versionr
    },
    {
        "P0CLB",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_p0clb
    },
    {
        "P0FB",
        "",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_p0fb
    },
    {
        "P0IS",
        "This register is used to generate SATA block interrupt when any of the"
        " bits are set.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_sata_p0is
    },
    {
        "P0IE",
        "This register enables and disables the reporting of the corresponding "
        "interrupt to the software.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_sata_p0ie
    },
    {
        "P0CMD",
        "This register contains bits controlling various Port functions.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_sata_p0cmd
    },
    {
        "P0TFD",
        "This register contains Error and Status registers updated every time a"
        " new Register FIS, PIO Setup FIS, or Set Device Bits FIS is received f"
        "rom the device.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sata_p0tfd
    },
    {
        "P0SIG",
        "",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sata_p0sig
    },
    {
        "P0SSTS",
        "This 32-bit register conveys the current state of the interface and ho"
        "st.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sata_p0ssts
    },
    {
        "P0SCTL",
        "This 32-bit read-write register is used by the software to control SAT"
        "A interface capabilities.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sata_p0sctl
    },
    {
        "P0SERR",
        "This 32-bit register represents all the detected interface errors accu"
        "mulated since the last time it was cleared.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_sata_p0serr
    },
    {
        "P0SACT",
        "",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_p0sact
    },
    {
        "P0CI",
        "",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_p0ci
    },
    {
        "P0SNTF",
        "This register is used to determine when asynchronous notification even"
        "ts have occurred for directly connected devices and devices connected "
        "to a Port Multiplier.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sata_p0sntf
    },
    {
        "P0DMACR",
        "This register contains bits for controlling the Port DMA engine.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sata_p0dmacr
    },
    {
        "P0PHYCR",
        "This register is used for Port PHY control.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_sata_p0phycr
    },
    {
        "P0PHYSR",
        "This register is used to monitor PHY status.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sata_p0physr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMAARM
#endif

// Bitfields in register SDMAARM_MC0PTR.
static const field_t hw_sdmaarm_mc0ptr[] =
{
    {
        "MC0PTR",
        "Channel 0 Pointer contains the 32-bit address, in ARM platform memory,"
        " of channel 0 control block (the boot channel).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_INTR.
static const field_t hw_sdmaarm_intr[] =
{
    {
        "HI",
        "The ARM platform Interrupts register contains the 32 HI[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_STOP_STAT.
static const field_t hw_sdmaarm_stop_stat[] =
{
    {
        "HE",
        "This 32-bit register gives access to the ARM platform Enable bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_HSTART.
static const field_t hw_sdmaarm_hstart[] =
{
    {
        "HSTART",
        "The HSTART/HE registers are 32 bits wide with one bit for every channe"
        "l.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTOVR.
static const field_t hw_sdmaarm_evtovr[] =
{
    {
        "EO",
        "The Channel Event Override register contains the 32 EO[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_DSPOVR.
static const field_t hw_sdmaarm_dspovr[] =
{
    {
        "DO",
        "This register is reserved.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_HOSTOVR.
static const field_t hw_sdmaarm_hostovr[] =
{
    {
        "HO",
        "The Channel ARM platform Override register contains the 32 HO[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTPEND.
static const field_t hw_sdmaarm_evtpend[] =
{
    {
        "EP",
        "The Channel Event Pending register contains the 32 EP[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_RESET.
static const field_t hw_sdmaarm_reset[] =
{
    {
        "RESET",
        "When set, this bit causes the SDMA to be held in a software reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RESCHED",
        "When set, this bit forces the SDMA to reschedule as if a script had ex"
        "ecuted a done instruction.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTERR.
static const field_t hw_sdmaarm_evterr[] =
{
    {
        "CHNERR",
        "This register is used by the SDMA to warn the ARM platform when an inc"
        "oming DMA request was detected and it triggers a channel that is alrea"
        "dy pending or being serviced.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_INTRMASK.
static const field_t hw_sdmaarm_intrmask[] =
{
    {
        "HIMASK",
        "The Interrupt Mask Register contains 32 interrupt generation mask bits"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_PSW.
static const field_t hw_sdmaarm_psw[] =
{
    {
        "CCR",
        "The Current Channel Register indicates the number of the channel that "
        "is being executed by the SDMA.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CCP",
        "The Current Channel Priority indicates the priority of the current act"
        "ive channel.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCR",
        "The Next Channel Register indicates the number of the next scheduled p"
        "ending channel with the highest priority.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCP",
        "The Next Channel Priority gives the next pending channel priority.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTERRDBG.
static const field_t hw_sdmaarm_evterrdbg[] =
{
    {
        "CHNERR",
        "This register is the same as EVTERR, except reading it does not clear "
        "its contents.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CONFIG.
static const field_t hw_sdmaarm_config[] =
{
    {
        "CSM",
        "Selects the Context Switch Mode.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        "ARM platform DMA / SDMA Core Clock Ratio.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTDOBS",
        "Indicates if Real-Time Debug pins are used: They do not toggle by defa"
        "ult in order to reduce power consumption.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSPDMA",
        "This bit's function is reserved and should be configured as zero.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_LOCK.
static const field_t hw_sdmaarm_sdma_lock[] =
{
    {
        "LOCK",
        "The LOCK bit is used to restrict access to update SDMA script memory t"
        "hrough ROM channel zero scripts and through the OnCE interface under A"
        "RM platform control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRESET_LOCK_CLR",
        "The SRESET_LOCK_CLR bit determine if the LOCK bit is cleared on a soft"
        "ware reset triggered by writing to the RESET register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_ENB.
static const field_t hw_sdmaarm_once_enb[] =
{
    {
        "ENB",
        "The OnCE Enable register selects the OnCE control source: When cleared"
        " (0), the OnCE registers are accessed through the JTAG interface; when"
        " set (1), the OnCE registers may be accessed by the ARM platform throu"
        "gh the addresses described, as follows.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_DATA.
static const field_t hw_sdmaarm_once_data[] =
{
    {
        "DATA",
        "Data register of the OnCE JTAG controller.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_INSTR.
static const field_t hw_sdmaarm_once_instr[] =
{
    {
        "INSTR",
        "Instruction register of the OnCE JTAG controller.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_STAT.
static const field_t hw_sdmaarm_once_stat[] =
{
    {
        "ECDR",
        "Event Cell Debug Request.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST",
        "This flag is raised when the OnCE is controlled from the ARM platform "
        "peripheral interface.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWB",
        "This flag is raised when the SDMA has entered debug mode after a softw"
        "are breakpoint.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODR",
        "This flag is raised when the SDMA has entered debug mode after a OnCE "
        "debug request.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EDR",
        "This flag is raised when the SDMA has entered debug mode after an exte"
        "rnal debug request.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCV",
        "After each write access to the real time buffer (RTB), the RCV bit is "
        "set.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "The Processor Status bits reflect the state of the SDMA RISC engine.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_CMD.
static const field_t hw_sdmaarm_once_cmd[] =
{
    {
        "CMD",
        "Writing to this register will cause the OnCE to execute the command th"
        "at is written.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ILLINSTADDR.
static const field_t hw_sdmaarm_illinstaddr[] =
{
    {
        "ILLINSTADDR",
        "The Illegal Instruction Trap Address is the address where the SDMA jum"
        "ps when an illegal instruction is executed.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHN0ADDR.
static const field_t hw_sdmaarm_chn0addr[] =
{
    {
        "CHN0ADDR",
        "This 14-bit register is used by the boot code of the SDMA.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMSZ",
        "The bit 14 (Scratch Memory Size) determines if scratch memory must be "
        "available after every channel context.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVT_MIRROR.
static const field_t hw_sdmaarm_evt_mirror[] =
{
    {
        "EVENTS",
        "This register reflects the DMA requests received by the SDMA for event"
        "s 31-0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVT_MIRROR2.
static const field_t hw_sdmaarm_evt_mirror2[] =
{
    {
        "EVENTS",
        "This register reflects the DMA requests received by the SDMA for event"
        "s 47-32.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_XTRIG_CONF1.
static const field_t hw_sdmaarm_xtrig_conf1[] =
{
    {
        "NUM0",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF0",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM1",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF1",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM2",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF2",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM3",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF3",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_XTRIG_CONF2.
static const field_t hw_sdmaarm_xtrig_conf2[] =
{
    {
        "NUM4",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF4",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM5",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF5",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM6",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF6",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM7",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF7",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI0.
static const field_t hw_sdmaarm_sdma_chnpri0[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI1.
static const field_t hw_sdmaarm_sdma_chnpri1[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI2.
static const field_t hw_sdmaarm_sdma_chnpri2[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI3.
static const field_t hw_sdmaarm_sdma_chnpri3[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI4.
static const field_t hw_sdmaarm_sdma_chnpri4[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI5.
static const field_t hw_sdmaarm_sdma_chnpri5[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI6.
static const field_t hw_sdmaarm_sdma_chnpri6[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI7.
static const field_t hw_sdmaarm_sdma_chnpri7[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI8.
static const field_t hw_sdmaarm_sdma_chnpri8[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI9.
static const field_t hw_sdmaarm_sdma_chnpri9[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI10.
static const field_t hw_sdmaarm_sdma_chnpri10[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI11.
static const field_t hw_sdmaarm_sdma_chnpri11[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI12.
static const field_t hw_sdmaarm_sdma_chnpri12[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI13.
static const field_t hw_sdmaarm_sdma_chnpri13[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI14.
static const field_t hw_sdmaarm_sdma_chnpri14[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI15.
static const field_t hw_sdmaarm_sdma_chnpri15[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI16.
static const field_t hw_sdmaarm_sdma_chnpri16[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI17.
static const field_t hw_sdmaarm_sdma_chnpri17[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI18.
static const field_t hw_sdmaarm_sdma_chnpri18[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI19.
static const field_t hw_sdmaarm_sdma_chnpri19[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI20.
static const field_t hw_sdmaarm_sdma_chnpri20[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI21.
static const field_t hw_sdmaarm_sdma_chnpri21[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI22.
static const field_t hw_sdmaarm_sdma_chnpri22[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI23.
static const field_t hw_sdmaarm_sdma_chnpri23[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI24.
static const field_t hw_sdmaarm_sdma_chnpri24[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI25.
static const field_t hw_sdmaarm_sdma_chnpri25[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI26.
static const field_t hw_sdmaarm_sdma_chnpri26[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI27.
static const field_t hw_sdmaarm_sdma_chnpri27[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI28.
static const field_t hw_sdmaarm_sdma_chnpri28[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI29.
static const field_t hw_sdmaarm_sdma_chnpri29[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI30.
static const field_t hw_sdmaarm_sdma_chnpri30[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI31.
static const field_t hw_sdmaarm_sdma_chnpri31[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n .",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL0.
static const field_t hw_sdmaarm_sdma_chnenbl0[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL1.
static const field_t hw_sdmaarm_sdma_chnenbl1[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL2.
static const field_t hw_sdmaarm_sdma_chnenbl2[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL3.
static const field_t hw_sdmaarm_sdma_chnenbl3[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL4.
static const field_t hw_sdmaarm_sdma_chnenbl4[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL5.
static const field_t hw_sdmaarm_sdma_chnenbl5[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL6.
static const field_t hw_sdmaarm_sdma_chnenbl6[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL7.
static const field_t hw_sdmaarm_sdma_chnenbl7[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL8.
static const field_t hw_sdmaarm_sdma_chnenbl8[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL9.
static const field_t hw_sdmaarm_sdma_chnenbl9[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL10.
static const field_t hw_sdmaarm_sdma_chnenbl10[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL11.
static const field_t hw_sdmaarm_sdma_chnenbl11[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL12.
static const field_t hw_sdmaarm_sdma_chnenbl12[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL13.
static const field_t hw_sdmaarm_sdma_chnenbl13[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL14.
static const field_t hw_sdmaarm_sdma_chnenbl14[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL15.
static const field_t hw_sdmaarm_sdma_chnenbl15[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL16.
static const field_t hw_sdmaarm_sdma_chnenbl16[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL17.
static const field_t hw_sdmaarm_sdma_chnenbl17[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL18.
static const field_t hw_sdmaarm_sdma_chnenbl18[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL19.
static const field_t hw_sdmaarm_sdma_chnenbl19[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL20.
static const field_t hw_sdmaarm_sdma_chnenbl20[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL21.
static const field_t hw_sdmaarm_sdma_chnenbl21[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL22.
static const field_t hw_sdmaarm_sdma_chnenbl22[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL23.
static const field_t hw_sdmaarm_sdma_chnenbl23[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL24.
static const field_t hw_sdmaarm_sdma_chnenbl24[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL25.
static const field_t hw_sdmaarm_sdma_chnenbl25[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL26.
static const field_t hw_sdmaarm_sdma_chnenbl26[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL27.
static const field_t hw_sdmaarm_sdma_chnenbl27[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL28.
static const field_t hw_sdmaarm_sdma_chnenbl28[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL29.
static const field_t hw_sdmaarm_sdma_chnenbl29[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL30.
static const field_t hw_sdmaarm_sdma_chnenbl30[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL31.
static const field_t hw_sdmaarm_sdma_chnenbl31[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL32.
static const field_t hw_sdmaarm_sdma_chnenbl32[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL33.
static const field_t hw_sdmaarm_sdma_chnenbl33[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL34.
static const field_t hw_sdmaarm_sdma_chnenbl34[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL35.
static const field_t hw_sdmaarm_sdma_chnenbl35[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL36.
static const field_t hw_sdmaarm_sdma_chnenbl36[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL37.
static const field_t hw_sdmaarm_sdma_chnenbl37[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL38.
static const field_t hw_sdmaarm_sdma_chnenbl38[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL39.
static const field_t hw_sdmaarm_sdma_chnenbl39[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL40.
static const field_t hw_sdmaarm_sdma_chnenbl40[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL41.
static const field_t hw_sdmaarm_sdma_chnenbl41[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL42.
static const field_t hw_sdmaarm_sdma_chnenbl42[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL43.
static const field_t hw_sdmaarm_sdma_chnenbl43[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL44.
static const field_t hw_sdmaarm_sdma_chnenbl44[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL45.
static const field_t hw_sdmaarm_sdma_chnenbl45[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL46.
static const field_t hw_sdmaarm_sdma_chnenbl46[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL47.
static const field_t hw_sdmaarm_sdma_chnenbl47[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMAARM module.
static const reg_t hw_sdmaarm[] =
{
    {
        "MC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_mc0ptr
    },
    {
        "INTR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_intr
    },
    {
        "STOP_STAT",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_stop_stat
    },
    {
        "HSTART",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_hstart
    },
    {
        "EVTOVR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evtovr
    },
    {
        "DSPOVR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_dspovr
    },
    {
        "HOSTOVR",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_hostovr
    },
    {
        "EVTPEND",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evtpend
    },
    {
        "RESET",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sdmaarm_reset
    },
    {
        "EVTERR",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evterr
    },
    {
        "INTRMASK",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_intrmask
    },
    {
        "PSW",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sdmaarm_psw
    },
    {
        "EVTERRDBG",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evterrdbg
    },
    {
        "CONFIG",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_sdmaarm_config
    },
    {
        "SDMA_LOCK",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sdmaarm_sdma_lock
    },
    {
        "ONCE_ENB",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_enb
    },
    {
        "ONCE_DATA",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_data
    },
    {
        "ONCE_INSTR",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_instr
    },
    {
        "ONCE_STAT",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_sdmaarm_once_stat
    },
    {
        "ONCE_CMD",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_cmd
    },
    {
        "ILLINSTADDR",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_illinstaddr
    },
    {
        "CHN0ADDR",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sdmaarm_chn0addr
    },
    {
        "EVT_MIRROR",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evt_mirror
    },
    {
        "EVT_MIRROR2",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evt_mirror2
    },
    {
        "XTRIG_CONF1",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmaarm_xtrig_conf1
    },
    {
        "XTRIG_CONF2",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmaarm_xtrig_conf2
    },
    {
        "SDMA_CHNPRI0",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri0
    },
    {
        "SDMA_CHNPRI1",
        "",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri1
    },
    {
        "SDMA_CHNPRI2",
        "",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri2
    },
    {
        "SDMA_CHNPRI3",
        "",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri3
    },
    {
        "SDMA_CHNPRI4",
        "",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri4
    },
    {
        "SDMA_CHNPRI5",
        "",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri5
    },
    {
        "SDMA_CHNPRI6",
        "",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri6
    },
    {
        "SDMA_CHNPRI7",
        "",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri7
    },
    {
        "SDMA_CHNPRI8",
        "",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri8
    },
    {
        "SDMA_CHNPRI9",
        "",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri9
    },
    {
        "SDMA_CHNPRI10",
        "",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri10
    },
    {
        "SDMA_CHNPRI11",
        "",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri11
    },
    {
        "SDMA_CHNPRI12",
        "",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri12
    },
    {
        "SDMA_CHNPRI13",
        "",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri13
    },
    {
        "SDMA_CHNPRI14",
        "",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri14
    },
    {
        "SDMA_CHNPRI15",
        "",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri15
    },
    {
        "SDMA_CHNPRI16",
        "",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri16
    },
    {
        "SDMA_CHNPRI17",
        "",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri17
    },
    {
        "SDMA_CHNPRI18",
        "",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri18
    },
    {
        "SDMA_CHNPRI19",
        "",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri19
    },
    {
        "SDMA_CHNPRI20",
        "",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri20
    },
    {
        "SDMA_CHNPRI21",
        "",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri21
    },
    {
        "SDMA_CHNPRI22",
        "",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri22
    },
    {
        "SDMA_CHNPRI23",
        "",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri23
    },
    {
        "SDMA_CHNPRI24",
        "",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri24
    },
    {
        "SDMA_CHNPRI25",
        "",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri25
    },
    {
        "SDMA_CHNPRI26",
        "",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri26
    },
    {
        "SDMA_CHNPRI27",
        "",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri27
    },
    {
        "SDMA_CHNPRI28",
        "",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri28
    },
    {
        "SDMA_CHNPRI29",
        "",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri29
    },
    {
        "SDMA_CHNPRI30",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri30
    },
    {
        "SDMA_CHNPRI31",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri31
    },
    {
        "SDMA_CHNENBL0",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl0
    },
    {
        "SDMA_CHNENBL1",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl1
    },
    {
        "SDMA_CHNENBL2",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl2
    },
    {
        "SDMA_CHNENBL3",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl3
    },
    {
        "SDMA_CHNENBL4",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl4
    },
    {
        "SDMA_CHNENBL5",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl5
    },
    {
        "SDMA_CHNENBL6",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl6
    },
    {
        "SDMA_CHNENBL7",
        "",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl7
    },
    {
        "SDMA_CHNENBL8",
        "",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl8
    },
    {
        "SDMA_CHNENBL9",
        "",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl9
    },
    {
        "SDMA_CHNENBL10",
        "",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl10
    },
    {
        "SDMA_CHNENBL11",
        "",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl11
    },
    {
        "SDMA_CHNENBL12",
        "",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl12
    },
    {
        "SDMA_CHNENBL13",
        "",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl13
    },
    {
        "SDMA_CHNENBL14",
        "",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl14
    },
    {
        "SDMA_CHNENBL15",
        "",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl15
    },
    {
        "SDMA_CHNENBL16",
        "",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl16
    },
    {
        "SDMA_CHNENBL17",
        "",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl17
    },
    {
        "SDMA_CHNENBL18",
        "",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl18
    },
    {
        "SDMA_CHNENBL19",
        "",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl19
    },
    {
        "SDMA_CHNENBL20",
        "",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl20
    },
    {
        "SDMA_CHNENBL21",
        "",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl21
    },
    {
        "SDMA_CHNENBL22",
        "",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl22
    },
    {
        "SDMA_CHNENBL23",
        "",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl23
    },
    {
        "SDMA_CHNENBL24",
        "",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl24
    },
    {
        "SDMA_CHNENBL25",
        "",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl25
    },
    {
        "SDMA_CHNENBL26",
        "",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl26
    },
    {
        "SDMA_CHNENBL27",
        "",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl27
    },
    {
        "SDMA_CHNENBL28",
        "",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl28
    },
    {
        "SDMA_CHNENBL29",
        "",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl29
    },
    {
        "SDMA_CHNENBL30",
        "",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl30
    },
    {
        "SDMA_CHNENBL31",
        "",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl31
    },
    {
        "SDMA_CHNENBL32",
        "",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl32
    },
    {
        "SDMA_CHNENBL33",
        "",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl33
    },
    {
        "SDMA_CHNENBL34",
        "",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl34
    },
    {
        "SDMA_CHNENBL35",
        "",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl35
    },
    {
        "SDMA_CHNENBL36",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl36
    },
    {
        "SDMA_CHNENBL37",
        "",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl37
    },
    {
        "SDMA_CHNENBL38",
        "",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl38
    },
    {
        "SDMA_CHNENBL39",
        "",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl39
    },
    {
        "SDMA_CHNENBL40",
        "",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl40
    },
    {
        "SDMA_CHNENBL41",
        "",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl41
    },
    {
        "SDMA_CHNENBL42",
        "",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl42
    },
    {
        "SDMA_CHNENBL43",
        "",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl43
    },
    {
        "SDMA_CHNENBL44",
        "",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl44
    },
    {
        "SDMA_CHNENBL45",
        "",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl45
    },
    {
        "SDMA_CHNENBL46",
        "",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl46
    },
    {
        "SDMA_CHNENBL47",
        "",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl47
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMABP
#endif

// Bitfields in register SDMABP_DC0PTR.
static const field_t hw_sdmabp_dc0ptr[] =
{
    {
        "DC0PTR",
        "Channel 0 Pointer contains the 32-bit address, in BP memory, of the ar"
        "ray of channel control blocks starting with the one for channel 0 (the"
        " control channel).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_INTR.
static const field_t hw_sdmabp_intr[] =
{
    {
        "DI",
        "The BP Interrupts register contains the 32 DI[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_STOP_STAT.
static const field_t hw_sdmabp_stop_stat[] =
{
    {
        "DE",
        "This 32-bit register gives access to the BP (DSP) Enable bits, DE.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_DSTART.
static const field_t hw_sdmabp_dstart[] =
{
    {
        "DSTART",
        "The DSTART/DE registers are 32 bits wide with one bit for every channe"
        "l.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_EVTERR.
static const field_t hw_sdmabp_evterr[] =
{
    {
        "CHNERR",
        "This register is used by the SDMA to warn the BP when an incoming DMA "
        "request was detected; it then triggers a channel that is already pendi"
        "ng or being serviced, which may mean there is an overflow of data for "
        "that channel.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_INTRMASK.
static const field_t hw_sdmabp_intrmask[] =
{
    {
        "DIMASK",
        "The Interrupt Mask Register contains 32 interrupt generation mask bits"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_EVTERRDBG.
static const field_t hw_sdmabp_evterrdbg[] =
{
    {
        "CHNERR",
        "This register is the same as EVTERR except reading it does not clear i"
        "ts contents.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMABP module.
static const reg_t hw_sdmabp[] =
{
    {
        "DC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_dc0ptr
    },
    {
        "INTR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_intr
    },
    {
        "STOP_STAT",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_stop_stat
    },
    {
        "DSTART",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_dstart
    },
    {
        "EVTERR",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_evterr
    },
    {
        "INTRMASK",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_intrmask
    },
    {
        "EVTERRDBG",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_evterrdbg
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMACORE
#endif

// Bitfields in register SDMACORE_MC0PTR.
static const field_t hw_sdmacore_mc0ptr[] =
{
    {
        "MC0PTR",
        "Contains the address-in the ARM platform memory space-of the initial S"
        "DMA context and scripts that are loaded by the SDMA boot script runnin"
        "g on channel 0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCPTR.
static const field_t hw_sdmacore_ccptr[] =
{
    {
        "CCPTR",
        "Contains the start address of the context data for the current channel"
        ": Its value is CONTEXT_BASE + 24* CCR or CONTEXT_BASE + 32* CCR where "
        "CONTEXT_BASE = 0x0800.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCR.
static const field_t hw_sdmacore_ccr[] =
{
    {
        "CCR",
        "Contains the number of the current running channel whose context is in"
        "stalled.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_NCR.
static const field_t hw_sdmacore_ncr[] =
{
    {
        "NCR",
        "Contains the number of the pending channel that the scheduler has sele"
        "cted to run next.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EVENTS.
static const field_t hw_sdmacore_events[] =
{
    {
        "EVENTS",
        "Reflects the status of the SDMA's external DMA requests.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCPRI.
static const field_t hw_sdmacore_ccpri[] =
{
    {
        "CCPRI",
        "Contains the 3-bit priority of the channel whose context is installed.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_NCPRI.
static const field_t hw_sdmacore_ncpri[] =
{
    {
        "NCPRI",
        "Contains the 3-bit priority of the channel the scheduler has selected "
        "to run next.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ECOUNT.
static const field_t hw_sdmacore_ecount[] =
{
    {
        "ECOUNT",
        "The event cell counter contains the number of times minus one that an "
        "event detection must occur before generating a debug request.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ECTL.
static const field_t hw_sdmacore_ectl[] =
{
    {
        "ATS",
        "The access type select bits define the memory access type required on "
        "the SDMA memory bus.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AATC",
        "The Address A Trigger Condition (AATC) controls the operations perform"
        "ed by address comparator A.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABTC",
        "The Address B Trigger Condition (ABTC) controls the operations perform"
        "ed by address comparator B.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATC",
        "The address trigger condition bits select how the two address conditio"
        "ns (addressA and addressB) are combined to define the global address m"
        "atching condition.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTC",
        "The data trigger condition bits define when data is considered matchin"
        "g after comparison with the data register of the event detection unit.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECTC",
        "The event cell trigger condition bits select the combination of addres"
        "s and data matching conditions that generate the final address/data co"
        "ndition.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNT",
        "Event Counter Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN",
        "Event Cell Enable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAA.
static const field_t hw_sdmacore_eaa[] =
{
    {
        "EAA",
        "Event Cell Address Register A computes an address A condition.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAB.
static const field_t hw_sdmacore_eab[] =
{
    {
        "EAB",
        "Event Cell Address Register B computes an address B condition.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAM.
static const field_t hw_sdmacore_eam[] =
{
    {
        "EAM",
        "The Event Cell Address Mask contains a user-defined address mask value"
        ".",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ED.
static const field_t hw_sdmacore_ed[] =
{
    {
        "ED",
        "The event cell data register contains a user defined data value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EDM.
static const field_t hw_sdmacore_edm[] =
{
    {
        "EDM",
        "The event cell data mask register contains the user-defined data mask "
        "value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_RTB.
static const field_t hw_sdmacore_rtb[] =
{
    {
        "RTB",
        "The Real Time Buffer register stores and retrieves run time informatio"
        "n without putting the SDMA in debug mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_TB.
static const field_t hw_sdmacore_tb[] =
{
    {
        "CHFADDR",
        "The change of flow address is the address where the change of flow is "
        "taken when executing a change of flow instruction.",
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TADDR",
        "The target address is the address taken after the execution of the cha"
        "nge of flow instruction.",
        14, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TBF",
        "The Trace Buffer Flag is set when the buffer contains the addresses of"
        " a valid change of flow.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_OSTAT.
static const field_t hw_sdmacore_ostat[] =
{
    {
        "ECDR",
        "Event Cell Debug Request.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST",
        "This flag is raised when the OnCE is controlled from the ARM platform "
        "peripheral interface.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWB",
        "This flag is raised when the SDMA has entered debug mode after a softw"
        "are breakpoint.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODR",
        "This flag is raised when the SDMA has entered debug mode after a OnCE "
        "debug request.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EDR",
        "This flag is raised when the SDMA has entered debug mode after an exte"
        "rnal debug request.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCV",
        "After each write access to the real time buffer (RTB), the RCV bit is "
        "set.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "The Processor Status bits reflect the state of the SDMA RISC engine.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_MCHN0ADDR.
static const field_t hw_sdmacore_mchn0addr[] =
{
    {
        "CHN0ADDR",
        "Contains the address of the channel 0 routine programmed by the ARM pl"
        "atform; it is loaded into a general register at the very start of the "
        "boot and the SDMA jumps to the address it contains.",
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SMSZ",
        "The bit 14 (Scratch Memory Size) determines if scratch memory must be "
        "available after every channel context.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ENDIANNESS.
static const field_t hw_sdmacore_endianness[] =
{
    {
        "APEND",
        "APEND indicates the endian mode of the Peripheral and Burst DMA interf"
        "aces.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_SDMA_LOCK.
static const field_t hw_sdmacore_sdma_lock[] =
{
    {
        "LOCK",
        "The LOCK bit reports the value of the LOCK bit in the SDMA_LOCK status"
        " register.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EVENTS2.
static const field_t hw_sdmacore_events2[] =
{
    {
        "EVENTS",
        "Reflects the status of the SDMA's external DMA requests.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMACORE module.
static const reg_t hw_sdmacore[] =
{
    {
        "MC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_mc0ptr
    },
    {
        "CCPTR",
        "",
        4, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccptr
    },
    {
        "CCR",
        "",
        4, // Width in bytes
        0x00000003, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccr
    },
    {
        "NCR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ncr
    },
    {
        "EVENTS",
        "This register is very useful in the case of DMA requests that are acti"
        "ve when a peripheral FIFO level is above the programmed watermark.",
        4, // Width in bytes
        0x00000005, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_events
    },
    {
        "CCPRI",
        "",
        4, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccpri
    },
    {
        "NCPRI",
        "",
        4, // Width in bytes
        0x00000007, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ncpri
    },
    {
        "ECOUNT",
        "",
        4, // Width in bytes
        0x00000009, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_ecount
    },
    {
        "ECTL",
        "",
        4, // Width in bytes
        0x0000000a, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmacore_ectl
    },
    {
        "EAA",
        "",
        4, // Width in bytes
        0x0000000b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eaa
    },
    {
        "EAB",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eab
    },
    {
        "EAM",
        "",
        4, // Width in bytes
        0x0000000d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eam
    },
    {
        "ED",
        "",
        4, // Width in bytes
        0x0000000e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_ed
    },
    {
        "EDM",
        "",
        4, // Width in bytes
        0x0000000f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_edm
    },
    {
        "RTB",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_rtb
    },
    {
        "TB",
        "",
        4, // Width in bytes
        0x00000019, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sdmacore_tb
    },
    {
        "OSTAT",
        "",
        4, // Width in bytes
        0x0000001a, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_sdmacore_ostat
    },
    {
        "MCHN0ADDR",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sdmacore_mchn0addr
    },
    {
        "ENDIANNESS",
        "",
        4, // Width in bytes
        0x0000001d, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_endianness
    },
    {
        "SDMA_LOCK",
        "",
        4, // Width in bytes
        0x0000001e, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_sdma_lock
    },
    {
        "EVENTS2",
        "",
        4, // Width in bytes
        0x0000001f, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_events2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SJC
#endif

// Bitfields in register SJC_GPUSR1.
static const field_t hw_sjc_gpusr1[] =
{
    {
        "A_DBG",
        "ARM core debug status bit  Bit 0 is the ARM core DBGACK (debug acknowl"
        "edge)  DBGACK can be overwritten in the ARM core DCR to force a partic"
        "ular DBGACK value.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A_WFI",
        "ARM core wait-for interrupt bit  Bit 1 is the ARM core standbywfi (sta"
        "nd by wait-for interrupt).",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S_STAT",
        "3 LSBits of SDMA core statusH.",
        2, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PLL_LOCK",
        "PLL_LOCK  A Combined PLL-Lock flag indicator, for all the PLL's.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPUSR2.
static const field_t hw_sjc_gpusr2[] =
{
    {
        "STBYWFI",
        "STBYWFI[3:0]  These bits provide status of \"Standby Wait-For-Interrup"
        "t\" state of all ARM cores.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S_STAT",
        "S_STAT[3:0]  SDMA debug status bits: debug_core_state[3:0]",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STBYWFE",
        "STBYWFE[3:0]  Reflecting the \"Standby Wait For Event\" signals of all"
        " cores.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPUSR3.
static const field_t hw_sjc_gpusr3[] =
{
    {
        "IPG_WAIT",
        "IPG_WAIT  CCM's \"ipg_wait\" signal indication",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPG_STOP",
        "IPG_STOP  CCM's \"ipg_stop\" signal indication",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYS_WAIT",
        "System In wait  Indication on System in wait mode (from CCM).",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPSSR.
static const field_t hw_sjc_gpssr[] =
{
    {
        "GPSSR",
        "General Purpose Secured Status Register  Register is used for testing "
        "and debug.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_DCR.
static const field_t hw_sjc_dcr[] =
{
    {
        "DE_TO_ARM",
        "ARM platform debug request input propagation  This bit controls the pr"
        "opagation of debug request to ARM platform (\"dbgreq\"), when the JTAG"
        " state machine is put in \"ENTER_DEBUG\" IR instruction.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_TO_SDMA",
        "SDMA debug request input propagation  This bit controls the propagatio"
        "n of debug request to SDMA, when the JTAG state machine is put in \"EN"
        "TER_DEBUG\" IR instruction..",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_OBS",
        "Debug observability  This bit controls the propagation of the \"system"
        " debug\" input to SJC  For i.MX 6x, the SJC's \"system_debug\" input i"
        "s tied to logic HIGH value, therefore, set of \"debug_obs\" bit, will "
        "result in unconditional assertion of DE_B pad.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIRECT_SDMA_REQ_EN",
        "Debug enable of the sdma debug request  This bit controls the propagat"
        "ion of debug request DE_B to the sdma.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIRECT_ARM_REQ_EN",
        "Pass Debug Enable event from DE_B pin to ARM platform debug request si"
        "gnal(s).",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_SSR.
static const field_t hw_sjc_ssr[] =
{
    {
        "KTF",
        "Kill Trace Enable fuse value",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KTA",
        "Kill Trace is active",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWF",
        "Software JTAG enable fuse  Status of the no SW disable JTAG fuse",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWE",
        "SW enable  SW JTAG enable status",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EBF",
        "External Boot fuse  Status of the external boot disable fuse",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EBG",
        "External boot granted  External boot enabled, requested and granted",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FT",
        "Fuse type  Fuse type bit - e-fuse or laser fuse",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SJM",
        "SJC Secure mode  Secure JTAG mode, as set by external fuses.",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSSTAT",
        "Response status  Response status bits",
        11, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOTIND",
        "Boot Indication  Inverted Internal Boot indication, i.e inverse of SRC"
        ": \"src_int_boot\" signal",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPCCR.
static const field_t hw_sjc_gpccr[] =
{
    {
        "SCLKR",
        "SDMA Clock ON Register - This bit forces the clock on of the SDMA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLKOFFDIS",
        "Disable/prevent ARM platform clock/power shutdown",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SJC module.
static const reg_t hw_sjc[] =
{
    {
        "GPUSR1",
        "The General Purpose Unsecured Status Register 1 is a read only registe"
        "rs used to check the status of the different Cores and of the PLL.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sjc_gpusr1
    },
    {
        "GPUSR2",
        "",
        4, // Width in bytes
        0x00000001, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sjc_gpusr2
    },
    {
        "GPUSR3",
        "",
        4, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sjc_gpusr3
    },
    {
        "GPSSR",
        "The General Purpose Secured Status Register is a read-only register us"
        "ed to check the status of the different critical information in the So"
        "C.",
        4, // Width in bytes
        0x00000003, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sjc_gpssr
    },
    {
        "DCR",
        "This register is used to control propagation of debug request from DE_"
        "B pad to the cores and debug signals from internal logic to the DE_B p"
        "ad.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_sjc_dcr
    },
    {
        "SSR",
        "",
        4, // Width in bytes
        0x00000005, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_sjc_ssr
    },
    {
        "GPCCR",
        "This register is used to configure clock related modes in SOC, see Sys"
        "tem Configuration chapter for more information.",
        4, // Width in bytes
        0x00000007, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sjc_gpccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPBA
#endif

// Bitfields in register SPBA_PRR0.
static const field_t hw_spba_prr0[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR1.
static const field_t hw_spba_prr1[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR2.
static const field_t hw_spba_prr2[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR3.
static const field_t hw_spba_prr3[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR4.
static const field_t hw_spba_prr4[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR5.
static const field_t hw_spba_prr5[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR6.
static const field_t hw_spba_prr6[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR7.
static const field_t hw_spba_prr7[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR8.
static const field_t hw_spba_prr8[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR9.
static const field_t hw_spba_prr9[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR10.
static const field_t hw_spba_prr10[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR11.
static const field_t hw_spba_prr11[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR12.
static const field_t hw_spba_prr12[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR13.
static const field_t hw_spba_prr13[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR14.
static const field_t hw_spba_prr14[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR15.
static const field_t hw_spba_prr15[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR16.
static const field_t hw_spba_prr16[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR17.
static const field_t hw_spba_prr17[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR18.
static const field_t hw_spba_prr18[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR19.
static const field_t hw_spba_prr19[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR20.
static const field_t hw_spba_prr20[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR21.
static const field_t hw_spba_prr21[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR22.
static const field_t hw_spba_prr22[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR23.
static const field_t hw_spba_prr23[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR24.
static const field_t hw_spba_prr24[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR25.
static const field_t hw_spba_prr25[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR26.
static const field_t hw_spba_prr26[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR27.
static const field_t hw_spba_prr27[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR28.
static const field_t hw_spba_prr28[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR29.
static const field_t hw_spba_prr29[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR30.
static const field_t hw_spba_prr30[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR31.
static const field_t hw_spba_prr31[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPBA module.
static const reg_t hw_spba[] =
{
    {
        "PRR0",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr0
    },
    {
        "PRR1",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr1
    },
    {
        "PRR2",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr2
    },
    {
        "PRR3",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr3
    },
    {
        "PRR4",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr4
    },
    {
        "PRR5",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr5
    },
    {
        "PRR6",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr6
    },
    {
        "PRR7",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr7
    },
    {
        "PRR8",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr8
    },
    {
        "PRR9",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr9
    },
    {
        "PRR10",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr10
    },
    {
        "PRR11",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr11
    },
    {
        "PRR12",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr12
    },
    {
        "PRR13",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr13
    },
    {
        "PRR14",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr14
    },
    {
        "PRR15",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr15
    },
    {
        "PRR16",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr16
    },
    {
        "PRR17",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr17
    },
    {
        "PRR18",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr18
    },
    {
        "PRR19",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr19
    },
    {
        "PRR20",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr20
    },
    {
        "PRR21",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr21
    },
    {
        "PRR22",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr22
    },
    {
        "PRR23",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr23
    },
    {
        "PRR24",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr24
    },
    {
        "PRR25",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr25
    },
    {
        "PRR26",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr26
    },
    {
        "PRR27",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr27
    },
    {
        "PRR28",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr28
    },
    {
        "PRR29",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr29
    },
    {
        "PRR30",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr30
    },
    {
        "PRR31",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr31
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPDIF
#endif

// Bitfields in register SPDIF_SCR.
static const field_t hw_spdif_scr[] =
{
    {
        "USRC_SEL",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSEL",
        "",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALCTRL",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TX_EN",
        "DMA Transmit Request Enable  (Tx FIFO empty)",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_RX_EN",
        "DMA Receive Request Enable  (RX FIFO full)",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFO_CTRL",
        "",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOFT_RESET",
        "When write 1 to this bit, it will cause SPDIF software reset.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOW_POWER",
        "When write 1 to this bit, it will cause SPDIF enter low-power mode.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOEMPTY_SEL",
        "",
        15, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXAUTOSYNC",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXAUTOSYNC",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFOFULL_SEL",
        "",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_RST",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_OFF",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_CTRL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCD.
static const field_t hw_spdif_srcd[] =
{
    {
        "USYNCMODE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRPC.
static const field_t hw_spdif_srpc[] =
{
    {
        "GAINSEL",
        "Gain selection:",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "LOCK bit to show that the internal DPLL is locked, read only",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKSRC_SEL",
        "Clock source selection, all other settings not shown are reserved:",
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIE.
static const field_t hw_spdif_sie[] =
{
    {
        "RXFIFOFUL",
        "SPDIF Rx FIFO full, can't be cleared with reg.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEM",
        "SPDIF Tx FIFO empty, can't be cleared with reg.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKLOSS",
        "SPDIF receiver loss of lock",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFORESYN",
        "Rx FIFO resync",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFOUNOV",
        "Rx FIFO underrun/overrun",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UQERR",
        "U/Q Channel framing error",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UQSYNC",
        "U/Q Channel sync found",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QRXOV",
        "Q Channel receive register overrun",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QRXFUL",
        "Q Channel receive register full, can't be cleared with reg.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URXOV",
        "U Channel receive register overrun",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URXFUL",
        "U Channel receive register full, can't be cleared with reg.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BITERR",
        "SPDIF receiver found parity bit error",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYMERR",
        "SPDIF receiver found illegal symbol",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALNOGOOD",
        "SPDIF validity flag no good",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNEW",
        "SPDIF receive change in value of control channel",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRESYN",
        "SPDIF Tx FIFO resync",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXUNOV",
        "SPDIF Tx FIFO under/overrun",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "SPDIF receiver's DPLL is locked",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIS.
static const field_t hw_spdif_sis[] =
{
    {
        "RXFIFOFUL",
        "SPDIF Rx FIFO full, can't be cleared with reg.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEM",
        "SPDIF Tx FIFO empty, can't be cleared with reg.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCKLOSS",
        "SPDIF receiver loss of lock",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFORESYN",
        "Rx FIFO resync",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFOUNOV",
        "Rx FIFO underrun/overrun",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UQERR",
        "U/Q Channel framing error",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UQSYNC",
        "U/Q Channel sync found",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QRXOV",
        "Q Channel receive register overrun",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QRXFUL",
        "Q Channel receive register full, can't be cleared with reg.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "URXOV",
        "U Channel receive register overrun",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "URXFUL",
        "U Channel receive register full, can't be cleared with reg.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BITERR",
        "SPDIF receiver found parity bit error",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYMERR",
        "SPDIF receiver found illegal symbol",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALNOGOOD",
        "SPDIF validity flag no good",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNEW",
        "SPDIF receive change in value of control channel",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXRESYN",
        "SPDIF Tx FIFO resync",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXUNOV",
        "SPDIF Tx FIFO under/overrun",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "SPDIF receiver's DPLL is locked",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRL.
static const field_t hw_spdif_srl[] =
{
    {
        "RXDATALEFT",
        "Processor receive SPDIF data left",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRR.
static const field_t hw_spdif_srr[] =
{
    {
        "RXDATARIGHT",
        "Processor receive SPDIF data right",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCSH.
static const field_t hw_spdif_srcsh[] =
{
    {
        "RXCCHANNEL_H",
        "SPDIF receive C channel register, contains first 24 bits of C channel "
        "without interpretation",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCSL.
static const field_t hw_spdif_srcsl[] =
{
    {
        "RXCCHANNEL_L",
        "SPDIF receive C channel register, contains next 24 bits of C channel w"
        "ithout interpretation",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRU.
static const field_t hw_spdif_sru[] =
{
    {
        "RXUCHANNEL",
        "SPDIF receive U channel register, contains next 3 U channel bytes",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "This is a 24-bit register the upper byte is unimplemented.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRQ.
static const field_t hw_spdif_srq[] =
{
    {
        "RXQCHANNEL",
        "SPDIF receive Q channel register, contains next 3 Q channel bytes",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STL.
static const field_t hw_spdif_stl[] =
{
    {
        "TXDATALEFT",
        "SPDIF transmit left channel data.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "This is a 24-bit register the upper byte is unimplemented.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STR.
static const field_t hw_spdif_str[] =
{
    {
        "TXDATARIGHT",
        "SPDIF transmit right channel data.",
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "This is a 24-bit register the upper byte is unimplemented.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STCSCH.
static const field_t hw_spdif_stcsch[] =
{
    {
        "TXCCHANNELCONS_H",
        "SPDIF transmit Cons.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STCSCL.
static const field_t hw_spdif_stcscl[] =
{
    {
        "TXCCHANNELCONS_L",
        "SPDIF transmit Cons.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRFM.
static const field_t hw_spdif_srfm[] =
{
    {
        "FREQMEAS",
        "Frequency measurement data",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STC.
static const field_t hw_spdif_stc[] =
{
    {
        "TXCLK_DF",
        "Divider factor (1-128)",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_ALL_CLK_EN",
        "Spdif transfer clock enable.When data is going to be transfered, this "
        "bit should be set to1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCLK_SOURCE",
        "",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYSCLK_DF",
        "system clock divider factor, 2~512.",
        11, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPDIF module.
static const reg_t hw_spdif[] =
{
    {
        "SCR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_spdif_scr
    },
    {
        "SRCD",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_srcd
    },
    {
        "SRPC",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_spdif_srpc
    },
    {
        "SIE",
        "The InterruptEn register (SPDIF_SIE) provides control over the enablin"
        "g of interrupts.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_spdif_sie
    },
    {
        "SIS",
        "The InterruptStat (SPDIF_SIS) register is a read only register that pr"
        "ovides the status on interrupt operations.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_spdif_sis
    },
    {
        "SRL",
        "SPDIFRxLeft register is an audio data reception register.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srl
    },
    {
        "SRR",
        "SPDIFRxRight register is an audio data reception register.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srr
    },
    {
        "SRCSH",
        "SPDIFRxCChannel_h register is a channel status reception register.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srcsh
    },
    {
        "SRCSL",
        "SPDIFRxCChannel_l register is a channel status reception register.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srcsl
    },
    {
        "SRU",
        "UChannelRx register is a user bits reception register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_sru
    },
    {
        "SRQ",
        "QChannelRx register is a user bits reception register.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srq
    },
    {
        "STL",
        "SPDIFTxLeft register is an audio data transmission register.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_stl
    },
    {
        "STR",
        "SPDIFTxRight register is an audio data transmission register.",
        4, // Width in bytes
        0x00000030, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_str
    },
    {
        "STCSCH",
        "SPDIFTxCChannelCons_h register is a channel status transmission regist"
        "er.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_stcsch
    },
    {
        "STCSCL",
        "SPDIFTxCChannelCons_l register is a channel status transmission regist"
        "er.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_stcscl
    },
    {
        "SRFM",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srfm
    },
    {
        "STC",
        "The SPDIFTxClk Control register includes the means to select the trans"
        "mit clock and frequency division.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spdif_stc
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SRC
#endif

// Bitfields in register SRC_SCR.
static const field_t hw_src_scr[] =
{
    {
        "WARM_RESET_ENABLE",
        "WARM reset enable bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_GPU_RST",
        "Software reset for gpu  this is a self clearing bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_VPU_RST",
        "Software reset for vpu  this is a self clearing bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_IPU1_RST",
        "Software reset for ipu1  Note: this is a self clearing bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_OPEN_VG_RST",
        "Software reset for open_vg  This is a self clearing bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM_RST_BYPASS_COUNT",
        "Defines the ckil cycles to count before bypassing the MMDC acknowledge"
        " for WARM reset.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_WDOG_RST",
        "Mask wdog_rst_b source.",
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EIM_RST",
        "EIM reset is needed in order to reconfigure the eim chip select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_IPU2_RST",
        "Software reset for ipu2  this is a self clearing bit.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_RST",
        "Software reset for core0 only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE1_RST",
        "Software reset for core1 only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE2_RST",
        "Software reset for core2 only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE3_RST",
        "Software reset for core3 only.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_DBG_RST",
        "Software reset for core0 debug only.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE1_DBG_RST",
        "Software reset for core1 debug only.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE2_DBG_RST",
        "Software reset for core2 debug only.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE3_DBG_RST",
        "Software reset for core3 debug only.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORES_DBG_RST",
        "Software reset for debug of arm platform only.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE1_ENABLE",
        "CPU core1 enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE2_ENABLE",
        "CPU core2 enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE3_ENABLE",
        "CPU core3 enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST_MSK_PG",
        "Do not assert debug resets after power gating event of cpu",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SBMR1.
static const field_t hw_src_sbmr1[] =
{
    {
        "BOOT_CFG1",
        "Please refer to fuse map.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG2",
        "Please refer to fuse map.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG3",
        "Please refer to fuse map.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG4",
        "Please refer to fuse map.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SRSR.
static const field_t hw_src_srsr[] =
{
    {
        "IPP_RESET_B",
        "Indicates whether reset was the result of ipp_reset_b pin (Power-up se"
        "quence)",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSU_RESET_B",
        "Indicates whether the reset was the result of the csu_reset_b input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_USER_RESET_B",
        "Indicates whether the reset was the result of the ipp_user_reset_b qua"
        "lified reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_RST_B",
        "IC Watchdog Time-out reset.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_RST_B",
        "HIGH - Z JTAG reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_SW_RST",
        "JTAG SW reset.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM_BOOT",
        "WARM boot indication shows that WARM boot was initiated by software.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SISR.
static const field_t hw_src_sisr[] =
{
    {
        "GPU_PASSED_RESET",
        "Interrupt generated to indicate that gpu passed software reset and is "
        "ready to be used",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VPU_PASSED_RESET",
        "Interrupt generated to indicate that vpu passed software reset and is "
        "ready to be used",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPU1_PASSED_RESET",
        "Interrupt generated to indicate that ipu passed software reset and is "
        "ready to be used",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OPEN_VG_PASSED_RESET",
        "Interrupt generated to indicate that open_vg passed software reset and"
        " is ready to be used",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPU2_PASSED_RESET",
        "Interrupt generated to indicate that ipu2 passed software reset and is"
        " ready to be used",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE0_WDOG_RST_REQ",
        "WDOG reset request from CPU core0.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE1_WDOG_RST_REQ",
        "WDOG reset request from CPU core1.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE2_WDOG_RST_REQ",
        "WDOG reset request from CPU core2.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE3_WDOG_RST_REQ",
        "WDOG reset request from CPU core3.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SIMR.
static const field_t hw_src_simr[] =
{
    {
        "MASK_GPU_PASSED_RESET",
        "mask interrupt generation due to gpu passed reset",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VPU_PASSED_RESET",
        "mask interrupt generation due to vpu passed reset",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_IPU_PASSED_RESET",
        "mask interrupt generation due to ipu passed reset",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_OPEN_VG_PASSED_RESET",
        "mask interrupt generation due to open_vg passed reset",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_IPU2_PASSED_RESET",
        "mask interrupt generation due to ipu2 passing reset",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SBMR2.
static const field_t hw_src_sbmr2[] =
{
    {
        "SEC_CONFIG",
        "Please refer to fuse map.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIR_BT_DIS",
        "Please refer to fuse map.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BT_FUSE_SEL",
        "BT_FUSE_SEL (connected to gpio bt_fuse_sel)",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BMOD",
        "Please refer to fuse map.",
        24, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEST_MODE",
        "Please refer to fuse map.",
        27, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SRC module.
static const reg_t hw_src[] =
{
    {
        "SCR",
        "The Reset control register (SCR), contains bits that control operation"
        " of the reset controller.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_src_scr
    },
    {
        "SBMR1",
        "The Boot Mode register (SBMR) contains bits that reflect the status of"
        " Boot Mode Pins of the chip.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_src_sbmr1
    },
    {
        "SRSR",
        "The SRSR is a write to one clear register which records the source of "
        "the reset events for the chip.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_src_srsr
    },
    {
        "SISR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_src_sisr
    },
    {
        "SIMR",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_src_simr
    },
    {
        "SBMR2",
        "The Boot Mode register (SBMR), contains bits that reflect the status o"
        "f Boot Mode Pins of the chip.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_src_sbmr2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SSI
#endif

// Bitfields in register SSI_SSI_STX0.
static const field_t hw_ssi_ssi_stx0[] =
{
    {
        "STXN",
        "SSI Transmit Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_STX1.
static const field_t hw_ssi_ssi_stx1[] =
{
    {
        "STXN",
        "SSI Transmit Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SRX0.
static const field_t hw_ssi_ssi_srx0[] =
{
    {
        "SRXN",
        "SSI Receive Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SRX1.
static const field_t hw_ssi_ssi_srx1[] =
{
    {
        "SRXN",
        "SSI Receive Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SCR.
static const field_t hw_ssi_ssi_scr[] =
{
    {
        "SSIEN",
        "SSIEN - SSI Enable  This bit is used to enable/disable the SSI.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        "Transmit Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        "Receive Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NET",
        "Network Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYN",
        "Synchronous Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "I2S_MODE",
        "I2S Mode Select.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYS_CLK_EN",
        "Network Clock (Oversampling Clock) Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCH_EN",
        "Two-Channel Operation Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_IST",
        "Clock Idle State.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFR_CLK_DIS",
        "Transmit Frame Clock Disable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFR_CLK_DIS",
        "Receive Frame Clock Disable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_TX_FS",
        "SYNC_FS_TX bit provides a safe window for TE to be visible to the inte"
        "rnal circuit which is just after FS occurrence.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SISR.
static const field_t hw_ssi_ssi_sisr[] =
{
    {
        "TFE0",
        "Transmit FIFO Empty 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFE1",
        "Transmit FIFO Empty 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFF0",
        "Receive FIFO Full 0.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFF1",
        "Receive FIFO Full 1.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RLS",
        "Receive Last Time Slot.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TLS",
        "Transmit Last Time Slot.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFS",
        "Receive Frame Sync.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFS",
        "Transmit Frame Sync.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TUE0",
        "Transmitter Underrun Error 0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUE1",
        "Transmitter Underrun Error 1.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROE0",
        "Receiver Overrun Error 0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROE1",
        "Receiver Overrun Error 1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDE0",
        "Transmit Data Register Empty 0.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDE1",
        "Transmit Data Register Empty 1.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR0",
        "Receive Data Ready 0.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR1",
        "Receive Data Ready 1.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXT",
        "Receive Tag Updated.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDDU",
        "Command Data Register Updated.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDAU",
        "Command Address Register Updated.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFRC",
        "Transmit Frame Complete.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFRC",
        "Receive Frame Complete.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SIER.
static const field_t hw_ssi_sier[] =
{
    {
        "ENABLE_BITS1",
        "Enable Bit.",
        0, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "Transmit Interrupt Enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMAE",
        "Transmit DMA Enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "Receive Interrupt Enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMAE",
        "Receive DMA Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BITS",
        "Enable Bit.",
        23, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_STCR.
static const field_t hw_ssi_ssi_stcr[] =
{
    {
        "TEFS",
        "Transmit Early Frame Sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSL",
        "Transmit Frame Sync Length.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSI",
        "Transmit Frame Sync Invert.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSCKP",
        "Transmit Clock Polarity.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSHFD",
        "Transmit Shift Direction.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDIR",
        "Transmit Clock Direction.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFDIR",
        "Transmit Frame Direction.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN0",
        "Transmit FIFO Enable 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN1",
        "Transmit FIFO Enable 1.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXBIT0",
        "Transmit Bit 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SRCR.
static const field_t hw_ssi_ssi_srcr[] =
{
    {
        "REFS",
        "Receive Early Frame Sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSL",
        "Receive Frame Sync Length.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSI",
        "Receive Frame Sync Invert.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSCKP",
        "Receive Clock Polarity.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSHFD",
        "Receive Shift Direction.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDIR",
        "Receive Clock Direction.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFDIR",
        "Receive Frame Direction.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN0",
        "Receive FIFO Enable 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN1",
        "Receive FIFO Enable 1.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXBIT0",
        "Receive Bit 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEXT",
        "Receive Data Extension.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_STCCR.
static const field_t hw_ssi_ssi_stccr[] =
{
    {
        "PM7_PM0",
        "Prescaler Modulus Select.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC4_DC0",
        "Frame Rate Divider Control.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL3_WL0",
        "Word Length Control.",
        13, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSR",
        "Prescaler Range.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV2",
        "Divide By 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SRCCR.
static const field_t hw_ssi_srccr[] =
{
    {
        "PM7_PM0",
        "Prescaler Modulus Select.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC4_DC0",
        "Frame Rate Divider Control.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL3_WL0",
        "Word Length Control.",
        13, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSR",
        "Prescaler Range.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV2",
        "Divide By 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SFCSR.
static const field_t hw_ssi_ssi_sfcsr[] =
{
    {
        "TFWM0",
        "Transmit FIFO Empty WaterMark 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFWM0",
        "Receive FIFO Full WaterMark 0.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFCNT0",
        "Transmit FIFO Counter 0.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFCNT0",
        "Receive FIFO Counter 0.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFWM1",
        "Transmit FIFO Empty WaterMark 1.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFWM1",
        "Receive FIFO Full WaterMark 1.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFCNT1",
        "Transmit FIFO Counter1.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFCNT1",
        "Receive FIFO Counter1.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACNT.
static const field_t hw_ssi_ssi_sacnt[] =
{
    {
        "AC97EN",
        "AC97 Mode Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FV",
        "Fixed/Variable Operation.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIF",
        "Tag in FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD",
        "Read Command.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR",
        "Write Command.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRDIV",
        "Frame Rate Divider.",
        5, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACADD.
static const field_t hw_ssi_ssi_sacadd[] =
{
    {
        "SACADD",
        "AC97 Command Address.",
        0, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACDAT.
static const field_t hw_ssi_ssi_sacdat[] =
{
    {
        "SACDAT",
        "AC97 Command Data.",
        0, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SATAG.
static const field_t hw_ssi_satag[] =
{
    {
        "SATAG",
        "AC97 Tag Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_STMSK.
static const field_t hw_ssi_ssi_stmsk[] =
{
    {
        "STMSK",
        "Transmit Mask.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SRMSK.
static const field_t hw_ssi_ssi_srmsk[] =
{
    {
        "SRMSK",
        "Receive Mask.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACCST.
static const field_t hw_ssi_ssi_saccst[] =
{
    {
        "SACCST",
        "AC97 Channel Status.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACCEN.
static const field_t hw_ssi_ssi_saccen[] =
{
    {
        "SACCEN",
        "AC97 Channel Enable.",
        0, // LSB
        9, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACCDIS.
static const field_t hw_ssi_ssi_saccdis[] =
{
    {
        "SACCDIS",
        "AC97 Channel Disable.",
        0, // LSB
        9, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SSI module.
static const reg_t hw_ssi[] =
{
    {
        "SSI_STX0",
        "Enable SSI (SSIEN=1) before writing to SSI Transmit Data Registers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_stx0
    },
    {
        "SSI_STX1",
        "Enable SSI (SSIEN=1) before writing to SSI Transmit Data Registers.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_stx1
    },
    {
        "SSI_SRX0",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_srx0
    },
    {
        "SSI_SRX1",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_srx1
    },
    {
        "SSI_SCR",
        "The SSI Control Register (SSI_SCR) sets up the SSI reset is controlled"
        " by bit 0 in the SSI_SCR.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ssi_ssi_scr
    },
    {
        "SSI_SISR",
        "The SSI Interrupt Status Register (SSI_SISR) is used to monitor the SS"
        "I.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_ssi_ssi_sisr
    },
    {
        "SIER",
        "The SSI Interrupt Enable Register (SIER) is a 25-bit register used to "
        "set up the SSI interrupts and DMA requests.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ssi_sier
    },
    {
        "SSI_STCR",
        "The SSI Transmit Configuration Register (SSI_STCR) is a read/write con"
        "trol register used to direct the transmit operation of the STCR contro"
        "ls the direction of the bit clock and frame sync ports, STCK and STFS.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ssi_ssi_stcr
    },
    {
        "SSI_SRCR",
        "The SSI Receive Configuration Register (SSI_SRCR) is a read/write cont"
        "rol register used to direct the receive operation of the SSI.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ssi_ssi_srcr
    },
    {
        "SSI_STCCR",
        "The SSI Transmit and Receive Control (SSI_STCCR and SSI_SRCCR) registe"
        "rs are 19-bit, read/write control registers used to direct the operati"
        "on of the SSI.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ssi_ssi_stccr
    },
    {
        "SRCCR",
        "The SSI Transmit and Receive Control (SSI_STCCR and SSI_SRCCR) registe"
        "rs are 19-bit, read/write control registers used to direct the operati"
        "on of the SSI.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ssi_srccr
    },
    {
        "SSI_SFCSR",
        "The SSI FIFO Control / Status Register indicates the status of the Tra"
        "nsmit FIFO Empty flag, with different settings of the Transmit FIFO Wa"
        "terMark bits and varying amounts of data in the Tx FIFO  .",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ssi_ssi_sfcsr
    },
    {
        "SSI_SACNT",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ssi_ssi_sacnt
    },
    {
        "SSI_SACADD",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_sacadd
    },
    {
        "SSI_SACDAT",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_sacdat
    },
    {
        "SATAG",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_satag
    },
    {
        "SSI_STMSK",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_stmsk
    },
    {
        "SSI_SRMSK",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_srmsk
    },
    {
        "SSI_SACCST",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_saccst
    },
    {
        "SSI_SACCEN",
        "",
        4, // Width in bytes
        0x00000054, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_saccen
    },
    {
        "SSI_SACCDIS",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_saccdis
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TEMPMON
#endif

// Bitfields in register TEMPMON_TEMPSENSE0.
static const field_t hw_tempmon_tempsense0[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1.
static const field_t hw_tempmon_tempsense1[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a TEMPMON module.
static const reg_t hw_tempmon[] =
{
    {
        "TEMPSENSE0",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0
    },
    {
        "TEMPSENSE1",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark UART
#endif

// Bitfields in register UART_URXD.
static const field_t hw_uart_urxd[] =
{
    {
        "RX_DATA",
        "Received Data .",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRERR",
        "In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bi"
        "t RS-485 data In RS232/IrDA mode, it is the Parity Error flag .",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BRK",
        "BREAK Detect.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRMERR",
        "Frame Error.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OVRRUN",
        "Receiver Overrun.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR",
        "Error Detect.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHARRDY",
        "Character Ready.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTXD.
static const field_t hw_uart_utxd[] =
{
    {
        "TX_DATA",
        "Transmit Data .",
        0, // LSB
        7, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR1.
static const field_t hw_uart_ucr1[] =
{
    {
        "UARTEN",
        "UART Enable .",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZE",
        "DOZE .",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDMAEN",
        "Aging DMA Timer Enable .",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDMAEN",
        "Transmitter Ready DMA Enable .",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNDBRK",
        "Send BREAK .",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSDEN",
        "RTS Delta Interrupt Enable .",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXMPTYEN",
        "Transmitter Empty Interrupt Enable .",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREN",
        "Infrared Interface Enable .",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDMAEN",
        "Receive Ready DMA Enable .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRDYEN",
        "Receiver Ready Interrupt Enable .",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICD",
        "Idle Condition Detect .",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDEN",
        "Idle Condition Detected Interrupt Enable .",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRDYEN",
        "Transmitter Ready Interrupt Enable .",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADBR",
        "Automatic Detection of Baud Rate .",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADEN",
        "Automatic Baud Rate Detection Interrupt Enable .",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR2.
static const field_t hw_uart_ucr2[] =
{
    {
        "SRST",
        "Software Reset .",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEN",
        "Receiver Enable .",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEN",
        "Transmitter Enable .",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATEN",
        "Aging Timer Enable .",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSEN",
        "Request to Send Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Word Size .",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STPB",
        "Stop .",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROE",
        "Parity Odd/Even .",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREN",
        "Parity Enable .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEC",
        "Request to Send Edge Control .",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCEN",
        "Escape Enable .",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTS",
        "Clear to Send .",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTSC",
        "CTS Pin Control .",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRTS",
        "Ignore RTS Pin .",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCI",
        "Escape Sequence Interrupt Enable .",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR3.
static const field_t hw_uart_ucr3[] =
{
    {
        "ACIEN",
        "Autobaud Counter Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVT",
        "Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA "
        "mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDMUXSEL",
        "RXD Muxed Input Selected.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTRDEN",
        "Data Terminal Ready Delta Enable .",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWAKEN",
        "Asynchronous WAKE Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIRINTEN",
        "Asynchronous IR WAKE Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEN",
        "Receive Status Interrupt Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADNIMP",
        "Autobaud Detection Not Improved-.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RI",
        "Ring Indicator .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCD",
        "Data Carrier Detect .",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSR",
        "Data Set Ready .",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAERREN",
        "Frame Error Interrupt Enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARERREN",
        "Parity Error Interrupt Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTREN",
        "Data Terminal Ready Interrupt Enable .",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPEC",
        "DTR/DSR Interrupt Edge Control .",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR4.
static const field_t hw_uart_ucr4[] =
{
    {
        "DREN",
        "Receive Data Ready Interrupt Enable .",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OREN",
        "Receiver Overrun Interrupt Enable .",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BKEN",
        "BREAK Condition Detected Interrupt Enable .",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCEN",
        "Transmit Complete Interrupt Enable .",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBYP",
        "Low Power Bypass .",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRSC",
        "IR Special Case .",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDDMAEN",
        "DMA IDLE Condition Detected Interrupt Enable Enables/Disables the rece"
        "ive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE"
        " flag in USR2[12]).",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKEN",
        "WAKE Interrupt Enable .",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRI",
        "Serial Infrared Interrupt Enable .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVR",
        "Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic lev"
        "el being sampled in In IrDA mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTSTL",
        "CTS Trigger Level .",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UFCR.
static const field_t hw_uart_ufcr[] =
{
    {
        "RXTL",
        "Receiver Trigger Level .",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEDTE",
        "DCE/DTE mode select .",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFDIV",
        "Reference Frequency Divider.",
        7, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXTL",
        "Transmitter Trigger Level .",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_USR1.
static const field_t hw_uart_usr1[] =
{
    {
        "SAD",
        "RS-485 Slave Address Detected Interrupt Flag.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWAKE",
        "Asynchronous WAKE Interrupt Flag.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIRINT",
        "Asynchronous IR WAKE Interrupt Flag.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDS",
        "Receiver IDLE Interrupt Flag.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DTRD",
        "DTR Delta.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AGTIM",
        "Ageing Timer Interrupt Flag.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRDY",
        "Receiver Ready Interrupt / DMA Flag .",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRAMERR",
        "Frame Error Interrupt Flag .",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCF",
        "Escape Sequence Interrupt Flag .",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSD",
        "RTS Delta.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRDY",
        "Transmitter Ready Interrupt / DMA Flag .",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTSS",
        "RTS Pin Status .",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PARITYERR",
        "Parity Error Interrupt Flag .",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_USR2.
static const field_t hw_uart_usr2[] =
{
    {
        "RDR",
        "Receive Data Ready -Indicates that at least 1 character is received an"
        "d written to the RxFIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ORE",
        "Overrun Error .",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRCD",
        "BREAK Condition Detected .",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDC",
        "Transmitter Complete .",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTSF",
        "RTS Edge Triggered Interrupt Flag.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCDIN",
        "Data Carrier Detect Input .",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DCDDELT",
        "Data Carrier Detect Delta .",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKE",
        "Wake .",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRINT",
        "Serial Infrared Interrupt Flag.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIIN",
        "Ring Indicator Input .",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIDELT",
        "Ring Indicator Delta .",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACST",
        "Autobaud Counter Stopped .",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE",
        "Idle Condition .",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTRF",
        "DTR edge triggered interrupt flag .",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFE",
        "Transmit Buffer FIFO Empty .",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADET",
        "Automatic Baud Rate Detect Complete .",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UESC.
static const field_t hw_uart_uesc[] =
{
    {
        "ESC_CHAR",
        "UART Escape Character .",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTIM.
static const field_t hw_uart_utim[] =
{
    {
        "TIM",
        "UART Escape Timer.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBIR.
static const field_t hw_uart_ubir[] =
{
    {
        "INC",
        "Incremental Numerator.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBMR.
static const field_t hw_uart_ubmr[] =
{
    {
        "MOD",
        "Modulator Denominator.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBRC.
static const field_t hw_uart_ubrc[] =
{
    {
        "BCNT",
        "Baud Rate Count Register.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_ONEMS.
static const field_t hw_uart_onems[] =
{
    {
        "ONEMS",
        "One Millisecond Register.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTS.
static const field_t hw_uart_uts[] =
{
    {
        "SOFTRST",
        "Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFULL",
        "RxFIFO FULL.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFULL",
        "TxFIFO FULL.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEMPTY",
        "RxFIFO Empty.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEMPTY",
        "TxFIFO Empty.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBG",
        "RX_fifo_debug_mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOPIR",
        "Loop TX and RX for IR Test (LOOPIR) .",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "debug_enable .",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Loop TX and RX for Test.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRCPERR",
        "Force Parity Error.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UMCR.
static const field_t hw_uart_umcr[] =
{
    {
        "MDEN",
        "9-bit data or Multidrop Mode (RS-485) Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLAM",
        "RS-485 Slave Address Detect Mode Selection.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB8",
        "Transmit RS-485 bit 8 (the ninth bit or 9 th bit).",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SADEN",
        "RS-485 Slave Address Detected Interrupt Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLADDR",
        "RS-485 Slave Address Character.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a UART module.
static const reg_t hw_uart[] =
{
    {
        "URXD",
        "The UART will yield a transfer error on the peripheral bus when core i"
        "s reading URXD register with receive interface disabled (RXEN=0 or UAR"
        "TEN=0).",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_uart_urxd
    },
    {
        "UTXD",
        "The UART will yield a transfer error on the peripheral bus when core i"
        "s writing into UART_URXD register with transmit interface disabled (TX"
        "EN=0 or UARTEN=0).",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_utxd
    },
    {
        "UCR1",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr1
    },
    {
        "UCR2",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr2
    },
    {
        "UCR3",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr3
    },
    {
        "UCR4",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_uart_ucr4
    },
    {
        "UFCR",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_uart_ufcr
    },
    {
        "USR1",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_uart_usr1
    },
    {
        "USR2",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_uart_usr2
    },
    {
        "UESC",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_uesc
    },
    {
        "UTIM",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_utim
    },
    {
        "UBIR",
        "This register can be written by both software and hardware.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_ubir
    },
    {
        "UBMR",
        "This register can be written by both software and hardware.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_ubmr
    },
    {
        "UBRC",
        "",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_uart_ubrc
    },
    {
        "ONEMS",
        "This register has been expanded from 16 bits to 24 bits.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_onems
    },
    {
        "UTS",
        "",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_uart_uts
    },
    {
        "UMCR",
        "",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_uart_umcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USB_ANALOG
#endif

// Bitfields in register USB_ANALOG_USB1_VBUS_DETECT.
static const field_t hw_usb_analog_usb1_vbus_detect[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CHARGER_RESISTOR",
        "Enable 125k pullup on USB_DP and 375k on USB_DN to provide USB_CHARGER"
        " functionality for USB.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB1_CHRG_DETECT.
static const field_t hw_usb_analog_usb1_chrg_detect[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB1_VBUS_DETECT_STAT.
static const field_t hw_usb_analog_usb1_vbus_detect_stat[] =
{
    {
        "SESSEND",
        "Session End for USB OTG.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BVALID",
        "Indicates VBus is valid for a B-peripheral.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVALID",
        "Indicates VBus is valid for a A-peripheral.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBUS_VALID",
        "VBus valid for USB OTG.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB1_CHRG_DETECT_STAT.
static const field_t hw_usb_analog_usb1_chrg_detect_stat[] =
{
    {
        "PLUG_CONTACT",
        "State of the USB plug contact detector.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHRG_DETECTED",
        "State of charger detection.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DM_STATE",
        "DM line state output of the charger detector.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_STATE",
        "DP line state output of the charger detector.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB1_MISC.
static const field_t hw_usb_analog_usb1_misc[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_VBUS_DETECT.
static const field_t hw_usb_analog_usb2_vbus_detect[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CHARGER_RESISTOR",
        "Enable 125k pullup on USB_DP and 375k on USB_DN to provide USB_CHARGER"
        " functionality for USB.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_CHRG_DETECT.
static const field_t hw_usb_analog_usb2_chrg_detect[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_VBUS_DETECT_STAT.
static const field_t hw_usb_analog_usb2_vbus_detect_stat[] =
{
    {
        "SESSEND",
        "Session End for USB OTG.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BVALID",
        "Indicates VBus is valid for a B-peripheral.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVALID",
        "Indicates VBus is valid for a A-peripheral.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBUS_VALID",
        "VBus valid for USB OTG.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_CHRG_DETECT_STAT.
static const field_t hw_usb_analog_usb2_chrg_detect_stat[] =
{
    {
        "PLUG_CONTACT",
        "State of the USB plug contact detector.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHRG_DETECTED",
        "State of charger detection.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DM_STATE",
        "DM line state output of the charger detector.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_STATE",
        "DP line state output of the charger detector.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_MISC.
static const field_t hw_usb_analog_usb2_misc[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_DIGPROG.
static const field_t hw_usb_analog_digprog[] =
{
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        8, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USB_ANALOG module.
static const reg_t hw_usb_analog[] =
{
    {
        "USB1_VBUS_DETECT",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usb_analog_usb1_vbus_detect
    },
    {
        "USB1_CHRG_DETECT",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_usb1_chrg_detect
    },
    {
        "USB1_VBUS_DETECT_STAT",
        "This register defines fields for USB VBUS Detect status.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_usb1_vbus_detect_stat
    },
    {
        "USB1_CHRG_DETECT_STAT",
        "This register defines fields for USB charger detect status.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_usb1_chrg_detect_stat
    },
    {
        "USB1_MISC",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_usb1_misc
    },
    {
        "USB2_VBUS_DETECT",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usb_analog_usb2_vbus_detect
    },
    {
        "USB2_CHRG_DETECT",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_usb2_chrg_detect
    },
    {
        "USB2_VBUS_DETECT_STAT",
        "This register defines fields for USB VBUS Detect status.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_usb2_vbus_detect_stat
    },
    {
        "USB2_CHRG_DETECT_STAT",
        "This register defines fields for USB charger detect status.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_usb2_chrg_detect_stat
    },
    {
        "USB2_MISC",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_usb2_misc
    },
    {
        "DIGPROG",
        "The DIGPROG register returns the digital program ID for the silicon.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_analog_digprog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBC
#endif

// Bitfields in register USBC_UOG_ID.
static const field_t hw_usbc_uog_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_HWGENERAL.
static const field_t hw_usbc_uog_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type  PHYM bit reset value: '0000b' for OTG controller cor"
        "e, '0100b' for Host-only controller core.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability  SM bit reset value is '00b'",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_HWHOST.
static const field_t hw_usbc_uog_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_HWDEVICE.
static const field_t hw_usbc_uog_hwdevice[] =
{
    {
        "DC",
        "Device Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVEP",
        "Device Endpoint Number",
        1, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_HWTXBUF.
static const field_t hw_usbc_uog_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_HWRXBUF.
static const field_t hw_usbc_uog_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_GPTIMER0LD.
static const field_t hw_usbc_uog_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_GPTIMER0CTRL.
static const field_t hw_usbc_uog_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software;  In repeat mode, the timer will count down to zero, gener"
        "ate an interrupt and automatically reload the counter value from GPTLD"
        " bits to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_GPTIMER1LD.
static const field_t hw_usbc_uog_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_GPTIMER1CTRL.
static const field_t hw_usbc_uog_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_SBUSCFG.
static const field_t hw_usbc_uog_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration  These bits control AHB maste"
        "r transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_CAPLENGTH.
static const field_t hw_usbc_uog_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_HCIVERSION.
static const field_t hw_usbc_uog_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number  Default value is '10h', whic"
        "h means EHCI rev1.0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_HCSPARAMS.
static const field_t hw_usbc_uog_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control  This field indicates whether the host controller i"
        "mplementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller  This field indicates the num"
        "ber of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR)  This bit indicates whether the ports su"
        "pport port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_HCCPARAMS.
static const field_t hw_usbc_uog_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability  This bit is set '0b' in all controller c"
        "ore, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag  If this bit is set to zero, then the sys"
        "tem software must use a frame list length of 1024 elements with this h"
        "ost controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability  If this bit is set to a one, th"
        "en the host controller supports the park feature for high-speed queue "
        "heads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_DCIVERSION.
static const field_t hw_usbc_uog_dciversion[] =
{
    {
        "DCIVERSION",
        "Device Controller Interface Version Number  Default value is '01h', wh"
        "ich means rev0.1.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_DCCPARAMS.
static const field_t hw_usbc_uog_dccparams[] =
{
    {
        "DEN",
        "Device Endpoint Number  This field indicates the number of endpoints b"
        "uilt into the device controller.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        "Device Capable  When this bit is 1, this controller is capable of oper"
        "ating as a USB 2.0 device.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HC",
        "Host Capable  When this bit is 1, this controller is capable of operat"
        "ing as an EHCI compatible USB 2.0 host controller.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_USBCMD.
static const field_t hw_usbc_uog_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS1",
        "See also bits 3-2  Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_USBSTS.
static const field_t hw_usbc_uog_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_USBINTR.
static const field_t hw_usbc_uog_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe  When this bit is one and the UI bit in n_USBSTS "
        "register is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable  When this bit is one and the UEI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable  When this bit is one and the PCI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable  When this bit is one and the FRI"
        " bit in n_USBSTS register is a one the controller will issue an interr"
        "upt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable  When this bit is one and the SEI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable  When this bit is one and the AAI bit i"
        "n n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable  When this bit is one and the URI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable  When this bit is one and the SRI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable  When this bit is one and the SLI bit in n_n_US"
        "BSTS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable  When this bit is one and the UPLII bit in n_USB"
        "STS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable  When this bit is one and the NAKI bit in n_USBST"
        "S register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable  When this bit is one, and the "
        "UAI bit in the n_USBSTS register is one, host controller will issue an"
        " interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable  When this bit is one, and the UPI "
        "bit in the n_USBSTS register is one, host controller will issue an int"
        "errupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable  When this bit is one and th"
        "e TI0 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable  When this bit is one and th"
        "e TI1 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_FRINDEX.
static const field_t hw_usbc_uog_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_PERIODICLISTBASE.
static const field_t hw_usbc_uog_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ASYNCLISTADDR.
static const field_t hw_usbc_uog_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_BURSTSIZE.
static const field_t hw_usbc_uog_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_TXFILLTUNING.
static const field_t hw_usbc_uog_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTNAK.
static const field_t hw_usbc_uog_endptnak[] =
{
    {
        "EPRN",
        "RX Endpoint NAK - R/WC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTN",
        "TX Endpoint NAK - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTNAKEN.
static const field_t hw_usbc_uog_endptnaken[] =
{
    {
        "EPRNE",
        "RX Endpoint NAK Enable - R/W.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTNE",
        "TX Endpoint NAK Enable - R/W.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_CONFIGFLAG.
static const field_t hw_usbc_uog_configflag[] =
{
    {
        "CF",
        "Configure Flag  Host software sets this bit as the last action in its "
        "process of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_PORTSC1.
static const field_t hw_usbc_uog_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width  This bit has no effect if serial interface"
        " engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select - Read Only  Serial Transceiver Select  1 Se"
        "rial Interface Engine is selected  0 Parallel Interface signals is sel"
        "ected  Serial Interface Engine can be used in combination with UTMI+/U"
        "LPI physical interface to provide FS/LS signaling instead of the paral"
        "lel interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS1",
        "Bit field {bit25, bit31, bit30}:  \"000b\" UTMI/UTMI+  \"001b\" Reserv"
        "ed  \"010b\" ULPI  \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only)  \"100"
        "b\" HSIC  Parallel Transceiver Select (bit25, bit31, bi30).",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_OTGSC.
static const field_t hw_usbc_uog_otgsc[] =
{
    {
        "VD",
        "VBUS_Discharge - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC",
        "VBUS Charge - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OT",
        "OTG Termination - Read/Write.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP",
        "Data Pulsing - Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDPU",
        "ID Pullup - Read/Write  This bit provide control over the ID pull-up r"
        "esister; 0 = off, 1 = on [default].",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID",
        "USB ID - Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVV",
        "A VBus Valid - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASV",
        "A Session Valid - Read Only.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSV",
        "B Session Valid - Read Only.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSE",
        "B Session End - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "_1MST",
        "1 millisecond timer toggle - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        "Data Bus Pulsing Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDIS",
        "USB ID Interrupt Status - Read/Write.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIS",
        "A VBus Valid Interrupt Status - Read/Write to Clear.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIS",
        "A Session Valid Interrupt Status - Read/Write to Clear.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIS",
        "B Session Valid Interrupt Status - Read/Write to Clear.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIS",
        "B Session End Interrupt Status - Read/Write to Clear.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_1MSS",
        "1 millisecond timer Interrupt Status - Read/Write to Clear.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIS",
        "Data Pulse Interrupt Status - Read/Write to Clear.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDIE",
        "USB ID Interrupt Enable - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIE",
        "A VBus Valid Interrupt Enable - Read/Write.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIE",
        "A Session Valid Interrupt Enable - Read/Write.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIE",
        "B Session Valid Interrupt Enable - Read/Write.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIE",
        "B Session End Interrupt Enable - Read/Write.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_1MSE",
        "1 millisecond timer Interrupt Enable - Read/Write",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIE",
        "Data Pulse Interrupt Enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_USBMODE.
static const field_t hw_usbc_uog_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTSETUPSTAT.
static const field_t hw_usbc_uog_endptsetupstat[] =
{
    {
        "ENDPTSETUPSTAT",
        "Setup Endpoint Status.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTPRIME.
static const field_t hw_usbc_uog_endptprime[] =
{
    {
        "PERB",
        "Prime Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PETB",
        "Prime Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTFLUSH.
static const field_t hw_usbc_uog_endptflush[] =
{
    {
        "FERB",
        "Flush Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FETB",
        "Flush Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTSTAT.
static const field_t hw_usbc_uog_endptstat[] =
{
    {
        "ERBR",
        "Endpoint Receive Buffer Ready -- Read Only.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETBR",
        "Endpoint Transmit Buffer Ready -- Read Only.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCOMPLETE.
static const field_t hw_usbc_uog_endptcomplete[] =
{
    {
        "ERCE",
        "Endpoint Receive Complete Event - RW/C.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCE",
        "Endpoint Transmit Complete Event - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCTRL0.
static const field_t hw_usbc_uog_endptctrl0[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write  0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write  00 Control  Endpoint0 is fixed as a Con"
        "trol End Point.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable  1 Enabled  Endpoint0 is always enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write  0 End Point OK [Default]  1 End Point "
        "Stalled  Software can write a one to this bit to force the endpoint to"
        " return a STALL handshake to the Host.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write  00 - Control  Endpoint0 is fixed as a C"
        "ontrol End Point.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable  1 Enabled  Endpoint0 is always enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCTRL1.
static const field_t hw_usbc_uog_endptctrl1[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write  0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit  0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCTRL2.
static const field_t hw_usbc_uog_endptctrl2[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write  0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit  0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCTRL3.
static const field_t hw_usbc_uog_endptctrl3[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write  0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit  0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCTRL4.
static const field_t hw_usbc_uog_endptctrl4[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write  0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit  0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCTRL5.
static const field_t hw_usbc_uog_endptctrl5[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write  0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit  0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCTRL6.
static const field_t hw_usbc_uog_endptctrl6[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write  0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit  0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG_ENDPTCTRL7.
static const field_t hw_usbc_uog_endptctrl7[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write  0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit  0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_ID.
static const field_t hw_usbc_uh1_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWGENERAL.
static const field_t hw_usbc_uh1_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type  PHYM bit reset value: '0000b' for OTG controller cor"
        "e, '0100b' for Host-only controller core.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability  SM bit reset value is '00b'",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWHOST.
static const field_t hw_usbc_uh1_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWTXBUF.
static const field_t hw_usbc_uh1_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWRXBUF.
static const field_t hw_usbc_uh1_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER0LD.
static const field_t hw_usbc_uh1_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER0CTRL.
static const field_t hw_usbc_uh1_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software;  In repeat mode, the timer will count down to zero, gener"
        "ate an interrupt and automatically reload the counter value from GPTLD"
        " bits to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER1LD.
static const field_t hw_usbc_uh1_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER1CTRL.
static const field_t hw_usbc_uh1_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_SBUSCFG.
static const field_t hw_usbc_uh1_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration  These bits control AHB maste"
        "r transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_CAPLENGTH.
static const field_t hw_usbc_uh1_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCIVERSION.
static const field_t hw_usbc_uh1_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number  Default value is '10h', whic"
        "h means EHCI rev1.0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCSPARAMS.
static const field_t hw_usbc_uh1_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control  This field indicates whether the host controller i"
        "mplementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller  This field indicates the num"
        "ber of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR)  This bit indicates whether the ports su"
        "pport port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCCPARAMS.
static const field_t hw_usbc_uh1_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability  This bit is set '0b' in all controller c"
        "ore, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag  If this bit is set to zero, then the sys"
        "tem software must use a frame list length of 1024 elements with this h"
        "ost controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability  If this bit is set to a one, th"
        "en the host controller supports the park feature for high-speed queue "
        "heads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBCMD.
static const field_t hw_usbc_uh1_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS1",
        "See also bits 3-2  Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBSTS.
static const field_t hw_usbc_uh1_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBINTR.
static const field_t hw_usbc_uh1_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe  When this bit is one and the UI bit in n_USBSTS "
        "register is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable  When this bit is one and the UEI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable  When this bit is one and the PCI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable  When this bit is one and the FRI"
        " bit in n_USBSTS register is a one the controller will issue an interr"
        "upt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable  When this bit is one and the SEI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable  When this bit is one and the AAI bit i"
        "n n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable  When this bit is one and the URI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable  When this bit is one and the SRI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable  When this bit is one and the SLI bit in n_n_US"
        "BSTS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable  When this bit is one and the UPLII bit in n_USB"
        "STS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable  When this bit is one and the NAKI bit in n_USBST"
        "S register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable  When this bit is one, and the "
        "UAI bit in the n_USBSTS register is one, host controller will issue an"
        " interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable  When this bit is one, and the UPI "
        "bit in the n_USBSTS register is one, host controller will issue an int"
        "errupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable  When this bit is one and th"
        "e TI0 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable  When this bit is one and th"
        "e TI1 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_FRINDEX.
static const field_t hw_usbc_uh1_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_PERIODICLISTBASE.
static const field_t hw_usbc_uh1_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_ASYNCLISTADDR.
static const field_t hw_usbc_uh1_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_BURSTSIZE.
static const field_t hw_usbc_uh1_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_TXFILLTUNING.
static const field_t hw_usbc_uh1_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_CONFIGFLAG.
static const field_t hw_usbc_uh1_configflag[] =
{
    {
        "CF",
        "Configure Flag  Host software sets this bit as the last action in its "
        "process of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_PORTSC1.
static const field_t hw_usbc_uh1_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width  This bit has no effect if serial interface"
        " engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select - Read Only  Serial Transceiver Select  1 Se"
        "rial Interface Engine is selected  0 Parallel Interface signals is sel"
        "ected  Serial Interface Engine can be used in combination with UTMI+/U"
        "LPI physical interface to provide FS/LS signaling instead of the paral"
        "lel interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS1",
        "Bit field {bit25, bit31, bit30}:  \"000b\" UTMI/UTMI+  \"001b\" Reserv"
        "ed  \"010b\" ULPI  \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only)  \"100"
        "b\" HSIC  Parallel Transceiver Select (bit25, bit31, bi30).",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBMODE.
static const field_t hw_usbc_uh1_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_ID.
static const field_t hw_usbc_uh2_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_HWGENERAL.
static const field_t hw_usbc_uh2_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type  PHYM bit reset value: '0000b' for OTG controller cor"
        "e, '0100b' for Host-only controller core.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability  SM bit reset value is '00b'",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_HWHOST.
static const field_t hw_usbc_uh2_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_HWTXBUF.
static const field_t hw_usbc_uh2_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_HWRXBUF.
static const field_t hw_usbc_uh2_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_GPTIMER0LD.
static const field_t hw_usbc_uh2_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_GPTIMER0CTRL.
static const field_t hw_usbc_uh2_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software;  In repeat mode, the timer will count down to zero, gener"
        "ate an interrupt and automatically reload the counter value from GPTLD"
        " bits to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_GPTIMER1LD.
static const field_t hw_usbc_uh2_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_GPTIMER1CTRL.
static const field_t hw_usbc_uh2_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_SBUSCFG.
static const field_t hw_usbc_uh2_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration  These bits control AHB maste"
        "r transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_CAPLENGTH.
static const field_t hw_usbc_uh2_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_HCIVERSION.
static const field_t hw_usbc_uh2_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number  Default value is '10h', whic"
        "h means EHCI rev1.0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_HCSPARAMS.
static const field_t hw_usbc_uh2_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control  This field indicates whether the host controller i"
        "mplementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller  This field indicates the num"
        "ber of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR)  This bit indicates whether the ports su"
        "pport port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_HCCPARAMS.
static const field_t hw_usbc_uh2_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability  This bit is set '0b' in all controller c"
        "ore, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag  If this bit is set to zero, then the sys"
        "tem software must use a frame list length of 1024 elements with this h"
        "ost controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability  If this bit is set to a one, th"
        "en the host controller supports the park feature for high-speed queue "
        "heads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_USBCMD.
static const field_t hw_usbc_uh2_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS1",
        "See also bits 3-2  Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_USBSTS.
static const field_t hw_usbc_uh2_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_USBINTR.
static const field_t hw_usbc_uh2_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe  When this bit is one and the UI bit in n_USBSTS "
        "register is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable  When this bit is one and the UEI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable  When this bit is one and the PCI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable  When this bit is one and the FRI"
        " bit in n_USBSTS register is a one the controller will issue an interr"
        "upt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable  When this bit is one and the SEI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable  When this bit is one and the AAI bit i"
        "n n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable  When this bit is one and the URI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable  When this bit is one and the SRI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable  When this bit is one and the SLI bit in n_n_US"
        "BSTS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable  When this bit is one and the UPLII bit in n_USB"
        "STS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable  When this bit is one and the NAKI bit in n_USBST"
        "S register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable  When this bit is one, and the "
        "UAI bit in the n_USBSTS register is one, host controller will issue an"
        " interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable  When this bit is one, and the UPI "
        "bit in the n_USBSTS register is one, host controller will issue an int"
        "errupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable  When this bit is one and th"
        "e TI0 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable  When this bit is one and th"
        "e TI1 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_FRINDEX.
static const field_t hw_usbc_uh2_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_PERIODICLISTBASE.
static const field_t hw_usbc_uh2_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_ASYNCLISTADDR.
static const field_t hw_usbc_uh2_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_BURSTSIZE.
static const field_t hw_usbc_uh2_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_TXFILLTUNING.
static const field_t hw_usbc_uh2_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_CONFIGFLAG.
static const field_t hw_usbc_uh2_configflag[] =
{
    {
        "CF",
        "Configure Flag  Host software sets this bit as the last action in its "
        "process of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_PORTSC1.
static const field_t hw_usbc_uh2_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width  This bit has no effect if serial interface"
        " engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select - Read Only  Serial Transceiver Select  1 Se"
        "rial Interface Engine is selected  0 Parallel Interface signals is sel"
        "ected  Serial Interface Engine can be used in combination with UTMI+/U"
        "LPI physical interface to provide FS/LS signaling instead of the paral"
        "lel interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS1",
        "Bit field {bit25, bit31, bit30}:  \"000b\" UTMI/UTMI+  \"001b\" Reserv"
        "ed  \"010b\" ULPI  \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only)  \"100"
        "b\" HSIC  Parallel Transceiver Select (bit25, bit31, bi30).",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH2_USBMODE.
static const field_t hw_usbc_uh2_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_ID.
static const field_t hw_usbc_uh3_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_HWGENERAL.
static const field_t hw_usbc_uh3_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type  PHYM bit reset value: '0000b' for OTG controller cor"
        "e, '0100b' for Host-only controller core.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability  SM bit reset value is '00b'",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_HWHOST.
static const field_t hw_usbc_uh3_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_HWTXBUF.
static const field_t hw_usbc_uh3_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_HWRXBUF.
static const field_t hw_usbc_uh3_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_GPTIMER0LD.
static const field_t hw_usbc_uh3_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_GPTIMER0CTRL.
static const field_t hw_usbc_uh3_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software;  In repeat mode, the timer will count down to zero, gener"
        "ate an interrupt and automatically reload the counter value from GPTLD"
        " bits to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_GPTIMER1LD.
static const field_t hw_usbc_uh3_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_GPTIMER1CTRL.
static const field_t hw_usbc_uh3_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_SBUSCFG.
static const field_t hw_usbc_uh3_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration  These bits control AHB maste"
        "r transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_CAPLENGTH.
static const field_t hw_usbc_uh3_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_HCIVERSION.
static const field_t hw_usbc_uh3_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number  Default value is '10h', whic"
        "h means EHCI rev1.0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_HCSPARAMS.
static const field_t hw_usbc_uh3_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control  This field indicates whether the host controller i"
        "mplementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller  This field indicates the num"
        "ber of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR)  This bit indicates whether the ports su"
        "pport port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_HCCPARAMS.
static const field_t hw_usbc_uh3_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability  This bit is set '0b' in all controller c"
        "ore, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag  If this bit is set to zero, then the sys"
        "tem software must use a frame list length of 1024 elements with this h"
        "ost controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability  If this bit is set to a one, th"
        "en the host controller supports the park feature for high-speed queue "
        "heads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_USBCMD.
static const field_t hw_usbc_uh3_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS1",
        "See also bits 3-2  Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_USBSTS.
static const field_t hw_usbc_uh3_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_USBINTR.
static const field_t hw_usbc_uh3_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe  When this bit is one and the UI bit in n_USBSTS "
        "register is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable  When this bit is one and the UEI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable  When this bit is one and the PCI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable  When this bit is one and the FRI"
        " bit in n_USBSTS register is a one the controller will issue an interr"
        "upt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable  When this bit is one and the SEI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable  When this bit is one and the AAI bit i"
        "n n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable  When this bit is one and the URI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable  When this bit is one and the SRI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable  When this bit is one and the SLI bit in n_n_US"
        "BSTS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable  When this bit is one and the UPLII bit in n_USB"
        "STS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable  When this bit is one and the NAKI bit in n_USBST"
        "S register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable  When this bit is one, and the "
        "UAI bit in the n_USBSTS register is one, host controller will issue an"
        " interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable  When this bit is one, and the UPI "
        "bit in the n_USBSTS register is one, host controller will issue an int"
        "errupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable  When this bit is one and th"
        "e TI0 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable  When this bit is one and th"
        "e TI1 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_FRINDEX.
static const field_t hw_usbc_uh3_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_PERIODICLISTBASE.
static const field_t hw_usbc_uh3_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_ASYNCLISTADDR.
static const field_t hw_usbc_uh3_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_BURSTSIZE.
static const field_t hw_usbc_uh3_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_TXFILLTUNING.
static const field_t hw_usbc_uh3_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_CONFIGFLAG.
static const field_t hw_usbc_uh3_configflag[] =
{
    {
        "CF",
        "Configure Flag  Host software sets this bit as the last action in its "
        "process of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_PORTSC1.
static const field_t hw_usbc_uh3_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width  This bit has no effect if serial interface"
        " engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select - Read Only  Serial Transceiver Select  1 Se"
        "rial Interface Engine is selected  0 Parallel Interface signals is sel"
        "ected  Serial Interface Engine can be used in combination with UTMI+/U"
        "LPI physical interface to provide FS/LS signaling instead of the paral"
        "lel interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS1",
        "Bit field {bit25, bit31, bit30}:  \"000b\" UTMI/UTMI+  \"001b\" Reserv"
        "ed  \"010b\" ULPI  \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only)  \"100"
        "b\" HSIC  Parallel Transceiver Select (bit25, bit31, bi30).",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH3_USBMODE.
static const field_t hw_usbc_uh3_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBC module.
static const reg_t hw_usbc[] =
{
    {
        "UOG_ID",
        "The ID register identifies the USB 2.0 High-Speed core and its revisio"
        "n.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog_id
    },
    {
        "UOG_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog_hwgeneral
    },
    {
        "UOG_HWHOST",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog_hwhost
    },
    {
        "UOG_HWDEVICE",
        "This register is only available in OTG core.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog_hwdevice
    },
    {
        "UOG_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog_hwtxbuf
    },
    {
        "UOG_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog_hwrxbuf
    },
    {
        "UOG_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog_gptimer0ld
    },
    {
        "UOG_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog_gptimer0ctrl
    },
    {
        "UOG_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog_gptimer1ld
    },
    {
        "UOG_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog_gptimer1ctrl
    },
    {
        "UOG_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog_sbuscfg
    },
    {
        "UOG_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog_caplength
    },
    {
        "UOG_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000102, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog_hciversion
    },
    {
        "UOG_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uog_hcsparams
    },
    {
        "UOG_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uog_hccparams
    },
    {
        "UOG_DCIVERSION",
        "This register indicates the two-byte BCD encoding of the device contro"
        "ller interface version number.",
        2, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog_dciversion
    },
    {
        "UOG_DCCPARAMS",
        "These fields describe the overall device capability of the controller.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog_dccparams
    },
    {
        "UOG_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog_usbcmd
    },
    {
        "UOG_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uog_usbsts
    },
    {
        "UOG_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uog_usbintr
    },
    {
        "UOG_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog_frindex
    },
    {
        "UOG_PERIODICLISTBASE",
        "Host Controller only  This 32-bit register contains the beginning addr"
        "ess of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog_periodiclistbase
    },
    {
        "UOG_ASYNCLISTADDR",
        "Host Controller only  This 32-bit register contains the address of the"
        " next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog_asynclistaddr
    },
    {
        "UOG_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog_burstsize
    },
    {
        "UOG_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uog_txfilltuning
    },
    {
        "UOG_ENDPTNAK",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog_endptnak
    },
    {
        "UOG_ENDPTNAKEN",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog_endptnaken
    },
    {
        "UOG_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog_configflag
    },
    {
        "UOG_PORTSC1",
        "Host Controller  A host controller could implement one to eight port s"
        "tatus and control registers.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uog_portsc1
    },
    {
        "UOG_OTGSC",
        "This register is availabe only in OTG controller core.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_usbc_uog_otgsc
    },
    {
        "UOG_USBMODE",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog_usbmode
    },
    {
        "UOG_ENDPTSETUPSTAT",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog_endptsetupstat
    },
    {
        "UOG_ENDPTPRIME",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog_endptprime
    },
    {
        "UOG_ENDPTFLUSH",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog_endptflush
    },
    {
        "UOG_ENDPTSTAT",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog_endptstat
    },
    {
        "UOG_ENDPTCOMPLETE",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog_endptcomplete
    },
    {
        "UOG_ENDPTCTRL0",
        "Every Device implements Endpoint 0 as a control endpoint.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbc_uog_endptctrl0
    },
    {
        "UOG_ENDPTCTRL1",
        "This is endpoint control register for endpoint 1 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog_endptctrl1
    },
    {
        "UOG_ENDPTCTRL2",
        "This is endpoint control register for endpoint 2 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog_endptctrl2
    },
    {
        "UOG_ENDPTCTRL3",
        "This is endpoint control register for endpoint 3 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog_endptctrl3
    },
    {
        "UOG_ENDPTCTRL4",
        "This is endpoint control register for endpoint 4 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog_endptctrl4
    },
    {
        "UOG_ENDPTCTRL5",
        "This is endpoint control register for endpoint 5 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog_endptctrl5
    },
    {
        "UOG_ENDPTCTRL6",
        "This is endpoint control register for endpoint 6 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog_endptctrl6
    },
    {
        "UOG_ENDPTCTRL7",
        "This is endpoint control register for endpoint 7 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog_endptctrl7
    },
    {
        "UH1_ID",
        "The ID register identifies the USB 2.0 High-Speed core and its revisio"
        "n.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_id
    },
    {
        "UH1_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_hwgeneral
    },
    {
        "UH1_HWHOST",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwhost
    },
    {
        "UH1_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwtxbuf
    },
    {
        "UH1_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwrxbuf
    },
    {
        "UH1_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_gptimer0ld
    },
    {
        "UH1_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_gptimer0ctrl
    },
    {
        "UH1_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_gptimer1ld
    },
    {
        "UH1_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_gptimer1ctrl
    },
    {
        "UH1_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_sbuscfg
    },
    {
        "UH1_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_caplength
    },
    {
        "UH1_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000302, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_hciversion
    },
    {
        "UH1_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uh1_hcsparams
    },
    {
        "UH1_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uh1_hccparams
    },
    {
        "UH1_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uh1_usbcmd
    },
    {
        "UH1_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uh1_usbsts
    },
    {
        "UH1_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uh1_usbintr
    },
    {
        "UH1_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_frindex
    },
    {
        "UH1_PERIODICLISTBASE",
        "Host Controller only  This 32-bit register contains the beginning addr"
        "ess of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_periodiclistbase
    },
    {
        "UH1_ASYNCLISTADDR",
        "Host Controller only  This 32-bit register contains the address of the"
        " next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_asynclistaddr
    },
    {
        "UH1_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_burstsize
    },
    {
        "UH1_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_txfilltuning
    },
    {
        "UH1_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_configflag
    },
    {
        "UH1_PORTSC1",
        "Host Controller  A host controller could implement one to eight port s"
        "tatus and control registers.",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uh1_portsc1
    },
    {
        "UH1_USBMODE",
        "",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_usbmode
    },
    {
        "UH2_ID",
        "The ID register identifies the USB 2.0 High-Speed core and its revisio"
        "n.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh2_id
    },
    {
        "UH2_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh2_hwgeneral
    },
    {
        "UH2_HWHOST",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh2_hwhost
    },
    {
        "UH2_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh2_hwtxbuf
    },
    {
        "UH2_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh2_hwrxbuf
    },
    {
        "UH2_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_gptimer0ld
    },
    {
        "UH2_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh2_gptimer0ctrl
    },
    {
        "UH2_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_gptimer1ld
    },
    {
        "UH2_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh2_gptimer1ctrl
    },
    {
        "UH2_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_sbuscfg
    },
    {
        "UH2_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_caplength
    },
    {
        "UH2_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000502, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_hciversion
    },
    {
        "UH2_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uh2_hcsparams
    },
    {
        "UH2_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uh2_hccparams
    },
    {
        "UH2_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uh2_usbcmd
    },
    {
        "UH2_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000544, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uh2_usbsts
    },
    {
        "UH2_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000548, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uh2_usbintr
    },
    {
        "UH2_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000054c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_frindex
    },
    {
        "UH2_PERIODICLISTBASE",
        "Host Controller only  This 32-bit register contains the beginning addr"
        "ess of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000554, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_periodiclistbase
    },
    {
        "UH2_ASYNCLISTADDR",
        "Host Controller only  This 32-bit register contains the address of the"
        " next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000558, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_asynclistaddr
    },
    {
        "UH2_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uh2_burstsize
    },
    {
        "UH2_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000564, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uh2_txfilltuning
    },
    {
        "UH2_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh2_configflag
    },
    {
        "UH2_PORTSC1",
        "Host Controller  A host controller could implement one to eight port s"
        "tatus and control registers.",
        4, // Width in bytes
        0x00000584, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uh2_portsc1
    },
    {
        "UH2_USBMODE",
        "",
        4, // Width in bytes
        0x000005a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh2_usbmode
    },
    {
        "UH3_ID",
        "The ID register identifies the USB 2.0 High-Speed core and its revisio"
        "n.",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh3_id
    },
    {
        "UH3_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh3_hwgeneral
    },
    {
        "UH3_HWHOST",
        "",
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh3_hwhost
    },
    {
        "UH3_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh3_hwtxbuf
    },
    {
        "UH3_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000614, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh3_hwrxbuf
    },
    {
        "UH3_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_gptimer0ld
    },
    {
        "UH3_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000684, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh3_gptimer0ctrl
    },
    {
        "UH3_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000688, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_gptimer1ld
    },
    {
        "UH3_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000068c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh3_gptimer1ctrl
    },
    {
        "UH3_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_sbuscfg
    },
    {
        "UH3_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_caplength
    },
    {
        "UH3_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000702, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_hciversion
    },
    {
        "UH3_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000704, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uh3_hcsparams
    },
    {
        "UH3_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000708, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uh3_hccparams
    },
    {
        "UH3_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000740, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uh3_usbcmd
    },
    {
        "UH3_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000744, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uh3_usbsts
    },
    {
        "UH3_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000748, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uh3_usbintr
    },
    {
        "UH3_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000074c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_frindex
    },
    {
        "UH3_PERIODICLISTBASE",
        "Host Controller only  This 32-bit register contains the beginning addr"
        "ess of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000754, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_periodiclistbase
    },
    {
        "UH3_ASYNCLISTADDR",
        "Host Controller only  This 32-bit register contains the address of the"
        " next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000758, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_asynclistaddr
    },
    {
        "UH3_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000760, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uh3_burstsize
    },
    {
        "UH3_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000764, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uh3_txfilltuning
    },
    {
        "UH3_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000780, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh3_configflag
    },
    {
        "UH3_PORTSC1",
        "Host Controller  A host controller could implement one to eight port s"
        "tatus and control registers.",
        4, // Width in bytes
        0x00000784, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uh3_portsc1
    },
    {
        "UH3_USBMODE",
        "",
        4, // Width in bytes
        0x000007a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh3_usbmode
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBNC
#endif

// Bitfields in register USBNC_USB_OTG_CTRL.
static const field_t hw_usbnc_usb_otg_ctrl[] =
{
    {
        "OVER_CUR_DIS",
        "Disable OTG Overcurrent Detection",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        "OTG Polarity of Overcurrent  The polarity of OTG port overcurrent even"
        "t",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        "OTG Power Polarity  This bit should be set according to power switch's"
        " enable polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "OTG Wake-up Interrupt Enable  This bit enables or disables the OTG wak"
        "e-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Force OTG UTMI PHY Reset  This bit is used to force a reset to the UTM"
        "I PHY.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSPENDM",
        "Force OTG UTMI PHY Suspend.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_ON_CLOCK",
        "Force OTG UTMI PHY clock output on even if suspend mode.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "OTG Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "OTG Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        "OTG Wake-up on ID change enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        "OTG wake-up on VBUS change enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "OTG Wake-up Interrupt Request  This bit indicates that a wake-up inter"
        "rupt request is received on the OTG port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH1_CTRL.
static const field_t hw_usbnc_usb_uh1_ctrl[] =
{
    {
        "OVER_CUR_DIS",
        "Disable Host 1 Overcurrent Detection",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        "Host 1 Polarity of Overcurrent  The polarity of Host 1 port overcurren"
        "t event",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        "Host1 Power Polarity  This bit should be set according to the power sw"
        "itch's enable polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "Host 1 Wake-up Interrupt Enable  This bit enables or disables the Host"
        " 1 wake-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Force Host 1 UTMI PHY Reset.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSPENDM",
        "Force Host 1 UTMI PHY Suspend.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_ON_CLOCK",
        "Force Host 1 UTMI PHY clock output on even if in low-power suspend mod"
        "e.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "Host 1 Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "Host 1 Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        "Host 1 Wake-up on ID change enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        "Host 1 wake-up on VBUS change enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "Host 1 Wake-up Interrupt Request  This bit indicates that a wake-up in"
        "terrupt request is received on the OTG port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH2_CTRL.
static const field_t hw_usbnc_usb_uh2_ctrl[] =
{
    {
        "WIE",
        "Host 2 Wake-up Interrupt Enable  This bit enables or disables the Host"
        " 2 wake-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Force Host 2 UTMI PHY Reset  This bit is used to force a reset to the "
        "UTMI PHY.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSPENDM",
        "Force Host 2 UTMI PHY Suspend  This bit is used to put PHY into suspen"
        "d mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_480M_CLK_ON",
        "Force OTG UTMI PHY 480M clock output on when Host 2 is not in suspend "
        "mode.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "Host 2 Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "Host 2 Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "Host 2 Wake-up Interrupt Request  This bit indicates that a wake-up in"
        "terrupt request is received on the Host 2 port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH3_CTRL.
static const field_t hw_usbnc_usb_uh3_ctrl[] =
{
    {
        "WIE",
        "Host 3 Wake-up Interrupt Enable  This bit enables or disables the Host"
        " 3 wake-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Force Host 3 UTMI PHY Reset  This bit is used to force a reset to the "
        "UTMI PHY.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSPENDM",
        "Force Host 3 UTMI PHY Suspend  This bit is used to put PHY into suspen"
        "d mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_480M_CLK_ON",
        "Force OTG UTMI PHY 480M clock output on when Host 3 is not in suspend "
        "mode.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "Host 3 Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "Host 3 Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "Host 3 Wake-up Interrupt Request  This bit indicates that a wake-up in"
        "terrupt request is received on the OTG port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH2_HSIC_CTRL.
static const field_t hw_usbnc_usb_uh2_hsic_ctrl[] =
{
    {
        "HSIC_CLK_ON",
        "Force Host2 HSIC module 480M clock on, even when in Host 2 is in suspe"
        "nd mode.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_EN",
        "Host2 HSIC enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_VLD",
        "Indicating whether Host2 HSIC clock is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH3_HSIC_CTRL.
static const field_t hw_usbnc_usb_uh3_hsic_ctrl[] =
{
    {
        "HSIC_CLK_ON",
        "Force Host3 HSIC module 480M clock on, even when in Host 2 is in suspe"
        "nd mode.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_EN",
        "Host3 HSIC enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_VLD",
        "Indicating whether Host3 HSIC clock is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG_PHY_CTRL_0.
static const field_t hw_usbnc_usb_otg_phy_ctrl_0[] =
{
    {
        "UTMI_CLK_VLD",
        "Indicating whether OTG UTMI PHY clock is valid",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH1_PHY_CTRL_0.
static const field_t hw_usbnc_usb_uh1_phy_ctrl_0[] =
{
    {
        "UTMI_CLK_VLD",
        "Indicating whether Host 1 UTMI PHY clock is valid",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBNC module.
static const reg_t hw_usbnc[] =
{
    {
        "USB_OTG_CTRL",
        "The USB OTG control register controls the integration specific feature"
        "s of the USB OTG module.",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbnc_usb_otg_ctrl
    },
    {
        "USB_UH1_CTRL",
        "The USB Host1 control register controls the integration specific featu"
        "res of the USB Host1 module.",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbnc_usb_uh1_ctrl
    },
    {
        "USB_UH2_CTRL",
        "The USB Host2 control register controls the integration specific featu"
        "res of the USB host2 module.",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbnc_usb_uh2_ctrl
    },
    {
        "USB_UH3_CTRL",
        "The USB Host3 control register controls the integration specific featu"
        "res of the USB Host3 module.",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbnc_usb_uh3_ctrl
    },
    {
        "USB_UH2_HSIC_CTRL",
        "The USB Host2 HSIC control register controls Host2 high speed IC confi"
        "guration.",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbnc_usb_uh2_hsic_ctrl
    },
    {
        "USB_UH3_HSIC_CTRL",
        "The USB Host3 HSIC control register controls Host3 high speed IC confi"
        "guration.",
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbnc_usb_uh3_hsic_ctrl
    },
    {
        "USB_OTG_PHY_CTRL_0",
        "USB OTG UTMI PHY control register 0 is used to control the on-chip OTG"
        " UTMI PHY.",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbnc_usb_otg_phy_ctrl_0
    },
    {
        "USB_UH1_PHY_CTRL_0",
        "USB Host1 UTMI PHY Control Register 0 are used to control the on-chip "
        "Host1 UTMI PHY.",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbnc_usb_uh1_phy_ctrl_0
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBPHY
#endif

// Bitfields in register USBPHY_PWD.
static const field_t hw_usbphy_pwd[] =
{
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX.
static const field_t hw_usbphy_tx[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code:  0000 = 0.16%  0111 = Nominal  1111 = +25%",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX.
static const field_t hw_usbphy_rx[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ":  000 = Trip-Level Voltage is 0.57500 V  001 = Trip-Level Voltage is "
        "0.56875 V  010 = Trip-Level Voltage is 0.58125 V  011 = Trip-Level Vol"
        "tage is 0.58750 V  1XX = Reserved",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL.
static const field_t hw_usbphy_ctrl[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_STATUS.
static const field_t hw_usbphy_status[] =
{
    {
        "HOSTDISCONDETECT_STATUS",
        "Indicates that the device has disconnected while in high-speed host mo"
        "de.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVPLUGIN_STATUS",
        "Indicates that the device has been connected on the USB_DP and USB_DM "
        "lines.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTGID_STATUS",
        "Indicates the results of ID pin on MiniAB plug.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_STATUS",
        "Indicates that the host is sending a wake-up after suspend and has tri"
        "ggered an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG.
static const field_t hw_usbphy_debug[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG0_STATUS.
static const field_t hw_usbphy_debug0_status[] =
{
    {
        "LOOP_BACK_FAIL_COUNT",
        "Running count of the failed pseudo-random generator loopback.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UTMI_RXERROR_FAIL_COUNT",
        "Running count of the UTMI_RXERROR.",
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCH_COUNT",
        "Running count of the squelch reset instead of normal end for HS RX.",
        26, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1.
static const field_t hw_usbphy_debug1[] =
{
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch:  00 = Delay is nominal  01 = D"
        "elay is +20%  10 = Delay is -20%  11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_VERSION.
static const field_t hw_usbphy_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBPHY module.
static const reg_t hw_usbphy[] =
{
    {
        "PWD",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbphy_pwd
    },
    {
        "TX",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_tx
    },
    {
        "RX",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_rx
    },
    {
        "CTRL",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        29, // Number of bitfields
        hw_usbphy_ctrl
    },
    {
        "STATUS",
        "The USB PHY Status Register holds results of IRQ and other detects.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbphy_status
    },
    {
        "DEBUG",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_debug
    },
    {
        "DEBUG0_STATUS",
        "The UTMI Debug Status Register 0 holds multiple views for counters and"
        " status of state machines.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_debug0_status
    },
    {
        "DEBUG1",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_debug1
    },
    {
        "VERSION",
        "Fields for RTL Version.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USDHC
#endif

// Bitfields in register USDHC_DS_ADDR.
static const field_t hw_usdhc_ds_addr[] =
{
    {
        "DS_ADDR",
        "DMA System Address: This register contains the 32-bit system memory ad"
        "dress for a DMA transfer.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_BLK_ATT.
static const field_t hw_usdhc_blk_att[] =
{
    {
        "BLKSIZE",
        "Transfer Block Size: This register specifies the block size for block "
        "data transfers.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLKCNT",
        "Blocks Count For Current Transfer: This register is enabled when the B"
        "lock Count Enable bit in the Transfer Mode register is set to 1 and is"
        " valid only for multiple block transfers.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_ARG.
static const field_t hw_usdhc_cmd_arg[] =
{
    {
        "CMDARG",
        "Command Argument: The SD/MMC Command Argument is specified as bits 39-"
        "8 of the Command Format in the SD or MMC Specification.This register i"
        "s write protected when the Command Inhibit (CMD) bit in the Present St"
        "ate register is set.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_XFR_TYP.
static const field_t hw_usdhc_cmd_xfr_typ[] =
{
    {
        "RSPTYP",
        "Response Type Select:",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCCEN",
        "Command CRC Check Enable: If this bit is set to 1, the uSDHC shall che"
        "ck the CRC field in the response.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CICEN",
        "Command Index Check Enable: If this bit is set to 1, the uSDHC will ch"
        "eck the Index field in the response to see if it has the same value as"
        " the command index.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPSEL",
        "Data Present Select: This bit is set to 1 to indicate that data is pre"
        "sent and shall be transferred using the DAT line.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDTYP",
        "Command Type: There are three types of special commands: Suspend, Resu"
        "me and Abort.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDINX",
        "Command Index: These bits shall be set to the command number that is s"
        "pecified in bits 45-40 of the Command-Format in the SD Memory Card Phy"
        "sical Layer Specification and SDIO Card Specification.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP0.
static const field_t hw_usdhc_cmd_rsp0[] =
{
    {
        "CMDRSP0",
        "Command Response 0: Refer to for the mapping of command responses from"
        " the SD Bus to this register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP1.
static const field_t hw_usdhc_cmd_rsp1[] =
{
    {
        "CMDRSP1",
        "Command Response 1: Refer to for the mapping of command responses from"
        " the SD Bus to this register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP2.
static const field_t hw_usdhc_cmd_rsp2[] =
{
    {
        "CMDRSP2",
        "Command Response 2: Refer to for the mapping of command responses from"
        " the SD Bus to this register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP3.
static const field_t hw_usdhc_cmd_rsp3[] =
{
    {
        "CMDRSP3",
        "Command Response 3: Refer to for the mapping of command responses from"
        " the SD Bus to this register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DATA_BUFF_ACC_PORT.
static const field_t hw_usdhc_data_buff_acc_port[] =
{
    {
        "DATCONT",
        "Data Content: The Buffer Data Port register is for 32-bit data access "
        "by the ARM platform or the external DMA.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_PRES_STATE.
static const field_t hw_usdhc_pres_state[] =
{
    {
        "CIHB",
        "Command Inhibit (CMD): If this status bit is 0, it indicates that the "
        "CMD line is not in use and the uSDHC can issue a SD/MMC Command using "
        "the CMD line.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDIHB",
        "Command Inhibit (DAT): This status bit is generated if either the DAT "
        "Line Active or the Read Transfer Active is set to 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLA",
        "Data Line Active This status bit indicates whether one of the DAT line"
        "s on the SD Bus is in use.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDSTB",
        "SD Clock Stable This status bit indicates that the internal card clock"
        " is stable.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPGOFF",
        "ipg_clk Gated Off Internally: This status bit indicates that the ipg_c"
        "lk is internally gated off.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HCKOFF",
        "hclk Gated Off Internally: This status bit indicates that the hclk is "
        "internally gated off.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PEROFF",
        "ipg_perclk Gated Off Internally: This status bit indicates that the ip"
        "g_perclk is internally gated off.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDOFF",
        "SD Clock Gated Off Internally: This status bit indicates that the SD C"
        "lock is internally gated off, because of buffer over/under-run or read"
        " pause without read wait assertion, or the driver set FRC_SDCLK_ON bit"
        " is 0 to stop the SD clock in idle status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WTA",
        "Write Transfer Active: This status bit indicates a write transfer is a"
        "ctive.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTA",
        "Read Transfer Active: This status bit is used for detecting completion"
        " of a read transfer.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BWEN",
        "Buffer Write Enable: This status bit is used for non-DMA write transfe"
        "rs.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BREN",
        "Buffer Read Enable: This status bit is used for non-DMA read transfers"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTR",
        "Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may re"
        "quest Host Driver to execute re-tuning sequence by setting this bit wh"
        "en the data window is shifted by temperature drift and a tuned samplin"
        "g point does not have a good margin to receive correct data.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CINST",
        "Card Inserted: This bit indicates whether a card has been inserted.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDPL",
        "Card Detect Pin Level: This bit reflects the inverse value of the CD# "
        "pin for the card socket.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WPSPL",
        "Write Protect Switch Pin Level: The Write Protect Switch is supported "
        "for memory and combo cards.This bit reflects the inverted value of the"
        " WP pin of the card socket.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLSL",
        "CMD Line Signal Level: This status is used to check the CMD line level"
        " to recover from errors, and for debugging.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLSL",
        "DAT[7:0] Line Signal Level: This status is used to check the DAT line "
        "level to recover from errors, and for debugging.This is especially use"
        "ful in detecting the busy signal level from DAT[0].",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_PROT_CTRL.
static const field_t hw_usdhc_prot_ctrl[] =
{
    {
        "LCTL",
        "LED Control: This bit, fully controlled by the Host Driver, is used to"
        " caution the user not to remove the card while the card is being acces"
        "sed.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTW",
        "Data Transfer Width: This bit selects the data width of the SD bus for"
        " a data transfer.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3CD",
        "DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled "
        "down to act as a card detection pin.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EMODE",
        "Endian Mode: The uSDHC supports all three endian modes in data transfe"
        "r.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDTL",
        "Card Detect Test Level: This is bit is enabled while the Card Detectio"
        "n Signal Selection is set to 1 and it indicates card insertion.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDSS",
        "Card Detect Signal Selection: This bit selects the source for the card"
        " detection.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMASEL",
        "DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled an"
        "d selects the DMA operation.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SABGREQ",
        "Stop At Block Gap Request: This bit is used to stop executing a transa"
        "ction at the next block gap for both DMA and non-DMA transfers.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREQ",
        "Continue Request: This bit is used to restart a transaction which was "
        "stopped using the Stop At Block Gap Request.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWCTL",
        "Read Wait Control: The read wait function is optional for SDIO cards.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IABG",
        "Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the S"
        "DIO card, and selects a sample point in the interrupt cycle.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DONE_NO_8CLK",
        "Read done no 8 clock: According to the SD/MMC spec, for read data tran"
        "saction, 8 clocks are needed after the end bit of the last data block.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINT",
        "Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event"
        ", via a Card Interrupt, in the Interrupt Status register.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINS",
        "Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup ev"
        "ent, via a Card Insertion, in the Interrupt Status register.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECRM",
        "Wakeup Event Enable On SD Card Removal: This bit enables a wakeup even"
        "t, via a Card Removal, in the Interrupt Status register.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LEN_EN",
        "BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRA"
        "P/INCR16-WRAP This is used to enable/disable the burst length for the "
        "external AHB2AXI bridge.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_EXACT_BLK_RD",
        "Current block read is non-exact block read.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_SYS_CTRL.
static const field_t hw_usdhc_sys_ctrl[] =
{
    {
        "DVS",
        "Divisor: This register is used to provide a more exact divisor to gene"
        "rate the desired SD clock frequency.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDCLKFS",
        "SDCLK Frequency Select: This register is used to select the frequency "
        "of the SDCLK pin.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOCV",
        "Data Timeout Counter Value: This value determines the interval by whic"
        "h DAT line timeouts are detected.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_RST_N",
        "This register's value will be output to CARD from pad directly for har"
        "dware reset of the card if the card supports this feature.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTA",
        "Software Reset For ALL: This reset effects the entire Host Controller "
        "except for the card detection circuit.",
        24, // LSB
        24, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RSTC",
        "Software Reset For CMD Line: Only part of the command circuit is reset"
        ".",
        25, // LSB
        25, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RSTD",
        "Software Reset For DAT Line: Only part of the data circuit is reset.",
        26, // LSB
        26, // MSB
        false, // Readable
        true // Writable
    },
    {
        "INITA",
        "Initialization Active: When this bit is set, 80 SD-Clocks are sent to "
        "the card.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_STATUS.
static const field_t hw_usdhc_int_status[] =
{
    {
        "CC",
        "Command Complete: This bit is set when you receive the end bit of the "
        "command response (except Auto CMD12).",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        "Transfer Complete: This bit is set when a read or write transfer is co"
        "mpleted.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGE",
        "Block Gap Event: If the Stop At Block Gap Request bit in the Protocol "
        "Control register is set, this bit is set when a read or write transact"
        "ion is stopped at a block gap.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINT",
        "DMA Interrupt: Occurs only when the internal DMA finishes the data tra"
        "nsfer successfully.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWR",
        "Buffer Write Ready: This status bit is set if the Buffer Write Enable "
        "bit, in the Present State register, changes from 0 to 1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRR",
        "Buffer Read Ready: This status bit is set if the Buffer Read Enable bi"
        "t, in the Present State register, changes from 0 to 1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINS",
        "Card Insertion: This status bit is set if the Card Inserted bit in the"
        " Present State register changes from 0 to 1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRM",
        "Card Removal: This status bit is set if the Card Inserted bit in the P"
        "resent State register changes from 1 to 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINT",
        "Card Interrupt: This status bit is set when an interrupt signal is det"
        "ected from the external card.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTE",
        "Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re"
        "-Tuning Request in the Present State register changes from 0 to 1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TP",
        "Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is don"
        "e successfully.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOE",
        "Command Timeout Error: Occurs only if no response is returned within 6"
        "4 SDCLK cycles from the end bit of the command.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCE",
        "Command CRC Error: Command CRC Error is generated in two cases.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBE",
        "Command End Bit Error: Occurs when detecting that the end bit of a com"
        "mand response is 0.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        "Command Index Error: Occurs if a Command Index error occurs in the com"
        "mand response.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOE",
        "Data Timeout Error: Occurs when detecting one of following time-out co"
        "nditions.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCE",
        "Data CRC Error: Occurs when detecting a CRC error when transferring re"
        "ad data, which uses the DAT line, or when detecting the Write CRC stat"
        "us having a value other than 010.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBE",
        "Data End Bit Error: Occurs either when detecting 0 at the end bit posi"
        "tion of read data, which uses the DAT line, or at the end bit position"
        " of the CRC.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12E",
        "Auto CMD12 Error: Occurs when detecting that one of the bits in the Au"
        "to CMD12 Error Status register has changed from 0 to 1.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNE",
        "Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unr"
        "ecoverable error is detected in a tuning circuit.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAE",
        "DMA Error: Occurs when an Internal DMA transfer has failed.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_STATUS_EN.
static const field_t hw_usdhc_int_status_en[] =
{
    {
        "CCSEN",
        "Command Complete Status Enable: 1 Enabled 0 Masked",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEN",
        "Transfer Complete Status Enable:",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGESEN",
        "Block Gap Event Status Enable:",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTSEN",
        "DMA Interrupt Status Enable:",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRSEN",
        "Buffer Write Ready Status Enable:",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRSEN",
        "Buffer Read Ready Status Enable:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSSEN",
        "Card Insertion Status Enable:",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMSEN",
        "Card Removal Status Enable:",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTSEN",
        "Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will "
        "clear the interrupt request to the System.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTESEN",
        "Re-Tuning Event Status Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPSEN",
        "Tuning Pass Status Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOESEN",
        "Command Timeout Error Status Enable:",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCESEN",
        "Command CRC Error Status Enable:",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBESEN",
        "Command End Bit Error Status Enable:",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIESEN",
        "Command Index Error Status Enable:",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOESEN",
        "Data Timeout Error Status Enable:",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCESEN",
        "Data CRC Error Status Enable:",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBESEN",
        "Data End Bit Error Status Enable:",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12ESEN",
        "Auto CMD12 Error Status Enable:",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNESEN",
        "Tuning Error Status Enable:",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAESEN",
        "DMA Error Status Enable:",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_SIGNAL_EN.
static const field_t hw_usdhc_int_signal_en[] =
{
    {
        "CCIEN",
        "Command Complete Interrupt Enable:",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIEN",
        "Transfer Complete Interrupt Enable:",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGEIEN",
        "Block Gap Event Interrupt Enable:",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTIEN",
        "DMA Interrupt Enable:",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRIEN",
        "Buffer Write Ready Interrupt Enable:",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRIEN",
        "Buffer Read Ready Interrupt Enable:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSIEN",
        "Card Insertion Interrupt Enable:",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMIEN",
        "Card Removal Interrupt Enable:",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTIEN",
        "Card Interrupt Interrupt Enable:",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEIEN",
        "Re-Tuning Event Interrupt Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPIEN",
        "Tuning Pass Interrupt Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOEIEN",
        "Command Timeout Error Interrupt Enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCEIEN",
        "Command CRC Error Interrupt Enable:",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBEIEN",
        "Command End Bit Error Interrupt Enable:",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIEIEN",
        "Command Index Error Interrupt Enable:",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOEIEN",
        "Data Timeout Error Interrupt Enable:",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEIEN",
        "Data CRC Error Interrupt Enable:",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBEIEN",
        "Data End Bit Error Interrupt Enable:",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EIEN",
        "Auto CMD12 Error Interrupt Enable:",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNEIEN",
        "Tuning Error Interrupt Enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAEIEN",
        "DMA Error Interrupt Enable:",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_AUTOCMD12_ERR_STATUS.
static const field_t hw_usdhc_autocmd12_err_status[] =
{
    {
        "AC12NE",
        "Auto CMD12 Not Executed: If memory multiple block data transfer is not"
        " started, due to a command error, this bit is not set because it is no"
        "t necessary to issue an Auto CMD12.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12TOE",
        "Auto CMD12 Timeout Error: Occurs if no response is returned within 64 "
        "SDCLK cycles from the end bit of the command.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12EBE",
        "Auto CMD12 End Bit Error: Occurs when detecting that the end bit of co"
        "mmand response is 0 which should be 1.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12CE",
        "Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command"
        " response.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12IE",
        "Auto CMD12 Index Error: Occurs if the Command Index error occurs in re"
        "sponse to a command.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNIBAC12E",
        "Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CM"
        "D_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this "
        "register.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_HOST_CTRL_CAP.
static const field_t hw_usdhc_host_ctrl_cap[] =
{
    {
        "MBL",
        "Max Block Length: This value indicates the maximum block size that the"
        " Host Driver can read and write to the buffer in the uSDHC.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMAS",
        "ADMA Support: This bit indicates whether the uSDHC supports the ADMA f"
        "eature.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HSS",
        "High Speed Support: This bit indicates whether the uSDHC supports High"
        " Speed mode and the Host System can supply a SD Clock frequency from 2"
        "5 MHz to 50 MHz.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMAS",
        "DMA Support: This bit indicates whether the uSDHC is capable of using "
        "the internal DMA to transfer data between system memory and the data b"
        "uffer directly.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRS",
        "Suspend / Resume Support: This bit indicates whether the uSDHC support"
        "s Suspend / Resume functionality.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS33",
        "Voltage Support 3.3V: This bit shall depend on the Host System ability"
        ".",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS30",
        "Voltage Support 3.0V: This bit shall depend on the Host System ability"
        ".",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS18",
        "Voltage Support 1.8V: This bit shall depend on the Host System ability"
        ".",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_WTMK_LVL.
static const field_t hw_usdhc_wtmk_lvl[] =
{
    {
        "RD_WML",
        "Read Watermark Level: The number of words used as the watermark level "
        "(FIFO threshold) in a DMA read operation.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_BRST_LEN",
        "Read Burst Length: Due to system restriction, the actual burst length "
        "may not exceed 16.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_WML",
        "Write Watermark Level: The number of words used as the watermark level"
        " (FIFO threshold) in a DMA write operation.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_BRST_LEN",
        "Write Burst Length: Due to system restriction, the actual burst length"
        " may not exceed 16.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_MIX_CTRL.
static const field_t hw_usdhc_mix_ctrl[] =
{
    {
        "DMAEN",
        "DMA Enable: This bit enables DMA functionality.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCEN",
        "Block Count Enable: This bit is used to enable the Block Count registe"
        "r, which is only relevant for multiple block transfers.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EN",
        "Auto CMD12 Enable: Multiple block transfers for memory require a CMD12"
        " to stop the transaction.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_EN",
        "Dual Data Rate mode selection",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTDSEL",
        "Data Transfer Direction Select: This bit defines the direction of DAT "
        "line data transfers.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSBSEL",
        "Multi / Single Block Select: This bit enables multiple block DAT line "
        "data transfers.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIBBLE_POS",
        "In DDR 4-bit mode nibble position indictation.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC23EN",
        "Auto CMD23 Enable When this bit is set to 1, the Host Controller issue"
        "s a CMD23 automatically before issuing a command specified in the Comm"
        "and Register.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXE_TUNE",
        "Execute Tuning: (Only used for SD3.0, SDR104 mode) This bit is set to "
        "1 to indicate the Host Driver is starting tuning procedure.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        "Tuned clock or Fixed clock is used to sample data/cmd (Only used for S"
        "D3.0, SDR104 mode)",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_TUNE_EN",
        "Auto tuning enable (Only used for SD3.0, SDR104 mode)",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBCLK_SEL",
        "Feedback clock source selection (Only used for SD3.0, SDR104 mode)",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_FORCE_EVENT.
static const field_t hw_usdhc_force_event[] =
{
    {
        "FEVTAC12NE",
        "Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the"
        " Auto Command12 Error Status Register to be set",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12TOE",
        "Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in "
        "the Auto Command12 Error Status Register to be set",
        1, // LSB
        1, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12CE",
        "Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Au"
        "to Command12 Error Status Register to be set",
        2, // LSB
        2, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12EBE",
        "Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in t"
        "he Auto Command12 Error Status Register to be set",
        3, // LSB
        3, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12IE",
        "Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the "
        "Auto Command12 Error Status Register to be set",
        4, // LSB
        4, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCNIBAC12E",
        "Force Event Command Not Executed By Auto Command 12 Error: Forces the "
        "CNIBAC12E bit in the Auto Command12 Error Status Register to be set",
        7, // LSB
        7, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCCE",
        "Force Event Command Time Out Error: Forces the CTOE bit of Interrupt S"
        "tatus Register to be set",
        16, // LSB
        16, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCCE1",
        "Force Event Command CRC Error: Forces the CCE bit of Interrupt Status "
        "Register to be set",
        17, // LSB
        17, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCEBE",
        "Force Event Command End Bit Error: Forces the CEBE bit of Interrupt St"
        "atus Register to be set",
        18, // LSB
        18, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCIE",
        "Force Event Command Index Error: Forces the CCE bit of Interrupt Statu"
        "s Register to be set",
        19, // LSB
        19, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTDTOE",
        "Force Event Data Time Out Error: Force the DTOE bit of Interrupt Statu"
        "s Register to be set",
        20, // LSB
        20, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTDCE",
        "Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Reg"
        "ister to be set",
        21, // LSB
        21, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTDEBE",
        "Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Statu"
        "s Register to be set",
        22, // LSB
        22, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12E",
        "Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt S"
        "tatus Register to be set",
        24, // LSB
        24, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTTNE",
        "Force Tuning Error: Forces the TNE bit of Interrupt Status Register to"
        " be set",
        26, // LSB
        26, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTDMAE",
        "Force Event DMA Error: Forces the DMAE bit of Interrupt Status Registe"
        "r to be set",
        28, // LSB
        28, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCINT",
        "Force Event Card Interrupt: Writing 1 to this bit generates a short lo"
        "w-level pulse on the internal DAT[1] line, as if a self clearing inter"
        "rupt was received from the external card.",
        31, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_ADMA_ERR_STATUS.
static const field_t hw_usdhc_adma_err_status[] =
{
    {
        "ADMAES",
        "ADMA Error State (when ADMA Error is occurred.): This field indicates "
        "the state of the ADMA when an error has occurred during an ADMA data t"
        "ransfer.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMALME",
        "ADMA Length Mismatch Error: This error occurs in the following 2 cases"
        ": While the Block Count Enable is being set, the total data length spe"
        "cified by the Descriptor table is different from that specified by the"
        " Block Count and Block Length Total data length can not be divided by "
        "the block length",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMADCE",
        "ADMA Descritor Error: This error occurs when invalid descriptor fetche"
        "d by ADMA:",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_ADMA_SYS_ADDR.
static const field_t hw_usdhc_adma_sys_addr[] =
{
    {
        "ADS_ADDR",
        "ADMA System Address: This register holds the word address of the execu"
        "ting command in the Descriptor table.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DLL_CTRL.
static const field_t hw_usdhc_dll_ctrl[] =
{
    {
        "DLL_CTRL_ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET",
        "The delay target for the uSDHC loopback read clock can be programmed i"
        "n 1/16th increments of an ref_clock half-period.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_GATE_UPDATE",
        "Set this bit to 1 to prevent the DLL from updating (since when clock_i"
        "n exists, glitches may appear during DLL updates).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical tap"
        "s manually.",
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET1",
        "Refer to DLL_CTRL_SLV_DLY_TARGET[3:0] below.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_UPDATE_INT",
        "Slave delay line update interval.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_UPDATE_INT",
        "DLL control loop update interval.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DLL_STATUS.
static const field_t hw_usdhc_dll_status[] =
{
    {
        "DLL_STS_SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_LOCK",
        "Reference DLL lock status.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_SLV_SEL",
        "Slave delay line select status.",
        2, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_SEL",
        "Reference delay line select taps.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CLK_TUNE_CTRL_STATUS.
static const field_t hw_usdhc_clk_tune_ctrl_status[] =
{
    {
        "DLY_CELL_SET_POST",
        "Set the number of delay cells on the feedback clock between CLK_OUT an"
        "d CLK_POST.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_OUT",
        "Set the number of delay cells on the feedback clock between CLK_PRE an"
        "d CLK_OUT.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_PRE",
        "Set the number of delay cells on the feedback clock between the feedba"
        "ck clock and CLK_PRE.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NXT_ERR",
        "NXT error which means the number of delay cells added on the feedback "
        "clock is too large.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_POST",
        "Reflect the number of delay cells added on the feedback clock between "
        "CLK_OUT and CLK_POST.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_OUT",
        "Reflect the number of delay cells added on the feedback clock between "
        "CLK_PRE and CLK_OUT.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_PRE",
        "Reflects the number of delay cells added on the feedback clock between"
        " the feedback clock and CLK_PRE.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRE_ERR",
        "PRE error which means the number of delay cells added on the feedback "
        "clock is too small.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_VEND_SPEC.
static const field_t hw_usdhc_vend_spec[] =
{
    {
        "EXT_DMA_EN",
        "External DMA Request Enable Enable the request to external DMA.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSELECT",
        "Voltage Selection Change the value of output signal VSELECT, to contro"
        "l the voltage on pads for external card.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONFLICT_CHK_EN",
        "It's not implemented in uSDHC IP.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12_WR_CHKBUSY_EN",
        "Check busy enable after auto CMD12 for write data packet",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAT3_CD_POL",
        "Only for debug.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CD_POL",
        "Only for debug.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP_POL",
        "Only for debug.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKONJ_IN_ABORT",
        "Only for debug.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_SDCLK_ON",
        "Force CLK output active:",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_CLK_SOFT_EN",
        "IPG_CLK software enable",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCLK_SOFT_EN",
        "Please note, hardware auto-enables the AHB clock when the internal DMA"
        " is enabled even if HCLK_SOFT_EN is 0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_PERCLK_SOFT_EN",
        "ipg_perclk software enable",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_CLK_SOFT_EN",
        "card clock software enable",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CRC_CHK_DIS",
        "CRC check disable",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_ST_VAL",
        "Internal State Value Internal state value, reflecting the correspondin"
        "g state value selected by Debug Select field.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_MMC_BOOT.
static const field_t hw_usdhc_mmc_boot[] =
{
    {
        "DTOCV_ACK",
        "Boot ACK time out counter value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_ACK",
        "Boot ack mode select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_MODE",
        "Boot mode select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_EN",
        "Boot mode enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_SABG_EN",
        "During boot, enable auto stop at block gap function.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_TIME_OUT",
        "Please note, when this bit is set, there is no timeout check no matter"
        " whether boot_en is set or not.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_BLK_CNT",
        "The value defines the Stop At Block Gap value of automatic mode.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_VEND_SPEC2.
static const field_t hw_usdhc_vend_spec2[] =
{
    {
        "SDR104_TIMING_DIS",
        "Timeout counter test.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_OE_DIS",
        "CMD_OE/DAT_OE logic generation test.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_NSD_DIS",
        "Interrupt window after abort command is sent.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_D3_TEST",
        "Card interrupt detection test.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_8BIT_EN",
        "Enable the auto tuning circuit to check the DAT[7:0].",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_1BIT_EN",
        "Enable the auto tuning circuit to check the DAT0 only.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_CMD_EN",
        "Enable the auto tuning circuit to check the CMD line.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_AUTO_CLR_DIS",
        "Disable the feature to clear the Card interrupt status bit when Card I"
        "nterrupt status enable bit is cleared.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USDHC module.
static const reg_t hw_usdhc[] =
{
    {
        "DS_ADDR",
        "This register contains the physical system memory address used for DMA"
        " transfers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_ds_addr
    },
    {
        "BLK_ATT",
        "This register is used to configure the number of data blocks and the n"
        "umber of bytes in each block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usdhc_blk_att
    },
    {
        "CMD_ARG",
        "This register contains the SD/MMC Command Argument.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_arg
    },
    {
        "CMD_XFR_TYP",
        "This register is used to control the operation of data transfers.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usdhc_cmd_xfr_typ
    },
    {
        "CMD_RSP0",
        "This register is used to store part 0 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp0
    },
    {
        "CMD_RSP1",
        "This register is used to store part 1 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp1
    },
    {
        "CMD_RSP2",
        "This register is used to store part 2 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp2
    },
    {
        "CMD_RSP3",
        "This register is used to store part 3 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp3
    },
    {
        "DATA_BUFF_ACC_PORT",
        "This is a 32-bit data port register used to access the internal buffer"
        ".",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_data_buff_acc_port
    },
    {
        "PRES_STATE",
        "The Host Driver can get status of the uSDHC from this 32-bit read only"
        " register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        18, // Number of bitfields
        hw_usdhc_pres_state
    },
    {
        "PROT_CTRL",
        "There are three cases to restart the transfer after stop at the block "
        "gap.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_prot_ctrl
    },
    {
        "SYS_CTRL",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_sys_ctrl
    },
    {
        "INT_STATUS",
        "An interrupt is generated when the Normal Interrupt Signal Enable is e"
        "nabled and at least one of the status bits is set to 1.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status
    },
    {
        "INT_STATUS_EN",
        "Setting the bits in this register to 1 enables the corresponding Inter"
        "rupt Status to be set by the specified event.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status_en
    },
    {
        "INT_SIGNAL_EN",
        "This register is used to select which interrupt status is indicated to"
        " the Host System as the interrupt.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_signal_en
    },
    {
        "AUTOCMD12_ERR_STATUS",
        "When the Auto CMD12 Error Status bit in the Status register is set, th"
        "e Host Driver shall check this register to identify what kind of error"
        " the Auto CMD12 indicated.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_usdhc_autocmd12_err_status
    },
    {
        "HOST_CTRL_CAP",
        "This register provides the Host Driver with information specific to th"
        "e uSDHC implementation.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_usdhc_host_ctrl_cap
    },
    {
        "WTMK_LVL",
        "Both write and read watermark levels (FIFO threshold) are configurable"
        ".",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usdhc_wtmk_lvl
    },
    {
        "MIX_CTRL",
        "This register is used to DMA and data transfer.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usdhc_mix_ctrl
    },
    {
        "FORCE_EVENT",
        "The Force Event Register is not a physically implemented register.",
        4, // Width in bytes
        0x00000050, // Base address offset
        false, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_force_event
    },
    {
        "ADMA_ERR_STATUS",
        "When an ADMA Error Interrupt has occurred, the ADMA Error States field"
        " in this register holds the ADMA state and the ADMA System Address reg"
        "ister holds the address around the error descriptor.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usdhc_adma_err_status
    },
    {
        "ADMA_SYS_ADDR",
        "This register contains the physical system memory address used for ADM"
        "A transfers.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_adma_sys_addr
    },
    {
        "DLL_CTRL",
        "This register contains control bits for DLL.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usdhc_dll_ctrl
    },
    {
        "DLL_STATUS",
        "This register contains the DLL status information.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usdhc_dll_status
    },
    {
        "CLK_TUNE_CTRL_STATUS",
        "This register contains the Clock Tuning Control status information.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_clk_tune_ctrl_status
    },
    {
        "VEND_SPEC",
        "This register contains the vendor specific control/status register.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usdhc_vend_spec
    },
    {
        "MMC_BOOT",
        "This register contains the MMC Fast Boot control register.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usdhc_mmc_boot
    },
    {
        "VEND_SPEC2",
        "This register contains the vendor specific control 2 register.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_vend_spec2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark VDOA
#endif

// Bitfields in register VDOA_VDOAC.
static const field_t hw_vdoa_vdoac[] =
{
    {
        "BNDM",
        "BNDM Band Size",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NF",
        "Number of frames - Determines whether to transfer 1 frame or three fra"
        "mes",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "SYNC MODE - defines whether the VDOA will transfer a full frame (or 2 "
        "frames) continuously or will transfer a band at a time and wait for IP"
        "U signal to continue",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SO",
        "Scan Order",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFS",
        "Pixel Format Select - Pixel format of data written to / read from IPU.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISEL",
        "IPU SELECT - determines in sync mode which of the two sets of hand sha"
        "ke pins is used",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOASRR.
static const field_t hw_vdoa_vdoasrr[] =
{
    {
        "SWRST",
        "Software reset - Finish outstanding AXI transfer and reset all interna"
        "l registers the configuration registers are mnot cleared",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START",
        "Start Transfer - Strat a VDOA data transfer according to all parameter"
        "s.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIE.
static const field_t hw_vdoa_vdoaie[] =
{
    {
        "EIEOT",
        "EIEOT - Enable Interrupt End Of Transfer- Enables Interrupt on end of "
        "transfer",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EITERR",
        "EITERR - Enable Interrupt Transfer access Error - Enables Interrupt on"
        " AXI access Error",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIST.
static const field_t hw_vdoa_vdoaist[] =
{
    {
        "EOT",
        "End Of transfer - Transfer was completed if EIEOT is set an interrupt "
        "will be generated",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TERR",
        "Axi Access had an access error see ERRW bit in 0XBASE_0044 (VDOASR) fo"
        "r type of access (read write) if EITERR is set an interrupt will be ge"
        "nerated",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAFP.
static const field_t hw_vdoa_vdoafp[] =
{
    {
        "FW",
        "Number of pixels in one row, of the frame.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FH",
        "Number of pixels in one column, of the frame.",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIEBA00.
static const field_t hw_vdoa_vdoaieba00[] =
{
    {
        "IEBA00",
        "External Address of Frame 0 output (IPU) buffer 0 - Note that the 3 LS"
        "B are always 0 (aligned to 8 address)  Used for all transfer types",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIEBA01.
static const field_t hw_vdoa_vdoaieba01[] =
{
    {
        "IEBA01",
        "External Address of Frame 1 output (IPU) buffer 0 - Note that the 3 LS"
        "B are always 0 (aligned to 8 address)  Used when transfering 3 frames "
        "(NF=1) only",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIEBA02.
static const field_t hw_vdoa_vdoaieba02[] =
{
    {
        "IEBA02",
        "External Address of Frame 2 output (IPU) buffer 0 - Note that the 3 LS"
        "B are always 0 (aligned to 8 address)  Used when transfering 3 frames "
        "(NF=1) only",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIEBA10.
static const field_t hw_vdoa_vdoaieba10[] =
{
    {
        "IEBA10",
        "External Address of Frame 0 output (IPU) buffer 1 - Note that the 3 LS"
        "B are always 0 (aligned to 8 address)  Used in sync mode (SYNC=1) only",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIEBA11.
static const field_t hw_vdoa_vdoaieba11[] =
{
    {
        "IEBA11",
        "External Address of Frame 1 output (IPU) buffer 1 - Note that the 3 LS"
        "B are always 0 (aligned to 8 address)  This register is used only in s"
        "ync mode (SYNC=1), 3 frames transfer (NF=1)",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIEBA12.
static const field_t hw_vdoa_vdoaieba12[] =
{
    {
        "IEBA12",
        "External Address of Frame 2 output (IPU) buffer 1 - Note that the 3 LS"
        "B are always 0 (aligned to 8 address)  This register is used only in s"
        "ync mode (SYNC=1), 3 frames transfer (NF=1)",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOASL.
static const field_t hw_vdoa_vdoasl[] =
{
    {
        "ISLY",
        "IPU Stride Line - Address vertical scaling factor in bytes for memory "
        "access.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSLY",
        "VPU Stride Line - Address vertical scaling factor in bytes for memory "
        "access.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAIUBO.
static const field_t hw_vdoa_vdoaiubo[] =
{
    {
        "IUBO",
        "The offset of Chroma (UV) Buffer for all IPU output frames i.e Buffer "
        "Chroma address will be VDOAIEBAnm+VDOAIUBO - Note that the 3 LSB are a"
        "lways 0 (aligned to 8 address) used only for PFL = 4:2:0",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAVEBA0.
static const field_t hw_vdoa_vdoaveba0[] =
{
    {
        "VEBA0",
        "Address of Frame 0 VPU buffers - Note that the 3 LSB are always 0 (ali"
        "gned to 8 address)  Used for all transfers",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAVEBA1.
static const field_t hw_vdoa_vdoaveba1[] =
{
    {
        "VEBA1",
        "Address of Frame 1 VPU buffers - Note that the 3 LSB are always 0 (ali"
        "gned to 8 address)  Used when transfering three frame (NF=1) only",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAVEBA2.
static const field_t hw_vdoa_vdoaveba2[] =
{
    {
        "VEBA2",
        "Address of Frame 2 VPU buffers - Note that the 3 LSB are always 0 (ali"
        "gned to 8 address)  Used when transfering three frame (NF=1) only",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOAVUBO.
static const field_t hw_vdoa_vdoavubo[] =
{
    {
        "VUBO",
        "The offset of Chroma (UV) Buffer for all VPU input frames i.e Chroma B"
        "uffer address will be VDOAVEBAm+VDOAVUBO - Note that the 3 LSB are alw"
        "ays 0 (aligned to 8 address)",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDOA_VDOASR.
static const field_t hw_vdoa_vdoasr[] =
{
    {
        "CURRENT_BUFFER",
        "Current Buffer - for Double buffer shows the number of buffer currentl"
        "y transferred",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CURRENT_FRAME",
        "Current Frame - When working on 3 frames the number of frame currently"
        " transferred",
        1, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EOB",
        "End of Band- Indicates that the VDOA has finished transferring a band "
        "in SYNC mode and is waiting to IPU to continue",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERRW",
        "Error Write - Indicates that the last access that failed was a read or"
        " a write.This field is valid only when TERR bit is set in VDOA Interru"
        "pt Status Register - VDOAIST",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a VDOA module.
static const reg_t hw_vdoa[] =
{
    {
        "VDOAC",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_vdoa_vdoac
    },
    {
        "VDOASRR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vdoa_vdoasrr
    },
    {
        "VDOAIE",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vdoa_vdoaie
    },
    {
        "VDOAIST",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vdoa_vdoaist
    },
    {
        "VDOAFP",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vdoa_vdoafp
    },
    {
        "VDOAIEBA00",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaieba00
    },
    {
        "VDOAIEBA01",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaieba01
    },
    {
        "VDOAIEBA02",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaieba02
    },
    {
        "VDOAIEBA10",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaieba10
    },
    {
        "VDOAIEBA11",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaieba11
    },
    {
        "VDOAIEBA12",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaieba12
    },
    {
        "VDOASL",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vdoa_vdoasl
    },
    {
        "VDOAIUBO",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaiubo
    },
    {
        "VDOAVEBA0",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaveba0
    },
    {
        "VDOAVEBA1",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaveba1
    },
    {
        "VDOAVEBA2",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoaveba2
    },
    {
        "VDOAVUBO",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdoa_vdoavubo
    },
    {
        "VDOASR",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_vdoa_vdoasr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark VPU
#endif

// Bitfields in register VPU_CODERUN.
static const field_t hw_vpu_coderun[] =
{
    {
        "VPU_CODERUN",
        "VPU_CodeRun.",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VPU_CODEDOWN.
static const field_t hw_vpu_codedown[] =
{
    {
        "CODEDATA",
        "CodeData[15:0]  Download data of VPU BIT boot code.",
        0, // LSB
        15, // MSB
        false, // Readable
        true // Writable
    },
    {
        "CODEADDR",
        "CodeAddr[12:0]  Download address of VPU BIT boot code, which is VPU in"
        "ternal address of BIT processor.",
        16, // LSB
        28, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VPU_HOSTINTREQ.
static const field_t hw_vpu_hostintreq[] =
{
    {
        "INTREQ",
        "IntReq.",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VPU_BITINTCLEAR.
static const field_t hw_vpu_bitintclear[] =
{
    {
        "INTCLEAR",
        "IntClear.",
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VPU_BITINTSTS.
static const field_t hw_vpu_bitintsts[] =
{
    {
        "INTSTS",
        "IntSts.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VPU_BITCURPC.
static const field_t hw_vpu_bitcurpc[] =
{
    {
        "CURPC",
        "CurPc[13:0].",
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VPU_BITCODECBUSY.
static const field_t hw_vpu_bitcodecbusy[] =
{
    {
        "CODECBUSY",
        "Codec busy flag for Bit processor.BIT processor write \"1\"to this reg"
        "ister when the processor is running.\"0\"means processor is waiting fo"
        "r a command.This value is connected to the o_vpu_idle.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a VPU module.
static const reg_t hw_vpu[] =
{
    {
        "CODERUN",
        "See the figure below for illustration of valid bits in VPU Code Run Re"
        "gister and the table below for description of the bit fields in the re"
        "gister.",
        4, // Width in bytes
        0x00000000, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vpu_coderun
    },
    {
        "CODEDOWN",
        "See the figure below for illustration of valid bits in VPU BIT Boot Co"
        "de Download Data Register and the following table for description of t"
        "he bit fields in the register.",
        4, // Width in bytes
        0x00000004, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vpu_codedown
    },
    {
        "HOSTINTREQ",
        "See the figure below for illustration of valid bits in VPU Host Interr"
        "upt Request Register and the following table for description of the bi"
        "t fields in the register.",
        4, // Width in bytes
        0x00000008, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vpu_hostintreq
    },
    {
        "BITINTCLEAR",
        "See the figure below for illustration of valid bits in VPU BIT Interru"
        "pt Clear Register and the following table for description of the bit f"
        "ields in the register.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vpu_bitintclear
    },
    {
        "BITINTSTS",
        "See the figure below for illustration of valid bits in VPU BIT Interru"
        "pt Status Register and the following table for description of the bit "
        "fields in the register.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_vpu_bitintsts
    },
    {
        "BITCURPC",
        "See the figure below for illustration of valid bits in VPU BIT Current"
        " PC Register and the following table for description of the bit fields"
        " in the register.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_vpu_bitcurpc
    },
    {
        "BITCODECBUSY",
        "See the figure below for illustration of valid bits in VPU BIT Codec B"
        "usy Register and the following table for description of the bit fields"
        " in the register.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_vpu_bitcodecbusy
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark WDOG
#endif

// Bitfields in register WDOG_WCR.
static const field_t hw_wdog_wcr[] =
{
    {
        "WDZST",
        "Watchdog Low Power.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDBG",
        "Watchdog DEBUG Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDE",
        "Watchdog Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDT",
        "WDOG Time-out assertion.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRS",
        "Software Reset Signal.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDA",
        "WDOG assertion.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDW",
        "Watchdog Disable for Wait.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WT",
        "Watchdog Time-out Field.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WSR.
static const field_t hw_wdog_wsr[] =
{
    {
        "WSR",
        "Watchdog Service Register.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WRSR.
static const field_t hw_wdog_wrsr[] =
{
    {
        "SFTW",
        "Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TOUT",
        "Timeout.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POR",
        "Power On Reset.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WICR.
static const field_t hw_wdog_wicr[] =
{
    {
        "WICT",
        "Watchdog Interrupt Count Time-out (WICT) field determines, how long be"
        "fore the counter time-out must the interrupt occur.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTIS",
        "Watchdog TImer Interrupt Status bit will reflect the timer interrupt s"
        "tatus, whether interrupt has occurred or not.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "Watchdog Timer Interrupt enable bit.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WMCR.
static const field_t hw_wdog_wmcr[] =
{
    {
        "PDE",
        "Power Down Enable bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a WDOG module.
static const reg_t hw_wdog[] =
{
    {
        "WCR",
        "The Watchdog Control Register (WDOG_WCR) controls the WDOG operation.",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_wdog_wcr
    },
    {
        "WSR",
        "When enabled, the WDOG requires that a service sequence be written to "
        "the Watchdog Service Register (WSR) to prevent the timeout condition.",
        2, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wdog_wsr
    },
    {
        "WRSR",
        "The WRSR is a read-only register that records the source of the output"
        " reset assertion.",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_wdog_wrsr
    },
    {
        "WICR",
        "The WDOG_WICR controls the WDOG interrupt generation.",
        2, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_wdog_wicr
    },
    {
        "WMCR",
        "WDOG_WMCR Controls the Power Down counter operation.",
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wdog_wmcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark XTALOSC24M
#endif

// Bitfields in register XTALOSC24M_MISC0.
static const field_t hw_xtalosc24m_misc0[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to oscillator.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit which signals that the analog bandgap voltage is up and sta"
        "ble.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This bit field determines the bias current in the 24MHz oscillator.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit which signals that the output of the 24MHz crystal oscillat"
        "or is stable.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "Enable bit for the xtal_ok module(24 MHz)",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBCP_VPW_THRESH",
        "This signal alters the voltage that the pwell is charged pumped to.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always un-gated) for the xta"
        "l 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and release the clock to the digital logic inside the analog block.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a XTALOSC24M module.
static const reg_t hw_xtalosc24m[] =
{
    {
        "MISC0",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_xtalosc24m_misc0
    },
    { 0 } // Terminator
};


//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark mx6
#endif

const module_t mx6q[] =
{
    // Module name, instance number, base address, register count, register definitions
    { "AIPSTZ1",         1, 0x02000000, 6,    hw_aipstz },
    { "AIPSTZ2",         2, 0x02100000, 6,    hw_aipstz },
    { "ARMGLOBALTIMER",  1, 0x00a00000, 7,    hw_armglobaltimer },
    { "ASRC",            1, 0x02034000, 38,   hw_asrc },
    { "AUDMUX",          1, 0x021d8000, 14,   hw_audmux },
    { "CCM",             1, 0x020c4000, 32,   hw_ccm },
    { "CCM_ANALOG",      1, 0x020c8000, 19,   hw_ccm_analog },
    { "CSI2IPU",         1, 0x021dc000, 1,    hw_csi2ipu },
    { "CSU",             1, 0x021c0000, 45,   hw_csu },
    { "DCIC1",           1, 0x020e4000, 7,    hw_dcic },
    { "DCIC2",           2, 0x020e8000, 7,    hw_dcic },
    { "DVFSC",           1, 0x020dc000, 17,   hw_dvfsc },
    { "ECSPI1",          1, 0x02008000, 10,   hw_ecspi },
    { "ECSPI2",          2, 0x0200c000, 10,   hw_ecspi },
    { "ECSPI3",          3, 0x02010000, 10,   hw_ecspi },
    { "ECSPI4",          4, 0x02014000, 10,   hw_ecspi },
    { "ECSPI5",          5, 0x02018000, 10,   hw_ecspi },
    { "EIM",             1, 0x021b8000, 27,   hw_eim },
    { "ENET",            1, 0x02188000, 39,   hw_enet },
    { "EPIT1",           1, 0x020d0000, 5,    hw_epit },
    { "EPIT2",           2, 0x020d4000, 5,    hw_epit },
    { "ESAI",            1, 0x02024000, 31,   hw_esai },
    { "FLEXCAN1",        1, 0x02090000, 15,   hw_flexcan },
    { "FLEXCAN2",        2, 0x02094000, 15,   hw_flexcan },
    { "GPC",             1, 0x020dc000, 10,   hw_gpc },
    { "GPIO1",           1, 0x0209c000, 8,    hw_gpio },
    { "GPIO2",           2, 0x020a0000, 8,    hw_gpio },
    { "GPIO3",           3, 0x020a4000, 8,    hw_gpio },
    { "GPIO4",           4, 0x020a8000, 8,    hw_gpio },
    { "GPIO5",           5, 0x020ac000, 8,    hw_gpio },
    { "GPIO6",           6, 0x020b0000, 8,    hw_gpio },
    { "GPIO7",           7, 0x020b4000, 8,    hw_gpio },
    { "GPT",             1, 0x02098000, 10,   hw_gpt },
    { "GPU2D",           1, 0x00134000, 36,   hw_gpu2d },
    { "GPU3D",           1, 0x00130000, 32,   hw_gpu3d },
    { "HDMI",            1, 0x00120000, 338,  hw_hdmi },
    { "I2C1",            1, 0x021a0000, 5,    hw_i2c },
    { "I2C2",            2, 0x021a4000, 5,    hw_i2c },
    { "I2C3",            3, 0x021a8000, 5,    hw_i2c },
    { "IOMUXC",          1, 0x020e0000, 589,  hw_iomuxc },
    { "IPU1",            1, 0x02400000, 410,  hw_ipu },
    { "IPU2",            2, 0x02800000, 410,  hw_ipu },
    { "KPP",             1, 0x020b8000, 4,    hw_kpp },
    { "LDB",             1, 0x020e0008, 1,    hw_ldb },
    { "MIPI_CSI",        1, 0x021dc000, 14,   hw_mipi_csi },
    { "MIPI_DSI",        1, 0x021e0000, 27,   hw_mipi_dsi },
    { "MIPI_HSI",        1, 0x02208000, 132,  hw_mipi_hsi },
    { "MLB150",          1, 0x0218c000, 32,   hw_mlb150 },
    { "MMDC1",           1, 0x021b0000, 79,   hw_mmdc },
    { "MMDC2",           2, 0x021b4000, 79,   hw_mmdc },
    { "OCOTP",           1, 0x021bc000, 41,   hw_ocotp },
    { "PGC",             1, 0x020dc000, 12,   hw_pgc },
    { "PMU",             1, 0x020c8000, 7,    hw_pmu },
    { "PWM1",            1, 0x02080000, 6,    hw_pwm },
    { "PWM2",            2, 0x02084000, 6,    hw_pwm },
    { "PWM3",            3, 0x02088000, 6,    hw_pwm },
    { "PWM4",            4, 0x0208c000, 6,    hw_pwm },
    { "ROMC",            1, 0x021ac000, 28,   hw_romc },
    { "SATA",            1, 0x02200000, 34,   hw_sata },
    { "SDMAARM",         1, 0x020ec000, 106,  hw_sdmaarm },
    { "SDMABP",          1, 0x020ec000, 7,    hw_sdmabp },
    { "SDMACORE",        1, 0x020ec000, 21,   hw_sdmacore },
    { "SJC",             1, 0x00000000, 7,    hw_sjc },
    { "SPBA",            1, 0x0203c000, 32,   hw_spba },
    { "SPDIF",           1, 0x02004000, 17,   hw_spdif },
    { "SRC",             1, 0x020d8000, 6,    hw_src },
    { "SSI1",            1, 0x02028000, 21,   hw_ssi },
    { "SSI2",            2, 0x0202c000, 21,   hw_ssi },
    { "SSI3",            3, 0x02030000, 21,   hw_ssi },
    { "TEMPMON",         1, 0x020c8000, 2,    hw_tempmon },
    { "UART1",           1, 0x02020000, 17,   hw_uart },
    { "UART2",           2, 0x021e8000, 17,   hw_uart },
    { "UART3",           3, 0x021ec000, 17,   hw_uart },
    { "UART4",           4, 0x021f0000, 17,   hw_uart },
    { "UART5",           5, 0x021f4000, 17,   hw_uart },
    { "USBC",            1, 0x02184000, 119,  hw_usbc },
    { "USBNC",           1, 0x02184000, 8,    hw_usbnc },
    { "USBPHY1",         1, 0x020c9000, 9,    hw_usbphy },
    { "USBPHY2",         2, 0x020ca000, 9,    hw_usbphy },
    { "USB_ANALOG",      1, 0x020c8000, 11,   hw_usb_analog },
    { "USDHC1",          1, 0x02190000, 28,   hw_usdhc },
    { "USDHC2",          2, 0x02194000, 28,   hw_usdhc },
    { "USDHC3",          3, 0x02198000, 28,   hw_usdhc },
    { "USDHC4",          4, 0x0219c000, 28,   hw_usdhc },
    { "VDOA",            1, 0x021e4000, 18,   hw_vdoa },
    { "VPU",             1, 0x02040000, 7,    hw_vpu },
    { "WDOG1",           1, 0x020bc000, 5,    hw_wdog },
    { "WDOG2",           2, 0x020c0000, 5,    hw_wdog },
    { "XTALOSC24M",      1, 0x020c8000, 1,    hw_xtalosc24m },
    { 0 } // Terminator
};

////////////////////////////////////////////////////////////////////////////////
