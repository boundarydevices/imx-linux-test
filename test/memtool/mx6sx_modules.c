/*
 * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
 *
 * This is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this software; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

#include "memtools_register_info.h"

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ADC
#endif

// Bitfields in register ADC_HC0.
static const field_t hw_adc_hc0[] =
{
    {
        "ADCH",
        "This 5-bit field selects one of the input channels.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIEN",
        "An interrupt is generated whenever ADC_HS[COCO0]=1 (conversion ADC_HC0"
        " completed), provided the corresponding interrupt is enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_HC1.
static const field_t hw_adc_hc1[] =
{
    {
        "ADCH",
        "This 5-bit field selects one of the input channels.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIEN",
        "An interrupt is generated whenever ADC_HS[COCO0]=1(conversion ADC_HC0 "
        "completed), provided the corresponding interrupt is enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_HS.
static const field_t hw_adc_hs[] =
{
    {
        "COCO0",
        "The COCOn flag is a read-only bit that is set each time a conversion i"
        "s completed when the compare function is disabled (ADC_GC[ACFE]=0) and"
        " the hardware average function is disabled (ADC_GC[AVGE]=0).",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COCO1",
        "See description for COCO0.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_R0.
static const field_t hw_adc_r0[] =
{
    {
        "D",
        "",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_R1.
static const field_t hw_adc_r1[] =
{
    {
        "D",
        "Data (result of an ADC conversion)",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_CFG.
static const field_t hw_adc_cfg[] =
{
    {
        "ADICLK",
        "Selects the input clock source to generate the internal clock ADCK.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Used to set the ADC resolution mode.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADLSMP",
        "Selects between different sample times based on the ADC_CFG[ADSTS] fie"
        "ld.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADIV",
        "Selects the divide ratio used by the ADC to generate the internal cloc"
        "k ADCK.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADLPC",
        "Puts the ADC hard block into low power mode and reduces the comparator"
        " enable period by controlling its timing in the SAR controller block t"
        "owards the anlong hard block.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADSTS",
        "Defines the sample time duration.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADHSC",
        "This bit configures the ADC for high speed operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFSEL",
        "Selects the voltage reference source used for conversions (see the chi"
        "p-specific SARADC information for details).",
        11, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADTRG",
        "Selects the type of trigger used for initiating a conversion.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Determines how many ADC conversions will be averaged to create the ADC"
        " average result.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVWREN",
        "Controls the overwriting of the next converted Data onto the existing "
        "(previous) unread data into the Data result register.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_GC.
static const field_t hw_adc_gc[] =
{
    {
        "ADACKEN",
        "Enables the ADC's asynchronous clock source and the clock source outpu"
        "t regardless of the conversion and input clock select (ADC_CFG[ADICLK]"
        ") settings of the ADC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAEN",
        "Enables the DMA logic.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACREN",
        "Configures the compare function to check the conversion result of the "
        "input being monitored is either between or outside the range formed by"
        " the compare values in register (ADC_CV) determined by the value of AC"
        "FGT.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACFGT",
        "Configures the compare function to check the conversion result relativ"
        "e to the compare value register (ADC_CV) based upon the value of ACREN"
        " (bit 2 in ADC_GC register).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACFE",
        "Enables the compare function.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGE",
        "Enables the hardware average function of the ADC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADCO",
        "Enables continuous conversions.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAL",
        "CAL begins the calibration sequence when set.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_GS.
static const field_t hw_adc_gs[] =
{
    {
        "ADACT",
        "Indicates that a conversion or hardware averaging is in progress.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CALF",
        "Displays the result of the calibration sequence.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWKST",
        "Holds the status of asynchronous interrupt status that occured during "
        "stop mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_CV.
static const field_t hw_adc_cv[] =
{
    {
        "CV1",
        "Contains a compare value used to compare with the conversion result wh"
        "en the compare function ais enabled (ADC_GC[ACFE]=1).",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CV2",
        "Contains a compare value used to compare with the conversion result wh"
        "en the compare function and compare range function are enabled (ADC_GC"
        "[ACFE]=1, ADC_GC[ACREN]=1).",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_OFS.
static const field_t hw_adc_ofs[] =
{
    {
        "OFS",
        "User configurable offset value.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIGN",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_CAL.
static const field_t hw_adc_cal[] =
{
    {
        "CAL_CODE",
        "This value is automatically loaded and updated at the end of calibrati"
        "on.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ADC module.
static const reg_t hw_adc[] =
{
    {
        "HC0",
        "ADC_HC0 is for use only in hardware trigger mode.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_hc0
    },
    {
        "HC1",
        "ADC_HC1 are for use only in hardware trigger mode.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_hc1
    },
    {
        "HS",
        "Bit 0 is used for both software and hardware trigger modes of operatio"
        "n.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_adc_hs
    },
    {
        "R0",
        "Contains the result of an ADC conversion of the channel selected by th"
        "e respective hardware trigger and channel control register (ADC_HC0:AD"
        "C_HCn).",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_adc_r0
    },
    {
        "R1",
        "Contains the result of an ADC conversion of the channel selected by th"
        "e respective Hardware Trigger and channel control register (ADC_HC0:AD"
        "C_HCn).",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_adc_r1
    },
    {
        "CFG",
        "Selects the mode of operation, clock source, clock divide, configure f"
        "or low power, long sample time, high speed configuration and selects t"
        "he sample time duration.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_adc_cfg
    },
    {
        "GC",
        "Controls the calibration, continuous convert, hardware averaging funct"
        "ions, conversion active, hardware/software trigger select, compare fun"
        "ction and voltage reference select of the ADC module.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_adc_gc
    },
    {
        "GS",
        "Controls the calibration, continuous convert, hardware averaging funct"
        "ions, conversion active, hardware/software trigger select, compare fun"
        "ction and voltage reference select of the ADC module.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_adc_gs
    },
    {
        "CV",
        "Contains compare values used to compare with the conversion result whe"
        "n the compare function is enabled (ADC_GC[ACFE]=1).",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_cv
    },
    {
        "OFS",
        "Contains the user-defined offset error correction value.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_ofs
    },
    {
        "CAL",
        "Contains calibration information that is generated by the calibration "
        "function.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_adc_cal
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark AFE
#endif

// Bitfields in register AFE_BLOCK_ID.
static const field_t hw_afe_block_id[] =
{
    {
        "BLOCK_ID",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_PDBUF.
static const field_t hw_afe_pdbuf[] =
{
    {
        "ACAFE_PD_N",
        "Master power down control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGR_BGR_PD_N",
        "Both bgr_npd and bgr_bgr_npd have to be enabled for the bandgap to be "
        "in power up.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGR_PD_N",
        "Both bgr_pd_n and bgr_bgr_pd_n must be enabled for the bandgap to be i"
        "n power up.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TESTBUFFERS_PD_N",
        "",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_SWRST.
static const field_t hw_afe_swrst[] =
{
    {
        "SYSCLK_SW_RST_N",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADC_PROC_CLK_SW_RST_N",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACAFE_SW_RST_N",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_BGREG.
static const field_t hw_afe_bgreg[] =
{
    {
        "BGR_TRIMLEVEL",
        "Vbg(x) = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGR_EN_EXT_CURRENT",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ACCESSAR_ID.
static const field_t hw_afe_accessar_id[] =
{
    {
        "ACCESSAR_ID",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_PDADC.
static const field_t hw_afe_pdadc[] =
{
    {
        "ACCESSAR_PD_N",
        "Active low power down of all ADC related blocks.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLYLOOP_PD_N",
        "Active low power down of ADC delay loop reference.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADC_IREF_PD_N",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_PD_N",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_PDSARH.
static const field_t hw_afe_pdsarh[] =
{
    {
        "ADC_PD_N",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_PDSARL.
static const field_t hw_afe_pdsarl[] =
{
    {
        "ADC_PD_N",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_PDADCRFH.
static const field_t hw_afe_pdadcrfh[] =
{
    {
        "ADCREF_REFBUFSLICE_PD_N",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_PDADCRFL.
static const field_t hw_afe_pdadcrfl[] =
{
    {
        "ADCREF_REFBUFSLICE_PD_N",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ADCGN.
static const field_t hw_afe_adcgn[] =
{
    {
        "ADC_GAIN",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_REFTRIML.
static const field_t hw_afe_reftriml[] =
{
    {
        "ADCREF_REFTRIM08",
        "Trim 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADCREF_REFTRIM04",
        "Trim 0.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADCREF_REFTRIM02",
        "Trim 0.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADCREF_REFTRIMOP",
        "Trim reference buffers.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_REFTRIMH.
static const field_t hw_afe_reftrimh[] =
{
    {
        "ADCREF_REFTRIM",
        "Master trim.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_DACAMP.
static const field_t hw_afe_dacamp[] =
{
    {
        "CLAMPDAC_TRIM",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_CLMPDAT.
static const field_t hw_afe_clmpdat[] =
{
    {
        "CLAMPDAC_DATA",
        "Only valid when parameter clamp_current_reg_override is set to registe"
        "r mode.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_CLMPAMP.
static const field_t hw_afe_clmpamp[] =
{
    {
        "CLAMP_DACDATA_EXTRA",
        "Defines non-assigned bits when in current leakage mode.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_DACDATA_WEIGHT",
        "",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_UPDN_REG_OVERRIDE",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_CURRENT_REG_OVERRIDE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_CLAMP.
static const field_t hw_afe_clamp[] =
{
    {
        "NCLAMP_POWERSAVE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_VN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_IPEN_REG",
        "Only valid when clamp_updn_reg_override.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_INEN_REG",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_LOWCURRMODE",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV_PROC_CLK",
        "Divides proc_clock by 4 or 8.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_UP_DOWN_POLARITY",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLAMP_PWN_MODE",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_INPBUF.
static const field_t hw_afe_inpbuf[] =
{
    {
        "BUFF_EN_RI",
        "Enable differential output of analog input buffer.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFF_EN_DI",
        "Enable direct input output of analog input buffer.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFF_EN_CM",
        "Enable common-mode output of analog input buffer.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_BUFFER_BP_EN",
        "Bypasses filter when set together with register mux_filterbypass.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_BUFFER_15M_EN",
        "Selects 15 MHz low-pass filter when set together with register [mux_fi"
        "lter_15m_en].",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_CLAMPEN",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_INPFLT.
static const field_t hw_afe_inpflt[] =
{
    {
        "MUX_PDCURRENTMIRROR",
        "Enable buffter current mirrors.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_FILTER_15M_EN",
        "Selects 15 MHz low-pass filter when set together with AFE_INPBUF[mux_b"
        "uffer_15m_en].",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_FILTERBYPASS",
        "Bypasses filter when set together with register [mux_buffer_bp_en].",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ADCDGN.
static const field_t hw_afe_adcdgn[] =
{
    {
        "ADC_DIGITAL_GAIN",
        "Digital gain.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADC_DIGITAL_GAIN_BYPASS",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_OFFDRV.
static const field_t hw_afe_offdrv[] =
{
    {
        "ENOFFCHIPDRIVE",
        "Connect input VIN3 directly to ADC P-input and input VIN2 directly to "
        "ADC N-input.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SH_TRIM",
        "Bit[0] enables test mode for ADC reference.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_INPCONFIG.
static const field_t hw_afe_inpconfig[] =
{
    {
        "INPUT_PULLDOWN_EN",
        "Set on unused inputs to minimize crosstalk from unused inputs",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_ENLF",
        "One bit per port.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_PROGDELAY.
static const field_t hw_afe_progdelay[] =
{
    {
        "PROG_DELAY",
        "Programmed value.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ADCOMT.
static const field_t hw_afe_adcomt[] =
{
    {
        "OVERRIDE",
        "Selects programmed value instead of value found by algorithm.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_TIME",
        "Defines algorithm update frequency.",
        1, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TIMING",
        "Defines when to measure.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ALGDELAY.
static const field_t hw_afe_algdelay[] =
{
    {
        "ALGORITHM_DELAY",
        "Value found by algorithm.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ACC_ID.
static const field_t hw_afe_acc_id[] =
{
    {
        "BLOCK_ID",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ACCSTA.
static const field_t hw_afe_accsta[] =
{
    {
        "STATUS",
        "Bit number [2:0] Indicate current function state of the ACC.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ACCNOSLI.
static const field_t hw_afe_accnosli[] =
{
    {
        "NO_OF_SLICES",
        "",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_ACCCALCON.
static const field_t hw_afe_acccalcon[] =
{
    {
        "CALIBRATE_START",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Data output in serial mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CALIB",
        "Allow the user to bypass the calibration sequence for the coefficients"
        " and instead use the default values.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET_COMP_EN",
        "If enabled, the parameter ana_offset_comp_en should also be enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANA_OFFSET_COMP_EN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_BWEWRICTRL.
static const field_t hw_afe_bwewrictrl[] =
{
    {
        "BWE_CTRL",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWE_WRITE_CTRL",
        "Select programming of new weights can be completed on individual slice"
        "s or all slices minimize the number of writes at once.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_SELSLI.
static const field_t hw_afe_selsli[] =
{
    {
        "SELECT_SLICE",
        "Read/Write selector, lsb.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_SELBYT.
static const field_t hw_afe_selbyt[] =
{
    {
        "SELECT_BYTE",
        "Read/Write, msb.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_REDVAL.
static const field_t hw_afe_redval[] =
{
    {
        "READ_VALUE",
        "Weight read register, lsb.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AFE_WRIBYT.
static const field_t hw_afe_wribyt[] =
{
    {
        "WRITE_BYTE",
        "Weight write register, lsb.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a AFE module.
static const reg_t hw_afe[] =
{
    {
        "BLOCK_ID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_afe_block_id
    },
    {
        "PDBUF",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_afe_pdbuf
    },
    {
        "SWRST",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_afe_swrst
    },
    {
        "BGREG",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_afe_bgreg
    },
    {
        "ACCESSAR_ID",
        "",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_afe_accessar_id
    },
    {
        "PDADC",
        "",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_afe_pdadc
    },
    {
        "PDSARH",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_pdsarh
    },
    {
        "PDSARL",
        "",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_pdsarl
    },
    {
        "PDADCRFH",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_pdadcrfh
    },
    {
        "PDADCRFL",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_pdadcrfl
    },
    {
        "ADCGN",
        "",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_adcgn
    },
    {
        "REFTRIML",
        "",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_afe_reftriml
    },
    {
        "REFTRIMH",
        "",
        4, // Width in bytes
        0x00000438, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_reftrimh
    },
    {
        "DACAMP",
        "",
        4, // Width in bytes
        0x0000044c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_dacamp
    },
    {
        "CLMPDAT",
        "",
        4, // Width in bytes
        0x00000454, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_clmpdat
    },
    {
        "CLMPAMP",
        "",
        4, // Width in bytes
        0x00000458, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_afe_clmpamp
    },
    {
        "CLAMP",
        "",
        4, // Width in bytes
        0x0000045c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_afe_clamp
    },
    {
        "INPBUF",
        "",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_afe_inpbuf
    },
    {
        "INPFLT",
        "",
        4, // Width in bytes
        0x00000464, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_afe_inpflt
    },
    {
        "ADCDGN",
        "",
        4, // Width in bytes
        0x00000468, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_afe_adcdgn
    },
    {
        "OFFDRV",
        "",
        4, // Width in bytes
        0x0000046c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_afe_offdrv
    },
    {
        "INPCONFIG",
        "",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_afe_inpconfig
    },
    {
        "PROGDELAY",
        "",
        4, // Width in bytes
        0x00000474, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_progdelay
    },
    {
        "ADCOMT",
        "",
        4, // Width in bytes
        0x00000478, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_afe_adcomt
    },
    {
        "ALGDELAY",
        "",
        4, // Width in bytes
        0x0000047c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_afe_algdelay
    },
    {
        "ACC_ID",
        "",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_afe_acc_id
    },
    {
        "ACCSTA",
        "",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_afe_accsta
    },
    {
        "ACCNOSLI",
        "",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_accnosli
    },
    {
        "ACCCALCON",
        "",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_afe_acccalcon
    },
    {
        "BWEWRICTRL",
        "",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_afe_bwewrictrl
    },
    {
        "SELSLI",
        "",
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_selsli
    },
    {
        "SELBYT",
        "",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_selbyt
    },
    {
        "REDVAL",
        "",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_afe_redval
    },
    {
        "WRIBYT",
        "",
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_afe_wribyt
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ASRC
#endif

// Bitfields in register ASRC_ASRCTR.
static const field_t hw_asrc_asrctr[] =
{
    {
        "ASRCEN",
        "ASRC Enable Enable the operation of ASRC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREA",
        "ASRC Enable A Enable the operation of the conversion A of ASRC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREB",
        "ASRC Enable B Enable the operation of the conversion B of ASRC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREC",
        "ASRC Enable C Enable the operation of the conversion C of ASRC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRST",
        "Software Reset This bit is self-clear bit.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "IDRA",
        "Use Ideal Ratio for Pair A When USRA=0, this bit has no usage.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRA",
        "Use Ratio for Pair A Use ratio as the input to ASRC.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDRB",
        "Use Ideal Ratio for Pair B When USRB=0, this bit has no usage.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRB",
        "Use Ratio for Pair B Use ratio as the input to ASRC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDRC",
        "Use Ideal Ratio for Pair C When USRC=0, this bit has no usage.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRC",
        "Use Ratio for Pair C Use ratio as the input to ASRC.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSA",
        "ASRC Pair A Automatic Selection For Processing Options When this bit i"
        "s 1, pair A will automatic update its pre-processing and post-processi"
        "ng options (ASRCFG: PREMODA, ASRCFG:POSTMODA see ASRC Misc Control Reg"
        "ister 1 for Pair CASRC Filter Configuration Status Register ) based on"
        " the frequencies it detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSB",
        "ASRC Pair B Automatic Selection For Processing Options When this bit i"
        "s 1, pair B will automatic update its pre-processing and post-processi"
        "ng options (ASRCFG: PREMODB, ASRCFG:POSTMODB see ASRC Misc Control Reg"
        "ister 1 for Pair CASRC Filter Configuration Status Register ) based on"
        " the frequencies it detected.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSC",
        "ASRC Pair C Automatic Selection For Processing Options When this bit i"
        "s 1, pair C will automatic update its pre-processing and post-processi"
        "ng options (ASRCFG: PREMODC, ASRCFG:POSTMODC see ASRC Misc Control Reg"
        "ister 1 for Pair CASRC Filter Configuration Status Register ) based on"
        " the frequencies it detected.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIER.
static const field_t hw_asrc_asrier[] =
{
    {
        "ADIEA",
        "Data Input A Interrupt Enable Enables the data input A Interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADIEB",
        "Data Input B Interrupt Enable Enables the data input B interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADIEC",
        "Data Input C Interrupt Enable Enables the data input C interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEA",
        "Data Output A Interrupt Enable Enables the data output A interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEB",
        "Data Output B Interrupt Enable Enables the data output B interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEC",
        "Data Output C Interrupt Enable Enables the data output C interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOLIE",
        "Overload Interrupt Enable Enables the overload interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AFPWE",
        "FP in Wait State Interrupt Enable Enables the FP in wait state interru"
        "pt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCNCR.
static const field_t hw_asrc_asrcncr[] =
{
    {
        "ANCA",
        "Number of A Channels",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANCB",
        "Number of B Channels",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANCC",
        "Number of C ChannelsANCC+ANCB+ANCA<=10.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCFG.
static const field_t hw_asrc_asrcfg[] =
{
    {
        "PREMODA",
        "Pre-Processing Configuration for Conversion Pair A These bits will be "
        "read/write by user if ASRCTR:ATSA=0, and can also be automatically upd"
        "ated by the ASRC internal logic if ASRCTR:ATSA=1 (see ASRC Misc Contro"
        "l Register 1 for Pair CASRC Control Register ).",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODA",
        "Post-Processing Configuration for Conversion Pair A These bits will be"
        " read/write by user if ASRCTR:ATSA=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSA=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair CASRC Control Register ).",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREMODB",
        "Pre-Processing Configuration for Conversion Pair B These bits will be "
        "read/write by user if ASRCTR:ATSB=0, and can also be automatically upd"
        "ated by the ASRC internal logic if ASRCTR:ATSB=1 (see ASRC Misc Contro"
        "l Register 1 for Pair CASRC Control Register ).",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODB",
        "Post-Processing Configuration for Conversion Pair B These bits will be"
        " read/write by user if ASRCTR:ATSB=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSB=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair CASRC Control Register ).",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREMODC",
        "Pre-Processing Configuration for Conversion Pair C These bits will be "
        "read/write by user if ASRCTR:ATSC=0, and can also be automatically upd"
        "ated by the ASRC internal logic if ASRCTR:ATSC=1 (see ASRC Misc Contro"
        "l Register 1 for Pair CASRC Control Register ).",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODC",
        "Post-Processing Configuration for Conversion Pair C These bits will be"
        " read/write by user if ASRCTR:ATSC=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSC=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair CASRC Control Register ).",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRA",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir A",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRB",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir B",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRC",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir C",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INIRQA",
        "Initialization for Conversion Pair A is served When this bit is 1, it "
        "means the initialization for conversion pair A is served.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INIRQB",
        "Initialization for Conversion Pair B is served When this bit is 1, it "
        "means the initialization for conversion pair B is served.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INIRQC",
        "Initialization for Conversion Pair C is served When this bit is 1, it "
        "means the initialization for conversion pair C is served.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCSR.
static const field_t hw_asrc_asrcsr[] =
{
    {
        "AICSA",
        "Input Clock Source A",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICSB",
        "Input Clock Source B",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICSC",
        "Input Clock Source C",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSA",
        "Output Clock Source A",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSB",
        "Output Clock Source B",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSC",
        "Output Clock Source C",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCDR1.
static const field_t hw_asrc_asrcdr1[] =
{
    {
        "AICPA",
        "Input Clock Prescaler A Specify the prescaling factor of the input pre"
        "scaler A.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDA",
        "Input Clock Divider A Specify the divide ratio of the input clock divi"
        "der A.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICPB",
        "Input Clock Prescaler B Specify the prescaling factor of the input pre"
        "scaler B.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDB",
        "Input Clock Divider B Specify the divide ratio of the input clock divi"
        "der B.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPA",
        "Output Clock Prescaler A Specify the prescaling factor of the output p"
        "rescaler A.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDA",
        "Output Clock Divider A Specify the divide ratio of the output clock di"
        "vider A.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPB",
        "Output Clock Prescaler B Specify the prescaling factor of the output p"
        "rescaler B.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDB",
        "Output Clock Divider B Specify the divide ratio of the output clock di"
        "vider B.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCDR2.
static const field_t hw_asrc_asrcdr2[] =
{
    {
        "AICPC",
        "Input Clock Prescaler C Specify the prescaling factor of the input pre"
        "scaler C.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDC",
        "Input Clock Divider C Specify the divide ratio of the input clock divi"
        "der C.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPC",
        "Output Clock Prescaler C Specify the prescaling factor of the output p"
        "rescaler C.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDC",
        "Output Clock Divider C Specify the divide ratio of the output clock di"
        "vider C.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRSTR.
static const field_t hw_asrc_asrstr[] =
{
    {
        "AIDEA",
        "Number of data in Input Data Buffer A is less than threshold When set,"
        " this bit indicates that number of data still available in ASRDIRA is "
        "less than threshold and the processor can write data to ASRDIRA.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDEB",
        "Number of data in Input Data Buffer B is less than threshold When set,"
        " this bit indicates that number of data still available in ASRDIRB is "
        "less than threshold and the processor can write data to ASRDIRB.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDEC",
        "Number of data in Input Data Buffer C is less than threshold When set,"
        " this bit indicates that number of data still available in ASRDIRC is "
        "less than threshold and the processor can write data to ASRDIRC.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFA",
        "Number of data in Output Data Buffer A is greater than threshold When "
        "set, this bit indicates that number of data already existing in ASRDOR"
        "A is greater than threshold and the processor can read data from ASRDO"
        "RA.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFB",
        "Number of data in Output Data Buffer B is greater than threshold When "
        "set, this bit indicates that number of data already existing in ASRDOR"
        "B is greater than threshold and the processor can read data from ASRDO"
        "RB.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFC",
        "Number of data in Output Data Buffer C is greater than threshold When "
        "set, this bit indicates that number of data already existing in ASRDOR"
        "C is greater than threshold and the processor can read data from ASRDO"
        "RC.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOLE",
        "Overload Error Flag When set, this bit indicates that the task rate is"
        " too high for the ASRC to handle.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FPWT",
        "FP is in wait states This bit is for debug only.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUA",
        "Input Data Buffer A has underflowed When set, this bit indicates that "
        "input data buffer A has underflowed.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUB",
        "Input Data Buffer B has underflowed When set, this bit indicates that "
        "input data buffer B has underflowed.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUC",
        "Input Data Buffer C has underflowed When set, this bit indicates that "
        "input data buffer C has underflowed.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOA",
        "Output Data Buffer A has overflowed When set, this bit indicates that "
        "output data buffer A has overflowed.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOB",
        "Output Data Buffer B has overflowed When set, this bit indicates that "
        "output data buffer B has overflowed.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOC",
        "Output Data Buffer C has overflowed When set, this bit indicates that "
        "output data buffer C has overflowed.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLA",
        "Pair A Input Task Overload When set, this bit indicates that pair A in"
        "put task is oveloaded.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLB",
        "Pair B Input Task Overload When set, this bit indicates that pair B in"
        "put task is oveloaded.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLC",
        "Pair C Input Task Overload When set, this bit indicates that pair C in"
        "put task is oveloaded.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLA",
        "Pair A Output Task Overload When set, this bit indicates that pair A o"
        "utput task is oveloaded.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLB",
        "Pair B Output Task Overload When set, this bit indicates that pair B o"
        "utput task is oveloaded.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLC",
        "Pair C Output Task Overload When set, this bit indicates that pair C o"
        "utput task is oveloaded.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ATQOL",
        "Task Queue FIFO overload When set, this bit indicates that task queue "
        "FIFO logic is oveloaded.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSLCNT",
        "DSL Counter Input to FIFO ready When set, this bit indicates that new "
        "DSL counter information is stored in the internal ASRC FIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn1.
static const field_t hw_asrc_asrpmn1[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn2.
static const field_t hw_asrc_asrpmn2[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn3.
static const field_t hw_asrc_asrpmn3[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn4.
static const field_t hw_asrc_asrpmn4[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn5.
static const field_t hw_asrc_asrpmn5[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRTFR1.
static const field_t hw_asrc_asrtfr1[] =
{
    {
        "TF_BASE",
        "Base address for task queue FIFO.",
        6, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF_FILL",
        "Current number of entries in task queue FIFO.",
        13, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCCR.
static const field_t hw_asrc_asrccr[] =
{
    {
        "ACIA",
        "The channel counter for Pair A's input FIFO These bits stand for the c"
        "urrent channel being accessed through shared peripheral bus for Pair A"
        "'s input FIFO's usage.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACIB",
        "The channel counter for Pair B's input FIFO These bits stand for the c"
        "urrent channel being accessed through shared peripheral bus for Pair B"
        "'s input FIFO's usage.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACIC",
        "The channel counter for Pair C's input FIFO These bits stand for the c"
        "urrent channel being accessed through shared peripheral bus for Pair C"
        "'s input FIFO's usage.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOA",
        "The channel counter for Pair A's output FIFO These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "A's output FIFO's usage.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOB",
        "The channel counter for Pair B's output FIFO These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "B's output FIFO's usage.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOC",
        "The channel counter for Pair C's output FIFO These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "C's output FIFO's usage.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIA.
static const field_t hw_asrc_asrdia[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOA.
static const field_t hw_asrc_asrdoa[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIB.
static const field_t hw_asrc_asrdib[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOB.
static const field_t hw_asrc_asrdob[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIC.
static const field_t hw_asrc_asrdic[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOC.
static const field_t hw_asrc_asrdoc[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHA.
static const field_t hw_asrc_asridrha[] =
{
    {
        "IDRATIOA",
        "IDRATIOA[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLA.
static const field_t hw_asrc_asridrla[] =
{
    {
        "IDRATIOA",
        "IDRATIOA[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHB.
static const field_t hw_asrc_asridrhb[] =
{
    {
        "IDRATIOB",
        "IDRATIOB[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLB.
static const field_t hw_asrc_asridrlb[] =
{
    {
        "IDRATIOB",
        "IDRATIOB[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHC.
static const field_t hw_asrc_asridrhc[] =
{
    {
        "IDRATIOC",
        "IDRATIOC[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLC.
static const field_t hw_asrc_asridrlc[] =
{
    {
        "IDRATIOC",
        "IDRATIOC[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASR76K.
static const field_t hw_asrc_asr76k[] =
{
    {
        "ASR76K",
        "Value for the period of the 76kHz sampling clock.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASR56K.
static const field_t hw_asrc_asr56k[] =
{
    {
        "ASR56K",
        "Value for the period of the 56kHz sampling clock",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRA.
static const field_t hw_asrc_asrmcra[] =
{
    {
        "INFIFO_THRESHOLDA",
        "The threshold for Pair A's input FIFO per channel These bits stand for"
        " the threshold for Pair A's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFA",
        "Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOA=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFA",
        "Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIA=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDA",
        "The threshold for Pair A's output FIFO per channel These bits stand fo"
        "r the threshold for Pair A's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYA",
        "Bypass Polyphase Filtering for Pair A This bit will determine whether "
        "the polyphase filtering part of Pair A conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLA",
        "Stall Pair A conversion in case of Buffer Near Empty/Full Condition Th"
        "is bit will determine whether the near empty/full FIFO condition will "
        "stall the rate conversion for pair A.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHA",
        "Use external thresholds for FIFO control of Pair A This bit will deter"
        "mine whether the FIFO thresholds externally defined in this register i"
        "s used to control ASRC internal FIFO logic for pair A.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFA",
        "Initialize buf of Pair A when pair A is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTA.
static const field_t hw_asrc_asrfsta[] =
{
    {
        "INFIFO_FILLA",
        "The fillings for Pair A's input FIFO per channel These bits stand for "
        "the fillings for Pair A's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEA",
        "Input FIFO is near Empty for Pair A This bit is to indicate whether th"
        "e input FIFO of Pair A is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLA",
        "The fillings for Pair A's output FIFO per channel These bits stand for"
        " the fillings for Pair A's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFA",
        "Output FIFO is near Full for Pair A This bit is to indicate whether th"
        "e output FIFO of Pair A is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRB.
static const field_t hw_asrc_asrmcrb[] =
{
    {
        "INFIFO_THRESHOLDB",
        "The threshold for Pair B's input FIFO per channel These bits stand for"
        " the threshold for Pair B's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFB",
        "Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOB=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFB",
        "Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIB=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDB",
        "The threshold for Pair B's output FIFO per channel These bits stand fo"
        "r the threshold for Pair B's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYB",
        "Bypass Polyphase Filtering for Pair B This bit will determine whether "
        "the polyphase filtering part of Pair B conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLB",
        "Stall Pair B conversion in case of Buffer Near Empty/Full Condition Th"
        "is bit will determine whether the near empty/full FIFO condition will "
        "stall the rate conversion for pair B.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHB",
        "Use external thresholds for FIFO control of Pair B This bit will deter"
        "mine whether the FIFO thresholds externally defined in this register i"
        "s used to control ASRC internal FIFO logic for pair B.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFB",
        "Initialize buf of Pair B when pair B is enabled This bit is used to co"
        "ntrol whether the buffer is to be zeroized when pair B is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTB.
static const field_t hw_asrc_asrfstb[] =
{
    {
        "INFIFO_FILLB",
        "The fillings for Pair B's input FIFO per channel These bits stand for "
        "the fillings for Pair B's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEB",
        "Input FIFO is near Empty for Pair B This bit is to indicate whether th"
        "e input FIFO of Pair B is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLB",
        "The fillings for Pair B's output FIFO per channel These bits stand for"
        " the fillings for Pair B's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFB",
        "Output FIFO is near Full for Pair B This bit is to indicate whether th"
        "e output FIFO of Pair B is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRC.
static const field_t hw_asrc_asrmcrc[] =
{
    {
        "INFIFO_THRESHOLDC",
        "The threshold for Pair C's input FIFO per channel These bits stand for"
        " the threshold for Pair C's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFC",
        "Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOC=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFC",
        "Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIC=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDC",
        "The threshold for Pair C's output FIFO per channel These bits stand fo"
        "r the threshold for Pair C's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYC",
        "Bypass Polyphase Filtering for Pair C This bit will determine whether "
        "the polyphase filtering part of Pair C conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLC",
        "Stall Pair C conversion in case of Buffer Near Empty/Full Condition Th"
        "is bit will determine whether the near empty/full FIFO condition will "
        "stall the rate conversion for pair C.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHC",
        "Use external thresholds for FIFO control of Pair C This bit will deter"
        "mine whether the FIFO thresholds externally defined in this register i"
        "s used to control ASRC internal FIFO logic for pair C.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFC",
        "Initialize buf of Pair C when pair C is enabled This bit is used to co"
        "ntrol whether the buffer is to be zeroized when pair C is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTC.
static const field_t hw_asrc_asrfstc[] =
{
    {
        "INFIFO_FILLC",
        "The fillings for Pair C's input FIFO per channel These bits stand for "
        "the fillings for Pair C's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEC",
        "Input FIFO is near Empty for Pair C This bit is to indicate whether th"
        "e input FIFO of Pair C is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLC",
        "The fillings for Pair C's output FIFO per channel These bits stand for"
        " the fillings for Pair C's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFC",
        "Output FIFO is near Full for Pair C This bit is to indicate whether th"
        "e output FIFO of Pair C is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1A.
static const field_t hw_asrc_asrmcr1a[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO This bit will determine the bit wi"
        "dth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO This bit will determine the s"
        "ign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO This bit will determine the data ali"
        "gnment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO This bit will determine the data alig"
        "nment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO These three bits will determine the bitwi"
        "dth for the audio data into ASRC All other settings not shown are rese"
        "rved.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1B.
static const field_t hw_asrc_asrmcr1b[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO This bit will determine the bit wi"
        "dth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO This bit will determine the s"
        "ign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO This bit will determine the data ali"
        "gnment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO This bit will determine the data alig"
        "nment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO These three bits will determine the bitwi"
        "dth for the audio data into ASRC All other settings not shown are rese"
        "rved.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1C.
static const field_t hw_asrc_asrmcr1c[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO This bit will determine the bit wi"
        "dth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO This bit will determine the s"
        "ign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO This bit will determine the data ali"
        "gnment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO This bit will determine the data alig"
        "nment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO These three bits will determine the bitwi"
        "dth for the audio data into ASRC All other settings not shown are rese"
        "rved.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ASRC module.
static const reg_t hw_asrc[] =
{
    {
        "ASRCTR",
        "The ASRC control register (ASRCTR) is a 24-bit read/write register tha"
        "t controls the ASRC operations.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_asrc_asrctr
    },
    {
        "ASRIER",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrier
    },
    {
        "ASRCNCR",
        "The ASRC channel number configuration register (ASRCNCR) is a 24-bit r"
        "ead/write register that sets the number of channels used by each ASRC "
        "conversion pair.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_asrc_asrcncr
    },
    {
        "ASRCFG",
        "The ASRC configuration status register (ASRCFG) is a 24-bit read/write"
        " register that sets and/or automatically senses the ASRC operations.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_asrc_asrcfg
    },
    {
        "ASRCSR",
        "The ASRC clock source register (ASRCSR) is a 24-bit read/write registe"
        "r that controls the sources of the input and output clocks of the ASRC"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_asrc_asrcsr
    },
    {
        "ASRCDR1",
        "The ASRC clock divider register (ASRCDR1) is a 24-bit read/write regis"
        "ter that controls the division factors of the ASRC input and output cl"
        "ock sources.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrcdr1
    },
    {
        "ASRCDR2",
        "The ASRC clock divider register (ASRCDR2) is a 24-bit read/write regis"
        "ter that controls the division factors of the ASRC input and output cl"
        "ock sources.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_asrc_asrcdr2
    },
    {
        "ASRSTR",
        "The ASRC status register (ASRSTR) is a 24-bit read-write register used"
        " by the processor core to examine the status of the ASRC block and cle"
        "ar the overload interrupt request and AOLE flag bit.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        22, // Number of bitfields
        hw_asrc_asrstr
    },
    {
        "ASRPMn1",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn1
    },
    {
        "ASRPMn2",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn2
    },
    {
        "ASRPMn3",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn3
    },
    {
        "ASRPMn4",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn4
    },
    {
        "ASRPMn5",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn5
    },
    {
        "ASRTFR1",
        "The register defines and shows the parameters for ASRC inner task queu"
        "e FIFOs.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrtfr1
    },
    {
        "ASRCCR",
        "The ASRC channel counter register (ASRCCR) is a 24-bit read/write regi"
        "ster that sets and reflects the current specific input/output FIFO bei"
        "ng accessed through shared peripheral bus for each ASRC conversion pai"
        "r.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_asrc_asrccr
    },
    {
        "ASRDIA",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000060, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdia
    },
    {
        "ASRDOA",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdoa
    },
    {
        "ASRDIB",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000068, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdib
    },
    {
        "ASRDOB",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdob
    },
    {
        "ASRDIC",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000070, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdic
    },
    {
        "ASRDOC",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdoc
    },
    {
        "ASRIDRHA",
        "The ideal ratio registers (ASRIDRHA, ASRIDRLA) hold the ratio value ID"
        "RATIOA.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrha
    },
    {
        "ASRIDRLA",
        "The ideal ratio registers (ASRIDRHA, ASRIDRLA) hold the ratio value ID"
        "RATIOA.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrla
    },
    {
        "ASRIDRHB",
        "The ideal ratio registers (ASRIDRHB, ASRIDRLB) hold the ratio value ID"
        "RATIOB.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrhb
    },
    {
        "ASRIDRLB",
        "The ideal ratio registers (ASRIDRHB, ASRIDRLB) hold the ratio value ID"
        "RATIOB.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrlb
    },
    {
        "ASRIDRHC",
        "The ideal ratio registers (ASRIDRHC, ASRIDRLC) hold the ratio value ID"
        "RATIOC.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrhc
    },
    {
        "ASRIDRLC",
        "The ideal ratio registers (ASRIDRHC, ASRIDRLC) hold the ratio value ID"
        "RATIOC.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrlc
    },
    {
        "ASR76K",
        "The register (ASR76K) holds the period of the 76kHz sampling clock in "
        "terms of the ASRC processing clock with frequency FsASRC.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asr76k
    },
    {
        "ASR56K",
        "The register (ASR56K) holds the period of the 56kHz sampling clock in "
        "terms of the ASRC processing clock with frequency FsASRC.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asr56k
    },
    {
        "ASRMCRA",
        "The register (ASRMCRA) is used to control Pair A internal logic.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrmcra
    },
    {
        "ASRFSTA",
        "The register (ASRFSTA) is used to show Pair A internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_asrc_asrfsta
    },
    {
        "ASRMCRB",
        "The register (ASRMCRB) is used to control Pair B internal logic.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrmcrb
    },
    {
        "ASRFSTB",
        "The register (ASRFSTB) is used to show Pair B internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_asrc_asrfstb
    },
    {
        "ASRMCRC",
        "The register (ASRMCRC) is used to control Pair C internal logic.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrmcrc
    },
    {
        "ASRFSTC",
        "The register (ASRFSTC) is used to show Pair C internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_asrc_asrfstc
    },
    {
        "ASRMCR1A",
        "The register (ASRMCR1x) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_asrc_asrmcr1a
    },
    {
        "ASRMCR1B",
        "The register (ASRMCR1x) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_asrc_asrmcr1b
    },
    {
        "ASRMCR1C",
        "The register (ASRMCR1x) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_asrc_asrmcr1c
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark AUDMUX
#endif

// Bitfields in register AUDMUX_PTCR1.
static const field_t hw_audmux_ptcr1[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR1.
static const field_t hw_audmux_pdcr1[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR2.
static const field_t hw_audmux_ptcr2[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR2.
static const field_t hw_audmux_pdcr2[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR3.
static const field_t hw_audmux_ptcr3[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR3.
static const field_t hw_audmux_pdcr3[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR4.
static const field_t hw_audmux_ptcr4[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR4.
static const field_t hw_audmux_pdcr4[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR5.
static const field_t hw_audmux_ptcr5[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR5.
static const field_t hw_audmux_pdcr5[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR6.
static const field_t hw_audmux_ptcr6[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR6.
static const field_t hw_audmux_pdcr6[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR7.
static const field_t hw_audmux_ptcr7[] =
{
    {
        "SYN",
        "Synchronous/Asynchronous Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        "Receive Clock Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        "Receive Clock Direction Control.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        "Receive Frame Sync Select.",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        "Receive Frame Sync Direction Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        "Transmit Clock Select.",
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        "Transmit Clock Direction Control.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        "Transmit Frame Sync Select.",
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        "Transmit Frame Sync Direction Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR7.
static const field_t hw_audmux_pdcr7[] =
{
    {
        "INMMASK",
        "Internal Network Mode Mask.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Mode Select.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        "Transmit/Receive Switch Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        "Receive Data Select.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a AUDMUX module.
static const reg_t hw_audmux[] =
{
    {
        "PTCR1",
        "PTCR1 is the Port Timing Control Register for Port 1.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr1
    },
    {
        "PDCR1",
        "PDCR1 is the Port Data Control Register for Port 1.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr1
    },
    {
        "PTCR2",
        "PTCR2 is the Port Timing Control Register for Port 2.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr2
    },
    {
        "PDCR2",
        "PDCR2 is the Port Data Control Register for Port 2.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr2
    },
    {
        "PTCR3",
        "PTCR3 is the Port Timing Control Register for Port 3.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr3
    },
    {
        "PDCR3",
        "PDCR3 is the Port Data Control Register for Port 3.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr3
    },
    {
        "PTCR4",
        "Port Timing Control Register for Port 4",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr4
    },
    {
        "PDCR4",
        "PDCR4 is the Port Data Control Register for Port 4.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr4
    },
    {
        "PTCR5",
        "Port Timing Control Register for Port 5",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr5
    },
    {
        "PDCR5",
        "PDCR5 is the Port Data Control Register for Port 5.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr5
    },
    {
        "PTCR6",
        "Port Timing Control Register for Port 6",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr6
    },
    {
        "PDCR6",
        "PDCR6 is the Port Data Control Register for Port 6.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr6
    },
    {
        "PTCR7",
        "Port Timing Control Register for Port 7",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr7
    },
    {
        "PDCR7",
        "PDCR7 is the Port Data Control Register for Port 7.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr7
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark BCH
#endif

// Bitfields in register BCH_CTRL.
static const field_t hw_bch_ctrl[] =
{
    {
        "COMPLETE_IRQ",
        "This bit indicates the state of the external interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ",
        "DEBUG STALL Interrupt Status.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "AHB Bus interface Error Interrupt Status.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETE_IRQ_EN",
        "1 = interrupt on completion of correction is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set these bits to zero.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ_EN",
        "1 = interrupt on debug stall mode is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set these bits to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2M_ENABLE",
        "NOTE! WRITING THIS BIT INITIATES A MEMORY-TO-MEMORY OPERATION.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_ENCODE",
        "Selects encode (parity generation) or decode (correction) mode for mem"
        "ory-to-memory operations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_LAYOUT",
        "Selects the flash page format for memory-to-memory operations.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set these bits to zero.",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUGSYNDROME",
        "(For debug purposes only).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved, always set this bit to zero.",
        23, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal BCH operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_CTRL_SET.
static const field_t hw_bch_ctrl_set[] =
{
    {
        "COMPLETE_IRQ",
        "This bit indicates the state of the external interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ",
        "DEBUG STALL Interrupt Status.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "AHB Bus interface Error Interrupt Status.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETE_IRQ_EN",
        "1 = interrupt on completion of correction is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set these bits to zero.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ_EN",
        "1 = interrupt on debug stall mode is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set these bits to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2M_ENABLE",
        "NOTE! WRITING THIS BIT INITIATES A MEMORY-TO-MEMORY OPERATION.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_ENCODE",
        "Selects encode (parity generation) or decode (correction) mode for mem"
        "ory-to-memory operations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_LAYOUT",
        "Selects the flash page format for memory-to-memory operations.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set these bits to zero.",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUGSYNDROME",
        "(For debug purposes only).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved, always set this bit to zero.",
        23, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal BCH operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_CTRL_CLR.
static const field_t hw_bch_ctrl_clr[] =
{
    {
        "COMPLETE_IRQ",
        "This bit indicates the state of the external interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ",
        "DEBUG STALL Interrupt Status.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "AHB Bus interface Error Interrupt Status.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETE_IRQ_EN",
        "1 = interrupt on completion of correction is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set these bits to zero.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ_EN",
        "1 = interrupt on debug stall mode is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set these bits to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2M_ENABLE",
        "NOTE! WRITING THIS BIT INITIATES A MEMORY-TO-MEMORY OPERATION.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_ENCODE",
        "Selects encode (parity generation) or decode (correction) mode for mem"
        "ory-to-memory operations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_LAYOUT",
        "Selects the flash page format for memory-to-memory operations.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set these bits to zero.",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUGSYNDROME",
        "(For debug purposes only).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved, always set this bit to zero.",
        23, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal BCH operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_CTRL_TOG.
static const field_t hw_bch_ctrl_tog[] =
{
    {
        "COMPLETE_IRQ",
        "This bit indicates the state of the external interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ",
        "DEBUG STALL Interrupt Status.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "AHB Bus interface Error Interrupt Status.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETE_IRQ_EN",
        "1 = interrupt on completion of correction is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set these bits to zero.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ_EN",
        "1 = interrupt on debug stall mode is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set these bits to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2M_ENABLE",
        "NOTE! WRITING THIS BIT INITIATES A MEMORY-TO-MEMORY OPERATION.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_ENCODE",
        "Selects encode (parity generation) or decode (correction) mode for mem"
        "ory-to-memory operations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_LAYOUT",
        "Selects the flash page format for memory-to-memory operations.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set these bits to zero.",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUGSYNDROME",
        "(For debug purposes only).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved, always set this bit to zero.",
        23, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal BCH operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_STATUS0.
static const field_t hw_bch_status0[] =
{
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNCORRECTABLE",
        "1 = Uncorrectable error encountered during last processing cycle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECTED",
        "1 = At least one correctable error encountered during last processing "
        "cycle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALLONES",
        "1 = All data bits of this transaction are ONE.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATUS_BLK0",
        "Count of symbols in error during processing of first block of flash (m"
        "etadata block).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETED_CE",
        "This is the chip enable number corresponding to the NAND device from w"
        "hich this data came.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HANDLE",
        "Software supplies a 12 bit handle for this transfer as part of the GPM"
        "I DMA PIO operation that started the transaction.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_STATUS0_SET.
static const field_t hw_bch_status0_set[] =
{
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNCORRECTABLE",
        "1 = Uncorrectable error encountered during last processing cycle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECTED",
        "1 = At least one correctable error encountered during last processing "
        "cycle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALLONES",
        "1 = All data bits of this transaction are ONE.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATUS_BLK0",
        "Count of symbols in error during processing of first block of flash (m"
        "etadata block).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETED_CE",
        "This is the chip enable number corresponding to the NAND device from w"
        "hich this data came.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HANDLE",
        "Software supplies a 12 bit handle for this transfer as part of the GPM"
        "I DMA PIO operation that started the transaction.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_STATUS0_CLR.
static const field_t hw_bch_status0_clr[] =
{
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNCORRECTABLE",
        "1 = Uncorrectable error encountered during last processing cycle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECTED",
        "1 = At least one correctable error encountered during last processing "
        "cycle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALLONES",
        "1 = All data bits of this transaction are ONE.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATUS_BLK0",
        "Count of symbols in error during processing of first block of flash (m"
        "etadata block).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETED_CE",
        "This is the chip enable number corresponding to the NAND device from w"
        "hich this data came.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HANDLE",
        "Software supplies a 12 bit handle for this transfer as part of the GPM"
        "I DMA PIO operation that started the transaction.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_STATUS0_TOG.
static const field_t hw_bch_status0_tog[] =
{
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNCORRECTABLE",
        "1 = Uncorrectable error encountered during last processing cycle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECTED",
        "1 = At least one correctable error encountered during last processing "
        "cycle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALLONES",
        "1 = All data bits of this transaction are ONE.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATUS_BLK0",
        "Count of symbols in error during processing of first block of flash (m"
        "etadata block).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETED_CE",
        "This is the chip enable number corresponding to the NAND device from w"
        "hich this data came.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HANDLE",
        "Software supplies a 12 bit handle for this transfer as part of the GPM"
        "I DMA PIO operation that started the transaction.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_MODE.
static const field_t hw_bch_mode[] =
{
    {
        "ERASE_THRESHOLD",
        "This value indicates the maximum number of zero bits on a flash page f"
        "or it to be considered erased.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set these bits to zero.",
        8, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_MODE_SET.
static const field_t hw_bch_mode_set[] =
{
    {
        "ERASE_THRESHOLD",
        "This value indicates the maximum number of zero bits on a flash page f"
        "or it to be considered erased.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set these bits to zero.",
        8, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_MODE_CLR.
static const field_t hw_bch_mode_clr[] =
{
    {
        "ERASE_THRESHOLD",
        "This value indicates the maximum number of zero bits on a flash page f"
        "or it to be considered erased.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set these bits to zero.",
        8, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_MODE_TOG.
static const field_t hw_bch_mode_tog[] =
{
    {
        "ERASE_THRESHOLD",
        "This value indicates the maximum number of zero bits on a flash page f"
        "or it to be considered erased.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set these bits to zero.",
        8, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_ENCODEPTR.
static const field_t hw_bch_encodeptr[] =
{
    {
        "ADDR",
        "Address pointer to encode buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_ENCODEPTR_SET.
static const field_t hw_bch_encodeptr_set[] =
{
    {
        "ADDR",
        "Address pointer to encode buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_ENCODEPTR_CLR.
static const field_t hw_bch_encodeptr_clr[] =
{
    {
        "ADDR",
        "Address pointer to encode buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_ENCODEPTR_TOG.
static const field_t hw_bch_encodeptr_tog[] =
{
    {
        "ADDR",
        "Address pointer to encode buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DATAPTR.
static const field_t hw_bch_dataptr[] =
{
    {
        "ADDR",
        "Address pointer to data buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DATAPTR_SET.
static const field_t hw_bch_dataptr_set[] =
{
    {
        "ADDR",
        "Address pointer to data buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DATAPTR_CLR.
static const field_t hw_bch_dataptr_clr[] =
{
    {
        "ADDR",
        "Address pointer to data buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DATAPTR_TOG.
static const field_t hw_bch_dataptr_tog[] =
{
    {
        "ADDR",
        "Address pointer to data buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_METAPTR.
static const field_t hw_bch_metaptr[] =
{
    {
        "ADDR",
        "Address pointer to metadata buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_METAPTR_SET.
static const field_t hw_bch_metaptr_set[] =
{
    {
        "ADDR",
        "Address pointer to metadata buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_METAPTR_CLR.
static const field_t hw_bch_metaptr_clr[] =
{
    {
        "ADDR",
        "Address pointer to metadata buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_METAPTR_TOG.
static const field_t hw_bch_metaptr_tog[] =
{
    {
        "ADDR",
        "Address pointer to metadata buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_LAYOUTSELECT.
static const field_t hw_bch_layoutselect[] =
{
    {
        "CS0_SELECT",
        "Selects which layout is used for chip select 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_SELECT",
        "Selects which layout is used for chip select 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS2_SELECT",
        "Selects which layout is used for chip select 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS3_SELECT",
        "Selects which layout is used for chip select 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS4_SELECT",
        "Selects which layout is used for chip select 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS5_SELECT",
        "Selects which layout is used for chip select 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS6_SELECT",
        "Selects which layout is used for chip select 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS7_SELECT",
        "Selects which layout is used for chip select 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS8_SELECT",
        "Selects which layout is used for chip select 8.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS9_SELECT",
        "Selects which layout is used for chip select 9.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS10_SELECT",
        "Selects which layout is used for chip select 10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS11_SELECT",
        "Selects which layout is used for chip select 11.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS12_SELECT",
        "Selects which layout is used for chip select 12.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS13_SELECT",
        "Selects which layout is used for chip select 13.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS14_SELECT",
        "Selects which layout is used for chip select 14.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS15_SELECT",
        "Selects which layout is used for chip select 15.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_LAYOUTSELECT_SET.
static const field_t hw_bch_layoutselect_set[] =
{
    {
        "CS0_SELECT",
        "Selects which layout is used for chip select 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_SELECT",
        "Selects which layout is used for chip select 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS2_SELECT",
        "Selects which layout is used for chip select 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS3_SELECT",
        "Selects which layout is used for chip select 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS4_SELECT",
        "Selects which layout is used for chip select 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS5_SELECT",
        "Selects which layout is used for chip select 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS6_SELECT",
        "Selects which layout is used for chip select 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS7_SELECT",
        "Selects which layout is used for chip select 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS8_SELECT",
        "Selects which layout is used for chip select 8.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS9_SELECT",
        "Selects which layout is used for chip select 9.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS10_SELECT",
        "Selects which layout is used for chip select 10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS11_SELECT",
        "Selects which layout is used for chip select 11.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS12_SELECT",
        "Selects which layout is used for chip select 12.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS13_SELECT",
        "Selects which layout is used for chip select 13.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS14_SELECT",
        "Selects which layout is used for chip select 14.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS15_SELECT",
        "Selects which layout is used for chip select 15.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_LAYOUTSELECT_CLR.
static const field_t hw_bch_layoutselect_clr[] =
{
    {
        "CS0_SELECT",
        "Selects which layout is used for chip select 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_SELECT",
        "Selects which layout is used for chip select 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS2_SELECT",
        "Selects which layout is used for chip select 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS3_SELECT",
        "Selects which layout is used for chip select 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS4_SELECT",
        "Selects which layout is used for chip select 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS5_SELECT",
        "Selects which layout is used for chip select 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS6_SELECT",
        "Selects which layout is used for chip select 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS7_SELECT",
        "Selects which layout is used for chip select 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS8_SELECT",
        "Selects which layout is used for chip select 8.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS9_SELECT",
        "Selects which layout is used for chip select 9.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS10_SELECT",
        "Selects which layout is used for chip select 10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS11_SELECT",
        "Selects which layout is used for chip select 11.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS12_SELECT",
        "Selects which layout is used for chip select 12.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS13_SELECT",
        "Selects which layout is used for chip select 13.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS14_SELECT",
        "Selects which layout is used for chip select 14.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS15_SELECT",
        "Selects which layout is used for chip select 15.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_LAYOUTSELECT_TOG.
static const field_t hw_bch_layoutselect_tog[] =
{
    {
        "CS0_SELECT",
        "Selects which layout is used for chip select 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_SELECT",
        "Selects which layout is used for chip select 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS2_SELECT",
        "Selects which layout is used for chip select 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS3_SELECT",
        "Selects which layout is used for chip select 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS4_SELECT",
        "Selects which layout is used for chip select 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS5_SELECT",
        "Selects which layout is used for chip select 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS6_SELECT",
        "Selects which layout is used for chip select 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS7_SELECT",
        "Selects which layout is used for chip select 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS8_SELECT",
        "Selects which layout is used for chip select 8.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS9_SELECT",
        "Selects which layout is used for chip select 9.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS10_SELECT",
        "Selects which layout is used for chip select 10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS11_SELECT",
        "Selects which layout is used for chip select 11.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS12_SELECT",
        "Selects which layout is used for chip select 12.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS13_SELECT",
        "Selects which layout is used for chip select 13.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS14_SELECT",
        "Selects which layout is used for chip select 14.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS15_SELECT",
        "Selects which layout is used for chip select 15.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT0.
static const field_t hw_bch_flash0layout0[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT0_SET.
static const field_t hw_bch_flash0layout0_set[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT0_CLR.
static const field_t hw_bch_flash0layout0_clr[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT0_TOG.
static const field_t hw_bch_flash0layout0_tog[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT1.
static const field_t hw_bch_flash0layout1[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT1_SET.
static const field_t hw_bch_flash0layout1_set[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT1_CLR.
static const field_t hw_bch_flash0layout1_clr[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT1_TOG.
static const field_t hw_bch_flash0layout1_tog[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT0.
static const field_t hw_bch_flash1layout0[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT0_SET.
static const field_t hw_bch_flash1layout0_set[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT0_CLR.
static const field_t hw_bch_flash1layout0_clr[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT0_TOG.
static const field_t hw_bch_flash1layout0_tog[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT1.
static const field_t hw_bch_flash1layout1[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT1_SET.
static const field_t hw_bch_flash1layout1_set[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT1_CLR.
static const field_t hw_bch_flash1layout1_clr[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT1_TOG.
static const field_t hw_bch_flash1layout1_tog[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT0.
static const field_t hw_bch_flash2layout0[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT0_SET.
static const field_t hw_bch_flash2layout0_set[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT0_CLR.
static const field_t hw_bch_flash2layout0_clr[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT0_TOG.
static const field_t hw_bch_flash2layout0_tog[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT1.
static const field_t hw_bch_flash2layout1[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT1_SET.
static const field_t hw_bch_flash2layout1_set[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT1_CLR.
static const field_t hw_bch_flash2layout1_clr[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT1_TOG.
static const field_t hw_bch_flash2layout1_tog[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT0.
static const field_t hw_bch_flash3layout0[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT0_SET.
static const field_t hw_bch_flash3layout0_set[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT0_CLR.
static const field_t hw_bch_flash3layout0_clr[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT0_TOG.
static const field_t hw_bch_flash3layout0_tog[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT1.
static const field_t hw_bch_flash3layout1[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT1_SET.
static const field_t hw_bch_flash3layout1_set[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT1_CLR.
static const field_t hw_bch_flash3layout1_clr[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT1_TOG.
static const field_t hw_bch_flash3layout1_tog[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG0.
static const field_t hw_bch_debug0[] =
{
    {
        "DEBUG_REG_SELECT",
        "The value loaded in this bit field is used to select the internal regi"
        "ster state view of KES engine or the Chien search engine.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BM_KES_TEST_BYPASS",
        "1 = Point all synd_gen writes to dummy area at the end of the AUXILLIA"
        "RY block so that diagnostics can preload all payload, parity bytes and"
        " computed syndrome bytes for test the KES engine.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STALL",
        "Set to one to cause KES FSM to stall after notifying Chien search engi"
        "ne to start processing its block but before notifying the bus master t"
        "hat the KES computation is complete.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STEP",
        "Toggling this bit causes the KES FSM to skip passed the stall state if"
        " it is in DEBUG_STALL mode and it has completed processing a block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_STANDALONE",
        "Set to one to cause the KES engine to suppress toggling the KES_BM_DON"
        "E signal to the bus master and to suppress toggling the CF_BM_DONE sig"
        "nal by the CF engine.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_KICK",
        "Toggling causes KES engine FSM to start as if kick by the Bus Master.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_MODE4K",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input mode (4K "
        "or 2K pages).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_PAYLOAD_FLAG",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input payload f"
        "lag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SHIFT_SYND",
        "Toggling this bit causes the value in BCH_DEBUG0_KES_SYNDROME_SYMBOL t"
        "o be shift into the syndrome register array at the input to the KES en"
        "gine.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SYNDROME_SYMBOL",
        "The 9 bit value in this bit field will be shifted into the syndrome re"
        "gister array at the input of the KES engine whenever BCH_DEBUG0_KES_DE"
        "BUG_SHIFT_SYND is toggled.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG0_SET.
static const field_t hw_bch_debug0_set[] =
{
    {
        "DEBUG_REG_SELECT",
        "The value loaded in this bit field is used to select the internal regi"
        "ster state view of KES engine or the Chien search engine.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BM_KES_TEST_BYPASS",
        "1 = Point all synd_gen writes to dummy area at the end of the AUXILLIA"
        "RY block so that diagnostics can preload all payload, parity bytes and"
        " computed syndrome bytes for test the KES engine.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STALL",
        "Set to one to cause KES FSM to stall after notifying Chien search engi"
        "ne to start processing its block but before notifying the bus master t"
        "hat the KES computation is complete.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STEP",
        "Toggling this bit causes the KES FSM to skip passed the stall state if"
        " it is in DEBUG_STALL mode and it has completed processing a block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_STANDALONE",
        "Set to one to cause the KES engine to suppress toggling the KES_BM_DON"
        "E signal to the bus master and to suppress toggling the CF_BM_DONE sig"
        "nal by the CF engine.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_KICK",
        "Toggling causes KES engine FSM to start as if kick by the Bus Master.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_MODE4K",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input mode (4K "
        "or 2K pages).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_PAYLOAD_FLAG",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input payload f"
        "lag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SHIFT_SYND",
        "Toggling this bit causes the value in BCH_DEBUG0_KES_SYNDROME_SYMBOL t"
        "o be shift into the syndrome register array at the input to the KES en"
        "gine.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SYNDROME_SYMBOL",
        "The 9 bit value in this bit field will be shifted into the syndrome re"
        "gister array at the input of the KES engine whenever BCH_DEBUG0_KES_DE"
        "BUG_SHIFT_SYND is toggled.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG0_CLR.
static const field_t hw_bch_debug0_clr[] =
{
    {
        "DEBUG_REG_SELECT",
        "The value loaded in this bit field is used to select the internal regi"
        "ster state view of KES engine or the Chien search engine.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BM_KES_TEST_BYPASS",
        "1 = Point all synd_gen writes to dummy area at the end of the AUXILLIA"
        "RY block so that diagnostics can preload all payload, parity bytes and"
        " computed syndrome bytes for test the KES engine.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STALL",
        "Set to one to cause KES FSM to stall after notifying Chien search engi"
        "ne to start processing its block but before notifying the bus master t"
        "hat the KES computation is complete.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STEP",
        "Toggling this bit causes the KES FSM to skip passed the stall state if"
        " it is in DEBUG_STALL mode and it has completed processing a block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_STANDALONE",
        "Set to one to cause the KES engine to suppress toggling the KES_BM_DON"
        "E signal to the bus master and to suppress toggling the CF_BM_DONE sig"
        "nal by the CF engine.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_KICK",
        "Toggling causes KES engine FSM to start as if kick by the Bus Master.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_MODE4K",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input mode (4K "
        "or 2K pages).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_PAYLOAD_FLAG",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input payload f"
        "lag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SHIFT_SYND",
        "Toggling this bit causes the value in BCH_DEBUG0_KES_SYNDROME_SYMBOL t"
        "o be shift into the syndrome register array at the input to the KES en"
        "gine.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SYNDROME_SYMBOL",
        "The 9 bit value in this bit field will be shifted into the syndrome re"
        "gister array at the input of the KES engine whenever BCH_DEBUG0_KES_DE"
        "BUG_SHIFT_SYND is toggled.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG0_TOG.
static const field_t hw_bch_debug0_tog[] =
{
    {
        "DEBUG_REG_SELECT",
        "The value loaded in this bit field is used to select the internal regi"
        "ster state view of KES engine or the Chien search engine.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set these bits to zero.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BM_KES_TEST_BYPASS",
        "1 = Point all synd_gen writes to dummy area at the end of the AUXILLIA"
        "RY block so that diagnostics can preload all payload, parity bytes and"
        " computed syndrome bytes for test the KES engine.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STALL",
        "Set to one to cause KES FSM to stall after notifying Chien search engi"
        "ne to start processing its block but before notifying the bus master t"
        "hat the KES computation is complete.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STEP",
        "Toggling this bit causes the KES FSM to skip passed the stall state if"
        " it is in DEBUG_STALL mode and it has completed processing a block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_STANDALONE",
        "Set to one to cause the KES engine to suppress toggling the KES_BM_DON"
        "E signal to the bus master and to suppress toggling the CF_BM_DONE sig"
        "nal by the CF engine.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_KICK",
        "Toggling causes KES engine FSM to start as if kick by the Bus Master.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_MODE4K",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input mode (4K "
        "or 2K pages).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_PAYLOAD_FLAG",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input payload f"
        "lag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SHIFT_SYND",
        "Toggling this bit causes the value in BCH_DEBUG0_KES_SYNDROME_SYMBOL t"
        "o be shift into the syndrome register array at the input to the KES en"
        "gine.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SYNDROME_SYMBOL",
        "The 9 bit value in this bit field will be shifted into the syndrome re"
        "gister array at the input of the KES engine whenever BCH_DEBUG0_KES_DE"
        "BUG_SHIFT_SYND is toggled.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set these bits to zero.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGKESREAD.
static const field_t hw_bch_dbgkesread[] =
{
    {
        "VALUES",
        "This register will return the ROM BIST CRC value after a BIST test.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGKESREAD_SET.
static const field_t hw_bch_dbgkesread_set[] =
{
    {
        "VALUES",
        "This register will return the ROM BIST CRC value after a BIST test.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGKESREAD_CLR.
static const field_t hw_bch_dbgkesread_clr[] =
{
    {
        "VALUES",
        "This register will return the ROM BIST CRC value after a BIST test.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGKESREAD_TOG.
static const field_t hw_bch_dbgkesread_tog[] =
{
    {
        "VALUES",
        "This register will return the ROM BIST CRC value after a BIST test.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGCSFEREAD.
static const field_t hw_bch_dbgcsferead[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGCSFEREAD_SET.
static const field_t hw_bch_dbgcsferead_set[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGCSFEREAD_CLR.
static const field_t hw_bch_dbgcsferead_clr[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGCSFEREAD_TOG.
static const field_t hw_bch_dbgcsferead_tog[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGSYNDGENREAD.
static const field_t hw_bch_dbgsyndgenread[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGSYNDGENREAD_SET.
static const field_t hw_bch_dbgsyndgenread_set[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGSYNDGENREAD_CLR.
static const field_t hw_bch_dbgsyndgenread_clr[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGSYNDGENREAD_TOG.
static const field_t hw_bch_dbgsyndgenread_tog[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGAHBMREAD.
static const field_t hw_bch_dbgahbmread[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGAHBMREAD_SET.
static const field_t hw_bch_dbgahbmread_set[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGAHBMREAD_CLR.
static const field_t hw_bch_dbgahbmread_clr[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGAHBMREAD_TOG.
static const field_t hw_bch_dbgahbmread_tog[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_BLOCKNAME.
static const field_t hw_bch_blockname[] =
{
    {
        "NAME",
        "Should be the ASCII characters BCH (0x20, H, C, B).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_BLOCKNAME_SET.
static const field_t hw_bch_blockname_set[] =
{
    {
        "NAME",
        "Should be the ASCII characters BCH (0x20, H, C, B).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_BLOCKNAME_CLR.
static const field_t hw_bch_blockname_clr[] =
{
    {
        "NAME",
        "Should be the ASCII characters BCH (0x20, H, C, B).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_BLOCKNAME_TOG.
static const field_t hw_bch_blockname_tog[] =
{
    {
        "NAME",
        "Should be the ASCII characters BCH (0x20, H, C, B).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_VERSION.
static const field_t hw_bch_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_VERSION_SET.
static const field_t hw_bch_version_set[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_VERSION_CLR.
static const field_t hw_bch_version_clr[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_VERSION_TOG.
static const field_t hw_bch_version_tog[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a BCH module.
static const reg_t hw_bch[] =
{
    {
        "CTRL",
        "The BCH CTRL provides overall control of the hardware ECC accelerator",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_bch_ctrl
    },
    {
        "CTRL_SET",
        "The BCH CTRL provides overall control of the hardware ECC accelerator",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_bch_ctrl_set
    },
    {
        "CTRL_CLR",
        "The BCH CTRL provides overall control of the hardware ECC accelerator",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_bch_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The BCH CTRL provides overall control of the hardware ECC accelerator",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_bch_ctrl_tog
    },
    {
        "STATUS0",
        "The BCH STAT register provides visibility into the run-time status of "
        "the BCH and status information when processing is complete.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_bch_status0
    },
    {
        "STATUS0_SET",
        "The BCH STAT register provides visibility into the run-time status of "
        "the BCH and status information when processing is complete.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_bch_status0_set
    },
    {
        "STATUS0_CLR",
        "The BCH STAT register provides visibility into the run-time status of "
        "the BCH and status information when processing is complete.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_bch_status0_clr
    },
    {
        "STATUS0_TOG",
        "The BCH STAT register provides visibility into the run-time status of "
        "the BCH and status information when processing is complete.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_bch_status0_tog
    },
    {
        "MODE",
        "The BCH MODE register provides additional mode controls.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_bch_mode
    },
    {
        "MODE_SET",
        "The BCH MODE register provides additional mode controls.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_bch_mode_set
    },
    {
        "MODE_CLR",
        "The BCH MODE register provides additional mode controls.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_bch_mode_clr
    },
    {
        "MODE_TOG",
        "The BCH MODE register provides additional mode controls.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_bch_mode_tog
    },
    {
        "ENCODEPTR",
        "When performing memory to memory operations, indicates the address of "
        "the encode buffer.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_encodeptr
    },
    {
        "ENCODEPTR_SET",
        "When performing memory to memory operations, indicates the address of "
        "the encode buffer.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_encodeptr_set
    },
    {
        "ENCODEPTR_CLR",
        "When performing memory to memory operations, indicates the address of "
        "the encode buffer.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_encodeptr_clr
    },
    {
        "ENCODEPTR_TOG",
        "When performing memory to memory operations, indicates the address of "
        "the encode buffer.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_encodeptr_tog
    },
    {
        "DATAPTR",
        "When performing memory to memory operations, indicates the address of "
        "the data buffer.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_dataptr
    },
    {
        "DATAPTR_SET",
        "When performing memory to memory operations, indicates the address of "
        "the data buffer.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_dataptr_set
    },
    {
        "DATAPTR_CLR",
        "When performing memory to memory operations, indicates the address of "
        "the data buffer.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_dataptr_clr
    },
    {
        "DATAPTR_TOG",
        "When performing memory to memory operations, indicates the address of "
        "the data buffer.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_dataptr_tog
    },
    {
        "METAPTR",
        "When performing memory to memory operations, indicates the address of "
        "the metadata buffer.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_metaptr
    },
    {
        "METAPTR_SET",
        "When performing memory to memory operations, indicates the address of "
        "the metadata buffer.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_metaptr_set
    },
    {
        "METAPTR_CLR",
        "When performing memory to memory operations, indicates the address of "
        "the metadata buffer.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_metaptr_clr
    },
    {
        "METAPTR_TOG",
        "When performing memory to memory operations, indicates the address of "
        "the metadata buffer.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_metaptr_tog
    },
    {
        "LAYOUTSELECT",
        "The BCH LAYOUTSELECT register provides a mapping of chip selects to la"
        "yout registers.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_bch_layoutselect
    },
    {
        "LAYOUTSELECT_SET",
        "The BCH LAYOUTSELECT register provides a mapping of chip selects to la"
        "yout registers.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_bch_layoutselect_set
    },
    {
        "LAYOUTSELECT_CLR",
        "The BCH LAYOUTSELECT register provides a mapping of chip selects to la"
        "yout registers.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_bch_layoutselect_clr
    },
    {
        "LAYOUTSELECT_TOG",
        "The BCH LAYOUTSELECT register provides a mapping of chip selects to la"
        "yout registers.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_bch_layoutselect_tog
    },
    {
        "FLASH0LAYOUT0",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash0layout0
    },
    {
        "FLASH0LAYOUT0_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash0layout0_set
    },
    {
        "FLASH0LAYOUT0_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash0layout0_clr
    },
    {
        "FLASH0LAYOUT0_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash0layout0_tog
    },
    {
        "FLASH0LAYOUT1",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash0layout1
    },
    {
        "FLASH0LAYOUT1_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash0layout1_set
    },
    {
        "FLASH0LAYOUT1_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash0layout1_clr
    },
    {
        "FLASH0LAYOUT1_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash0layout1_tog
    },
    {
        "FLASH1LAYOUT0",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash1layout0
    },
    {
        "FLASH1LAYOUT0_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash1layout0_set
    },
    {
        "FLASH1LAYOUT0_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash1layout0_clr
    },
    {
        "FLASH1LAYOUT0_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash1layout0_tog
    },
    {
        "FLASH1LAYOUT1",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash1layout1
    },
    {
        "FLASH1LAYOUT1_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash1layout1_set
    },
    {
        "FLASH1LAYOUT1_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash1layout1_clr
    },
    {
        "FLASH1LAYOUT1_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash1layout1_tog
    },
    {
        "FLASH2LAYOUT0",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash2layout0
    },
    {
        "FLASH2LAYOUT0_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash2layout0_set
    },
    {
        "FLASH2LAYOUT0_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash2layout0_clr
    },
    {
        "FLASH2LAYOUT0_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash2layout0_tog
    },
    {
        "FLASH2LAYOUT1",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash2layout1
    },
    {
        "FLASH2LAYOUT1_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash2layout1_set
    },
    {
        "FLASH2LAYOUT1_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash2layout1_clr
    },
    {
        "FLASH2LAYOUT1_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash2layout1_tog
    },
    {
        "FLASH3LAYOUT0",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash3layout0
    },
    {
        "FLASH3LAYOUT0_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash3layout0_set
    },
    {
        "FLASH3LAYOUT0_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash3layout0_clr
    },
    {
        "FLASH3LAYOUT0_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash3layout0_tog
    },
    {
        "FLASH3LAYOUT1",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash3layout1
    },
    {
        "FLASH3LAYOUT1_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash3layout1_set
    },
    {
        "FLASH3LAYOUT1_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash3layout1_clr
    },
    {
        "FLASH3LAYOUT1_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash3layout1_tog
    },
    {
        "DEBUG0",
        "The hardware BCH accelerator internal state machines and signals can b"
        "e seen in the ECC debug register.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_bch_debug0
    },
    {
        "DEBUG0_SET",
        "The hardware BCH accelerator internal state machines and signals can b"
        "e seen in the ECC debug register.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_bch_debug0_set
    },
    {
        "DEBUG0_CLR",
        "The hardware BCH accelerator internal state machines and signals can b"
        "e seen in the ECC debug register.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_bch_debug0_clr
    },
    {
        "DEBUG0_TOG",
        "The hardware BCH accelerator internal state machines and signals can b"
        "e seen in the ECC debug register.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_bch_debug0_tog
    },
    {
        "DBGKESREAD",
        "The hardware BCH ECC accelerator key equation solver internal state ma"
        "chines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgkesread
    },
    {
        "DBGKESREAD_SET",
        "The hardware BCH ECC accelerator key equation solver internal state ma"
        "chines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgkesread_set
    },
    {
        "DBGKESREAD_CLR",
        "The hardware BCH ECC accelerator key equation solver internal state ma"
        "chines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgkesread_clr
    },
    {
        "DBGKESREAD_TOG",
        "The hardware BCH ECC accelerator key equation solver internal state ma"
        "chines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgkesread_tog
    },
    {
        "DBGCSFEREAD",
        "The hardware BCH ECC accelerator Chien Search internal state machines "
        "and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgcsferead
    },
    {
        "DBGCSFEREAD_SET",
        "The hardware BCH ECC accelerator Chien Search internal state machines "
        "and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgcsferead_set
    },
    {
        "DBGCSFEREAD_CLR",
        "The hardware BCH ECC accelerator Chien Search internal state machines "
        "and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgcsferead_clr
    },
    {
        "DBGCSFEREAD_TOG",
        "The hardware BCH ECC accelerator Chien Search internal state machines "
        "and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgcsferead_tog
    },
    {
        "DBGSYNDGENREAD",
        "The hardware BCH ECC accelerator syndrome generator internal state mac"
        "hines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgsyndgenread
    },
    {
        "DBGSYNDGENREAD_SET",
        "The hardware BCH ECC accelerator syndrome generator internal state mac"
        "hines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgsyndgenread_set
    },
    {
        "DBGSYNDGENREAD_CLR",
        "The hardware BCH ECC accelerator syndrome generator internal state mac"
        "hines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgsyndgenread_clr
    },
    {
        "DBGSYNDGENREAD_TOG",
        "The hardware BCH ECC accelerator syndrome generator internal state mac"
        "hines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgsyndgenread_tog
    },
    {
        "DBGAHBMREAD",
        "The hardware BCH ECC accelerator bus master and ecc controller interna"
        "l state machines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgahbmread
    },
    {
        "DBGAHBMREAD_SET",
        "The hardware BCH ECC accelerator bus master and ecc controller interna"
        "l state machines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgahbmread_set
    },
    {
        "DBGAHBMREAD_CLR",
        "The hardware BCH ECC accelerator bus master and ecc controller interna"
        "l state machines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgahbmread_clr
    },
    {
        "DBGAHBMREAD_TOG",
        "The hardware BCH ECC accelerator bus master and ecc controller interna"
        "l state machines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgahbmread_tog
    },
    {
        "BLOCKNAME",
        "Read only view of the block name string BCH.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_blockname
    },
    {
        "BLOCKNAME_SET",
        "Read only view of the block name string BCH.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_blockname_set
    },
    {
        "BLOCKNAME_CLR",
        "Read only view of the block name string BCH.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_blockname_clr
    },
    {
        "BLOCKNAME_TOG",
        "Read only view of the block name string BCH.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_blockname_tog
    },
    {
        "VERSION",
        "This register always returns a known read value for debug purposes and"
        " indicates the version of the block and RTL version in use.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_bch_version
    },
    {
        "VERSION_SET",
        "This register always returns a known read value for debug purposes and"
        " indicates the version of the block and RTL version in use.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_bch_version_set
    },
    {
        "VERSION_CLR",
        "This register always returns a known read value for debug purposes and"
        " indicates the version of the block and RTL version in use.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_bch_version_clr
    },
    {
        "VERSION_TOG",
        "This register always returns a known read value for debug purposes and"
        " indicates the version of the block and RTL version in use.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_bch_version_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CCM
#endif

// Bitfields in register CCM_CCR.
static const field_t hw_ccm_ccr[] =
{
    {
        "OSCNT",
        "Oscillator ready counter value.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_EN",
        "On chip oscillator enable bit - this bit value is reflected on the out"
        "put cosc_en.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG_BYPASS_COUNT",
        "Counter for analog_reg_bypass signal assertion after standby voltage r"
        "equest by PMIC_STBY_REQ.",
        21, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBC_EN",
        "Enable for REG_BYPASS_COUNTER.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCDR.
static const field_t hw_ccm_ccdr[] =
{
    {
        "MMDC_MASK",
        "During divider ratio mmdc_axi_podf change or sync mux periph2_clk_sel "
        "change (but not jtag) or SRC request during warm reset, mask handshake"
        " with mmdc module.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSR.
static const field_t hw_ccm_csr[] =
{
    {
        "REF_EN_B",
        "Status of the value of CCM_REF_EN_B output of ccm",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COSC_READY",
        "Status indication of on board oscillator.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCSR.
static const field_t hw_ccm_ccsr[] =
{
    {
        "PLL3_SW_CLK_SEL",
        "Selects source to generate pll3_sw_clk.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL1_SW_CLK_SEL",
        "Selects source to generate pll1_sw_clk.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STEP_SEL",
        "Selects the option to be chosen for the step frequency when shifting A"
        "RM frequency.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CACRR.
static const field_t hw_ccm_cacrr[] =
{
    {
        "ARM_PODF",
        "Divider for ARM clock root.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CBCDR.
static const field_t hw_ccm_cbcdr[] =
{
    {
        "PERIPH2_CLK2_PODF",
        "Divider for periph2_clk2 podf.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FABRIC_MMDC_PODF",
        "Post divider for fabric / mmdc clock.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_CLK_SEL",
        "OCRAM clock source select",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_ALT_CLK_SEL",
        "OCRAM alternative clock select",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_PODF",
        "Divider for ipg podf.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_PODF",
        "Divider for AHB PODF.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_PODF",
        "Post divider for ocram clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK_SEL",
        "Selector for peripheral main clock (source of MMDC_CLK_ROOT).",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK_SEL",
        "Selector for peripheral2 main clock (source of mmdc_clk_root ).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK2_PODF",
        "Divider for periph2 clock podf.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CBCMR.
static const field_t hw_ccm_cbcmr[] =
{
    {
        "GPU_CORE_SEL",
        "Selector for gpu_core clock multiplexer",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_AXI_SEL",
        "Selector for gpu_axi clock multiplexer",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_AXI_CLK_SEL",
        "Selector for pcie_axi clock multiplexer",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK2_SEL",
        "Selector for peripheral clk2 clock multiplexer",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_PERIPH_CLK_SEL",
        "Selector for pre_periph clock multiplexer",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK2_SEL",
        "Selector for periph2_clk2 clock multiplexer",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_PERIPH2_CLK_SEL",
        "Selector for pre_periph2 clock multiplexer",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_PODF",
        "Post-divider for lcdif1 clock.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_AXI_PODF",
        "Divider for gpu_axi_podf.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_CORE_PODF",
        "Post divider for gpu_core clock.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCMR1.
static const field_t hw_ccm_cscmr1[] =
{
    {
        "PERCLK_PODF",
        "Divider for perclk podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERCLK_CLK_SEL",
        "Selector for the perclk clock multiplexor",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QSPI1_SEL",
        "QSPI1 clock select",
        7, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI1_CLK_SEL",
        "Selector for ssi1 clock multiplexer",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI2_CLK_SEL",
        "Selector for ssi2 clock multiplexer",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_SEL",
        "Selector for ssi3 clock multiplexer",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC1_CLK_SEL",
        "Selector for usdhc1 clock multiplexer",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC2_CLK_SEL",
        "Selector for usdhc2 clock multiplexer",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC3_CLK_SEL",
        "Selector for usdhc3 clock multiplexer",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC4_CLK_SEL",
        "Selector for usdhc4 clock multiplexer",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_PODF",
        "Post-divider for lcdif2 clock.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EIM_SLOW_PODF",
        "Divider for aclk_eim_slow clock root.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QSPI1_PODF",
        "Divider for QSPI1 clock root",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EIM_SLOW_SEL",
        "Selector for aclk_eim_slow root clock multiplexer",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCMR2.
static const field_t hw_ccm_cscmr2[] =
{
    {
        "CAN_CLK_PODF",
        "Divider for can clock podf.",
        2, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAN_CLK_SEL",
        "Selector for FlexCAN clock multiplexer",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI0_DIV",
        "Control for divider of ldb clock for di0",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI1_DIV",
        "Control for divider of ldb clock for di1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESAI_CLK_SEL",
        "Selector for esai clock multiplexer",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_CLK_SEL",
        "Selector for vid clock multiplexer",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_CLK_PRE_PODF",
        "Post-divider for vid clock root",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_CLK_PODF",
        "Post-divider for vid clock root",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR1.
static const field_t hw_ccm_cscdr1[] =
{
    {
        "UART_CLK_PODF",
        "Divider for uart clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UART_CLK_SEL",
        "Selector for the UART clock multiplexor",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC1_PODF",
        "Divider for usdhc1 clock podf.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC2_PODF",
        "Divider for usdhc2 clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC3_PODF",
        "Divider for usdhc3 clock podf.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC4_PODF",
        "Divider for esdhc4 clock pred.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CS1CDR.
static const field_t hw_ccm_cs1cdr[] =
{
    {
        "SSI1_CLK_PODF",
        "Divider for ssi1 clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI1_CLK_PRED",
        "Divider for ssi1 clock pred.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESAI_CLK_PRED",
        "Divider for esai clock pred.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_PODF",
        "Divider for ssi3 clock podf.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_PRED",
        "Divider for ssi3 clock pred.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESAI_CLK_PODF",
        "Divider for esai clock podf.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CS2CDR.
static const field_t hw_ccm_cs2cdr[] =
{
    {
        "SSI2_CLK_PODF",
        "Divider for ssi2 clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI2_CLK_PRED",
        "Divider for ssi2 clock pred.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI0_CLK_SEL",
        "Selector for ldb_di1 clock multiplexerMultiplexor should be updated wh"
        "en both input and output clocks are gated.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI1_CLK_SEL",
        "Selector for ldb_di1 clock multiplexerMultiplexor should be updated wh"
        "en both input and output clocks are gated.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QSPI2_CLK_SEL",
        "Selector for QSPI2 clock multiplexer",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QSPI2_CLK_PRED",
        "Divider for QSPI1 clock pred divider.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QSPI2_CLK_PODF",
        "Divider for QSPI2 clock divider.",
        21, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CDCDR.
static const field_t hw_ccm_cdcdr[] =
{
    {
        "AUDIO_CLK_SEL",
        "Selector for audio clock multiplexer",
        7, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_CLK_PODF",
        "Divider for audio clock podf.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_CLK_PRED",
        "Divider for audio clock pred.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_SEL",
        "Selector for spdif0 clock multiplexer",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_PODF",
        "Divider for spdif0 clock podf.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_PRED",
        "Divider for spdif0 clock pred.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CHSCCDR.
static const field_t hw_ccm_chsccdr[] =
{
    {
        "M4_CLK_SEL",
        "Selector for M4 root clock multiplexer",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_PODF",
        "Divider for M4 clock divider.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_PRE_CLK_SEL",
        "Selector for M4 root clock pre-multiplexer",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_CLK_SEL",
        "Selector for ENET root clock multiplexer",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_PODF",
        "Divider for ENET clock divider.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_PRE_CLK_SEL",
        "Selector for ENET root clock pre-multiplexer",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR2.
static const field_t hw_ccm_cscdr2[] =
{
    {
        "LCDIF2_CLK_SEL",
        "Selector for lcdif2 root clock multiplexer",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_PRED",
        "Pre-divider for lcdif2 clock.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_PRE_CLK_SEL",
        "Selector for lcdif2 root clock pre-multiplexer",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_CLK_SEL",
        "Selector for lcdif1 root clock multiplexer",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_PRED",
        "Pre-divider for lcdif1 clock.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_PRE_CLK_SEL",
        "Selector for lcdif1 root clock pre-multiplexer",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECSPI_CLK_SEL",
        "Selector for the ECSPI clock multiplexor",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECSPI_CLK_PODF",
        "Divider for ecspi clock podf.",
        19, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR3.
static const field_t hw_ccm_cscdr3[] =
{
    {
        "CSI_CLK_SEL",
        "Selector for csi clock multiplexer",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_PODF",
        "Post divider for csi_core clock.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_CLK_SEL",
        "Selector for display clock multiplexer",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PODF",
        "Divider for display clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CWDR.
static const field_t hw_ccm_cwdr[] =
{
    { 0 } // Terminator
};

// Bitfields in register CCM_CDHIPR.
static const field_t hw_ccm_cdhipr[] =
{
    {
        "OCRAM_PODF_BUSY",
        "Busy indicator for ocram_podf.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB_PODF_BUSY",
        "Busy indicator for ahb_podf.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MMDC_PODF_BUSY",
        "Busy indicator for mmdc_axi_podf.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH2_CLK_SEL_BUSY",
        "Busy indicator for periph2_clk_sel mux control.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH_CLK_SEL_BUSY",
        "Busy indicator for periph_clk_sel mux control.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_PODF_BUSY",
        "Busy indicator for arm_podf.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CLPCR.
static const field_t hw_ccm_clpcr[] =
{
    {
        "LPM",
        "Setting the low power mode that system will enter on next assertion of"
        " dsm_request signal.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_CLK_DIS_ON_LPM",
        "Define if ARM clocks (arm_clk, soc_mxclk, soc_pclk, soc_dbg_pclk, vl_w"
        "rck) will be disabled on wait mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBYOS",
        "Standby clock oscillator bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS_REF_OSC",
        "dis_ref_osc - in run mode, software can manually control closing of ex"
        "ternal reference oscillator clock, i.e.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSTBY",
        "Voltage standby request bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STBY_COUNT",
        "Standby counter definition.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_PWRDOWN",
        "In run mode, software can manually control powering down of on chip os"
        "cillator, i.e.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_MMDC_LPM_HS",
        "Bypass handshake with mmdc on next entrance to low power mode (STOP or"
        " WAIT).",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CORE0_WFI",
        "Mask WFI of core0 for entering low power mode Assertion of all bits[27"
        ":22] will generate low power mode request",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_SCU_IDLE",
        "Mask SCU IDLE for entering low power mode Assertion of all bits[27:22]"
        " will generate low power mode request",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_L2CC_IDLE",
        "Mask L2CC IDLE for entering low power mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CISR.
static const field_t hw_ccm_cisr[] =
{
    {
        "LRF_PLL",
        "CCM interrupt request 2 generated due to lock of all enabled and not b"
        "ypaseed PLLs",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_READY",
        "CCM interrupt request 2 generated due to on board oscillator ready, i."
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_PODF_LOADED",
        "CCM interrupt request 1 generated due to frequency change of ocram_pod"
        "f",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK_SEL_LOADED",
        "CCM interrupt request 1 generated due to frequency change of periph2_c"
        "lk_sel",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_PODF_LOADED",
        "CCM interrupt request 1 generated due to frequency change of ahb_podf",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_PODF_LOADED",
        "CCM interrupt request 1 generated due to frequency change of mmdc_podf"
        "_ loaded",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK_SEL_LOADED",
        "CCM interrupt request 1 generated due to update of periph_clk_sel.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_PODF_LOADED",
        "CCM interrupt request 1 generated due to frequency change of arm_podf.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CIMR.
static const field_t hw_ccm_cimr[] =
{
    {
        "MASK_LRF_PLL",
        "mask interrupt generation due to lrf of PLLs",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_COSC_READY",
        "mask interrupt generation due to on board oscillator ready",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_OCRAM_PODF_LOADED",
        "mask interrupt generation due to frequency change of ocram_podf",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PERIPH2_CLK_SEL_LOADED",
        "mask interrupt generation due to update of periph2_clk_sel.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AHB_PODF_LOADED",
        "mask interrupt generation due to frequency change of ahb_podf",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_MMDC_PODF_LOADED",
        "mask interrupt generation due to update of mask_mmdc_podf",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PERIPH_CLK_SEL_LOADED",
        "mask interrupt generation due to update of periph_clk_sel.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_PODF_LOADED",
        "mask interrupt generation due to frequency change of arm_podf",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCOSR.
static const field_t hw_ccm_ccosr[] =
{
    {
        "CLKO_SEL",
        "Selection of the clock to be generated on CCM_CLKO1",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_DIV",
        "Setting the divider of CCM_CLKO1",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_EN",
        "Enable of CCM_CLKO1 clock",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_OUT_SEL",
        "CCM_CLKO1 output to reflect CCM_CLKO1 or CCM_CLKO2 clocks",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_SEL",
        "Selection of the clock to be generated on CCM_CLKO2",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_DIV",
        "Setting the divider of CCM_CLKO2",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_EN",
        "Enable of CCM_CLKO2 clock",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CGPR.
static const field_t hw_ccm_cgpr[] =
{
    {
        "PMIC_DELAY_SCALER",
        "Defines clock dividion of clock for stby_count (pmic delay counter)",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_EXT_CLK_DIS",
        "Disable external clock driver of MMDC during STOP mode",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EFUSE_PROG_SUPPLY_GATE",
        "Defines the value of the output signal cgpr_dout[4].",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPL",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_MEM_CLK_LPM",
        "Control for the Deep Sleep signal to the ARM Platform memories with ad"
        "ditional control logic based on the ARM WFI signal.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR0.
static const field_t hw_ccm_ccgr0[] =
{
    {
        "CG0",
        "aips_tz1 clocks (aips_tz1_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "aips_tz2 clocks (aips_tz2_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "apbhdma hclk clock (apbhdma_hclk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "asrc clock (asrc_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "caam_secure_mem clock (caam_secure_mem_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "caam_wrapper_aclk clock (caam_wrapper_aclk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "caam_wrapper_ipg clock (caam_wrapper_ipg_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "can1 clock (can1_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "can1_serial clock (can1_serial_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "can2 clock (can2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "can2_serial clock (can2_serial_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "CPU debug clocks (arm_dbg_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "dcic 1 clocks (dcic1_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "dcic2 clocks (dcic2_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "Reserved",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "aips_tz3 clocks (aips_tz3_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR1.
static const field_t hw_ccm_ccgr1[] =
{
    {
        "CG0",
        "ecspi1 clocks (ecspi1_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "ecspi2 clocks (ecspi2_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "ecspi3 clocks (ecspi3_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "ecspi4 clocks (ecspi4_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "ecspi5 clocks (ecspi5_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "Reserved",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "epit1 clocks (epit1_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "epit2 clocks (epit2_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "esai clocks (esai_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "wakeup clock (wakeup_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "gpt bus clock (gpt_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "gpt serial clock (gpt_serial_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "Reserved",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "gpu clock (gpu_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "ocram_s clock (ocram_s_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "canfd clock (canfd_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR2.
static const field_t hw_ccm_ccgr2[] =
{
    {
        "CG0",
        "Reserved",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "csi clock (csi_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "Reserved",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "i2c1_serial clock (i2c1_serial_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "i2c2_serial clock (i2c2_serial_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "i2c3_serial clock (i2c3_serial_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "OCOTP_CTRL clock (iim_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "iomux_ipt_clk_io clock (iomux_ipt_clk_io_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "ipmux1 clock (ipmux1_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "ipmux2 clock (ipmux2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "ipmux3 clock (ipmux3_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "ipsync_ip2apb_tzasc1_ipg clocks (ipsync_ip2apb_tzasc1_ipg_master_clk_e"
        "nable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "Reserved",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "Reserved",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "lcd clocks (lcd_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "pxp clocks (pxp_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR3.
static const field_t hw_ccm_ccgr3[] =
{
    {
        "CG0",
        "Reserved",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "m4 clock (m4_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "enet clock (enet_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "display axi clock (disp_axi_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "lcdif2 pix clock (lcdif2_pix_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "lcdif1 pix clock (lcdif1_pix_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "ldb_di0 clock (ldb_di0_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "qspi1 clock (qspi1_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "Reserved",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "mlb clock (mlb_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "mmdc_core_aclk_fast_core_p0 clock (mmdc_core_aclk_fast_core_p0_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "Reserved",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "mmdc_core_ipg_clk_p0 clock (mmdc_core_ipg_clk_p0_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "mmdc_core_ipg_clk_p1 clock (mmdc_core_ipg_clk_p1_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "ocram clock (ocram_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "Reserved",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR4.
static const field_t hw_ccm_ccgr4[] =
{
    {
        "CG0",
        "pcie clock (pcie_root_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "Reserved.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "Reserved.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "Reserved",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "qspi2 clock (qspi2_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "pl301_mx6qper1_bch clocks (pl301_mx6qper1_bchclk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "pl301_mx6qper2_mainclk_enable (pl301_mx6qper2_mainclk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "pwm1 clocks (pwm1_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "pwm2 clocks (pwm2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "pwm3 clocks (pwm3_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "pwm4 clocks (pwm4_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "rawnand_u_bch_input_apb clock (rawnand_u_bch_input_apb_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "rawnand_u_gpmi_bch_input_bch clock (rawnand_u_gpmi_bch_input_bch_clk_e"
        "nable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "rawnand_u_gpmi_bch_input_gpmi_io clock (rawnand_u_gpmi_bch_input_gpmi_"
        "io_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "rawnand_u_gpmi_input_apb clock (rawnand_u_gpmi_input_apb_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR5.
static const field_t hw_ccm_ccgr5[] =
{
    {
        "CG0",
        "rom clock (rom_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "Reserved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "Reserved",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "sdma clock (sdma_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "Reserved",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "Reserved",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "spba clock (spba_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "spdif / audio clock (spdif_clk_enable, audio_clk_root)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "Reserved",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "ssi1 clocks (ssi1_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "ssi2 clocks (ssi2_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "ssi3 clocks (ssi3_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "uart clock (uart_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "uart_serial clock (uart_serial_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "sai1 clock (sai1_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "sai2 clock (sai2_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR6.
static const field_t hw_ccm_ccgr6[] =
{
    {
        "CG0",
        "usboh3 clock (usboh3_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "usdhc1 clocks (usdhc1_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "usdhc2 clocks (usdhc2_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "usdhc3 clocks (usdhc3_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "usdhc4 clocks (usdhc4_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "eim_slow clocks (eim_slow_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "Reserved",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "Reserved",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "pwm8 clocks (pwm8_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "Reserved",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "vadc clocks (vadc_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "gis clocks (gis_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "i2c4 serial clock (i2c4_serial_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "pwm5 clocks (pwm5_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "pwm6 clocks (pwm6_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "pwm7 clocks (pwm7_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CMEOR.
static const field_t hw_ccm_cmeor[] =
{
    {
        "MOD_EN_OV_GPT",
        "Overide clock enable signal from GPT - clock will not be gated based o"
        "n GPT's signal 'ipg_enable_clk' .",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_EPIT",
        "Overide clock enable signal from EPIT - clock will not be gated based "
        "on EPIT's signal 'ipg_enable_clk' .",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_USDHC",
        "overide clock enable signal from USDHC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_GPU",
        "Overide clock enable signal from GPU - clock will not be gated based o"
        "n GPU signal 'gpu_busy' .",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_CAN2_CPI",
        "Overide clock enable signal from CAN2 - clock will not be gated based "
        "on CAN's signal 'enable_clk_cpi'.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_CAN1_CPI",
        "Overide clock enable signal from CAN1 - clock will not be gated based "
        "on CAN's signal 'enable_clk_cpi'.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CCM module.
static const reg_t hw_ccm[] =
{
    {
        "CCR",
        "The figure below represents the CCM Control Register (CCR), which cont"
        "ains bits to control general operation of CCM.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_ccr
    },
    {
        "CCDR",
        "The figure below represents the CCM Control Divider Register (CCDR), w"
        "hich contains bits that control the loading of the dividers that need "
        "handshake with the modules they affect.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_ccdr
    },
    {
        "CSR",
        "The figure below represents the CCM status Register (CSR).",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_ccm_csr
    },
    {
        "CCSR",
        "The figure below represents the CCM Clock Switcher register (CCSR).",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ccm_ccsr
    },
    {
        "CACRR",
        "The figure below represents the CCM Arm Clock Root register (CACRR).",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_cacrr
    },
    {
        "CBCDR",
        "The figure below represents the CCM Bus Clock Divider Register (CBCDR)"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cbcdr
    },
    {
        "CBCMR",
        "The figure below represents the CCM Bus Clock Multiplexer Register (CB"
        "CMR).",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cbcmr
    },
    {
        "CSCMR1",
        "The figure below represents the CCM Serial Clock Multiplexer Register "
        "1 (CSCMR1).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_cscmr1
    },
    {
        "CSCMR2",
        "The figure below represents the CCM Serial Clock Multiplexer Register "
        "2 (CSCMR2).",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_cscmr2
    },
    {
        "CSCDR1",
        "The figure below represents the CCM Serial Clock Divider Register 1 (C"
        "SCDR1).",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cscdr1
    },
    {
        "CS1CDR",
        "The figure below represents the CCM SSI1, SSI3, ESAI Clock Divider Reg"
        "ister (CS1CDR).",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cs1cdr
    },
    {
        "CS2CDR",
        "The figure below represents the CCM SSI2, LDB Clock Divider Register ("
        "CS2CDR).",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_cs2cdr
    },
    {
        "CDCDR",
        "The figure below represents the CCM DI Clock Divider Register (CDCDR).",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cdcdr
    },
    {
        "CHSCCDR",
        "The figure below represents the CCM HSC Clock Divider Register (CHSCCD"
        "R).",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_chsccdr
    },
    {
        "CSCDR2",
        "The figure below represents the CCM Serial Clock Divider Register 2(CS"
        "CDR2).",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_cscdr2
    },
    {
        "CSCDR3",
        "The figure below represents the CCM Serial Clock Divider Register 3(CS"
        "CDR3).",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_cscdr3
    },
    {
        "CWDR",
        "The figure below represents the CCM Wakeup Detector Register (CWDR).",
        4, // Width in bytes
        0x00000044, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_ccm_cwdr
    },
    {
        "CDHIPR",
        "The figure below represents the CCM Divider Handshake In-Process Regis"
        "ter (CDHIPR).",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_ccm_cdhipr
    },
    {
        "CLPCR",
        "The figure below represents the CCM Low Power Control Register (CLPCR)"
        ".",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_clpcr
    },
    {
        "CISR",
        "The figure below represents the CCM Interrupt Status Register (CISR).",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_cisr
    },
    {
        "CIMR",
        "The figure below represents the CCM Interrupt Mask Register (CIMR).",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_cimr
    },
    {
        "CCOSR",
        "The figure below represents the CCM Clock Output Source Register (CCOS"
        "R).",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_ccosr
    },
    {
        "CGPR",
        "Fast PLL enable.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ccm_cgpr
    },
    {
        "CCGR0",
        "CG(i) bits CCGR 0-6 These bits are used to turn on/off the clock to ea"
        "ch module independently.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr0
    },
    {
        "CCGR1",
        "The figure below represents the CCM Clock Gating Register 1(CCM_CCGR1)"
        ".",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr1
    },
    {
        "CCGR2",
        "The figure below represents the CCM Clock Gating Register 2 (CCM_CCGR2"
        ").",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr2
    },
    {
        "CCGR3",
        "The figure below represents the CCM Clock Gating Register 3 (CCM_CCGR3"
        ").",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr3
    },
    {
        "CCGR4",
        "The figure below represents the CCM Clock Gating Register 4 (CCM_CCGR4"
        ").",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr4
    },
    {
        "CCGR5",
        "The figure below represents the CCM Clock Gating Register 5 (CCM_CCGR5"
        ").",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr5
    },
    {
        "CCGR6",
        "The figure below represents the CCM Clock Gating Register 6 (CCM_CCGR6"
        ").",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr6
    },
    {
        "CMEOR",
        "The follow figure represents the CCM Module Enable Override Register ("
        "CMEOR).",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cmeor
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CCM_ANALOG
#endif

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ARM.
static const field_t hw_ccm_analog_analog_pll_arm[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_SEL",
        "Analog Debug Bit",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_24MHZ_SEL",
        "Analog Debug Bit",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ARM_SET.
static const field_t hw_ccm_analog_analog_pll_arm_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_SEL",
        "Analog Debug Bit",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_24MHZ_SEL",
        "Analog Debug Bit",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ARM_CLR.
static const field_t hw_ccm_analog_analog_pll_arm_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_SEL",
        "Analog Debug Bit",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_24MHZ_SEL",
        "Analog Debug Bit",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ARM_TOG.
static const field_t hw_ccm_analog_analog_pll_arm_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_SEL",
        "Analog Debug Bit",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_24MHZ_SEL",
        "Analog Debug Bit",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB1.
static const field_t hw_ccm_analog_analog_pll_usb1[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB1_SET.
static const field_t hw_ccm_analog_analog_pll_usb1_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB1_CLR.
static const field_t hw_ccm_analog_analog_pll_usb1_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB1_TOG.
static const field_t hw_ccm_analog_analog_pll_usb1_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB2.
static const field_t hw_ccm_analog_analog_pll_usb2[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB2_SET.
static const field_t hw_ccm_analog_analog_pll_usb2_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB2_CLR.
static const field_t hw_ccm_analog_analog_pll_usb2_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB2_TOG.
static const field_t hw_ccm_analog_analog_pll_usb2_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS.
static const field_t hw_ccm_analog_analog_pll_sys[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_SET.
static const field_t hw_ccm_analog_analog_pll_sys_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_CLR.
static const field_t hw_ccm_analog_analog_pll_sys_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_TOG.
static const field_t hw_ccm_analog_analog_pll_sys_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_SS.
static const field_t hw_ccm_analog_analog_pll_sys_ss[] =
{
    {
        "STEP",
        "Frequency change step = step/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP",
        "Frequency change = stop/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO.
static const field_t hw_ccm_analog_analog_pll_audio[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_SET.
static const field_t hw_ccm_analog_analog_pll_audio_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_CLR.
static const field_t hw_ccm_analog_analog_pll_audio_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_TOG.
static const field_t hw_ccm_analog_analog_pll_audio_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_NUM.
static const field_t hw_ccm_analog_analog_pll_audio_num[] =
{
    {
        "A",
        "30 bit numerator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_DENOM.
static const field_t hw_ccm_analog_analog_pll_audio_denom[] =
{
    {
        "B",
        "30 bit Denominator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO.
static const field_t hw_ccm_analog_analog_pll_video[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_SET.
static const field_t hw_ccm_analog_analog_pll_video_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_CLR.
static const field_t hw_ccm_analog_analog_pll_video_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_TOG.
static const field_t hw_ccm_analog_analog_pll_video_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_NUM.
static const field_t hw_ccm_analog_analog_pll_video_num[] =
{
    {
        "A",
        "30 bit numerator of fractional loop divider(Signed number), absolute v"
        "alue should be less than denominator",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_DENOM.
static const field_t hw_ccm_analog_analog_pll_video_denom[] =
{
    {
        "B",
        "30 bit Denominator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ENET.
static const field_t hw_ccm_analog_analog_pll_enet[] =
{
    {
        "ENET0_DIV_SELECT",
        "Controls the frequency of the ethernet0 reference clock.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_DIV_SELECT",
        "Controls the frequency of the ethernet1 reference clock.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_125M_EN",
        "Enable the PLL providing the ENET1 125 MHz reference clock.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_125M_EN",
        "Enable the PLL providing the ENET2 125 MHz reference clock",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_25M_REF_EN",
        "Enable the PLL providing ENET 25 MHz reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ENET_SET.
static const field_t hw_ccm_analog_analog_pll_enet_set[] =
{
    {
        "ENET0_DIV_SELECT",
        "Controls the frequency of the ethernet0 reference clock.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_DIV_SELECT",
        "Controls the frequency of the ethernet1 reference clock.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_125M_EN",
        "Enable the PLL providing the ENET1 125 MHz reference clock.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_125M_EN",
        "Enable the PLL providing the ENET2 125 MHz reference clock",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_25M_REF_EN",
        "Enable the PLL providing ENET 25 MHz reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ENET_CLR.
static const field_t hw_ccm_analog_analog_pll_enet_clr[] =
{
    {
        "ENET0_DIV_SELECT",
        "Controls the frequency of the ethernet0 reference clock.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_DIV_SELECT",
        "Controls the frequency of the ethernet1 reference clock.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_125M_EN",
        "Enable the PLL providing the ENET1 125 MHz reference clock.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_125M_EN",
        "Enable the PLL providing the ENET2 125 MHz reference clock",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_25M_REF_EN",
        "Enable the PLL providing ENET 25 MHz reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ENET_TOG.
static const field_t hw_ccm_analog_analog_pll_enet_tog[] =
{
    {
        "ENET0_DIV_SELECT",
        "Controls the frequency of the ethernet0 reference clock.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_DIV_SELECT",
        "Controls the frequency of the ethernet1 reference clock.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_125M_EN",
        "Enable the PLL providing the ENET1 125 MHz reference clock.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_125M_EN",
        "Enable the PLL providing the ENET2 125 MHz reference clock",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_25M_REF_EN",
        "Enable the PLL providing ENET 25 MHz reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_480.
static const field_t hw_ccm_analog_analog_pfd_480[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_480_SET.
static const field_t hw_ccm_analog_analog_pfd_480_set[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_480_CLR.
static const field_t hw_ccm_analog_analog_pfd_480_clr[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_480_TOG.
static const field_t hw_ccm_analog_analog_pfd_480_tog[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_528.
static const field_t hw_ccm_analog_analog_pfd_528[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_528_SET.
static const field_t hw_ccm_analog_analog_pfd_528_set[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_528_CLR.
static const field_t hw_ccm_analog_analog_pfd_528_clr[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_528_TOG.
static const field_t hw_ccm_analog_analog_pfd_528_tog[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC0.
static const field_t hw_ccm_analog_analog_misc0[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to CCM.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_RINGOSC_EN",
        "Enables the internal ring oscillator that can be used in lieu of an ex"
        "ternal 32k crystal.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.Not related to CCM.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.Not rela"
        "ted to CCM.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC0_SET.
static const field_t hw_ccm_analog_analog_misc0_set[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to CCM.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_RINGOSC_EN",
        "Enables the internal ring oscillator that can be used in lieu of an ex"
        "ternal 32k crystal.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.Not related to CCM.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.Not rela"
        "ted to CCM.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC0_CLR.
static const field_t hw_ccm_analog_analog_misc0_clr[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to CCM.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_RINGOSC_EN",
        "Enables the internal ring oscillator that can be used in lieu of an ex"
        "ternal 32k crystal.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.Not related to CCM.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.Not rela"
        "ted to CCM.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC0_TOG.
static const field_t hw_ccm_analog_analog_misc0_tog[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to CCM.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_RINGOSC_EN",
        "Enables the internal ring oscillator that can be used in lieu of an ex"
        "ternal 32k crystal.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.Not related to CCM.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.Not rela"
        "ted to CCM.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC1.
static const field_t hw_ccm_analog_analog_misc1[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the LVDS output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the LVDS output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the LVDS input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the LVDS input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.Not related to CCM.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.Not related to CCM.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC1_SET.
static const field_t hw_ccm_analog_analog_misc1_set[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the LVDS output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the LVDS output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the LVDS input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the LVDS input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.Not related to CCM.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.Not related to CCM.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC1_CLR.
static const field_t hw_ccm_analog_analog_misc1_clr[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the LVDS output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the LVDS output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the LVDS input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the LVDS input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.Not related to CCM.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.Not related to CCM.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC1_TOG.
static const field_t hw_ccm_analog_analog_misc1_tog[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the LVDS output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the LVDS output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the LVDS input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the LVDS input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.Not related to CCM.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.Not related to CCM.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC2.
static const field_t hw_ccm_analog_analog_misc2[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.Not related to CCM.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "When USB is in low power suspend mode this Control bit is used to indi"
        "cate if other system peripherals require the USB PLL3 clock when the S"
        "oC is not in low power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.Not related to CCM.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC2_SET.
static const field_t hw_ccm_analog_analog_misc2_set[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.Not related to CCM.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "When USB is in low power suspend mode this Control bit is used to indi"
        "cate if other system peripherals require the USB PLL3 clock when the S"
        "oC is not in low power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.Not related to CCM.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC2_CLR.
static const field_t hw_ccm_analog_analog_misc2_clr[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.Not related to CCM.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "When USB is in low power suspend mode this Control bit is used to indi"
        "cate if other system peripherals require the USB PLL3 clock when the S"
        "oC is not in low power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.Not related to CCM.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC2_TOG.
static const field_t hw_ccm_analog_analog_misc2_tog[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.Not related to CCM.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "When USB is in low power suspend mode this Control bit is used to indi"
        "cate if other system peripherals require the USB PLL3 clock when the S"
        "oC is not in low power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.Not related to CCM.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CCM_ANALOG module.
static const reg_t hw_ccm_analog[] =
{
    {
        "ANALOG_PLL_ARM",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ccm_analog_analog_pll_arm
    },
    {
        "ANALOG_PLL_ARM_SET",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ccm_analog_analog_pll_arm_set
    },
    {
        "ANALOG_PLL_ARM_CLR",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ccm_analog_analog_pll_arm_clr
    },
    {
        "ANALOG_PLL_ARM_TOG",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ccm_analog_analog_pll_arm_tog
    },
    {
        "ANALOG_PLL_USB1",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb1
    },
    {
        "ANALOG_PLL_USB1_SET",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb1_set
    },
    {
        "ANALOG_PLL_USB1_CLR",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb1_clr
    },
    {
        "ANALOG_PLL_USB1_TOG",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb1_tog
    },
    {
        "ANALOG_PLL_USB2",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb2
    },
    {
        "ANALOG_PLL_USB2_SET",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb2_set
    },
    {
        "ANALOG_PLL_USB2_CLR",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb2_clr
    },
    {
        "ANALOG_PLL_USB2_TOG",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb2_tog
    },
    {
        "ANALOG_PLL_SYS",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_sys
    },
    {
        "ANALOG_PLL_SYS_SET",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_set
    },
    {
        "ANALOG_PLL_SYS_CLR",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_clr
    },
    {
        "ANALOG_PLL_SYS_TOG",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_tog
    },
    {
        "ANALOG_PLL_SYS_SS",
        "This register contains the 528 PLL spread spectrum controls.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_ss
    },
    {
        "ANALOG_PLL_AUDIO",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_audio
    },
    {
        "ANALOG_PLL_AUDIO_SET",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_set
    },
    {
        "ANALOG_PLL_AUDIO_CLR",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_clr
    },
    {
        "ANALOG_PLL_AUDIO_TOG",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_tog
    },
    {
        "ANALOG_PLL_AUDIO_NUM",
        "This register contains the numerator (A) of Audio PLL fractional loop "
        "divider.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_num
    },
    {
        "ANALOG_PLL_AUDIO_DENOM",
        "This register contains the Denominator (B) of Audio PLL fractional loo"
        "p divider.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_denom
    },
    {
        "ANALOG_PLL_VIDEO",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_video
    },
    {
        "ANALOG_PLL_VIDEO_SET",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_video_set
    },
    {
        "ANALOG_PLL_VIDEO_CLR",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_video_clr
    },
    {
        "ANALOG_PLL_VIDEO_TOG",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_video_tog
    },
    {
        "ANALOG_PLL_VIDEO_NUM",
        "This register contains the numerator (A) of Video PLL fractional loop "
        "divider.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_video_num
    },
    {
        "ANALOG_PLL_VIDEO_DENOM",
        "This register contains the Denominator (B) of Video PLL fractional loo"
        "p divider.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_video_denom
    },
    {
        "ANALOG_PLL_ENET",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_analog_analog_pll_enet
    },
    {
        "ANALOG_PLL_ENET_SET",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_analog_analog_pll_enet_set
    },
    {
        "ANALOG_PLL_ENET_CLR",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_analog_analog_pll_enet_clr
    },
    {
        "ANALOG_PLL_ENET_TOG",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_analog_analog_pll_enet_tog
    },
    {
        "ANALOG_PFD_480",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_480
    },
    {
        "ANALOG_PFD_480_SET",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_480_set
    },
    {
        "ANALOG_PFD_480_CLR",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_480_clr
    },
    {
        "ANALOG_PFD_480_TOG",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_480_tog
    },
    {
        "ANALOG_PFD_528",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_528
    },
    {
        "ANALOG_PFD_528_SET",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_528_set
    },
    {
        "ANALOG_PFD_528_CLR",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_528_clr
    },
    {
        "ANALOG_PFD_528_TOG",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_528_tog
    },
    {
        "ANALOG_MISC0",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_analog_misc0
    },
    {
        "ANALOG_MISC0_SET",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_analog_misc0_set
    },
    {
        "ANALOG_MISC0_CLR",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_analog_misc0_clr
    },
    {
        "ANALOG_MISC0_TOG",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_analog_misc0_tog
    },
    {
        "ANALOG_MISC1",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_ccm_analog_analog_misc1
    },
    {
        "ANALOG_MISC1_SET",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_ccm_analog_analog_misc1_set
    },
    {
        "ANALOG_MISC1_CLR",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_ccm_analog_analog_misc1_clr
    },
    {
        "ANALOG_MISC1_TOG",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_ccm_analog_analog_misc1_tog
    },
    {
        "ANALOG_MISC2",
        "This register defines the control for miscellaneous analog blocks.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_analog_analog_misc2
    },
    {
        "ANALOG_MISC2_SET",
        "This register defines the control for miscellaneous analog blocks.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_analog_analog_misc2_set
    },
    {
        "ANALOG_MISC2_CLR",
        "This register defines the control for miscellaneous analog blocks.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_analog_analog_misc2_clr
    },
    {
        "ANALOG_MISC2_TOG",
        "This register defines the control for miscellaneous analog blocks.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_analog_analog_misc2_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CSI
#endif

// Bitfields in register CSI_CSICR1.
static const field_t hw_csi_csicr1[] =
{
    {
        "PIXEL_BIT",
        "Pixel Bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REDGE",
        "Valid Pixel Clock Edge Select.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INV_PCLK",
        "Invert Pixel Clock Input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INV_DATA",
        "Invert Data Input.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GCLK_MODE",
        "Gated Clock Mode Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_RXFIFO",
        "Asynchronous RXFIFO Clear.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_STATFIFO",
        "Asynchronous STATFIFO Clear.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PACK_DIR",
        "Data Packing Direction.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCC",
        "FIFO Clear Control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCIR_EN",
        "CCIR656 Interface Enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "HSYNC Polarity Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_INTEN",
        "Start Of Frame (SOF) Interrupt Enable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_POL",
        "SOF Interrupt Polarity.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_INTEN",
        "RxFIFO Full Interrupt Enable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB1_DMA_DONE_INTEN",
        "Frame Buffer1 DMA Transfer Done Interrupt Enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB2_DMA_DONE_INTEN",
        "Frame Buffer2 DMA Transfer Done Interrupt Enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_INTEN",
        "STATFIFO Full Interrupt Enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFF_DMA_DONE_INTEN",
        "STATFIFO DMA Transfer Done Interrupt Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF_OR_INTEN",
        "RxFIFO Overrun Interrupt Enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SF_OR_INTEN",
        "STAT FIFO Overrun Interrupt Enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COF_INT_EN",
        "Change Of Image Field (COF) Interrupt Enable.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_MODE",
        "Video mode select.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRP_IF_EN",
        "CSI-PrP Interface Enable.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOF_INT_EN",
        "End-of-Frame Interrupt Enable.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXT_VSYNC",
        "External VSYNC Enable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWAP16_EN",
        "SWAP 16-Bit Enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR2.
static const field_t hw_csi_csicr2[] =
{
    {
        "HSC",
        "Horizontal Skip Count.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSC",
        "Vertical Skip Count.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVRM",
        "Live View Resolution Mode.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTS",
        "Bayer Tile Start.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCE",
        "Skip Count Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AFS",
        "Auto Focus Spread.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRM",
        "Double Resolution Mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_BURST_TYPE_SFF",
        "Burst Type of DMA Transfer from STATFIFO.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_BURST_TYPE_RFF",
        "Burst Type of DMA Transfer from RxFIFO.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR3.
static const field_t hw_csi_csicr3[] =
{
    {
        "ECC_AUTO_EN",
        "Automatic Error Correction Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_INT_EN",
        "Error Detection Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZERO_PACK_EN",
        "Dummy Zero Packing Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWO_8BIT_SENSOR",
        "Two 8-bit Sensor Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_LEVEL",
        "RxFIFO Full Level.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRESP_ERR_EN",
        "Hresponse Error Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_LEVEL",
        "STATFIFO Full Level.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REQ_EN_SFF",
        "DMA Request Enable for STATFIFO.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REQ_EN_RFF",
        "DMA Request Enable for RxFIFO.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REFLASH_SFF",
        "Reflash DMA Controller for STATFIFO.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REFLASH_RFF",
        "Reflash DMA Controller for RxFIFO.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRMCNT_RST",
        "Frame Count Reset.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRMCNT",
        "Frame Counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSISTATFIFO.
static const field_t hw_csi_csistatfifo[] =
{
    {
        "STAT",
        "Static data from sensor",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIRFIFO.
static const field_t hw_csi_csirfifo[] =
{
    {
        "IMAGE",
        "Received image data",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIRXCNT.
static const field_t hw_csi_csirxcnt[] =
{
    {
        "RXCNT",
        "RxFIFO Count.",
        0, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSISR.
static const field_t hw_csi_csisr[] =
{
    {
        "DRDY",
        "RXFIFO Data Ready.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_INT",
        "CCIR Error Interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRESP_ERR_INT",
        "Hresponse Error Interrupt Status.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COF_INT",
        "Change Of Field Interrupt Status.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_INT",
        "CCIR Field 1 Interrupt Status.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F2_INT",
        "CCIR Field 2 Interrupt Status.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_INT",
        "Start of Frame Interrupt Status.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOF_INT",
        "End of Frame (EOF) Interrupt Status.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_INT",
        "RXFIFO Full Interrupt Status.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_FB1",
        "DMA Transfer Done in Frame Buffer1.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_FB2",
        "DMA Transfer Done in Frame Buffer2.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_INT",
        "STATFIFO Full Interrupt Status.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_SFF",
        "DMA Transfer Done from StatFIFO.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF_OR_INT",
        "RxFIFO Overrun Interrupt Status.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SF_OR_INT",
        "STATFIFO Overrun Interrupt Status.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_FIELD1_DONE",
        "When DMA field 0 is complete, this bit will be set to 1(clear by writi"
        "ng 1).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_FIELD0_DONE",
        "When DMA field 0 is complete, this bit will be set to 1(clear by writi"
        "ng 1).",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASEADDR_CHHANGE_ERROR",
        "When using base address switching enable, this bit will be 1 when swit"
        "ching occur before DMA complete.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_STATFIFO.
static const field_t hw_csi_csidmasa_statfifo[] =
{
    {
        "DMA_START_ADDR_SFF",
        "DMA Start Address for STATFIFO.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMATS_STATFIFO.
static const field_t hw_csi_csidmats_statfifo[] =
{
    {
        "DMA_TSF_SIZE_SFF",
        "DMA Transfer Size for STATFIFO.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_FB1.
static const field_t hw_csi_csidmasa_fb1[] =
{
    {
        "DMA_START_ADDR_FB1",
        "DMA Start Address in Frame Buffer1.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_FB2.
static const field_t hw_csi_csidmasa_fb2[] =
{
    {
        "DMA_START_ADDR_FB2",
        "DMA Start Address in Frame Buffer2.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIFBUF_PARA.
static const field_t hw_csi_csifbuf_para[] =
{
    {
        "FBUF_STRIDE",
        "Frame Buffer Parameter.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIIMAG_PARA.
static const field_t hw_csi_csiimag_para[] =
{
    {
        "IMAGE_HEIGHT",
        "Image Height.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMAGE_WIDTH",
        "Image Width.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR18.
static const field_t hw_csi_csicr18[] =
{
    {
        "NTSC_EN",
        "This bit is used to select NTSC/PAL mode When input is TVDECODER or st"
        "andard CCIR656 video.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TVDECODER_IN_EN",
        "When input is from TV decoder, this bit is enabled.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEINTERLACE_EN",
        "This bit is used to select the output method When input is TVDECODER o"
        "r standard CCIR656 video.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARALLEL24_EN",
        "When input is parallel rgb888/yuv444 24bit, this bit can be enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASEADDR_SWITCH_EN",
        "When this bit is enabled, CSI DMA will switch the base address accordi"
        "ng to BASEADDR_SWITCH_SEL rather than atomically by DMA completed.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASEADDR_SWITCH_SEL",
        "CSI 2 base addresses switching method.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD0_DONE_IE",
        "In interlace mode, fileld 0 means interrupt enabled.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_FIELD1_DONE_IE",
        "When in interlace mode, field 1 done interrupt enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LAST_DMA_REQ_SEL",
        "Choosing the last DMA request condition.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASEADDR_CHANGE_ERROR_IE",
        "Base address change error interrupt enable signal.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB888A_FORMAT_SEL",
        "Output is 32-bit format.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_HPROT",
        "Hprot value in AHB bus protocol.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_LCDIF_BUFFER_LINES",
        "The number of lines are used in handshake mode with LCDIF.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_OPTION",
        "These bits used to choose the method to mask the CSI input.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_ENABLE",
        "CSI global enable signal.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR19.
static const field_t hw_csi_csicr19[] =
{
    {
        "DMA_RFIFO_HIGHEST_FIFO_LEVEL",
        "This byte stores the highest FIFO level achieved by CSI FIFO timely an"
        "d will be clear by writing 8'ff to it.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CSI module.
static const reg_t hw_csi[] =
{
    {
        "CSICR1",
        "This register controls the sensor interface timing and interrupt gener"
        "ation.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_csi_csicr1
    },
    {
        "CSICR2",
        "This register provides the statistic block with data about which live "
        "view resolution is being used, and the starting sensor pixel of the Ba"
        "yer pattern.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_csi_csicr2
    },
    {
        "CSICR3",
        "This read/write register acts as an extension of the functionality of "
        "the CSI Control register 1, adding additional control and features.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_csi_csicr3
    },
    {
        "CSISTATFIFO",
        "The StatFIFO is a read-only register containing statistic data from th"
        "e sensor.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_csi_csistatfifo
    },
    {
        "CSIRFIFO",
        "This read-only register contains received image data.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_csi_csirfifo
    },
    {
        "CSIRXCNT",
        "This register works for EOF interrupt generation.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csirxcnt
    },
    {
        "CSISR",
        "This read/write register shows sensor interface status, and which kind"
        " of interrupt is being generated.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csi_csisr
    },
    {
        "CSIDMASA_STATFIFO",
        "This register provides the start address for the embedded DMA controll"
        "er of STATFIFO.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_statfifo
    },
    {
        "CSIDMATS_STATFIFO",
        "This register provides the total transfer size for the embedded DMA co"
        "ntroller of STATFIFO.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmats_statfifo
    },
    {
        "CSIDMASA_FB1",
        "This register provides the start address in the frame buffer1 for the "
        "embedded DMA controller of RxFIFO.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_fb1
    },
    {
        "CSIDMASA_FB2",
        "This register provides the start address in the frame buffer2 for the "
        "embedded DMA controller of RxFIFO.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_fb2
    },
    {
        "CSIFBUF_PARA",
        "This register provides the stride of the frame buffer to show how many"
        " words to skip before starting to write the next row of the image.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csifbuf_para
    },
    {
        "CSIIMAG_PARA",
        "This register provides the width and the height of the image from the "
        "sensor.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_csi_csiimag_para
    },
    {
        "CSICR18",
        "This read/write register acts as an extension of the functionality of "
        "the CSI Control register 1 and mainly focus on new feature used in PEL"
        "E project.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_csi_csicr18
    },
    {
        "CSICR19",
        "This read/write register acts as an extension of the functionality of "
        "the CSI Control register 1 and mainly focus on new feature used in PEL"
        "E project.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csicr19
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DCIC
#endif

// Bitfields in register DCIC_DCICC.
static const field_t hw_dcic_dcicc[] =
{
    {
        "IC_EN",
        "Integrity Check enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_POL",
        "DATA_EN_IN signal polarity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "HSYNC_IN signal polarity.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "VSYNC_IN signal polarity.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_POL",
        "DISP_CLK signal polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICIC.
static const field_t hw_dcic_dcicic[] =
{
    {
        "EI_MASK",
        "Error Interrupt mask.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FI_MASK",
        "Functional Interrupt mask.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FREEZE_MASK",
        "Disable change of interrupt masks.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXT_SIG_EN",
        "External controller mismatch indication signal.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICS.
static const field_t hw_dcic_dcics[] =
{
    {
        "ROI_MATCH_STAT",
        "Each set bit of this field indicates there was a mismatch at appropria"
        "te ROIs signature during the last frame.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EI_STAT",
        "Error Interrupt status.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FI_STAT",
        "Functional Interrupt status.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICRC.
static const field_t hw_dcic_dcicrc[] =
{
    {
        "START_OFFSET_X",
        "Column number of ROIs upper-left corner (X coordinate) Range: 0 to 2^1"
        "3-1",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_OFFSET_Y",
        "Row number of ROIs upper-left corner (Y coordinate) Range: 0 to 2^12-1",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI_FREEZE",
        "When set, the only parameter of ROI #m that can be changed is referenc"
        "e signature.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI_EN",
        "ROI #m tracking enable",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICRS.
static const field_t hw_dcic_dcicrs[] =
{
    {
        "END_OFFSET_X",
        "Column number of ROIs lower-right corner (X coordinate) Range: 1 to 2^"
        "13-1",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "END_OFFSET_Y",
        "Row number of ROIs lower-right corner (Y coordinate) Range: 1 to 2^12-"
        "1",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICRRS.
static const field_t hw_dcic_dcicrrs[] =
{
    {
        "REFERENCE_SIGNATURE",
        "32-bit expected signature (CRC calculation result) for ROI #m",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCIC_DCICRCS.
static const field_t hw_dcic_dcicrcs[] =
{
    {
        "CALCULATED_SIGNATURE",
        "32-bit actual signature (CRC calculation result) for ROI #m during the"
        " last frame.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a DCIC module.
static const reg_t hw_dcic[] =
{
    {
        "DCICC",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_dcic_dcicc
    },
    {
        "DCICIC",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dcic_dcicic
    },
    {
        "DCICS",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dcic_dcics
    },
    {
        "DCICRC",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dcic_dcicrc
    },
    {
        "DCICRS",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcic_dcicrs
    },
    {
        "DCICRRS",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcic_dcicrrs
    },
    {
        "DCICRCS",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dcic_dcicrcs
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DVFSC
#endif

// Bitfields in register DVFSC_THRS.
static const field_t hw_dvfsc_thrs[] =
{
    {
        "PNCTHR",
        "Panic threshold for load tracking",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DWTHR",
        "Down threshold for load tracking",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPTHR",
        "Upper threshold for load tracking",
        22, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_COUN.
static const field_t hw_dvfsc_coun[] =
{
    {
        "UPCNT",
        "UP counter threshold value",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DN_CNT",
        "Down counter threshold value",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_SIG1.
static const field_t hw_dvfsc_sig1[] =
{
    {
        "WSW6",
        "General purpose load tracking signal weight dvfs_w_sig[6]",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW7",
        "General purpose load tracking signal weight dvfs_w_sig[7]",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW8",
        "General purpose load tracking signal weight dvfs_w_sig[8]",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW9",
        "General purpose load tracking signal weight dvfs_w_sig[9]",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW10",
        "General purpose load tracking signal weight dvfs_w_sig[10]",
        14, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW11",
        "General purpose load tracking signal weight dvfs_w_sig[11]",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW12",
        "General purpose load tracking signal weight dvfs_w_sig[12]",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW13",
        "General purpose load tracking signal weight dvfs_w_sig[13]",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW14",
        "General purpose load tracking signal weight dvfs_w_sig[14]",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW15",
        "General purpose load tracking signal weight dvfs_w_sig[15]",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSSIG0.
static const field_t hw_dvfsc_dvfssig0[] =
{
    {
        "WSW0",
        "General purpose load tracking signal weight dvfs_w_sig[0].",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW1",
        "General purpose load tracking signal weight dvfs_w_sig[1].",
        6, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW2",
        "General purpose load tracking signal weight dvfs_w_sig[2]",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW3",
        "General purpose load tracking signal weight dvfs_w_sig[3]",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW4",
        "General purpose load tracking signal weight dvfs_w_sig[4]",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW5",
        "General purpose load tracking signal weight dvfs_w_sig[5]",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPC0.
static const field_t hw_dvfsc_dvfsgpc0[] =
{
    {
        "GPBC0",
        "GPBC0 - General Purpose bits Counter 0 During period of this counter t"
        "he GeP bit 0 will be set and WSW0 will be added to the calculations.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C0ACT",
        "C0ACT - Counter 0 active indicator",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C0STRT",
        "C0STRT - Counter 0 start Setting of this bit will initialize down coun"
        "ting of the GPC0 value.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPC1.
static const field_t hw_dvfsc_dvfsgpc1[] =
{
    {
        "GPBC1",
        "GPBC1 - General Purpose bits Counter 1 During period of this counter t"
        "he GeP bit 1 will be set and WSW1 will be added to the calculations.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C1ACT",
        "C1ACT - Counter 1 active indicator",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C1STRT",
        "C1STRT - Counter 1start Setting of this bit will initialize down count"
        "ing of the GPC1 value.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPBT.
static const field_t hw_dvfsc_dvfsgpbt[] =
{
    {
        "GPB0",
        "General purpose bit 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB1",
        "General purpose bit 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB2",
        "General purpose bit 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB3",
        "General purpose bit 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB4",
        "General purpose bit 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB5",
        "General purpose bit 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB6",
        "General purpose bit 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB7",
        "General purpose bit 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB8",
        "General purpose bit 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB9",
        "General purpose bit 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB10",
        "General purpose bit 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB11",
        "General purpose bit 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB12",
        "General purpose bit 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB13",
        "General purpose bit 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB14",
        "General purpose bit 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB15",
        "General purpose bit 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSEMAC.
static const field_t hw_dvfsc_dvfsemac[] =
{
    {
        "EMAC",
        "EMAC - EMA control value",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEN0",
        "DVFS tracking for core0 enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSVAI0",
        "DVFS Frequency adjustment status of core 0.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFIM0",
        "DVFS Wait for Interrupt of core 0 mask bit",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_CNTR.
static const field_t hw_dvfsc_cntr[] =
{
    {
        "LTBRSR",
        "LTBRSR - Load Tracking Buffer Register Source:",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LTBRSH",
        "LTBRSH - Load Tracking Buffer Register Shift:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFUS",
        "PFUS - Periodic Frequency Update Status",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFUE",
        "PFUE - Period Frequency Update Enable",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV_RATIO",
        "DIV_RATIO - Divider value.",
        11, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MINF",
        "Minimum frequency reached.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAXF",
        "Maximum frequency reached.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSVAI",
        "FSVAI DVFS Frequency adjustment interrupt.",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FSVAIM",
        "DVFS Frequency adjustment interrupt mask.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIRQS",
        "PIRQS - Pattern IRQ Source * write '1' to clear.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFIS",
        "DVFS Interrupt select.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBFL0",
        "Load buffer 0 - full status bit.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBFL1",
        "Load buffer 1 - full status bit.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBMI",
        "Load buffer full mask interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEV",
        "Always give a DVFS event.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV3CK",
        "DIV3CK - div_3_clk division ratio inside the DVFS module.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR0_0.
static const field_t hw_dvfsc_dvfsltr0_0[] =
{
    {
        "LTS0_0",
        "core 0 Load Tracking Sample 0",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_1",
        "core 0 Load Tracking Sample 1",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_2",
        "core 0 Load Tracking Sample 2",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_3",
        "core 0 Load Tracking Sample 3",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_4",
        "core 0 Load Tracking Sample 4",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_5",
        "core 0 Load Tracking Sample 5",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_6",
        "core 0 Load Tracking Sample 6",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_7",
        "core 0 Load Tracking Sample 7",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR0_1.
static const field_t hw_dvfsc_dvfsltr0_1[] =
{
    {
        "LTS0_8",
        "core 0 Load Tracking Sample 8",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_9",
        "core 0 Load Tracking Sample 9",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_10",
        "core 0 Load Tracking Sample 10",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_11",
        "core 0 Load Tracking Sample 11",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_12",
        "core 0 Load Tracking Sample 12",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_13",
        "core 0 Load Tracking Sample 13",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_14",
        "core 0 Load Tracking Sample 14",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_15",
        "core 0 Load Tracking Sample 15",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR1_0.
static const field_t hw_dvfsc_dvfsltr1_0[] =
{
    {
        "LTS1_0",
        "core 0 Load Tracking Sample 0",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_1",
        "core 0 Load Tracking Sample 1",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_2",
        "core 0 Load Tracking Sample 2",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_3",
        "core 0 Load Tracking Sample 3",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_4",
        "core 0 Load Tracking Sample 4",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_5",
        "core 0 Load Tracking Sample 5",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_6",
        "core 0 Load Tracking Sample 6",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_7",
        "core 0 Load Tracking Sample 7",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR1_1.
static const field_t hw_dvfsc_dvfsltr1_1[] =
{
    {
        "LTS1_8",
        "core 0 Load Tracking Sample 8",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_9",
        "core 0 Load Tracking Sample 9",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_10",
        "core 0 Load Tracking Sample 10",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_11",
        "core 0 Load Tracking Sample 11",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_12",
        "core 0 Load Tracking Sample 12",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_13",
        "core 0 Load Tracking Sample 13",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_14",
        "core 0 Load Tracking Sample 14",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_15",
        "core 0 Load Tracking Sample 15",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT0.
static const field_t hw_dvfsc_dvfspt0[] =
{
    {
        "FPTN0",
        "FPTN0 - Frequency pattern 0 counter During period of this counter the "
        "frequency will be reduced from the EMA-detected level.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT0A",
        "PT0A - Pattern 0 currently active (read-only)",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT1.
static const field_t hw_dvfsc_dvfspt1[] =
{
    {
        "FPTN1",
        "FPTN1 - Frequency pattern 1 counter During period of this counter the "
        "frequency will be set to the EMA-detected level.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT1A",
        "PT1A - Pattern 1 currently active (read-only)",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT2.
static const field_t hw_dvfsc_dvfspt2[] =
{
    {
        "FPTN2",
        "FPTN2 - Frequency pattern 2 counter During period of this counter the "
        "frequency will be increased to higher, than detected by the EMA-detect"
        "ed level.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT2A",
        "PT2A - Pattern 2 currently active (read-only)",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "P2THR",
        "P2THR - Pattern 2 Threshold Threshold of current DVFS load (after EMA)"
        ", for generating interrupts with PFUS indicators 110, 111.",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT3.
static const field_t hw_dvfsc_dvfspt3[] =
{
    {
        "FPTN3",
        "FPTN3 - Frequency pattern 3 counter During period of this counter the "
        "frequency will be set to the EMA-detected level.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT3A",
        "PT3A - Pattern 3 currently active (read-only)",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a DVFSC module.
static const reg_t hw_dvfsc[] =
{
    {
        "THRS",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_thrs
    },
    {
        "COUN",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_coun
    },
    {
        "SIG1",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dvfsc_sig1
    },
    {
        "DVFSSIG0",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_dvfsc_dvfssig0
    },
    {
        "DVFSGPC0",
        "DVFS general purpose bits weight counter.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfsgpc0
    },
    {
        "DVFSGPC1",
        "DVFS general purpose bits weight counter1.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfsgpc1
    },
    {
        "DVFSGPBT",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_dvfsc_dvfsgpbt
    },
    {
        "DVFSEMAC",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dvfsc_dvfsemac
    },
    {
        "CNTR",
        "DIV3CK division DIV3CK setting dividing ratio sum_3 passing bits div_1"
        "_clk cumulative divider 00 1 4-0 1*512=512 001 4 6-2 4*512=2048 010 16"
        " 8-4 16*512=8192 011 64 10-6 64*512=32768 100 256 12-8 256*512=131072 "
        "101 1024 16-10 1024*512=524288 Preliminary Divider definition DIV_RATI"
        "O value ARM clk division ratio 000000 1 000001 2 000010 3 ...",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_dvfsc_cntr
    },
    {
        "DVFSLTR0_0",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr0_0
    },
    {
        "DVFSLTR0_1",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr0_1
    },
    {
        "DVFSLTR1_0",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr1_0
    },
    {
        "DVFSLTR1_1",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr1_1
    },
    {
        "DVFSPT0",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt0
    },
    {
        "DVFSPT1",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt1
    },
    {
        "DVFSPT2",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfspt2
    },
    {
        "DVFSPT3",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt3
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ECSPI
#endif

// Bitfields in register ECSPI_RXDATA.
static const field_t hw_ecspi_rxdata[] =
{
    {
        "ECSPI_RXDATA",
        "Receive Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_TXDATA.
static const field_t hw_ecspi_txdata[] =
{
    {
        "ECSPI_TXDATA",
        "Transmit Data.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_CONREG.
static const field_t hw_ecspi_conreg[] =
{
    {
        "EN",
        "SPI Block Enable Control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HT",
        "Hardware Trigger Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XCH",
        "SPI Exchange Bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMC",
        "Start Mode Control.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHANNEL_MODE",
        "SPI CHANNEL MODE selects the mode for each SPI channel.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIVIDER",
        "SPI Post Divider.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_DIVIDER",
        "SPI Pre Divider.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRCTL",
        "SPI Data Ready Control.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHANNEL_SELECT",
        "SPI CHANNEL SELECT bits.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LENGTH",
        "Burst Length.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_CONFIGREG.
static const field_t hw_ecspi_configreg[] =
{
    {
        "SCLK_PHA",
        "SPI Clock/Data Phase Control.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLK_POL",
        "SPI Clock Polarity Control.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS_CTL",
        "SPI SS Wave Form Select.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS_POL",
        "SPI SS Polarity Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_CTL",
        "DATA CTL.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLK_CTL",
        "SCLK CTL.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HT_LENGTH",
        "HT LENGTH.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_INTREG.
static const field_t hw_ecspi_intreg[] =
{
    {
        "TEEN",
        "TXFIFO Empty Interrupt enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDREN",
        "TXFIFO Data Request Interrupt enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN",
        "TXFIFO Full Interrupt enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RREN",
        "RXFIFO Ready Interrupt enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDREN",
        "RXFIFO Data Request Interrupt enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN",
        "RXFIFO Full Interrupt enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROEN",
        "RXFIFO Overflow Interrupt enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCEN",
        "Transfer Completed Interrupt enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_DMAREG.
static const field_t hw_ecspi_dmareg[] =
{
    {
        "TX_THRESHOLD",
        "TX THRESHOLD.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEDEN",
        "TXFIFO Empty DMA Request Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_THRESHOLD",
        "RX THRESHOLD.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDEN",
        "RXFIFO DMA Request Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_DMA_LENGTH",
        "RX DMA LENGTH.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXTDEN",
        "RXFIFO TAIL DMA Request Enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_STATREG.
static const field_t hw_ecspi_statreg[] =
{
    {
        "TE",
        "TXFIFO Empty.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDR",
        "TXFIFO Data Request.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF",
        "TXFIFO Full.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RR",
        "RXFIFO Ready.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR",
        "RXFIFO Data Request.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RF",
        "RXFIFO Full.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RO",
        "RXFIFO Overflow.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        "Transfer Completed Status bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_PERIODREG.
static const field_t hw_ecspi_periodreg[] =
{
    {
        "SAMPLE_PERIOD",
        "Sample Period Control.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSRC",
        "Clock Source Control.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSD_CTL",
        "Chip Select Delay Control bits.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_TESTREG.
static const field_t hw_ecspi_testreg[] =
{
    {
        "TXCNT",
        "TXFIFO Counter.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXCNT",
        "RXFIFO Counter.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBC",
        "Loop Back Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_MSGDATA.
static const field_t hw_ecspi_msgdata[] =
{
    {
        "ECSPI_MSGDATA",
        "ECSPI_MSGDATA holds the top word of MSG Data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a ECSPI module.
static const reg_t hw_ecspi[] =
{
    {
        "RXDATA",
        "The Receive Data register (ECSPI_RXDATA) is a read-only register that "
        "forms the top word of the 64 x 32 receive FIFO.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ecspi_rxdata
    },
    {
        "TXDATA",
        "The Transmit Data (ECSPI_TXDATA) register is a write-only data registe"
        "r that forms the bottom word of the 64 x 32 TXFIFO.",
        4, // Width in bytes
        0x00000004, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ecspi_txdata
    },
    {
        "CONREG",
        "The Control Register (ECSPI_CONREG) allows software to enable the ECSP"
        "I , configure its operating modes, specify the divider value, and SPI_"
        "RDY control signal, and define the transfer length.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ecspi_conreg
    },
    {
        "CONFIGREG",
        "The Config Register (ECSPI_CONFIGREG) allows software to configure eac"
        "h SPI channel, configure its operating modes, specify the phase and po"
        "larity of the clock, configure the Chip Select (SS), and define the HT"
        " transfer length.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ecspi_configreg
    },
    {
        "INTREG",
        "The Interrupt Control Register (ECSPI_INTREG) enables the generation o"
        "f interrupts to the host processor.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ecspi_intreg
    },
    {
        "DMAREG",
        "The Direct Memory Access Control Register (ECSPI_DMAREG) provides soft"
        "ware a way to use an on-chip DMA controller for ECSPI data.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ecspi_dmareg
    },
    {
        "STATREG",
        "The ECSPI Status Register (ECSPI_STATREG) reflects the status of the E"
        "CSPI's operating condition.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ecspi_statreg
    },
    {
        "PERIODREG",
        "The Sample Period Control Register (ECSPI_PERIODREG) provides software"
        " a way to insert delays (wait states) between consecutive SPI transfer"
        "s.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ecspi_periodreg
    },
    {
        "TESTREG",
        "The Test Control Register (ECSPI_TESTREG) provides software a mechanis"
        "m to internally connect the receive and transmit devices of the ECSPI "
        ", and monitor the contents of the receive and transmit FIFOs.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ecspi_testreg
    },
    {
        "MSGDATA",
        "The Message Data Register (ECSPI_MSGDATA) forms the top word of the 16"
        " x 32 MSG Data FIFO.",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ecspi_msgdata
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EIM
#endif

// Bitfields in register EIM_CS0GCR1.
static const field_t hw_eim_cs0gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0GCR2.
static const field_t hw_eim_cs0gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0RCR1.
static const field_t hw_eim_cs0rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0RCR2.
static const field_t hw_eim_cs0rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0WCR1.
static const field_t hw_eim_cs0wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0WCR2.
static const field_t hw_eim_cs0wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1GCR1.
static const field_t hw_eim_cs1gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1GCR2.
static const field_t hw_eim_cs1gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1RCR1.
static const field_t hw_eim_cs1rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1RCR2.
static const field_t hw_eim_cs1rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1WCR1.
static const field_t hw_eim_cs1wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1WCR2.
static const field_t hw_eim_cs1wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2GCR1.
static const field_t hw_eim_cs2gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2GCR2.
static const field_t hw_eim_cs2gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2RCR1.
static const field_t hw_eim_cs2rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2RCR2.
static const field_t hw_eim_cs2rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2WCR1.
static const field_t hw_eim_cs2wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2WCR2.
static const field_t hw_eim_cs2wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3GCR1.
static const field_t hw_eim_cs3gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3GCR2.
static const field_t hw_eim_cs3gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3RCR1.
static const field_t hw_eim_cs3rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3RCR2.
static const field_t hw_eim_cs3rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3WCR1.
static const field_t hw_eim_cs3wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3WCR2.
static const field_t hw_eim_cs3wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4GCR1.
static const field_t hw_eim_cs4gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4GCR2.
static const field_t hw_eim_cs4gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4RCR1.
static const field_t hw_eim_cs4rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4RCR2.
static const field_t hw_eim_cs4rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4WCR1.
static const field_t hw_eim_cs4wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4WCR2.
static const field_t hw_eim_cs4wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5GCR1.
static const field_t hw_eim_cs5gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5GCR2.
static const field_t hw_eim_cs5gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5RCR1.
static const field_t hw_eim_cs5rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5RCR2.
static const field_t hw_eim_cs5rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5WCR1.
static const field_t hw_eim_cs5wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5WCR2.
static const field_t hw_eim_cs5wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_WCR.
static const field_t hw_eim_wcr[] =
{
    {
        "BCM",
        "Burst Clock Mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBCD",
        "General Burst Clock Divisor.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONT_BCLK_SEL",
        "When this bit is set BCLK pin output continuous clock.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTEN",
        "Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTPOL",
        "Interrupt Polarity.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_EN",
        "Memory WDog enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_LIMIT",
        "Memory Watch Dog (WDog) cycle limit.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRUN_ACLK_EN",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_DCR.
static const field_t hw_eim_dcr[] =
{
    {
        "DLL_CTRL_ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OFFSET_DEC",
        "Decrease(or increase) the value defined by DLL_CTRL_SLV_OFFSET when ca"
        "lculating DLL_STS_SLV_SEL",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OFFSET",
        "OFFSET value for DLL_CTRL_SLV_SEL",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_GATE_UPDATE",
        "Set this bit to 1 to force DLL not update from now on.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical tap"
        "s manually.",
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_INITIAL_VAL",
        "This field is used to select the initial value of reference chain befo"
        "re DLL enabled.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_UPDATE_INT",
        "If default 0 is used, it means 256 cycles of ref_clock.",
        23, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_UPDATE_INT",
        "DLL control loop update interval.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_DSR.
static const field_t hw_eim_dsr[] =
{
    {
        "DLL_STS_SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_STS_REF_LOCK",
        "Reference DLL lock status.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_STS_SLV_SEL",
        "Slave delay line select status.",
        2, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_STS_REF_SEL",
        "Reference delay line select taps.",
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_WIAR.
static const field_t hw_eim_wiar[] =
{
    {
        "IPS_REQ",
        "IPS request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPS_ACK",
        "IPS ACK.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT",
        "Interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERRST",
        "READY After Reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EN",
        "ACLK enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_EAR.
static const field_t hw_eim_ear[] =
{
    {
        "ERROR_ADDR",
        "Error Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a EIM module.
static const reg_t hw_eim[] =
{
    {
        "CS0GCR1",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs0gcr1
    },
    {
        "CS0GCR2",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs0gcr2
    },
    {
        "CS0RCR1",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs0rcr1
    },
    {
        "CS0RCR2",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs0rcr2
    },
    {
        "CS0WCR1",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs0wcr1
    },
    {
        "CS0WCR2",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs0wcr2
    },
    {
        "CS1GCR1",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs1gcr1
    },
    {
        "CS1GCR2",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs1gcr2
    },
    {
        "CS1RCR1",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs1rcr1
    },
    {
        "CS1RCR2",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs1rcr2
    },
    {
        "CS1WCR1",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs1wcr1
    },
    {
        "CS1WCR2",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs1wcr2
    },
    {
        "CS2GCR1",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs2gcr1
    },
    {
        "CS2GCR2",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs2gcr2
    },
    {
        "CS2RCR1",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs2rcr1
    },
    {
        "CS2RCR2",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs2rcr2
    },
    {
        "CS2WCR1",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs2wcr1
    },
    {
        "CS2WCR2",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs2wcr2
    },
    {
        "CS3GCR1",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs3gcr1
    },
    {
        "CS3GCR2",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs3gcr2
    },
    {
        "CS3RCR1",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs3rcr1
    },
    {
        "CS3RCR2",
        "",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs3rcr2
    },
    {
        "CS3WCR1",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs3wcr1
    },
    {
        "CS3WCR2",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs3wcr2
    },
    {
        "CS4GCR1",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs4gcr1
    },
    {
        "CS4GCR2",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs4gcr2
    },
    {
        "CS4RCR1",
        "",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs4rcr1
    },
    {
        "CS4RCR2",
        "",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs4rcr2
    },
    {
        "CS4WCR1",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs4wcr1
    },
    {
        "CS4WCR2",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs4wcr2
    },
    {
        "CS5GCR1",
        "",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs5gcr1
    },
    {
        "CS5GCR2",
        "",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs5gcr2
    },
    {
        "CS5RCR1",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs5rcr1
    },
    {
        "CS5RCR2",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs5rcr2
    },
    {
        "CS5WCR1",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs5wcr1
    },
    {
        "CS5WCR2",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs5wcr2
    },
    {
        "WCR",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_wcr
    },
    {
        "DCR",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_dcr
    },
    {
        "DSR",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_eim_dsr
    },
    {
        "WIAR",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_wiar
    },
    {
        "EAR",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_ear
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ENET
#endif

// Bitfields in register ENET_EIR.
static const field_t hw_enet_eir[] =
{
    {
        "RXB1",
        "This field indicates that a receive buffer descriptor, that not the la"
        "st in the frame, has been updated (ring/class 1).",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF1",
        "This field indicates that a frame has been received and the last corre"
        "sponding buffer descriptor has been updated (ring/class 1).",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB1",
        "This field indicates that a transmit buffer descriptor has been update"
        "d (ring/class 1).",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF1",
        "This bit indicates that a frame has been transmitted and the last corr"
        "esponding buffer descriptor has been updated (ring/class 1).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB2",
        "This field indicates that a receive buffer descriptor, that not the la"
        "st in the frame, has been updated (ring/class 2).",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF2",
        "This field indicates that a frame has been received and the last corre"
        "sponding buffer descriptor has been updated (ring/class 2).",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB2",
        "This field indicates that a transmit buffer descriptor has been update"
        "d (ring/class 2).",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF2",
        "This bit indicates that a frame has been transmitted and the last corr"
        "esponding buffer descriptor has been updated (ring/class 2).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFLUSH_0",
        "RX DMA Ring 0 flush indication.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFLUSH_1",
        "RX DMA Ring 1 flush indication.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFLUSH_2",
        "RX DMA Ring 2 flush indication.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TS_TIMER",
        "The adjustable timer reached the period event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TS_AVAIL",
        "Indicates that the timestamp of the last transmitted timing frame is a"
        "vailable in the ATSTMP register.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "Read-only status bit to indicate that a magic packet has been detected"
        ".",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLR",
        "Indicates a frame was received with a payload length error.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UN",
        "Indicates the transmit FIFO became empty before the complete frame was"
        " transmitted.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Indicates a collision occurred on each of 16 successive attempts to tr"
        "ansmit the frame.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LC",
        "Indicates a collision occurred beyond the collision window (slot time)"
        " in half-duplex mode.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EBERR",
        "Indicates a system bus error occurred when a uDMA transaction is under"
        "way.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII",
        "Indicates that the MII has completed the data transfer requested.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB",
        "Indicates a receive buffer descriptor is not the last in the frame has"
        " been updated.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF",
        "Indicates a frame has been received and the last corresponding buffer "
        "descriptor has been updated.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB",
        "Indicates a transmit buffer descriptor has been updated.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF",
        "Indicates a frame has been transmitted and the last corresponding buff"
        "er descriptor has been updated.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRA",
        "This interrupt is asserted after the transmitter is put into a pause s"
        "tate after completion of the frame currently being transmitted.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABT",
        "Indicates the transmitted frame length exceeds RCR[MAX_FL] bytes.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABR",
        "Indicates a frame was received with length in excess of RCR[MAX_FL] by"
        "tes.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_EIMR.
static const field_t hw_enet_eimr[] =
{
    {
        "RXB1",
        "Corresponds to interrupt source EIR[RXB1] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF1",
        "Corresponds to interrupt source EIR[RXF1] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB1",
        "Corresponds to interrupt source EIR[TXB1] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF1",
        "Corresponds to interrupt source EIR[TXF1] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB2",
        "Corresponds to interrupt source EIR[RXB2] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF2",
        "Corresponds to interrupt source EIR[RXF2] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB2",
        "Corresponds to interrupt source EIR[TXB2] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF2",
        "Corresponds to interrupt source EIR[TXF2] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFLUSH_0",
        "Corresponds to interrupt source EIR[RXFLUSH_0] and determines whether "
        "an interrupt condition can generate an interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFLUSH_1",
        "Corresponds to interrupt source EIR[RXFLUSH_1] and determines whether "
        "an interrupt condition can generate an interrupt.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFLUSH_2",
        "Corresponds to interrupt source EIR[RXFLUSH_2] and determines whether "
        "an interrupt condition can generate an interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TS_TIMER",
        "Corresponds to interrupt source EIR[TS_TIMER] register and determines "
        "whether an interrupt condition can generate an interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TS_AVAIL",
        "Corresponds to interrupt source EIR[TS_AVAIL] register and determines "
        "whether an interrupt condition can generate an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "Corresponds to interrupt source EIR[WAKEUP] register and determines wh"
        "ether an interrupt condition can generate an interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLR",
        "Corresponds to interrupt source EIR[PLR] and determines whether an int"
        "errupt condition can generate an interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UN",
        "Corresponds to interrupt source EIR[UN] and determines whether an inte"
        "rrupt condition can generate an interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Corresponds to interrupt source EIR[RL] and determines whether an inte"
        "rrupt condition can generate an interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LC",
        "Corresponds to interrupt source EIR[LC] and determines whether an inte"
        "rrupt condition can generate an interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EBERR",
        "Corresponds to interrupt source EIR[EBERR] and determines whether an i"
        "nterrupt condition can generate an interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII",
        "Corresponds to interrupt source EIR[MII] and determines whether an int"
        "errupt condition can generate an interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB",
        "Corresponds to interrupt source EIR[RXB] and determines whether an int"
        "errupt condition can generate an interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF",
        "Corresponds to interrupt source EIR[RXF] and determines whether an int"
        "errupt condition can generate an interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB",
        "Corresponds to interrupt source EIR[TXB] and determines whether an int"
        "errupt condition can generate an interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF",
        "Corresponds to interrupt source EIR[TXF] and determines whether an int"
        "errupt condition can generate an interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRA",
        "Corresponds to interrupt source EIR[GRA] and determines whether an int"
        "errupt condition can generate an interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABT",
        "Corresponds to interrupt source EIR[BABT] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABR",
        "Corresponds to interrupt source EIR[BABR] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDAR.
static const field_t hw_enet_rdar[] =
{
    {
        "RDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDAR.
static const field_t hw_enet_tdar[] =
{
    {
        "TDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ECR.
static const field_t hw_enet_ecr[] =
{
    {
        "RESET",
        "When this field is set, it clears the ETHEREN field.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETHEREN",
        "Enables/disables the Ethernet MAC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAGICEN",
        "Enables/disables magic packet detection.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLEEP",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN1588",
        "Enables enhanced functionality of the MAC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Selects between 10/100 and 1000 Mbps modes of operation.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "Enables the MAC to enter hardware freeze mode when the device enters d"
        "ebug mode.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBSWP",
        "Swaps the byte locations of the buffer descriptors.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SVLANEN",
        "Enable additional detection of S-VLAN tag according to IEEE802.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLANUSE2ND",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SVLANDBL",
        "If enabled, S-VLAN detection requires a double-tagged frame to define "
        "a frame as being a VLAN frame.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MMFR.
static const field_t hw_enet_mmfr[] =
{
    {
        "DATA",
        "This is the field for data to be written to or read from the PHY regis"
        "ter.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TA",
        "This field must be programmed to 10 to generate a valid MII management"
        " frame.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RA",
        "Specifies one of up to 32 registers within the specified PHY device.",
        18, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "Specifies one of up to 32 attached PHY devices.",
        23, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OP",
        "Determines the frame operation.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ST",
        "These fields must be programmed to 01 for a valid MII management frame"
        ".",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MSCR.
static const field_t hw_enet_mscr[] =
{
    {
        "MII_SPEED",
        "Controls the frequency of the MII management interface clock (MDC) rel"
        "ative to the internal module clock.",
        1, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS_PRE",
        "Enables/disables prepending a preamble to the MII management frame.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLDTIME",
        "IEEE802.3 clause 22 defines a minimum of 10 ns for the hold time on th"
        "e MDIO output.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MIBC.
static const field_t hw_enet_mibc[] =
{
    {
        "MIB_CLEAR",
        "This field is not self-clearing.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIB_IDLE",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIB_DIS",
        "If this control field is set,",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RCR.
static const field_t hw_enet_rcr[] =
{
    {
        "LOOP",
        "This is an MII internal loopback, therefore MII_MODE must be written t"
        "o 1 and RMII_MODE must be written to 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRT",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII_MODE",
        "This field must always be set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROM",
        "All frames are accepted regardless of address matching.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BC_REJ",
        "If set, frames with destination address (DA) equal to 0xFFFF_FFFF_FFFF"
        " are rejected unless the PROM field is set.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCE",
        "If set, the receiver detects PAUSE frames.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGMII_EN",
        "Do not set both RCR[RGMII_EN] and RCR[RMII_MODE].",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RMII_MODE",
        "Specifies whether the MAC is configured for MII mode or RMII operation"
        " , when ECR[SPEED] is cleared .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RMII_10T",
        "Enables 10-Mbps mode of the RMII or RGMII .",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PADEN",
        "Specifies whether the MAC removes padding from received frames.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAUFWD",
        "Specifies whether pause frames are terminated or forwarded.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCFWD",
        "Specifies whether the CRC field of received frames is transmitted or s"
        "tripped.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFEN",
        "Enables/disables the MAC control frame.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAX_FL",
        "Resets to decimal 1518.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NLC",
        "Enables/disables a payload length check.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRS",
        "Read-only status indicating that the MAC receive datapath is stopped.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCR.
static const field_t hw_enet_tcr[] =
{
    {
        "GTS",
        "When this field is set, MAC stops transmission after any frame current"
        "ly transmitted is complete and EIR[GRA] is set.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FDEN",
        "If this field is set, frames transmit independent of carrier sense and"
        " collision inputs.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFC_PAUSE",
        "Pauses frame transmission.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFC_PAUSE",
        "This status field is set when a full-duplex flow control pause frame i"
        "s received and the transmitter pauses for the duration defined in this"
        " pause frame.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDSEL",
        "If ADDINS is set, indicates the MAC address that overwrites the source"
        " MAC address.",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDINS",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCFWD",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_PALR.
static const field_t hw_enet_palr[] =
{
    {
        "PADDR1",
        "Bytes 0 (bits 31:24), 1 (bits 23:16), 2 (bits 15:8), and 3 (bits 7:0) "
        "of the 6-byte individual address are used for exact match and the sour"
        "ce address field in PAUSE frames.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_PAUR.
static const field_t hw_enet_paur[] =
{
    {
        "TYPE",
        "These fields have a constant value of 0x8808.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PADDR2",
        "Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual addre"
        "ss used for exact match, and the source address field in PAUSE frames.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_OPD.
static const field_t hw_enet_opd[] =
{
    {
        "PAUSE_DUR",
        "Pause duration field used in PAUSE frames.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE",
        "These fields have a constant value of 0x0001.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TXIC0.
static const field_t hw_enet_txic0[] =
{
    {
        "ICTT",
        "Interrupt coalescing timer threshold in units of 64 clock periods.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICFT",
        "This value determines the number of frames needed to be transmitted fo"
        "r raising an interrupt.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICCS",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICEN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TXIC1.
static const field_t hw_enet_txic1[] =
{
    {
        "ICTT",
        "Interrupt coalescing timer threshold in units of 64 clock periods.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICFT",
        "This value determines the number of frames needed to be transmitted fo"
        "r raising an interrupt.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICCS",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICEN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TXIC2.
static const field_t hw_enet_txic2[] =
{
    {
        "ICTT",
        "Interrupt coalescing timer threshold in units of 64 clock periods.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICFT",
        "This value determines the number of frames needed to be transmitted fo"
        "r raising an interrupt.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICCS",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICEN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RXIC0.
static const field_t hw_enet_rxic0[] =
{
    {
        "ICTT",
        "Interrupt coalescing timer threshold in units of 64 clock periods.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICFT",
        "This value determines the number of frames needed to be received for r"
        "aising an interrupt.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICCS",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICEN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RXIC1.
static const field_t hw_enet_rxic1[] =
{
    {
        "ICTT",
        "Interrupt coalescing timer threshold in units of 64 clock periods.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICFT",
        "This value determines the number of frames needed to be received for r"
        "aising an interrupt.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICCS",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICEN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RXIC2.
static const field_t hw_enet_rxic2[] =
{
    {
        "ICTT",
        "Interrupt coalescing timer threshold in units of 64 clock periods.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICFT",
        "This value determines the number of frames needed to be received for r"
        "aising an interrupt.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICCS",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICEN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IAUR.
static const field_t hw_enet_iaur[] =
{
    {
        "IADDR1",
        "Contains the upper 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a unicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IALR.
static const field_t hw_enet_ialr[] =
{
    {
        "IADDR2",
        "Contains the lower 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a unicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_GAUR.
static const field_t hw_enet_gaur[] =
{
    {
        "GADDR1",
        "Contains the upper 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a multicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_GALR.
static const field_t hw_enet_galr[] =
{
    {
        "GADDR2",
        "Contains the lower 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a multicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TFWR.
static const field_t hw_enet_tfwr[] =
{
    {
        "TFWR",
        "If TFWR[STRFWD] is cleared, this field indicates the number of bytes, "
        "in steps of 64 bytes, written to the transmit FIFO before transmission"
        " of a frame begins.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STRFWD",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDSR1.
static const field_t hw_enet_rdsr1[] =
{
    {
        "R_DES_START",
        "Pointer to the beginning of the receive buffer descriptor queue 1.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDSR1.
static const field_t hw_enet_tdsr1[] =
{
    {
        "X_DES_START",
        "Pointer to the beginning of transmit buffer descriptor queue 1.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MRBR1.
static const field_t hw_enet_mrbr1[] =
{
    {
        "R_BUF_SIZE",
        "Receive buffer size in bytes.",
        4, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDSR2.
static const field_t hw_enet_rdsr2[] =
{
    {
        "R_DES_START",
        "Pointer to the beginning of receive buffer descriptor queue 2.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDSR2.
static const field_t hw_enet_tdsr2[] =
{
    {
        "X_DES_START",
        "Pointer to the beginning of transmit buffer descriptor queue 2.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MRBR2.
static const field_t hw_enet_mrbr2[] =
{
    {
        "R_BUF_SIZE",
        "Receive buffer size in bytes.",
        4, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDSR.
static const field_t hw_enet_rdsr[] =
{
    {
        "R_DES_START",
        "Pointer to the beginning of the receive buffer descriptor queue.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDSR.
static const field_t hw_enet_tdsr[] =
{
    {
        "X_DES_START",
        "Pointer to the beginning of the transmit buffer descriptor queue.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MRBR.
static const field_t hw_enet_mrbr[] =
{
    {
        "R_BUF_SIZE",
        "Receive buffer size in bytes.",
        4, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RSFL.
static const field_t hw_enet_rsfl[] =
{
    {
        "RX_SECTION_FULL",
        "Value, in 64-bit words, of the receive FIFO section full threshold.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RSEM.
static const field_t hw_enet_rsem[] =
{
    {
        "RX_SECTION_EMPTY",
        "Value, in 64-bit words, of the receive FIFO section empty threshold.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STAT_SECTION_EMPTY",
        "Defines number of frames in the receive FIFO, independent of its size,"
        " that can be accepted.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RAEM.
static const field_t hw_enet_raem[] =
{
    {
        "RX_ALMOST_EMPTY",
        "Value, in 64-bit words, of the receive FIFO almost empty threshold.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RAFL.
static const field_t hw_enet_rafl[] =
{
    {
        "RX_ALMOST_FULL",
        "Value, in 64-bit words, of the receive FIFO almost full threshold.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TSEM.
static const field_t hw_enet_tsem[] =
{
    {
        "TX_SECTION_EMPTY",
        "Value, in 64-bit words, of the transmit FIFO section empty threshold.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TAEM.
static const field_t hw_enet_taem[] =
{
    {
        "TX_ALMOST_EMPTY",
        "Value, in 64-bit words, of the transmit FIFO almost empty threshold.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TAFL.
static const field_t hw_enet_tafl[] =
{
    {
        "TX_ALMOST_FULL",
        "Value, in 64-bit words, of the transmit FIFO almost full threshold.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TIPG.
static const field_t hw_enet_tipg[] =
{
    {
        "IPG",
        "Indicates the IPG, in bytes, between transmitted frames.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_FTRL.
static const field_t hw_enet_ftrl[] =
{
    {
        "TRUNC_FL",
        "Indicates the value a receive frame is truncated, if it is greater tha"
        "n this value.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TACC.
static const field_t hw_enet_tacc[] =
{
    {
        "SHIFT16",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPCHK",
        "Enables insertion of IP header checksum.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROCHK",
        "Enables insertion of protocol checksum.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RACC.
static const field_t hw_enet_racc[] =
{
    {
        "PADREM",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPDIS",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRODIS",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINEDIS",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT16",
        "When this field is set, the actual frame data starts at bit 16 of the "
        "first word read from the RX FIFO aligning the Ethernet payload on a 32"
        "-bit boundary.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RCMR1.
static const field_t hw_enet_rcmr1[] =
{
    {
        "CMP0",
        "A three-bit value that will be compared with the frame's VLAN priority"
        " field (if a VLAN frame is received).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP1",
        "Second value to compare against.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP2",
        "Third value to compare against.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP3",
        "Fourth value to compare against.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MATCHEN",
        "A comparison is done only on incoming VLAN frames.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RCMR2.
static const field_t hw_enet_rcmr2[] =
{
    {
        "CMP0",
        "A three-bit value that will be compared with the frame's VLAN priority"
        " field (if a VLAN frame is received).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP1",
        "Second value to compare against.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP2",
        "Third value to compare against.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP3",
        "Fourth value to compare against.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MATCHEN",
        "A comparison is done only on incoming VLAN frames.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_DMA1CFG.
static const field_t hw_enet_dma1cfg[] =
{
    {
        "IDLE_SLOPE",
        "16-bit value to define the per class idle slope setting used by the cr"
        "edit based shaper defining allocated bandwidth for the class.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CLASS_EN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CALC_NOIPG",
        "Disable inclusion of IPG bytes for bandwidth calculations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_DMA2CFG.
static const field_t hw_enet_dma2cfg[] =
{
    {
        "IDLE_SLOPE",
        "16-bit value to define the per class idle slope setting used by the cr"
        "edit based shaper defining allocated bandwidth for the class.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_CLASS_EN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CALC_NOIPG",
        "Disable inclusion of IPG bytes for bandwidth calculations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDAR1.
static const field_t hw_enet_rdar1[] =
{
    {
        "RDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDAR1.
static const field_t hw_enet_tdar1[] =
{
    {
        "TDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDAR2.
static const field_t hw_enet_rdar2[] =
{
    {
        "RDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDAR2.
static const field_t hw_enet_tdar2[] =
{
    {
        "TDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_QOS.
static const field_t hw_enet_qos[] =
{
    {
        "TX_SCHEME",
        "Configuration information for DMA to select transmitter queue selectio"
        "n/arbitration scheme.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_FLUSH0",
        "Enable or disable RX Flush for ring 0.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_FLUSH1",
        "Enable or disable RX Flush for ring 1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_FLUSH2",
        "Enable or disable RX Flush for ring 2.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_PACKETS.
static const field_t hw_enet_rmon_t_packets[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_BC_PKT.
static const field_t hw_enet_rmon_t_bc_pkt[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_MC_PKT.
static const field_t hw_enet_rmon_t_mc_pkt[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_CRC_ALIGN.
static const field_t hw_enet_rmon_t_crc_align[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_UNDERSIZE.
static const field_t hw_enet_rmon_t_undersize[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_OVERSIZE.
static const field_t hw_enet_rmon_t_oversize[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_FRAG.
static const field_t hw_enet_rmon_t_frag[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_JAB.
static const field_t hw_enet_rmon_t_jab[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_COL.
static const field_t hw_enet_rmon_t_col[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P64.
static const field_t hw_enet_rmon_t_p64[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P65TO127.
static const field_t hw_enet_rmon_t_p65to127[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P128TO255.
static const field_t hw_enet_rmon_t_p128to255[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P256TO511.
static const field_t hw_enet_rmon_t_p256to511[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P512TO1023.
static const field_t hw_enet_rmon_t_p512to1023[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P1024TO2047.
static const field_t hw_enet_rmon_t_p1024to2047[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P_GTE2048.
static const field_t hw_enet_rmon_t_p_gte2048[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_OCTETS.
static const field_t hw_enet_rmon_t_octets[] =
{
    {
        "TXOCTS",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_FRAME_OK.
static const field_t hw_enet_ieee_t_frame_ok[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_1COL.
static const field_t hw_enet_ieee_t_1col[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_MCOL.
static const field_t hw_enet_ieee_t_mcol[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_DEF.
static const field_t hw_enet_ieee_t_def[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_LCOL.
static const field_t hw_enet_ieee_t_lcol[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_EXCOL.
static const field_t hw_enet_ieee_t_excol[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_MACERR.
static const field_t hw_enet_ieee_t_macerr[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_CSERR.
static const field_t hw_enet_ieee_t_cserr[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_FDXFC.
static const field_t hw_enet_ieee_t_fdxfc[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_OCTETS_OK.
static const field_t hw_enet_ieee_t_octets_ok[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_PACKETS.
static const field_t hw_enet_rmon_r_packets[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_BC_PKT.
static const field_t hw_enet_rmon_r_bc_pkt[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_MC_PKT.
static const field_t hw_enet_rmon_r_mc_pkt[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_CRC_ALIGN.
static const field_t hw_enet_rmon_r_crc_align[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_UNDERSIZE.
static const field_t hw_enet_rmon_r_undersize[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_OVERSIZE.
static const field_t hw_enet_rmon_r_oversize[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_FRAG.
static const field_t hw_enet_rmon_r_frag[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_JAB.
static const field_t hw_enet_rmon_r_jab[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P64.
static const field_t hw_enet_rmon_r_p64[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P65TO127.
static const field_t hw_enet_rmon_r_p65to127[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P128TO255.
static const field_t hw_enet_rmon_r_p128to255[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P256TO511.
static const field_t hw_enet_rmon_r_p256to511[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P512TO1023.
static const field_t hw_enet_rmon_r_p512to1023[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P1024TO2047.
static const field_t hw_enet_rmon_r_p1024to2047[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P_GTE2048.
static const field_t hw_enet_rmon_r_p_gte2048[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_OCTETS.
static const field_t hw_enet_rmon_r_octets[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_DROP.
static const field_t hw_enet_ieee_r_drop[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_FRAME_OK.
static const field_t hw_enet_ieee_r_frame_ok[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_CRC.
static const field_t hw_enet_ieee_r_crc[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_ALIGN.
static const field_t hw_enet_ieee_r_align[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_MACERR.
static const field_t hw_enet_ieee_r_macerr[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_FDXFC.
static const field_t hw_enet_ieee_r_fdxfc[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_OCTETS_OK.
static const field_t hw_enet_ieee_r_octets_ok[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATCR.
static const field_t hw_enet_atcr[] =
{
    {
        "EN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFRST",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEREN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPER",
        "Enables event signal output assertion on period event.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESTART",
        "Resets the timer to zero.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAPTURE",
        "This field automatically clears to 0 after the command completes.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLAVE",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATVR.
static const field_t hw_enet_atvr[] =
{
    {
        "ATIME",
        "A write sets the timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATOFF.
static const field_t hw_enet_atoff[] =
{
    {
        "OFFSET",
        "Offset value for one-shot event generation.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATPER.
static const field_t hw_enet_atper[] =
{
    {
        "PERIOD",
        "Value for generating periodic events.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATCOR.
static const field_t hw_enet_atcor[] =
{
    {
        "COR",
        "Defines after how many timer clock cycles (ts_clk) the correction coun"
        "ter should be reset and trigger a correction increment on the timer.",
        0, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATINC.
static const field_t hw_enet_atinc[] =
{
    {
        "INC",
        "The timer increments by this amount each clock cycle.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_CORR",
        "This value is added every time the correction timer expires (every clo"
        "ck cycle given in ATCOR).",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATSTMP.
static const field_t hw_enet_atstmp[] =
{
    {
        "TIMESTAMP",
        "Timestamp of the last frame transmitted by the core that had TxBD[TS] "
        "set .",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TGSR.
static const field_t hw_enet_tgsr[] =
{
    {
        "TF0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCSR0.
static const field_t hw_enet_tcsr0[] =
{
    {
        "TDRE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMODE",
        "Updating the Timer Mode field takes a few cycles to register because i"
        "t is synchronized to the 1588 clock.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF",
        "Sets when input capture or output compare occurs.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCCR0.
static const field_t hw_enet_tccr0[] =
{
    {
        "TCC",
        "This register is double buffered between the module clock and 1588 clo"
        "ck domains.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCSR1.
static const field_t hw_enet_tcsr1[] =
{
    {
        "TDRE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMODE",
        "Updating the Timer Mode field takes a few cycles to register because i"
        "t is synchronized to the 1588 clock.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF",
        "Sets when input capture or output compare occurs.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCCR1.
static const field_t hw_enet_tccr1[] =
{
    {
        "TCC",
        "This register is double buffered between the module clock and 1588 clo"
        "ck domains.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCSR2.
static const field_t hw_enet_tcsr2[] =
{
    {
        "TDRE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMODE",
        "Updating the Timer Mode field takes a few cycles to register because i"
        "t is synchronized to the 1588 clock.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF",
        "Sets when input capture or output compare occurs.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCCR2.
static const field_t hw_enet_tccr2[] =
{
    {
        "TCC",
        "This register is double buffered between the module clock and 1588 clo"
        "ck domains.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCSR3.
static const field_t hw_enet_tcsr3[] =
{
    {
        "TDRE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMODE",
        "Updating the Timer Mode field takes a few cycles to register because i"
        "t is synchronized to the 1588 clock.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF",
        "Sets when input capture or output compare occurs.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCCR3.
static const field_t hw_enet_tccr3[] =
{
    {
        "TCC",
        "This register is double buffered between the module clock and 1588 clo"
        "ck domains.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ENET module.
static const reg_t hw_enet[] =
{
    {
        "EIR",
        "When an event occurs that sets a bit in EIR, an interrupt occurs if th"
        "e corresponding bit in the interrupt mask register (EIMR) is also set.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_enet_eir
    },
    {
        "EIMR",
        "EIMR controls which interrupt events are allowed to generate actual in"
        "terrupts.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        27, // Number of bitfields
        hw_enet_eimr
    },
    {
        "RDAR",
        "RDAR is a command register, written by the user, to indicate that the "
        "receive descriptor ring 0 has been updated, that is, that the driver p"
        "roduced empty receive buffers with the empty bit set.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdar
    },
    {
        "TDAR",
        "The TDAR is a command register that the user writes to indicate that t"
        "he transmit descriptor ring 0 has been updated, that is, that transmit"
        " buffers have been produced by the driver with the ready bit set in th"
        "e buffer descriptor.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdar
    },
    {
        "ECR",
        "ECR is a read/write user register, though hardware may also alter fiel"
        "ds in this register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_enet_ecr
    },
    {
        "MMFR",
        "Writing to MMFR triggers a management frame transaction to the PHY dev"
        "ice unless MSCR is programmed to zero.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_enet_mmfr
    },
    {
        "MSCR",
        "MSCR provides control of the MII clock (MDC pin) frequency and allows "
        "a preamble drop on the MII management frame.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_mscr
    },
    {
        "MIBC",
        "MIBC is a read/write register controlling and observing the state of t"
        "he MIB block.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_mibc
    },
    {
        "RCR",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_enet_rcr
    },
    {
        "TCR",
        "TCR is read/write and configures the transmit block.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_enet_tcr
    },
    {
        "PALR",
        "PALR contains the lower 32 bits (bytes 0, 1, 2, 3) of the 48-bit addre"
        "ss used in the address recognition process to compare with the destina"
        "tion address (DA) field of receive frames with an individual DA.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_palr
    },
    {
        "PAUR",
        "PAUR contains the upper 16 bits (bytes 4 and 5) of the 48-bit address "
        "used in the address recognition process to compare with the destinatio"
        "n address (DA) field of receive frames with an individual DA.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_paur
    },
    {
        "OPD",
        "OPD is read/write accessible.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_opd
    },
    {
        "TXIC0",
        "See Interrupt coalescence for more information.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_txic0
    },
    {
        "TXIC1",
        "See Interrupt coalescence for more information.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_txic1
    },
    {
        "TXIC2",
        "See Interrupt coalescence for more information.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_txic2
    },
    {
        "RXIC0",
        "See Interrupt coalescence for more information.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_rxic0
    },
    {
        "RXIC1",
        "See Interrupt coalescence for more information.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_rxic1
    },
    {
        "RXIC2",
        "See Interrupt coalescence for more information.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_rxic2
    },
    {
        "IAUR",
        "IAUR contains the upper 32 bits of the 64-bit individual address hash "
        "table.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_iaur
    },
    {
        "IALR",
        "IALR contains the lower 32 bits of the 64-bit individual address hash "
        "table.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_ialr
    },
    {
        "GAUR",
        "GAUR contains the upper 32 bits of the 64-bit hash table used in the a"
        "ddress recognition process for receive frames with a multicast address"
        ".",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_gaur
    },
    {
        "GALR",
        "GALR contains the lower 32 bits of the 64-bit hash table used in the a"
        "ddress recognition process for receive frames with a multicast address"
        ".",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_galr
    },
    {
        "TFWR",
        "If TFWR[STRFWD] is cleared, TFWR[TFWR] controls the amount of data req"
        "uired in the transmit FIFO before transmission of a frame can begin.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_tfwr
    },
    {
        "RDSR1",
        "RDSR1 points to the beginning of circular receive buffer descriptor qu"
        "eue 1 in external memory.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdsr1
    },
    {
        "TDSR1",
        "TDSR1 provides a pointer to the beginning of the circular transmit buf"
        "fer descriptor queue 1 in external memory.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdsr1
    },
    {
        "MRBR1",
        "MRBR1 is a user-programmable register that dictates the maximum size o"
        "f all ring-1 receive buffers.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_mrbr1
    },
    {
        "RDSR2",
        "RDSR points to the beginning of circular receive buffer descriptor que"
        "ue 2 in external memory.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdsr2
    },
    {
        "TDSR2",
        "TDSR2 provides a pointer to the beginning of circular transmit buffer "
        "descriptor queue 2 in external memory.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdsr2
    },
    {
        "MRBR2",
        "MRBR2 is a user-programmable register that dictates the maximum size o"
        "f all ring-2 receive buffers.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_mrbr2
    },
    {
        "RDSR",
        "RDSR points to the beginning of the circular receive buffer descriptor"
        " queue in external memory.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdsr
    },
    {
        "TDSR",
        "TDSR provides a pointer to the beginning of the circular transmit buff"
        "er descriptor queue 0 in external memory.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdsr
    },
    {
        "MRBR",
        "The MRBR is a user-programmable register that dictates the maximum siz"
        "e of all ring-0 receive buffers.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_mrbr
    },
    {
        "RSFL",
        "",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rsfl
    },
    {
        "RSEM",
        "",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_rsem
    },
    {
        "RAEM",
        "",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_raem
    },
    {
        "RAFL",
        "",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rafl
    },
    {
        "TSEM",
        "",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tsem
    },
    {
        "TAEM",
        "",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_taem
    },
    {
        "TAFL",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tafl
    },
    {
        "TIPG",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tipg
    },
    {
        "FTRL",
        "",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_ftrl
    },
    {
        "TACC",
        "TACC controls accelerator actions when sending frames.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_tacc
    },
    {
        "RACC",
        "",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_racc
    },
    {
        "RCMR1",
        "This match register allows specifying up to four priorities, which are"
        " tested (OR'ed) simultaneously.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_rcmr1
    },
    {
        "RCMR2",
        "This match register allows specifying up to four priorities, which are"
        " tested (OR'ed) simultaneously.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_rcmr2
    },
    {
        "DMA1CFG",
        "The DMA class based configuration registers are used to configure the "
        "DMA controller interface to support the additional class 1 (buffer des"
        "criptor ring 1) and class 2 (buffer descriptor ring 2) traffic and def"
        "ine configuration options such as bandwidth allocation as needed.",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_dma1cfg
    },
    {
        "DMA2CFG",
        "The DMA class based configuration registers are used to configure the "
        "DMA controller interface to support the additional class 1 (buffer des"
        "criptor ring 1) and class 2 (buffer descriptor ring 2) traffic and def"
        "ine configuration options such as bandwidth allocation as needed.",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_dma2cfg
    },
    {
        "RDAR1",
        "RDAR1 is a command register, written by the user, to indicate that the"
        " receive descriptor ring 1 has been updated, that is, that the driver "
        "produced empty receive buffers with the empty bit set.",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdar1
    },
    {
        "TDAR1",
        "TDAR1 is a command register that the user writes to indicate that tran"
        "smit descriptor ring 1 has been updated, that is, that transmit buffer"
        "s have been produced by the driver with the ready bit set in the buffe"
        "r descriptor.",
        4, // Width in bytes
        0x000001e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdar1
    },
    {
        "RDAR2",
        "RDAR2 is a command register, written by the user, to indicate that the"
        " receive descriptor ring 2 has been updated, that is, that the driver "
        "produced empty receive buffers with the empty bit set.",
        4, // Width in bytes
        0x000001e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdar2
    },
    {
        "TDAR2",
        "TDAR2 is a command register that the user writes to indicate that tran"
        "smit descriptor ring 2 has been updated, that is, that transmit buffer"
        "s have been produced by the driver with the ready bit set in the buffe"
        "r descriptor.",
        4, // Width in bytes
        0x000001ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdar2
    },
    {
        "QOS",
        "This register sets the QOS scheme.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_qos
    },
    {
        "RMON_T_PACKETS",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_packets
    },
    {
        "RMON_T_BC_PKT",
        "RMON Tx Broadcast Packets",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_bc_pkt
    },
    {
        "RMON_T_MC_PKT",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_mc_pkt
    },
    {
        "RMON_T_CRC_ALIGN",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_crc_align
    },
    {
        "RMON_T_UNDERSIZE",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_undersize
    },
    {
        "RMON_T_OVERSIZE",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_oversize
    },
    {
        "RMON_T_FRAG",
        ".",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_frag
    },
    {
        "RMON_T_JAB",
        "",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_jab
    },
    {
        "RMON_T_COL",
        "",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_col
    },
    {
        "RMON_T_P64",
        ".",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p64
    },
    {
        "RMON_T_P65TO127",
        "",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p65to127
    },
    {
        "RMON_T_P128TO255",
        "",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p128to255
    },
    {
        "RMON_T_P256TO511",
        "",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p256to511
    },
    {
        "RMON_T_P512TO1023",
        ".",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p512to1023
    },
    {
        "RMON_T_P1024TO2047",
        "",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p1024to2047
    },
    {
        "RMON_T_P_GTE2048",
        "",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p_gte2048
    },
    {
        "RMON_T_OCTETS",
        "",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_octets
    },
    {
        "IEEE_T_FRAME_OK",
        "",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_frame_ok
    },
    {
        "IEEE_T_1COL",
        "",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_1col
    },
    {
        "IEEE_T_MCOL",
        "",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_mcol
    },
    {
        "IEEE_T_DEF",
        "",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_def
    },
    {
        "IEEE_T_LCOL",
        "",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_lcol
    },
    {
        "IEEE_T_EXCOL",
        "",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_excol
    },
    {
        "IEEE_T_MACERR",
        "",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_macerr
    },
    {
        "IEEE_T_CSERR",
        "",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_cserr
    },
    {
        "IEEE_T_FDXFC",
        "",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_fdxfc
    },
    {
        "IEEE_T_OCTETS_OK",
        "Counts total octets (includes header and FCS fields).",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_octets_ok
    },
    {
        "RMON_R_PACKETS",
        "",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_packets
    },
    {
        "RMON_R_BC_PKT",
        "",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_bc_pkt
    },
    {
        "RMON_R_MC_PKT",
        "",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_mc_pkt
    },
    {
        "RMON_R_CRC_ALIGN",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_crc_align
    },
    {
        "RMON_R_UNDERSIZE",
        "",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_undersize
    },
    {
        "RMON_R_OVERSIZE",
        "",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_oversize
    },
    {
        "RMON_R_FRAG",
        "",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_frag
    },
    {
        "RMON_R_JAB",
        "",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_jab
    },
    {
        "RMON_R_P64",
        "",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p64
    },
    {
        "RMON_R_P65TO127",
        "",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p65to127
    },
    {
        "RMON_R_P128TO255",
        "",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p128to255
    },
    {
        "RMON_R_P256TO511",
        "",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p256to511
    },
    {
        "RMON_R_P512TO1023",
        "",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p512to1023
    },
    {
        "RMON_R_P1024TO2047",
        "",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p1024to2047
    },
    {
        "RMON_R_P_GTE2048",
        "",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p_gte2048
    },
    {
        "RMON_R_OCTETS",
        "",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_octets
    },
    {
        "IEEE_R_DROP",
        "Counter increments if a frame with invalid or missing SFD character is"
        " detected and has been dropped.",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_drop
    },
    {
        "IEEE_R_FRAME_OK",
        "",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_frame_ok
    },
    {
        "IEEE_R_CRC",
        "",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_crc
    },
    {
        "IEEE_R_ALIGN",
        "",
        4, // Width in bytes
        0x000002d4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_align
    },
    {
        "IEEE_R_MACERR",
        "",
        4, // Width in bytes
        0x000002d8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_macerr
    },
    {
        "IEEE_R_FDXFC",
        "",
        4, // Width in bytes
        0x000002dc, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_fdxfc
    },
    {
        "IEEE_R_OCTETS_OK",
        "",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_octets_ok
    },
    {
        "ATCR",
        "ATCR command fields can trigger the corresponding events directly.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_enet_atcr
    },
    {
        "ATVR",
        "",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atvr
    },
    {
        "ATOFF",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atoff
    },
    {
        "ATPER",
        "",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atper
    },
    {
        "ATCOR",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atcor
    },
    {
        "ATINC",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_atinc
    },
    {
        "ATSTMP",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_atstmp
    },
    {
        "TGSR",
        "",
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_tgsr
    },
    {
        "TCSR0",
        "",
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_tcsr0
    },
    {
        "TCCR0",
        "",
        4, // Width in bytes
        0x0000060c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tccr0
    },
    {
        "TCSR1",
        "",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_tcsr1
    },
    {
        "TCCR1",
        "",
        4, // Width in bytes
        0x00000614, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tccr1
    },
    {
        "TCSR2",
        "",
        4, // Width in bytes
        0x00000618, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_tcsr2
    },
    {
        "TCCR2",
        "",
        4, // Width in bytes
        0x0000061c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tccr2
    },
    {
        "TCSR3",
        "",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_tcsr3
    },
    {
        "TCCR3",
        "",
        4, // Width in bytes
        0x00000624, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tccr3
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EPIT
#endif

// Bitfields in register EPIT_CR.
static const field_t hw_epit_cr[] =
{
    {
        "EN",
        "This bit enables the EPIT.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENMOD",
        "EPIT enable mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCIEN",
        "Output compare interrupt enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RLD",
        "Counter reload control.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALAR",
        "Counter clock prescaler value.",
        4, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software reset.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IOVW",
        "EPIT counter overwrite enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "This bit is used to keep the EPIT functional in debug mode.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "This read/write control bit enables the operation of the EPIT during w"
        "ait mode.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "EPIT stop mode enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM",
        "EPIT output mode.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Select clock source These bits determine which clock input is to be se"
        "lected for running the counter.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_SR.
static const field_t hw_epit_sr[] =
{
    {
        "OCIF",
        "Output compare interrupt flag.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_LR.
static const field_t hw_epit_lr[] =
{
    {
        "LOAD",
        "Load value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_CMPR.
static const field_t hw_epit_cmpr[] =
{
    {
        "COMPARE",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_CNR.
static const field_t hw_epit_cnr[] =
{
    {
        "COUNT",
        "Counter value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a EPIT module.
static const reg_t hw_epit[] =
{
    {
        "CR",
        "The EPIT control register (EPIT_CR) is used to configure the operating"
        " settings of the EPIT.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_epit_cr
    },
    {
        "SR",
        "The EPIT status register (EPIT_SR) has a single status bit for the out"
        "put compare event.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_sr
    },
    {
        "LR",
        "The EPIT load register (EPIT_LR) contains the value that is to be load"
        "ed into the counter when EPIT counter reaches zero if the RLD bit in E"
        "PIT_CR is set.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_lr
    },
    {
        "CMPR",
        "The EPIT compare register (EPIT_CMPR) holds the value that determines "
        "when a compare event is generated.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_cmpr
    },
    {
        "CNR",
        "The EPIT counter register (EPIT_CNR) contains the current count value "
        "and can be read at any time without disturbing the counter.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_epit_cnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ESAI
#endif

// Bitfields in register ESAI_ETDR.
static const field_t hw_esai_etdr[] =
{
    {
        "ETDR",
        "ESAI Transmit Data Register.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_ERDR.
static const field_t hw_esai_erdr[] =
{
    {
        "ERDR",
        "ESAI Receive Data Register.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_ECR.
static const field_t hw_esai_ecr[] =
{
    {
        "ESAIEN",
        "ESAI Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERST",
        "ESAI Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERO",
        "EXTAL Receiver Out.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERI",
        "EXTAL Receiver In.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETO",
        "EXTAL Transmitter Out.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETI",
        "EXTAL Transmitter In.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_ESR.
static const field_t hw_esai_esr[] =
{
    {
        "RD",
        "Receive Data.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RED",
        "Receive Even Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDE",
        "Receive Data Exception.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RLS",
        "Receive Last Slot.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TD",
        "Transmit Data.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TED",
        "Transmit Even Data.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDE",
        "Transmit Data Exception.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TLS",
        "Transmit Last Slot.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFE",
        "Transmit FIFO Empty.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFF",
        "Receive FIFO Full.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TINIT",
        "Transmit Initialization.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TFCR.
static const field_t hw_esai_tfcr[] =
{
    {
        "TFE",
        "Transmit FIFO Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFR",
        "Transmit FIFO Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE0",
        "Transmitter #0 FIFO Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE1",
        "Transmitter #1 FIFO Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE2",
        "Transmitter #2 FIFO Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE3",
        "Transmitter #3 FIFO Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE4",
        "Transmitter #4 FIFO Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE5",
        "Transmitter #5 FIFO Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFWM",
        "Transmit FIFO Watermark.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWA",
        "Transmit Word Alignment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIEN",
        "Transmitter Initialization Enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TFSR.
static const field_t hw_esai_tfsr[] =
{
    {
        "TFCNT",
        "Transmit FIFO Counter.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NTFI",
        "Next Transmitter FIFO In.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NTFO",
        "Next Transmitter FIFO Out.",
        12, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RFCR.
static const field_t hw_esai_rfcr[] =
{
    {
        "RFE",
        "Receive FIFO Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFR",
        "Receive FIFO Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE0",
        "Receiver #0 FIFO Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE1",
        "Receiver #1 FIFO Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE2",
        "Receiver #2 FIFO Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE3",
        "Receiver #3 FIFO Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFWM",
        "Receive FIFO Watermark.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWA",
        "Receive Word Alignment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REXT",
        "Receive Extension.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RFSR.
static const field_t hw_esai_rfsr[] =
{
    {
        "RFCNT",
        "Receive FIFO Counter.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NRFO",
        "Next Receiver FIFO Out.",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NRFI",
        "Next Receiver FIFO In.",
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX0.
static const field_t hw_esai_tx0[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX1.
static const field_t hw_esai_tx1[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX2.
static const field_t hw_esai_tx2[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX3.
static const field_t hw_esai_tx3[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX4.
static const field_t hw_esai_tx4[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TX5.
static const field_t hw_esai_tx5[] =
{
    {
        "TXN",
        "Stores the data to be transmitted and is automatically transferred to "
        "the transmit shift registers.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TSR.
static const field_t hw_esai_tsr[] =
{
    {
        "TSR",
        "The write-only Transmit Slot Register (ESAI_TSR) is effectively a null"
        " data register that is used when the data is not to be transmitted in "
        "the available transmit time slot.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RX0.
static const field_t hw_esai_rx0[] =
{
    {
        "RXN",
        "Accept data from the receive shift registers when they become full See"
        " ESAI Receive Shift Registers",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RX1.
static const field_t hw_esai_rx1[] =
{
    {
        "RXN",
        "Accept data from the receive shift registers when they become full See"
        " ESAI Receive Shift Registers",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RX2.
static const field_t hw_esai_rx2[] =
{
    {
        "RXN",
        "Accept data from the receive shift registers when they become full See"
        " ESAI Receive Shift Registers",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RX3.
static const field_t hw_esai_rx3[] =
{
    {
        "RXN",
        "Accept data from the receive shift registers when they become full See"
        " ESAI Receive Shift Registers",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_SAISR.
static const field_t hw_esai_saisr[] =
{
    {
        "IF0",
        "ESAI_SAISR Serial Input Flag 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IF1",
        "ESAI_SAISR Serial Inout Flag 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IF2",
        "ESAI_SAISR Serial Input Flag 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFS",
        "ESAI_SAISR Receive Frame Sync Flag.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROE",
        "ESAI_SAISR Receive Overrun Error Flag.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDF",
        "ESAI_SAISR Receive Data Register Full.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REDF",
        "ESAI_SAISR Receive Even-Data Register Full.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RODF",
        "ESAI_SAISR Receive Odd-Data Register Full.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFS",
        "ESAI_SAISR Transmit Frame Sync Flag.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TUE",
        "ESAI_SAISR Transmit Underrun Error Flag.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDE",
        "ESAI_SAISR Transmit Data Register Empty.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEDE",
        "ESAI_SAISR Transmit Even-DataRegister Empty.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TODFE",
        "ESAI_SAISR Transmit Odd-Data Register Empty.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_SAICR.
static const field_t hw_esai_saicr[] =
{
    {
        "OF0",
        "ESAI_SAICR Serial Output Flag 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF1",
        "ESAI_SAICR Serial Output Flag 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2",
        "ESAI_SAICR Serial Output Flag 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYN",
        "ESAI_SAICR Synchronous Mode Selection.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEBE",
        "ESAI_SAICR Transmit External Buffer Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALC",
        "ESAI_SAICR Alignment Control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TCR.
static const field_t hw_esai_tcr[] =
{
    {
        "TE0",
        "ESAI_TCR ESAI Transmit 0 Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE1",
        "ESAI_TCR ESAI Transmit 1 Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE2",
        "ESAI_TCR ESAI Transmit 2 Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE3",
        "ESAI_TCR ESAI Transmit 3 Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE4",
        "ESAI_TCR ESAI Transmit 4 Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE5",
        "ESAI_TCR ESAI Transmit 5 Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSHFD",
        "ESAI_TCR Transmit Shift Direction.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWA",
        "ESAI_TCR Transmit Word Alignment Control.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMOD",
        "ESAI_TCR Transmit Network Mode Control (TMOD1-TMOD0).",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSWS",
        "ESAI_TCR Tx Slot and Word Length Select (TSWS4-TSWS0).",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSL",
        "ESAI_TCR Transmit Frame Sync Length.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSR",
        "ESAI_TCR Transmit Frame Sync Relative Timing.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PADC",
        "ESAI_TCR Transmit Zero Padding Control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPR",
        "ESAI_TCR Transmit Section Personal Reset.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEIE",
        "ESAI_TCR Transmit Exception Interrupt Enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEDIE",
        "ESAI_TCR Transmit Even Slot Data Interrupt Enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "ESAI_TCR Transmit Interrupt Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TLIE",
        "ESAI_TCR Transmit Last Slot Interrupt Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TCCR.
static const field_t hw_esai_tccr[] =
{
    {
        "TPM",
        "ESAI_TCCR Transmit Prescale Modulus Select.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPSR",
        "ESAI_TCCR Transmit Prescaler Range.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDC",
        "ESAI_TCCR Tx Frame Rate Divider Control.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFP",
        "ESAI_TCCR Tx High Frequency Clock Divider.",
        14, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKP",
        "ESAI_TCCR Transmit Clock Polarity.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSP",
        "ESAI_TCCR Transmit Frame Sync Polarity.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "THCKP",
        "ESAI_TCCR Transmit High Frequency Clock Polarity The Transmitter High "
        "Frequency Clock Polarity (THCKP) bit controls the polarity of the HCKT"
        ".",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKD",
        "ESAI_TCCR Transmit Clock Source Direction.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSD",
        "ESAI_TCCR Transmit Frame Sync Signal Direction.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "THCKD",
        "ESAI_TCCR Transmit High Frequency Clock Direction.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RCR.
static const field_t hw_esai_rcr[] =
{
    {
        "RE0",
        "ESAI_RCR ESAI Receiver 0 Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE1",
        "ESAI_RCR ESAI Receiver 1 Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE2",
        "ESAI_RCR ESAI Receiver 2 Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE3",
        "ESAI_RCR ESAI Receiver 3 Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSHFD",
        "ESAI_RCR Receiver Shift Direction.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWA",
        "ESAI_RCR Receiver Word Alignment Control.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RMOD",
        "ESAI_RCR Receiver Network Mode Control.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSWS",
        "ESAI_RCR Receiver Slot and Word Select.",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSL",
        "ESAI_RCR Receiver Frame Sync Length.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSR",
        "ESAI_RCR Receiver Frame Sync Relative Timing.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RPR",
        "ESAI_RCR Receiver Section Personal Reset.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REIE",
        "ESAI_RCR Receive Exception Interrupt Enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REDIE",
        "ESAI_RCR Receive Even Slot Data Interrupt Enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "ESAI_RCR Receive Interrupt Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RLIE",
        "ESAI_RCR Receive Last Slot Interrupt Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RCCR.
static const field_t hw_esai_rccr[] =
{
    {
        "RPM",
        "ESAI_RCCR Receiver Prescale Modulus Select.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RPSR",
        "ESAI_RCCR Receiver Prescaler Range.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDC",
        "ESAI_RCCR Rx Frame Rate Divider Control.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFP",
        "ESAI_RCCR Rx High Frequency Clock Divider.",
        14, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCKP",
        "The Receiver Clock Polarity (RCKP) bit controls on which bit clock edg"
        "e data and frame sync are clocked out and latched in.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSP",
        "ESAI_RCCR Receiver Frame Sync Polarity.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RHCKP",
        "ESAI_RCCR Receiver High Frequency Clock Polarity.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCKD",
        "ESAI_RCCR Receiver Clock Source Direction.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSD",
        "ESAI_RCCR Receiver Frame Sync Signal Direction.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RHCKD",
        "ESAI_RCCR Receiver High Frequency Clock Direction.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TSMA.
static const field_t hw_esai_tsma[] =
{
    {
        "TS",
        "When bit number N in ESAI_TSMA is cleared, all the transmit data pins "
        "of the enabled transmitters are tri-stated during transmit time slot n"
        "umber N.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_TSMB.
static const field_t hw_esai_tsmb[] =
{
    {
        "TS",
        "When bit number N in ESAI_TSMB is cleared, all the transmit data pins "
        "of the enabled transmitters are tri-stated during transmit time slot n"
        "umber N.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RSMA.
static const field_t hw_esai_rsma[] =
{
    {
        "RS",
        "When bit number N in the ESAI_RSMA register is cleared, the data from "
        "the enabled receivers input pins are shifted into their receive shift "
        "registers during slot number N.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_RSMB.
static const field_t hw_esai_rsmb[] =
{
    {
        "RS",
        "When bit number N in the ESAI_RSMB register is cleared, the data from "
        "the enabled receivers input pins are shifted into their receive shift "
        "registers during slot number N.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_PRRC.
static const field_t hw_esai_prrc[] =
{
    {
        "PDC",
        "See .",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ESAI_PCRC.
static const field_t hw_esai_pcrc[] =
{
    {
        "PC",
        "See .",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ESAI module.
static const reg_t hw_esai[] =
{
    {
        "ETDR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_etdr
    },
    {
        "ERDR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_erdr
    },
    {
        "ECR",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_esai_ecr
    },
    {
        "ESR",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        11, // Number of bitfields
        hw_esai_esr
    },
    {
        "TFCR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_esai_tfcr
    },
    {
        "TFSR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_esai_tfsr
    },
    {
        "RFCR",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_esai_rfcr
    },
    {
        "RFSR",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_esai_rfsr
    },
    {
        "TX0",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000080, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx0
    },
    {
        "TX1",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000084, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx1
    },
    {
        "TX2",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000088, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx2
    },
    {
        "TX3",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx3
    },
    {
        "TX4",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000090, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx4
    },
    {
        "TX5",
        "ESAI_TX5, ESAI_TX4, ESAI_TX3, ESAI_TX2, ESAI_TX1 and ESAI_TX0 are 32-b"
        "it write-only registers.",
        4, // Width in bytes
        0x00000094, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tx5
    },
    {
        "TSR",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tsr
    },
    {
        "RX0",
        "ESAI_RX3, ESAI_RX2, ESAI_RX1, and ESAI_RX0 are 32-bit read-only regist"
        "ers that accept data from the receive shift registers when they become"
        " full ( and ).",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_rx0
    },
    {
        "RX1",
        "ESAI_RX3, ESAI_RX2, ESAI_RX1, and ESAI_RX0 are 32-bit read-only regist"
        "ers that accept data from the receive shift registers when they become"
        " full ( and ).",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_rx1
    },
    {
        "RX2",
        "ESAI_RX3, ESAI_RX2, ESAI_RX1, and ESAI_RX0 are 32-bit read-only regist"
        "ers that accept data from the receive shift registers when they become"
        " full ( and ).",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_rx2
    },
    {
        "RX3",
        "ESAI_RX3, ESAI_RX2, ESAI_RX1, and ESAI_RX0 are 32-bit read-only regist"
        "ers that accept data from the receive shift registers when they become"
        " full ( and ).",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_esai_rx3
    },
    {
        "SAISR",
        "The Status Register (ESAI_SAISR) is a read-only status register used b"
        "y the ARM Core to read the status and serial input flags of the ESAI.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        false, // Writable
        13, // Number of bitfields
        hw_esai_saisr
    },
    {
        "SAICR",
        "The read/write Common Control Register (ESAI_SAICR) contains control b"
        "its for functions that affect both the receive and transmit sections o"
        "f the ESAI.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_esai_saicr
    },
    {
        "TCR",
        "The read/write Transmit Control Register (ESAI_TCR) controls the ESAI "
        "transmitter section.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_esai_tcr
    },
    {
        "TCCR",
        "The read/write Transmitter Clock Control Register (ESAI_TCCR) controls"
        " the ESAI transmitter clock generator bit and frame sync rates, the bi"
        "t clock and high frequency clock sources and the directions of the HCK"
        "T, FST and SCKT signals.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_esai_tccr
    },
    {
        "RCR",
        "The read/write Receive Control Register (ESAI_RCR) controls the ESAI r"
        "eceiver section.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_esai_rcr
    },
    {
        "RCCR",
        "The read/write Receiver Clock Control Register (ESAI_RCCR) controls th"
        "e ESAI receiver clock generator bit and frame sync rates, word length,"
        " and number of words per frame for the serial data.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_esai_rccr
    },
    {
        "TSMA",
        "The Transmit Slot Mask Register A together with Transmit Slot Mask Reg"
        "ister B (ESAI_TSMA and ESAI_TSMB) are two read/write registers used by"
        " the transmitters in network mode to determine for each slot whether t"
        "o transmit a data word and generate a transmitter empty condition (TDE"
        "=1), or to tri-state the transmitter data pins.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tsma
    },
    {
        "TSMB",
        "The Transmit Slot Mask Register B together with Transmit Slot Mask Reg"
        "ister A (ESAI_TSMA and ESAI_TSMB) are two read/write registers used by"
        " the transmitters in network mode to determine for each slot whether t"
        "o transmit a data word and generate a transmitter empty condition (TDE"
        "=1), or to tri-state the transmitter data pins.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_tsmb
    },
    {
        "RSMA",
        "The Receive Slot Mask Register A together with Receive Slot Mask Regis"
        "ter B (ESAI_RSMA and ESAI_RSMB) are two read/write registers used by t"
        "he receiver in network mode to determine for each slot whether to rece"
        "ive a data word and generate a receiver full condition (RDF=1), or to "
        "ignore the received data.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_rsma
    },
    {
        "RSMB",
        "The Receive Slot Mask Register B together with Receive Slot Mask Regis"
        "ter A (ESAI_RSMA and ESAI_RSMB) are two read/write registers used by t"
        "he receiver in network mode to determine for each slot whether to rece"
        "ive a data word and generate a receiver full condition (RDF=1), or to "
        "ignore the received data.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_rsmb
    },
    {
        "PRRC",
        "There are two registers to control the ESAI personal reset status: Por"
        "t C Direction Register (ESAI_PRRC) and Port C Control Register (ESAI_P"
        "CRC).",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_prrc
    },
    {
        "PCRC",
        "The read/write 32-bit Port C Control Register (ESAI_PCRC) in conjuncti"
        "on with the Port C Direction Register (ESAI_PRRC) controls the functio"
        "nality of the ESAI personal reset state.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_esai_pcrc
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark FLEXCAN
#endif

// Bitfields in register FLEXCAN_MCR.
static const field_t hw_flexcan_mcr[] =
{
    {
        "MAXMB",
        "This 7-bit field defines the number of the last Message Buffers that w"
        "ill take part in the matching and arbitration processes.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDAM",
        "This 2-bit field identifies the format of the elements of the Rx FIFO "
        "filter table, as shown below.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AEN",
        "This bit is supplied for backwards compatibility reasons.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPRIO_EN",
        "This bit is provided for backwards compatibility reasons.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRMQ",
        "This bit indicates whether Rx matching process will be based either on"
        " individual masking and queue or on masking scheme with RXMGMASK, RX14"
        "MASK and RX15MASK, RXFGMASK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRX_DIS",
        "This bit defines whether FlexCAN is allowed to receive frames transmit"
        "ted by itself.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAK_SRC",
        "This bit defines whether the integrated low-pass filter is applied to "
        "protect the FLEXCAN_RX input from spurious wake up.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPM_ACK",
        "This read-only bit indicates that FLEXCAN is either in Disable Mode or"
        " Stop Mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WRN_EN",
        "When asserted, this bit enables the generation of the TWRN_INT and RWR"
        "N_INT flags in the Error and Status Register.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLF_WAK",
        "This bit enables the Self Wake Up feature when FLEXCAN is in Stop Mode"
        ".",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUPV",
        "This bit configures some of the FLEXCAN registers to be either in Supe"
        "rvisor or User Mode.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRZ_ACK",
        "This read-only bit indicates that FLEXCAN is in Freeze Mode and its pr"
        "escaler is stopped.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOFT_RST",
        "When this bit is asserted, FlexCAN resets its internal state machines "
        "and some of the memory mapped registers.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAK_MSK",
        "This bit enables the Wake Up Interrupt generation.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NOT_RDY",
        "This read-only bit indicates that FLEXCAN is either in Disable Mode, S"
        "top Mode or Freeze Mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALT",
        "Assertion of this bit puts the FLEXCAN module into Freeze Mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN",
        "This bit controls whether the Rx FIFO feature is enabled or not.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRZ",
        "The FRZ bit specifies the FLEXCAN behavior when the HALT bit in the MC"
        "R Register is set or when Debug Mode is requested at ARM level.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDIS",
        "This bit controls whether FLEXCAN is enabled or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_CTRL1.
static const field_t hw_flexcan_ctrl1[] =
{
    {
        "PROP_SEG",
        "This 3-bit field defines the length of the Propagation Segment in the "
        "bit time.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOM",
        "This bit configures FLEXCAN to operate in Listen Only Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBUF",
        "This bit defines the ordering mechanism for Message Buffer transmissio"
        "n.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSYN",
        "This bit enables a mechanism that resets the free-running timer each t"
        "ime a message is received in Message Buffer 0.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_REC",
        "This bit defines how FLEXCAN recovers from Bus Off state.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP",
        "This bit defines the sampling mode of CAN bits at the FLEXCAN_RX.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWRN_MSK",
        "This bit provides a mask for the Rx Warning Interrupt associated with "
        "the RWRN_INT flag in the Error and Status Register.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWRN_MSK",
        "This bit provides a mask for the Tx Warning Interrupt associated with "
        "the TWRN_INT flag in the Error and Status Register.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPB",
        "This bit configures FlexCAN to operate in Loop-Back Mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR_MSK",
        "This bit provides a mask for the Error Interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_MSK",
        "This bit provides a mask for the Bus Off Interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSEG2",
        "This 3-bit field defines the length of Phase Buffer Segment 2 in the b"
        "it time.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSEG1",
        "This 3-bit field defines the length of Phase Buffer Segment 1 in the b"
        "it time.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RJW",
        "This 2-bit field defines the maximum number of time quanta One time qu"
        "antum is equal to the Sclock period.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESDIV",
        "This 8-bit field defines the ratio between the PE clock frequency and "
        "the Serial Clock (Sclock) frequency.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_TIMER.
static const field_t hw_flexcan_timer[] =
{
    {
        "TIMER",
        "TIMER",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXMGMASK.
static const field_t hw_flexcan_rxmgmask[] =
{
    {
        "MG31_MG0",
        "These bits mask the Mailbox filter bits as shown in the figure above.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RX14MASK.
static const field_t hw_flexcan_rx14mask[] =
{
    {
        "RX14M31_RX14M0",
        "These bits mask Mailbox 14 filter bits in the same fashion as RXMGMASK"
        " masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask R"
        "egister )",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RX15MASK.
static const field_t hw_flexcan_rx15mask[] =
{
    {
        "RX15M31_RX15M0",
        "These bits mask Mailbox 15 filter bits in the same fashion as RXMGMASK"
        " masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask R"
        "egister ).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_ECR.
static const field_t hw_flexcan_ecr[] =
{
    {
        "TX_ERR_COUNTER",
        "Tx_Err_Counter",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_ERR_COUNTER",
        "Rx_Err_Counter",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_ESR1.
static const field_t hw_flexcan_esr1[] =
{
    {
        "WAK_INT",
        "When FLEXCAN is Stop Mode and a recessive to dominant transition is de"
        "tected on the CAN bus and if the WAK_MSK bit in the MCR Register is se"
        "t, an interrupt is generated to the ARM.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR_INT",
        "This bit indicates that at least one of the Error Bits (bits 15-10) is"
        " set.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_INT",
        "This bit is set when FLEXCAN enters 'Bus Off' state.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX",
        "This bit indicates if FlexCAN is receiving a message.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FLT_CONF",
        "If the LOM bit in the Control Register is asserted, after some delay t"
        "hat depends on the CAN bit timing the FLT_CONF field will indicate \"E"
        "rror Passive\".",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX",
        "This bit indicates if FLEXCAN is transmitting a message.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE",
        "This bit indicates when CAN bus is in IDLE state.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_WRN",
        "This bit indicates when repetitive errors are occurring during message"
        " reception.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_WRN",
        "This bit indicates when repetitive errors are occurring during message"
        " transmission.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STF_ERR",
        "This bit indicates that a Stuffing Error has been detected.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRM_ERR",
        "This bit indicates that a Form Error has been detected by the receiver"
        " node, i.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CRC_ERR",
        "This bit indicates that a CRC Error has been detected by the receiver "
        "node, i.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ACK_ERR",
        "This bit indicates that an Acknowledge Error has been detected by the "
        "transmitter node, i.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BIT0_ERR",
        "This bit indicates when an inconsistency occurs between the transmitte"
        "d and the received bit in a message.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BIT1_ERR",
        "This bit indicates when an inconsistency occurs between the transmitte"
        "d and the received bit in a message.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RWRN_INT",
        "If the WRN_EN bit in MCR is asserted, the RWRN_INT bit is set when the"
        " RX_WRN flag transition from '0' to '1', meaning that the Rx error cou"
        "nters reached 96.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWRN_INT",
        "If the WRN_EN bit in MCR is asserted, the TWRN_INT bit is set when the"
        " TX_WRN flag transition from '0' to '1', meaning that the Tx error cou"
        "nter reached 96.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNCH",
        "This read-only flag indicates whether the FlexCAN is synchronized to t"
        "he CAN bus and able to participate in the communication process.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IMASK2.
static const field_t hw_flexcan_imask2[] =
{
    {
        "BUF63M_BUF32M",
        "Each bit enables or disables the respective FLEXCAN Message Buffer (MB"
        "32 to MB63) Interrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IMASK1.
static const field_t hw_flexcan_imask1[] =
{
    {
        "BUF31M_BUF0M",
        "Each bit enables or disables the respective FLEXCAN Message Buffer (MB"
        "0 to MB31) Interrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IFLAG2.
static const field_t hw_flexcan_iflag2[] =
{
    {
        "BUF63I_BUF32I",
        "Each bit flags the respective FLEXCAN Message Buffer (MB32 to MB63) in"
        "terrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IFLAG1.
static const field_t hw_flexcan_iflag1[] =
{
    {
        "BUF4I_BUF0I",
        "If the Rx FIFO is not enabled, these bits flag the interrupts for MB0 "
        "to MB4.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF5I",
        "If the Rx FIFO is not enabled, this bit flags the interrupt for MB5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF6I",
        "If the Rx FIFO is not enabled, this bit flags the interrupt for MB6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF7I",
        "If the Rx FIFO is not enabled, this bit flags the interrupt for MB7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF31I_BUF8I",
        "Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) int"
        "errupt.",
        8, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_CTRL2.
static const field_t hw_flexcan_ctrl2[] =
{
    {
        "EACEN",
        "This bit controls the comparison of IDE and RTR bits within Rx Mailbox"
        "es filters with their corresponding bits in the incoming frame by the "
        "matching process.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRS",
        "If this bit is asserted Remote Request Frame is submitted to a matchin"
        "g process and stored in the corresponding Message Buffer in the same f"
        "ashion of a Data Frame.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRP",
        "If this bit is set the matching process starts from the Mailboxes and "
        "if no match occurs the matching continues on the Rx FIFO.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TASD",
        "This 5-bit field indicates how many CAN bits the Tx arbitration proces"
        "s start point can be delayed from the first bit of CRC field on CAN bu"
        "s.",
        19, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN",
        "This 4-bit field defines the number of Rx FIFO filters according to .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRMFRZ",
        "Enable unrestricted write access to FlexCAN memory in Freeze mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_ESR2.
static const field_t hw_flexcan_esr2[] =
{
    {
        "IMB",
        "If ESR2[VPS] is asserted, this bit indicates whether there is any inac"
        "tive Mailbox (CODE field is either 0b1000 or 0b0000).",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VPS",
        "This bit indicates whether IMB and LPTM contents are currently valid o"
        "r not.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LPTM",
        "If ESR2[VPS] is asserted, his 7-bit field indicates the lowest number "
        "inactive Mailbox (refer to IMB bit description).",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_CRCR.
static const field_t hw_flexcan_crcr[] =
{
    {
        "TXCRC",
        "This field indicates the CRC value of the last message transmitted.",
        0, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MBCRC",
        "This field indicates the number of the Mailbox corresponding to the va"
        "lue in TXCRC field.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXFGMASK.
static const field_t hw_flexcan_rxfgmask[] =
{
    {
        "FGM31_FGM0",
        "These bits mask the ID Filter Table elements bits in a perfect alignme"
        "nt.RXFGMASKRx FIFO Global Mask Register shows in detail which FGM bits"
        " mask each IDAF field.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXFIR.
static const field_t hw_flexcan_rxfir[] =
{
    {
        "IDHIT",
        "This 9-bit field indicates which Identifier Acceptance Filter (see Rx "
        "FIFO StructureWhen the MCR[RFEN] bit is set, the memory area from $80 "
        "to $DC (which is normally occupied by MBs 0 to 5) is used by the recep"
        "tion FIFO engine.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXIMR0_RXIMR63.
static const field_t hw_flexcan_rximr0_rximr63[] =
{
    {
        "MI31_MI0",
        "These bits mask both Mailbox filter and Rx FIFO ID Filter Table elemen"
        "t in distinct ways.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_GFWR.
static const field_t hw_flexcan_gfwr[] =
{
    {
        "GFWR",
        "It determines the Glitch Filter Width.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a FLEXCAN module.
static const reg_t hw_flexcan[] =
{
    {
        "MCR",
        "This register defines global system configurations, such as the module"
        " operation mode (e.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_flexcan_mcr
    },
    {
        "CTRL1",
        "This register is defined for specific FLEXCAN control features related"
        " to the CAN bus, such as bit-rate, programmable sampling point within "
        "an Rx bit, Loop Back Mode, Listen Only Mode, Bus Off recovery behavior"
        " and interrupt enabling (Bus-Off, Error, Warning).",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_flexcan_ctrl1
    },
    {
        "TIMER",
        "This register represents a 16-bit free running counter that can be rea"
        "d and written by the ARM.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_timer
    },
    {
        "RXMGMASK",
        "RXMGMASK is provided for legacy support.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rxmgmask
    },
    {
        "RX14MASK",
        "RX14MASK is provided for legacy support, asserting the MCR[IRMQ] bit c"
        "auses the RX14MASK to have no effect on the module operation.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rx14mask
    },
    {
        "RX15MASK",
        "RX15MASK is provided for legacy support, asserting the MCR[IRMQ] bit c"
        "auses the RX15MASK Register to have no effect on the module operation.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rx15mask
    },
    {
        "ECR",
        "This register has 2 8-bit fields reflecting the value of two FLEXCAN e"
        "rror counters: Transmit Error Counter (Tx_Err_Counter field) and Recei"
        "ve Error Counter (Rx_Err_Counter field).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_flexcan_ecr
    },
    {
        "ESR1",
        "This register reflects various error conditions, some general status o"
        "f the device and it is the source of four interrupts to the ARM.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_flexcan_esr1
    },
    {
        "IMASK2",
        "This register allows any number of a range of 32 Message Buffer Interr"
        "upts to be enabled or disabled.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_imask2
    },
    {
        "IMASK1",
        "This register allows to enable or disable any number of a range of 32 "
        "Message Buffer Interrupts.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_imask1
    },
    {
        "IFLAG2",
        "This register defines the flags for 32 Message Buffer interrupts.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_iflag2
    },
    {
        "IFLAG1",
        "This register defines the flags for 32 Message Buffer interrupts and F"
        "IFO interrupts.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_flexcan_iflag1
    },
    {
        "CTRL2",
        "This register contains control bits for CAN errors, FIFO features and "
        "mode selection.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexcan_ctrl2
    },
    {
        "ESR2",
        "This register reflects various interrupt flags and some general status"
        ".",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_flexcan_esr2
    },
    {
        "CRCR",
        "This register provides information about the CRC of transmitted messag"
        "es",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_flexcan_crcr
    },
    {
        "RXFGMASK",
        "If Rx FIFO is enabled RXFGMASK is used to mask the Rx FIFO ID Filter T"
        "able elements that do not have a corresponding RXIMR according to CTRL"
        "2[RFFN] field setting.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rxfgmask
    },
    {
        "RXFIR",
        "RXFIR provides information on Rx FIFO.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_flexcan_rxfir
    },
    {
        "RXIMR0_RXIMR63",
        "RXIMR are used as acceptance masks for ID filtering in Rx MBs and the "
        "Rx FIFO.",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rximr0_rximr63
    },
    {
        "GFWR",
        "The Glitch Filter just takes effects when FLEXCAN enters the STOP mode"
        ".",
        4, // Width in bytes
        0x000009e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_gfwr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GIS
#endif

// Bitfields in register GIS_CTRL.
static const field_t hw_gis_ctrl[] =
{
    {
        "ENABLE",
        "Enable the block to process interrupts.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB_START",
        "Specifies which CSI FB finished and caused the first CSI interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_SEL",
        "Specifies which of the two LCDIF interfaces to use, which interrupt to"
        " monitor.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SEL",
        "Specifies which of the two CSI interfaces to use, which interrupt to m"
        "onitor.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_IRQ_POLARITY",
        "Specifies the polarity of the irq assertion level.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_IRQ_POLARITY",
        "Specifies the polarity of the irq assertion level.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal GIS operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CTRL_SET.
static const field_t hw_gis_ctrl_set[] =
{
    {
        "ENABLE",
        "Enable the block to process interrupts.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB_START",
        "Specifies which CSI FB finished and caused the first CSI interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_SEL",
        "Specifies which of the two LCDIF interfaces to use, which interrupt to"
        " monitor.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SEL",
        "Specifies which of the two CSI interfaces to use, which interrupt to m"
        "onitor.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_IRQ_POLARITY",
        "Specifies the polarity of the irq assertion level.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_IRQ_POLARITY",
        "Specifies the polarity of the irq assertion level.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal GIS operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CTRL_CLR.
static const field_t hw_gis_ctrl_clr[] =
{
    {
        "ENABLE",
        "Enable the block to process interrupts.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB_START",
        "Specifies which CSI FB finished and caused the first CSI interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_SEL",
        "Specifies which of the two LCDIF interfaces to use, which interrupt to"
        " monitor.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SEL",
        "Specifies which of the two CSI interfaces to use, which interrupt to m"
        "onitor.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_IRQ_POLARITY",
        "Specifies the polarity of the irq assertion level.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_IRQ_POLARITY",
        "Specifies the polarity of the irq assertion level.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal GIS operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CTRL_TOG.
static const field_t hw_gis_ctrl_tog[] =
{
    {
        "ENABLE",
        "Enable the block to process interrupts.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB_START",
        "Specifies which CSI FB finished and caused the first CSI interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_SEL",
        "Specifies which of the two LCDIF interfaces to use, which interrupt to"
        " monitor.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SEL",
        "Specifies which of the two CSI interfaces to use, which interrupt to m"
        "onitor.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_IRQ_POLARITY",
        "This bit must be set to zero for normal operation.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_IRQ_POLARITY",
        "Specifies the polarity of the irq assertion level.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_IRQ_POLARITY",
        "Specifies the polarity of the irq assertion level.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal GIS operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CONFIG0.
static const field_t hw_gis_config0[] =
{
    {
        "CH0_MAPPING",
        "Command channel0 assignment.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_NUM",
        "Number of valid commands to execute for this channel.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_MAPPING",
        "Command channel1 assignment.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_NUM",
        "Number of valid commands to execute for this channel.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_MAPPING",
        "Command channel2 assignment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_NUM",
        "Number of valid commands to execute for this channel.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_MAPPING",
        "Command channel3 assignment.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_NUM",
        "Number of valid commands to execute for this channel.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CONFIG0_SET.
static const field_t hw_gis_config0_set[] =
{
    {
        "CH0_MAPPING",
        "Command channel0 assignment.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_NUM",
        "Number of valid commands to execute for this channel.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_MAPPING",
        "Command channel1 assignment.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_NUM",
        "Number of valid commands to execute for this channel.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_MAPPING",
        "Command channel2 assignment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_NUM",
        "Number of valid commands to execute for this channel.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_MAPPING",
        "Command channel3 assignment.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_NUM",
        "Number of valid commands to execute for this channel.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CONFIG0_CLR.
static const field_t hw_gis_config0_clr[] =
{
    {
        "CH0_MAPPING",
        "Command channel0 assignment.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_NUM",
        "Number of valid commands to execute for this channel.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_MAPPING",
        "Command channel1 assignment.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_NUM",
        "Number of valid commands to execute for this channel.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_MAPPING",
        "Command channel2 assignment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_NUM",
        "Number of valid commands to execute for this channel.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_MAPPING",
        "Command channel3 assignment.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_NUM",
        "Number of valid commands to execute for this channel.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CONFIG0_TOG.
static const field_t hw_gis_config0_tog[] =
{
    {
        "CH0_MAPPING",
        "Command channel0 assignment.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_NUM",
        "Number of valid commands to execute for this channel.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_MAPPING",
        "Command channel1 assignment.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_NUM",
        "Number of valid commands to execute for this channel.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_MAPPING",
        "Command channel2 assignment.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_NUM",
        "Number of valid commands to execute for this channel.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_MAPPING",
        "Command channel3 assignment.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_NUM",
        "Number of valid commands to execute for this channel.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CONFIG1.
static const field_t hw_gis_config1[] =
{
    {
        "CH4_MAPPING",
        "Command channel4 assignment.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_NUM",
        "Number of valid commands to execute for this channel.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_MAPPING",
        "Command channel5 assignment.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_NUM",
        "Number of valid commands to execute for this channel.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CONFIG1_SET.
static const field_t hw_gis_config1_set[] =
{
    {
        "CH4_MAPPING",
        "Command channel4 assignment.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_NUM",
        "Number of valid commands to execute for this channel.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_MAPPING",
        "Command channel5 assignment.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_NUM",
        "Number of valid commands to execute for this channel.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CONFIG1_CLR.
static const field_t hw_gis_config1_clr[] =
{
    {
        "CH4_MAPPING",
        "Command channel4 assignment.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_NUM",
        "Number of valid commands to execute for this channel.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_MAPPING",
        "Command channel5 assignment.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_NUM",
        "Number of valid commands to execute for this channel.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CONFIG1_TOG.
static const field_t hw_gis_config1_tog[] =
{
    {
        "CH4_MAPPING",
        "Command channel4 assignment.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_NUM",
        "Number of valid commands to execute for this channel.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_MAPPING",
        "Command channel5 assignment.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_NUM",
        "Number of valid commands to execute for this channel.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_FB0.
static const field_t hw_gis_fb0[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_FB1.
static const field_t hw_gis_fb1[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_PXP_FB0.
static const field_t hw_gis_pxp_fb0[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_PXP_FB1.
static const field_t hw_gis_pxp_fb1[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_CTRL.
static const field_t hw_gis_ch0_ctrl[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_CTRL_SET.
static const field_t hw_gis_ch0_ctrl_set[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_CTRL_CLR.
static const field_t hw_gis_ch0_ctrl_clr[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_CTRL_TOG.
static const field_t hw_gis_ch0_ctrl_tog[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR0.
static const field_t hw_gis_ch0_addr0[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR0_SET.
static const field_t hw_gis_ch0_addr0_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR0_CLR.
static const field_t hw_gis_ch0_addr0_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR0_TOG.
static const field_t hw_gis_ch0_addr0_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_DATA0.
static const field_t hw_gis_ch0_data0[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR1.
static const field_t hw_gis_ch0_addr1[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR1_SET.
static const field_t hw_gis_ch0_addr1_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR1_CLR.
static const field_t hw_gis_ch0_addr1_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR1_TOG.
static const field_t hw_gis_ch0_addr1_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_DATA1.
static const field_t hw_gis_ch0_data1[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR2.
static const field_t hw_gis_ch0_addr2[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR2_SET.
static const field_t hw_gis_ch0_addr2_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR2_CLR.
static const field_t hw_gis_ch0_addr2_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR2_TOG.
static const field_t hw_gis_ch0_addr2_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_DATA2.
static const field_t hw_gis_ch0_data2[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR3.
static const field_t hw_gis_ch0_addr3[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR3_SET.
static const field_t hw_gis_ch0_addr3_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR3_CLR.
static const field_t hw_gis_ch0_addr3_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_ADDR3_TOG.
static const field_t hw_gis_ch0_addr3_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH0_DATA3.
static const field_t hw_gis_ch0_data3[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_CTRL.
static const field_t hw_gis_ch1_ctrl[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_CTRL_SET.
static const field_t hw_gis_ch1_ctrl_set[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_CTRL_CLR.
static const field_t hw_gis_ch1_ctrl_clr[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_CTRL_TOG.
static const field_t hw_gis_ch1_ctrl_tog[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR0.
static const field_t hw_gis_ch1_addr0[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR0_SET.
static const field_t hw_gis_ch1_addr0_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR0_CLR.
static const field_t hw_gis_ch1_addr0_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR0_TOG.
static const field_t hw_gis_ch1_addr0_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_DATA0.
static const field_t hw_gis_ch1_data0[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR1.
static const field_t hw_gis_ch1_addr1[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR1_SET.
static const field_t hw_gis_ch1_addr1_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR1_CLR.
static const field_t hw_gis_ch1_addr1_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR1_TOG.
static const field_t hw_gis_ch1_addr1_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_DATA1.
static const field_t hw_gis_ch1_data1[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR2.
static const field_t hw_gis_ch1_addr2[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR2_SET.
static const field_t hw_gis_ch1_addr2_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR2_CLR.
static const field_t hw_gis_ch1_addr2_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR2_TOG.
static const field_t hw_gis_ch1_addr2_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_DATA2.
static const field_t hw_gis_ch1_data2[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR3.
static const field_t hw_gis_ch1_addr3[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR3_SET.
static const field_t hw_gis_ch1_addr3_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR3_CLR.
static const field_t hw_gis_ch1_addr3_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_ADDR3_TOG.
static const field_t hw_gis_ch1_addr3_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH1_DATA3.
static const field_t hw_gis_ch1_data3[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_CTRL.
static const field_t hw_gis_ch2_ctrl[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_CTRL_SET.
static const field_t hw_gis_ch2_ctrl_set[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_CTRL_CLR.
static const field_t hw_gis_ch2_ctrl_clr[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_CTRL_TOG.
static const field_t hw_gis_ch2_ctrl_tog[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR0.
static const field_t hw_gis_ch2_addr0[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR0_SET.
static const field_t hw_gis_ch2_addr0_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR0_CLR.
static const field_t hw_gis_ch2_addr0_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR0_TOG.
static const field_t hw_gis_ch2_addr0_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_DATA0.
static const field_t hw_gis_ch2_data0[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR1.
static const field_t hw_gis_ch2_addr1[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR1_SET.
static const field_t hw_gis_ch2_addr1_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR1_CLR.
static const field_t hw_gis_ch2_addr1_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR1_TOG.
static const field_t hw_gis_ch2_addr1_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_DATA1.
static const field_t hw_gis_ch2_data1[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR2.
static const field_t hw_gis_ch2_addr2[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR2_SET.
static const field_t hw_gis_ch2_addr2_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR2_CLR.
static const field_t hw_gis_ch2_addr2_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR2_TOG.
static const field_t hw_gis_ch2_addr2_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_DATA2.
static const field_t hw_gis_ch2_data2[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR3.
static const field_t hw_gis_ch2_addr3[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR3_SET.
static const field_t hw_gis_ch2_addr3_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR3_CLR.
static const field_t hw_gis_ch2_addr3_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_ADDR3_TOG.
static const field_t hw_gis_ch2_addr3_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH2_DATA3.
static const field_t hw_gis_ch2_data3[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_CTRL.
static const field_t hw_gis_ch3_ctrl[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_CTRL_SET.
static const field_t hw_gis_ch3_ctrl_set[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_CTRL_CLR.
static const field_t hw_gis_ch3_ctrl_clr[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_CTRL_TOG.
static const field_t hw_gis_ch3_ctrl_tog[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR0.
static const field_t hw_gis_ch3_addr0[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR0_SET.
static const field_t hw_gis_ch3_addr0_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR0_CLR.
static const field_t hw_gis_ch3_addr0_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR0_TOG.
static const field_t hw_gis_ch3_addr0_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_DATA0.
static const field_t hw_gis_ch3_data0[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR1.
static const field_t hw_gis_ch3_addr1[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR1_SET.
static const field_t hw_gis_ch3_addr1_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR1_CLR.
static const field_t hw_gis_ch3_addr1_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR1_TOG.
static const field_t hw_gis_ch3_addr1_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_DATA1.
static const field_t hw_gis_ch3_data1[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR2.
static const field_t hw_gis_ch3_addr2[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR2_SET.
static const field_t hw_gis_ch3_addr2_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR2_CLR.
static const field_t hw_gis_ch3_addr2_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR2_TOG.
static const field_t hw_gis_ch3_addr2_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_DATA2.
static const field_t hw_gis_ch3_data2[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR3.
static const field_t hw_gis_ch3_addr3[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR3_SET.
static const field_t hw_gis_ch3_addr3_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR3_CLR.
static const field_t hw_gis_ch3_addr3_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_ADDR3_TOG.
static const field_t hw_gis_ch3_addr3_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH3_DATA3.
static const field_t hw_gis_ch3_data3[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_CTRL.
static const field_t hw_gis_ch4_ctrl[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_CTRL_SET.
static const field_t hw_gis_ch4_ctrl_set[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_CTRL_CLR.
static const field_t hw_gis_ch4_ctrl_clr[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_CTRL_TOG.
static const field_t hw_gis_ch4_ctrl_tog[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR0.
static const field_t hw_gis_ch4_addr0[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR0_SET.
static const field_t hw_gis_ch4_addr0_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR0_CLR.
static const field_t hw_gis_ch4_addr0_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR0_TOG.
static const field_t hw_gis_ch4_addr0_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_DATA0.
static const field_t hw_gis_ch4_data0[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR1.
static const field_t hw_gis_ch4_addr1[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR1_SET.
static const field_t hw_gis_ch4_addr1_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR1_CLR.
static const field_t hw_gis_ch4_addr1_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR1_TOG.
static const field_t hw_gis_ch4_addr1_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_DATA1.
static const field_t hw_gis_ch4_data1[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR2.
static const field_t hw_gis_ch4_addr2[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR2_SET.
static const field_t hw_gis_ch4_addr2_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR2_CLR.
static const field_t hw_gis_ch4_addr2_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR2_TOG.
static const field_t hw_gis_ch4_addr2_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_DATA2.
static const field_t hw_gis_ch4_data2[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR3.
static const field_t hw_gis_ch4_addr3[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR3_SET.
static const field_t hw_gis_ch4_addr3_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR3_CLR.
static const field_t hw_gis_ch4_addr3_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_ADDR3_TOG.
static const field_t hw_gis_ch4_addr3_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH4_DATA3.
static const field_t hw_gis_ch4_data3[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_CTRL.
static const field_t hw_gis_ch5_ctrl[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_CTRL_SET.
static const field_t hw_gis_ch5_ctrl_set[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_CTRL_CLR.
static const field_t hw_gis_ch5_ctrl_clr[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_CTRL_TOG.
static const field_t hw_gis_ch5_ctrl_tog[] =
{
    {
        "CMD0_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD0_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD1_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD2_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_OPCODE",
        "This field specifies the opcode to go along with the address and data "
        "values for this command.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ALU",
        "Specifies the what logical or arithmetic operation for the ALU when co"
        "mbining the accumulator and the data bits.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD3_ACC_NEG",
        "If the accumulator is used in the command this bit specifies if the ac"
        "cumulator value should be to negated before it is used in the command.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR0.
static const field_t hw_gis_ch5_addr0[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR0_SET.
static const field_t hw_gis_ch5_addr0_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR0_CLR.
static const field_t hw_gis_ch5_addr0_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR0_TOG.
static const field_t hw_gis_ch5_addr0_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_DATA0.
static const field_t hw_gis_ch5_data0[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR1.
static const field_t hw_gis_ch5_addr1[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR1_SET.
static const field_t hw_gis_ch5_addr1_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR1_CLR.
static const field_t hw_gis_ch5_addr1_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR1_TOG.
static const field_t hw_gis_ch5_addr1_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_DATA1.
static const field_t hw_gis_ch5_data1[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR2.
static const field_t hw_gis_ch5_addr2[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR2_SET.
static const field_t hw_gis_ch5_addr2_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR2_CLR.
static const field_t hw_gis_ch5_addr2_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR2_TOG.
static const field_t hw_gis_ch5_addr2_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_DATA2.
static const field_t hw_gis_ch5_data2[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR3.
static const field_t hw_gis_ch5_addr3[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR3_SET.
static const field_t hw_gis_ch5_addr3_set[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR3_CLR.
static const field_t hw_gis_ch5_addr3_clr[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_ADDR3_TOG.
static const field_t hw_gis_ch5_addr3_tog[] =
{
    {
        "ADDR",
        "32 bit address of command.",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI0_SEL",
        "This bit selects the CSI0 block as the target if this command will acc"
        "ess the bus.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_SEL",
        "This bit selects the CSI1 block as the target if this command will acc"
        "ess the bus.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_SEL",
        "This bit selects the PXP block as the target if this command will acce"
        "ss the bus.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF0_SEL",
        "This bit selects the LCDIF0 block as the target if this command will a"
        "ccess the bus.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_SEL",
        "This bit selects the LCDIF1 block as the target if this command will a"
        "ccess the bus.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_CH5_DATA3.
static const field_t hw_gis_ch5_data3[] =
{
    {
        "DATA",
        "32 bit address of command.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_DEBUG0.
static const field_t hw_gis_debug0[] =
{
    {
        "CMD_STATE",
        "For debug purposes only.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAIN_STATE",
        "For debug purposes only.",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHANNEL_CUR",
        "For debug purposes only.",
        14, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMD_COUNTER",
        "For debug purposes only.",
        18, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMD_OPCODE",
        "For debug purposes only.",
        21, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_BUSY",
        "For debug purposes only.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_IRQ",
        "For debug purposes only.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSI_IRQ",
        "For debug purposes only.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSI_FB_REG",
        "For debug purposes only.",
        28, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_DEBUG1.
static const field_t hw_gis_debug1[] =
{
    {
        "CSI_FB",
        "For debug purposes only.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_OUT_FB",
        "For debug purposes only.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_IN_FB",
        "For debug purposes only.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LCDIF_FB",
        "For debug purposes only.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GIS_VERSION.
static const field_t hw_gis_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GIS module.
static const reg_t hw_gis[] =
{
    {
        "CTRL",
        "The control register provides control for the overall block.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_gis_ctrl
    },
    {
        "CTRL_SET",
        "The control register provides control for the overall block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_gis_ctrl_set
    },
    {
        "CTRL_CLR",
        "The control register provides control for the overall block.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_gis_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The control register provides control for the overall block.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_gis_ctrl_tog
    },
    {
        "CONFIG0",
        "This register provides configuration of the GIS channels.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_gis_config0
    },
    {
        "CONFIG0_SET",
        "This register provides configuration of the GIS channels.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_gis_config0_set
    },
    {
        "CONFIG0_CLR",
        "This register provides configuration of the GIS channels.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_gis_config0_clr
    },
    {
        "CONFIG0_TOG",
        "This register provides configuration of the GIS channels.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_gis_config0_tog
    },
    {
        "CONFIG1",
        "This register provides configuration of the GIS channels.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gis_config1
    },
    {
        "CONFIG1_SET",
        "This register provides configuration of the GIS channels.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gis_config1_set
    },
    {
        "CONFIG1_CLR",
        "This register provides configuration of the GIS channels.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gis_config1_clr
    },
    {
        "CONFIG1_TOG",
        "This register provides configuration of the GIS channels.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gis_config1_tog
    },
    {
        "FB0",
        "Camera frame buffer address 0.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_fb0
    },
    {
        "FB1",
        "Camera frame buffer address 1.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_fb1
    },
    {
        "PXP_FB0",
        "PXP frame buffer address 0.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_pxp_fb0
    },
    {
        "PXP_FB1",
        "PXP frame buffer address 1.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_pxp_fb1
    },
    {
        "CH0_CTRL",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch0_ctrl
    },
    {
        "CH0_CTRL_SET",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch0_ctrl_set
    },
    {
        "CH0_CTRL_CLR",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch0_ctrl_clr
    },
    {
        "CH0_CTRL_TOG",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch0_ctrl_tog
    },
    {
        "CH0_ADDR0",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr0
    },
    {
        "CH0_ADDR0_SET",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr0_set
    },
    {
        "CH0_ADDR0_CLR",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr0_clr
    },
    {
        "CH0_ADDR0_TOG",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr0_tog
    },
    {
        "CH0_DATA0",
        "Data register for channel 0 command 0.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch0_data0
    },
    {
        "CH0_ADDR1",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr1
    },
    {
        "CH0_ADDR1_SET",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr1_set
    },
    {
        "CH0_ADDR1_CLR",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr1_clr
    },
    {
        "CH0_ADDR1_TOG",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr1_tog
    },
    {
        "CH0_DATA1",
        "Data register for channel 0 command 1.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch0_data1
    },
    {
        "CH0_ADDR2",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr2
    },
    {
        "CH0_ADDR2_SET",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr2_set
    },
    {
        "CH0_ADDR2_CLR",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr2_clr
    },
    {
        "CH0_ADDR2_TOG",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr2_tog
    },
    {
        "CH0_DATA2",
        "Data register for channel 0 command 2.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch0_data2
    },
    {
        "CH0_ADDR3",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr3
    },
    {
        "CH0_ADDR3_SET",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr3_set
    },
    {
        "CH0_ADDR3_CLR",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr3_clr
    },
    {
        "CH0_ADDR3_TOG",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch0_addr3_tog
    },
    {
        "CH0_DATA3",
        "Data register for channel 0 command 3.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch0_data3
    },
    {
        "CH1_CTRL",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch1_ctrl
    },
    {
        "CH1_CTRL_SET",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch1_ctrl_set
    },
    {
        "CH1_CTRL_CLR",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch1_ctrl_clr
    },
    {
        "CH1_CTRL_TOG",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch1_ctrl_tog
    },
    {
        "CH1_ADDR0",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr0
    },
    {
        "CH1_ADDR0_SET",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr0_set
    },
    {
        "CH1_ADDR0_CLR",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr0_clr
    },
    {
        "CH1_ADDR0_TOG",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr0_tog
    },
    {
        "CH1_DATA0",
        "Data register for channel 0 command 0.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch1_data0
    },
    {
        "CH1_ADDR1",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr1
    },
    {
        "CH1_ADDR1_SET",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr1_set
    },
    {
        "CH1_ADDR1_CLR",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr1_clr
    },
    {
        "CH1_ADDR1_TOG",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr1_tog
    },
    {
        "CH1_DATA1",
        "Data register for channel 0 command 1.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch1_data1
    },
    {
        "CH1_ADDR2",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr2
    },
    {
        "CH1_ADDR2_SET",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr2_set
    },
    {
        "CH1_ADDR2_CLR",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr2_clr
    },
    {
        "CH1_ADDR2_TOG",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr2_tog
    },
    {
        "CH1_DATA2",
        "Data register for channel 0 command 2.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch1_data2
    },
    {
        "CH1_ADDR3",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr3
    },
    {
        "CH1_ADDR3_SET",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr3_set
    },
    {
        "CH1_ADDR3_CLR",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr3_clr
    },
    {
        "CH1_ADDR3_TOG",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch1_addr3_tog
    },
    {
        "CH1_DATA3",
        "Data register for channel 0 command 3.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch1_data3
    },
    {
        "CH2_CTRL",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch2_ctrl
    },
    {
        "CH2_CTRL_SET",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch2_ctrl_set
    },
    {
        "CH2_CTRL_CLR",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch2_ctrl_clr
    },
    {
        "CH2_CTRL_TOG",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch2_ctrl_tog
    },
    {
        "CH2_ADDR0",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr0
    },
    {
        "CH2_ADDR0_SET",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr0_set
    },
    {
        "CH2_ADDR0_CLR",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr0_clr
    },
    {
        "CH2_ADDR0_TOG",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr0_tog
    },
    {
        "CH2_DATA0",
        "Data register for channel 0 command 0.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch2_data0
    },
    {
        "CH2_ADDR1",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr1
    },
    {
        "CH2_ADDR1_SET",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr1_set
    },
    {
        "CH2_ADDR1_CLR",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr1_clr
    },
    {
        "CH2_ADDR1_TOG",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr1_tog
    },
    {
        "CH2_DATA1",
        "Data register for channel 0 command 1.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch2_data1
    },
    {
        "CH2_ADDR2",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr2
    },
    {
        "CH2_ADDR2_SET",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x000001e4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr2_set
    },
    {
        "CH2_ADDR2_CLR",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x000001e8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr2_clr
    },
    {
        "CH2_ADDR2_TOG",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x000001ec, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr2_tog
    },
    {
        "CH2_DATA2",
        "Data register for channel 0 command 2.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch2_data2
    },
    {
        "CH2_ADDR3",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr3
    },
    {
        "CH2_ADDR3_SET",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr3_set
    },
    {
        "CH2_ADDR3_CLR",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr3_clr
    },
    {
        "CH2_ADDR3_TOG",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch2_addr3_tog
    },
    {
        "CH2_DATA3",
        "Data register for channel 0 command 3.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch2_data3
    },
    {
        "CH3_CTRL",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch3_ctrl
    },
    {
        "CH3_CTRL_SET",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch3_ctrl_set
    },
    {
        "CH3_CTRL_CLR",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch3_ctrl_clr
    },
    {
        "CH3_CTRL_TOG",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch3_ctrl_tog
    },
    {
        "CH3_ADDR0",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr0
    },
    {
        "CH3_ADDR0_SET",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr0_set
    },
    {
        "CH3_ADDR0_CLR",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr0_clr
    },
    {
        "CH3_ADDR0_TOG",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr0_tog
    },
    {
        "CH3_DATA0",
        "Data register for channel 0 command 0.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch3_data0
    },
    {
        "CH3_ADDR1",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr1
    },
    {
        "CH3_ADDR1_SET",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr1_set
    },
    {
        "CH3_ADDR1_CLR",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr1_clr
    },
    {
        "CH3_ADDR1_TOG",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr1_tog
    },
    {
        "CH3_DATA1",
        "Data register for channel 0 command 1.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch3_data1
    },
    {
        "CH3_ADDR2",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr2
    },
    {
        "CH3_ADDR2_SET",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr2_set
    },
    {
        "CH3_ADDR2_CLR",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr2_clr
    },
    {
        "CH3_ADDR2_TOG",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr2_tog
    },
    {
        "CH3_DATA2",
        "Data register for channel 0 command 2.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch3_data2
    },
    {
        "CH3_ADDR3",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr3
    },
    {
        "CH3_ADDR3_SET",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr3_set
    },
    {
        "CH3_ADDR3_CLR",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr3_clr
    },
    {
        "CH3_ADDR3_TOG",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch3_addr3_tog
    },
    {
        "CH3_DATA3",
        "Data register for channel 0 command 3.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch3_data3
    },
    {
        "CH4_CTRL",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch4_ctrl
    },
    {
        "CH4_CTRL_SET",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch4_ctrl_set
    },
    {
        "CH4_CTRL_CLR",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch4_ctrl_clr
    },
    {
        "CH4_CTRL_TOG",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch4_ctrl_tog
    },
    {
        "CH4_ADDR0",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr0
    },
    {
        "CH4_ADDR0_SET",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr0_set
    },
    {
        "CH4_ADDR0_CLR",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr0_clr
    },
    {
        "CH4_ADDR0_TOG",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr0_tog
    },
    {
        "CH4_DATA0",
        "Data register for channel 0 command 0.",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch4_data0
    },
    {
        "CH4_ADDR1",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr1
    },
    {
        "CH4_ADDR1_SET",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000002e4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr1_set
    },
    {
        "CH4_ADDR1_CLR",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000002e8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr1_clr
    },
    {
        "CH4_ADDR1_TOG",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x000002ec, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr1_tog
    },
    {
        "CH4_DATA1",
        "Data register for channel 0 command 1.",
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch4_data1
    },
    {
        "CH4_ADDR2",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr2
    },
    {
        "CH4_ADDR2_SET",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr2_set
    },
    {
        "CH4_ADDR2_CLR",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr2_clr
    },
    {
        "CH4_ADDR2_TOG",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x0000030c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr2_tog
    },
    {
        "CH4_DATA2",
        "Data register for channel 0 command 2.",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch4_data2
    },
    {
        "CH4_ADDR3",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr3
    },
    {
        "CH4_ADDR3_SET",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr3_set
    },
    {
        "CH4_ADDR3_CLR",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr3_clr
    },
    {
        "CH4_ADDR3_TOG",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch4_addr3_tog
    },
    {
        "CH4_DATA3",
        "Data register for channel 0 command 3.",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch4_data3
    },
    {
        "CH5_CTRL",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch5_ctrl
    },
    {
        "CH5_CTRL_SET",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch5_ctrl_set
    },
    {
        "CH5_CTRL_CLR",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch5_ctrl_clr
    },
    {
        "CH5_CTRL_TOG",
        "Control information for command channel 0.",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gis_ch5_ctrl_tog
    },
    {
        "CH5_ADDR0",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr0
    },
    {
        "CH5_ADDR0_SET",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr0_set
    },
    {
        "CH5_ADDR0_CLR",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr0_clr
    },
    {
        "CH5_ADDR0_TOG",
        "Address register for channel 0 command 0.",
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr0_tog
    },
    {
        "CH5_DATA0",
        "Data register for channel 0 command 0.",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch5_data0
    },
    {
        "CH5_ADDR1",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr1
    },
    {
        "CH5_ADDR1_SET",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000374, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr1_set
    },
    {
        "CH5_ADDR1_CLR",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr1_clr
    },
    {
        "CH5_ADDR1_TOG",
        "Address register for channel 0 command 1.",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr1_tog
    },
    {
        "CH5_DATA1",
        "Data register for channel 0 command 1.",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch5_data1
    },
    {
        "CH5_ADDR2",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr2
    },
    {
        "CH5_ADDR2_SET",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr2_set
    },
    {
        "CH5_ADDR2_CLR",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr2_clr
    },
    {
        "CH5_ADDR2_TOG",
        "Address register for channel 0 command 2.",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr2_tog
    },
    {
        "CH5_DATA2",
        "Data register for channel 0 command 2.",
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch5_data2
    },
    {
        "CH5_ADDR3",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr3
    },
    {
        "CH5_ADDR3_SET",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr3_set
    },
    {
        "CH5_ADDR3_CLR",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr3_clr
    },
    {
        "CH5_ADDR3_TOG",
        "Address register for channel 0 command 3.",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gis_ch5_addr3_tog
    },
    {
        "CH5_DATA3",
        "Data register for channel 0 command 3.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gis_ch5_data3
    },
    {
        "DEBUG0",
        "Debug 0 Register.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_gis_debug0
    },
    {
        "DEBUG1",
        "Debug 1 Register",
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_gis_debug1
    },
    {
        "VERSION",
        "This register reflects the version number for the GIS.",
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_gis_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPC
#endif

// Bitfields in register GPC_CNTR.
static const field_t hw_gpc_cntr[] =
{
    {
        "GPU_VPU_PDN_REQ",
        "GPU Power Down request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_VPU_PUP_REQ",
        "GPU Power Up request.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEGA_PDN_REQ",
        "MEGA domain power down request.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEGA_PUP_REQ",
        "MEGA domain power up request.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PDN_REQ",
        "Display Power Down request.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PUP_REQ",
        "Display Power Up request.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_PHY_PDN_REQ",
        "PCIE PHY power down request.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_PHY_PUP_REQ",
        "PCIE PHY power up request.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS0CR",
        "DVFS0 (ARM) Change request (bit is read-only)",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VADC_ANALOG_OFF",
        "Indication to VADC whether the analog power to VADC is available or no"
        "t",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADC_EXT_PWD_N",
        "VADC power down bit",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPCIRQM",
        "GPC interrupt/event masking",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PGE",
        "L2 Cache Power Gate Enable",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_PGR.
static const field_t hw_gpc_pgr[] =
{
    {
        "DRCIC",
        "Debug ref cir in mux control",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR1.
static const field_t hw_gpc_imr1[] =
{
    {
        "IMR1",
        "IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR2.
static const field_t hw_gpc_imr2[] =
{
    {
        "IMR2",
        "IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR3.
static const field_t hw_gpc_imr3[] =
{
    {
        "IMR3",
        "IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR4.
static const field_t hw_gpc_imr4[] =
{
    {
        "IMR4",
        "IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR1.
static const field_t hw_gpc_isr1[] =
{
    {
        "ISR1",
        "IRQ[63:32] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR2.
static const field_t hw_gpc_isr2[] =
{
    {
        "ISR2",
        "IRQ[95:64] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR3.
static const field_t hw_gpc_isr3[] =
{
    {
        "ISR3",
        "IRQ[127:96] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR4.
static const field_t hw_gpc_isr4[] =
{
    {
        "ISR4",
        "IRQ[159:128] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_A9_LPSR.
static const field_t hw_gpc_a9_lpsr[] =
{
    {
        "A9_STANDBY_WFI",
        "A9 Standby wait for interrupt status",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A9_SCU_IDLE",
        "A9 SCU idle indication",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A9_L2CC_IDLE",
        "A9 L2 Cache idle indication",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A9_CLK_ENABLE",
        "A9 Clock Enable",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYSTEM_IN_WAIT_MODE",
        "WAIT mode status",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYSTEM_IN_STOP_MODE",
        "STOP mode status",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A9_DBG_ACK",
        "Debug Acknowledge of A9",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A9_RST",
        "Reset status of A9",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_M4_LPSR.
static const field_t hw_gpc_m4_lpsr[] =
{
    {
        "M4_SLEEP_HOLD_REQ_B",
        "M4 sleep hold request status",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_SLEEP_HOLD_ACK_B",
        "M4 sleep hold acknowledge",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_GATE_HCLK",
        "M4 hclk gating status",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_SLEEP_DEEP",
        "M4 deep sleeping indication",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_SLEEPING",
        "M4 sleeping indication",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_LOCKUP",
        "M4 lockup indication",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_HALTED",
        "M4 Halted indication",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_PLATFORM_RESET_B",
        "Reset status of M4 Platform",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_CORE_RESET_B",
        "Reset status of M4 Core",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_DR.
static const field_t hw_gpc_dr[] =
{
    {
        "PCIE_PHY_RESET_B",
        "PCIE PHY power switch control signal indication",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PCIE_PHY_ISO",
        "PCIE_PHY isolation signal indication",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEGA_RESET_B",
        "GPC indication to SRC to assert reset for MEGA domain",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEGA_SWITCH_B",
        "MEGA domain power switch control signal indication",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEGA_ISO",
        "MEGA domain isolation signal indication",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_PUP_ACK",
        "GPC pun_ack signal indication",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_PDN_ACK",
        "GPC pdn_ack signal indication",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_DISP_RESET_B",
        "GPC indication to SRC to assert reset for Display domain",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_DISP_SWITCH_B",
        "Display domain power switch control signal indication",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_DISP_ISO",
        "Display domain isolation signal indication",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_GPU_RESET_B",
        "GPC indication to SRC to assert reset for GPU domain",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_GPU_SWITCH_B",
        "GPU domain power switch control signal indication",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_GPU_ISO",
        "GPU domain isolation signal indication",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_L2SOC_ISO",
        "L2 Cache to SOC isolation signal indication",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_L2CPU_ISO",
        "L2 Cache to CPU isolation signal indication",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_L2_SWITCH_B",
        "L2 Cache power switch control signal indication",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_CPU_RESET_B",
        "GPC indication to SRC to assert reset for A9 CPU",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_CPU_SWITCH_B",
        "CPU power switch control signal indication",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPC_CPU_ISO",
        "A9 CPU isolation signal indication",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPG_STOP",
        "CCM ipg_stop signal indication",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPG_WAIT",
        "CCM ipg_wait signal indication",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPC module.
static const reg_t hw_gpc[] =
{
    {
        "CNTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_gpc_cntr
    },
    {
        "PGR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_pgr
    },
    {
        "IMR1",
        "IMR1 Register - masking of irq[63:32].",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr1
    },
    {
        "IMR2",
        "IMR2 Register - masking of irq[95:64].",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr2
    },
    {
        "IMR3",
        "IMR3 Register - masking of irq[127:96].",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr3
    },
    {
        "IMR4",
        "IMR4 Register - masking of irq[159:128].",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr4
    },
    {
        "ISR1",
        "ISR1 Register - status of irq [63:32].",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr1
    },
    {
        "ISR2",
        "ISR2 Register - status of irq [95:64].",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr2
    },
    {
        "ISR3",
        "ISR3 Register - status of irq [127:96].",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr3
    },
    {
        "ISR4",
        "ISR4 Register - status of irq [159:128].",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr4
    },
    {
        "A9_LPSR",
        "A9 Low Power Status Register, read only",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_gpc_a9_lpsr
    },
    {
        "M4_LPSR",
        "M4 Low Power Status Register, read only",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_gpc_m4_lpsr
    },
    {
        "DR",
        "Debug Register, read only",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        21, // Number of bitfields
        hw_gpc_dr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPIO
#endif

// Bitfields in register GPIO_DR.
static const field_t hw_gpio_dr[] =
{
    {
        "DR",
        "Data bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_GDIR.
static const field_t hw_gpio_gdir[] =
{
    {
        "GDIR",
        "GPIO direction bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PSR.
static const field_t hw_gpio_psr[] =
{
    {
        "PSR",
        "GPIO pad status bits (status bits).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ICR1.
static const field_t hw_gpio_icr1[] =
{
    {
        "ICR0",
        "Interrupt configuration 1 fields.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR1",
        "Interrupt configuration 1 fields.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR2",
        "Interrupt configuration 1 fields.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR3",
        "Interrupt configuration 1 fields.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR4",
        "Interrupt configuration 1 fields.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR5",
        "Interrupt configuration 1 fields.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR6",
        "Interrupt configuration 1 fields.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR7",
        "Interrupt configuration 1 fields.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR8",
        "Interrupt configuration 1 fields.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR9",
        "Interrupt configuration 1 fields.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR10",
        "Interrupt configuration 1 fields.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR11",
        "Interrupt configuration 1 fields.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR12",
        "Interrupt configuration 1 fields.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR13",
        "Interrupt configuration 1 fields.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR14",
        "Interrupt configuration 1 fields.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR15",
        "Interrupt configuration 1 fields.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ICR2.
static const field_t hw_gpio_icr2[] =
{
    {
        "ICR16",
        "Interrupt configuration 2 fields.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR17",
        "Interrupt configuration 2 fields.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR18",
        "Interrupt configuration 2 fields.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR19",
        "Interrupt configuration 2 fields.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR20",
        "Interrupt configuration 2 fields.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR21",
        "Interrupt configuration 2 fields.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR22",
        "Interrupt configuration 2 fields.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR23",
        "Interrupt configuration 2 fields.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR24",
        "Interrupt configuration 2 fields.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR25",
        "Interrupt configuration 2 fields.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR26",
        "Interrupt configuration 2 fields.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR27",
        "Interrupt configuration 2 fields.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR28",
        "Interrupt configuration 2 fields.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR29",
        "Interrupt configuration 2 fields.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR30",
        "Interrupt configuration 2 fields.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR31",
        "Interrupt configuration 2 fields.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_IMR.
static const field_t hw_gpio_imr[] =
{
    {
        "IMR",
        "Interrupt Mask bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ISR.
static const field_t hw_gpio_isr[] =
{
    {
        "ISR",
        "Interrupt status bits - Bit n of this register is asserted (active hig"
        "h) when the active condition (as determined by the corresponding ICR b"
        "it) is detected on the GPIO input and is waiting for service.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_EDGE_SEL.
static const field_t hw_gpio_edge_sel[] =
{
    {
        "GPIO_EDGE_SEL",
        "Edge select.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPIO module.
static const reg_t hw_gpio[] =
{
    {
        "DR",
        "The 32-bit GPIO_DR register stores data that is ready to be driven to "
        "the output lines.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_dr
    },
    {
        "GDIR",
        "GPIO_GDIR functions as direction control when the IOMUXC is in GPIO mo"
        "de.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_gdir
    },
    {
        "PSR",
        "GPIO_PSR is a read-only register.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpio_psr
    },
    {
        "ICR1",
        "GPIO_ICR1 contains 16 two-bit fields, where each field specifies the i"
        "nterrupt configuration for a different input signal.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_gpio_icr1
    },
    {
        "ICR2",
        "GPIO_ICR2 contains 16 two-bit fields, where each field specifies the i"
        "nterrupt configuration for a different input signal.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_gpio_icr2
    },
    {
        "IMR",
        "GPIO_IMR contains masking bits for each interrupt line.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_imr
    },
    {
        "ISR",
        "The GPIO_ISR functions as an interrupt status indicator.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_isr
    },
    {
        "EDGE_SEL",
        "GPIO_EDGE_SEL may be used to override the ICR registers' configuration"
        ".",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_edge_sel
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPMI
#endif

// Bitfields in register GPMI_CTRL0.
static const field_t hw_gpmi_ctrl0[] =
{
    {
        "XFER_COUNT",
        "Number of bytes to transfer for this command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_INCREMENT",
        "In ATA mode, the address will increment with each cycle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Specifies the three address lines for ATA mode.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS",
        "Selects which chip select is active for this command.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "This bit should only be changed when RUN==0.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_MODE",
        "WRITE = 0x0 Write mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDMA",
        "DISABLED = 0x0 Use ATA-PIO mode on the external bus.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_CS",
        "For ATA/NAND mode: 0= Deassert chip select (CS) after RUN is complete.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ_EN",
        "When set to '1' and ATA_IRQ pin is asserted, the GPMI_IRQ output will "
        "assert.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN",
        "The GPMI is busy running a command whenever this bit is set to '1'.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Set this bit zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set to zero for normal operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL0_SET.
static const field_t hw_gpmi_ctrl0_set[] =
{
    {
        "XFER_COUNT",
        "Number of bytes to transfer for this command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_INCREMENT",
        "In ATA mode, the address will increment with each cycle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Specifies the three address lines for ATA mode.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS",
        "Selects which chip select is active for this command.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "This bit should only be changed when RUN==0.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_MODE",
        "WRITE = 0x0 Write mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDMA",
        "DISABLED = 0x0 Use ATA-PIO mode on the external bus.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_CS",
        "For ATA/NAND mode: 0= Deassert chip select (CS) after RUN is complete.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ_EN",
        "When set to '1' and ATA_IRQ pin is asserted, the GPMI_IRQ output will "
        "assert.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN",
        "The GPMI is busy running a command whenever this bit is set to '1'.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Set this bit zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set to zero for normal operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL0_CLR.
static const field_t hw_gpmi_ctrl0_clr[] =
{
    {
        "XFER_COUNT",
        "Number of bytes to transfer for this command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_INCREMENT",
        "In ATA mode, the address will increment with each cycle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Specifies the three address lines for ATA mode.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS",
        "Selects which chip select is active for this command.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "This bit should only be changed when RUN==0.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_MODE",
        "WRITE = 0x0 Write mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDMA",
        "DISABLED = 0x0 Use ATA-PIO mode on the external bus.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_CS",
        "For ATA/NAND mode: 0= Deassert chip select (CS) after RUN is complete.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ_EN",
        "When set to '1' and ATA_IRQ pin is asserted, the GPMI_IRQ output will "
        "assert.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN",
        "The GPMI is busy running a command whenever this bit is set to '1'.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Set this bit zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set to zero for normal operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL0_TOG.
static const field_t hw_gpmi_ctrl0_tog[] =
{
    {
        "XFER_COUNT",
        "Number of bytes to transfer for this command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_INCREMENT",
        "In ATA mode, the address will increment with each cycle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Specifies the three address lines for ATA mode.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS",
        "Selects which chip select is active for this command.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "This bit should only be changed when RUN==0.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_MODE",
        "WRITE = 0x0 Write mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDMA",
        "DISABLED = 0x0 Use ATA-PIO mode on the external bus.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_CS",
        "For ATA/NAND mode: 0= Deassert chip select (CS) after RUN is complete.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ_EN",
        "When set to '1' and ATA_IRQ pin is asserted, the GPMI_IRQ output will "
        "assert.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN",
        "The GPMI is busy running a command whenever this bit is set to '1'.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Set this bit zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set to zero for normal operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_COMPARE.
static const field_t hw_gpmi_compare[] =
{
    {
        "REFERENCE",
        "16-bit value which is XORed with data read from the NAND device.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK",
        "16-bit mask which is applied after the read data is XORed with the REF"
        "ERENCE bit field.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCTRL.
static const field_t hw_gpmi_eccctrl[] =
{
    {
        "BUFFER_MASK",
        "ECC buffer information.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_ENABLE",
        "Enable randomizer function.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ECC",
        "Enable ECC processing of GPMI transfers.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_CMD",
        "ECC Command information.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Always write zeroes to this bit field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HANDLE",
        "This is a register available to software to attach an identifier to a "
        "transaction in progress.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCTRL_SET.
static const field_t hw_gpmi_eccctrl_set[] =
{
    {
        "BUFFER_MASK",
        "ECC buffer information.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_ENABLE",
        "Enable randomizer function.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ECC",
        "Enable ECC processing of GPMI transfers.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_CMD",
        "ECC Command information.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Always write zeroes to this bit field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HANDLE",
        "This is a register available to software to attach an identifier to a "
        "transaction in progress.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCTRL_CLR.
static const field_t hw_gpmi_eccctrl_clr[] =
{
    {
        "BUFFER_MASK",
        "ECC buffer information.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_ENABLE",
        "Enable randomizer function.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ECC",
        "Enable ECC processing of GPMI transfers.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_CMD",
        "ECC Command information.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Always write zeroes to this bit field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HANDLE",
        "This is a register available to software to attach an identifier to a "
        "transaction in progress.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCTRL_TOG.
static const field_t hw_gpmi_eccctrl_tog[] =
{
    {
        "BUFFER_MASK",
        "ECC buffer information.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_ENABLE",
        "Enable randomizer function.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ECC",
        "Enable ECC processing of GPMI transfers.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_CMD",
        "ECC Command information.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Always write zeroes to this bit field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HANDLE",
        "This is a register available to software to attach an identifier to a "
        "transaction in progress.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCOUNT.
static const field_t hw_gpmi_ecccount[] =
{
    {
        "COUNT",
        "Number of bytes to pass through ECC.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_PAGE",
        "Set NAND page number needed to be randomized.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_PAYLOAD.
static const field_t hw_gpmi_payload[] =
{
    {
        "RSVD0",
        "Always write zeroes to this bit field.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDRESS",
        "Pointer to an array of one or more 512 byte payload buffers.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_AUXILIARY.
static const field_t hw_gpmi_auxiliary[] =
{
    {
        "RSVD0",
        "Always write zeroes to this bit field.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDRESS",
        "Pointer to ECC control structure and meta-data storage.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL1.
static const field_t hw_gpmi_ctrl1[] =
{
    {
        "GPMI_MODE",
        "ATA mode is only supported on channel zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAMERA_MODE",
        "When set to 1 and ATA UDMA is enabled the UDMA interface becomes a cam"
        "era interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATA_IRQRDY_POLARITY",
        "For ATA MODE: Note NAND_RDY_BUSY[3:2] are not affected by this bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_RESET",
        "ENABLED = 0x0 NANDF_WP_B(WPN) pin is held low (asserted).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_FOR_READY_CHANNEL",
        "Abort a wait for ready command on selected channel.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_REQUEST",
        "Request to abort \"wait for ready\" command on channel indicated by AB"
        "ORT_WAIT_FOR_READY_CHANNEL.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_EN",
        "When set to 1 each DMA request will generate a 4-transfer burst on the"
        " APB bus.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ",
        "This bit is set when a timeout occurs using the Device_Busy_Timeout va"
        "lue.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ",
        "This bit is set when an Interrupt is received from the ATA device.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA2ECC_MODE",
        "This is mainly for testing HWECC without involving the Nand device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDN_DELAY",
        "This variable is a factor in the calculated delay to apply to the inte"
        "rnal read strobe for correct read data sampling.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_PERIOD",
        "Set this bit to 1 if the GPMI clock period is greater than 16ns for pr"
        "oper DLL operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_ENABLE",
        "Set this bit to 1 to enable the GPMI DLL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_MODE",
        "This bit selects which error correction unit will access GPMI.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GANGED_RDYBUSY",
        "Set this bit to 1 will force all Nand RDY_BUSY inputs to be sourced fr"
        "om (tied to) RDY_BUSY0.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ_EN",
        "Setting this bit to '1' will enable timeout IRQ for transfers in ATA m"
        "ode only, and for WAIT_FOR_READY commands in both ATA and Nand mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_TRIGGER",
        "Test Trigger Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRN_DLY_SEL",
        "Since the GPMI write strobe (WRN) is a fast clock pin, the delay on th"
        "is signal can be programmed to match the load on this pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECOUPLE_CS",
        "Decouple Chip Select from DMA Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNCMODE",
        "source synchronouse mode 1 or asynchrous mode 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_CS",
        "force the CS value is be updated to external chip select pin, even GPM"
        "I is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_DIV2_EN",
        "This bit should be reset to 0 in asynchronous mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOGGLE_MODE",
        "enable samsung toggle mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRITE_CLK_STOP",
        "In onfi source synchronous mode, host may save power during the data w"
        "rite cycles by holding the CLK signal high (i.e.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNC_CLK_STOP",
        "set this bit to 1 will stop the source synchronous mode clk.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_CLK_STOP",
        "set this bit to 1 will stop gpmi io working clk.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL1_SET.
static const field_t hw_gpmi_ctrl1_set[] =
{
    {
        "GPMI_MODE",
        "ATA mode is only supported on channel zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAMERA_MODE",
        "When set to 1 and ATA UDMA is enabled the UDMA interface becomes a cam"
        "era interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATA_IRQRDY_POLARITY",
        "For ATA MODE: Note NAND_RDY_BUSY[3:2] are not affected by this bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_RESET",
        "ENABLED = 0x0 NANDF_WP_B(WPN) pin is held low (asserted).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_FOR_READY_CHANNEL",
        "Abort a wait for ready command on selected channel.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_REQUEST",
        "Request to abort \"wait for ready\" command on channel indicated by AB"
        "ORT_WAIT_FOR_READY_CHANNEL.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_EN",
        "When set to 1 each DMA request will generate a 4-transfer burst on the"
        " APB bus.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ",
        "This bit is set when a timeout occurs using the Device_Busy_Timeout va"
        "lue.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ",
        "This bit is set when an Interrupt is received from the ATA device.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA2ECC_MODE",
        "This is mainly for testing HWECC without involving the Nand device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDN_DELAY",
        "This variable is a factor in the calculated delay to apply to the inte"
        "rnal read strobe for correct read data sampling.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_PERIOD",
        "Set this bit to 1 if the GPMI clock period is greater than 16ns for pr"
        "oper DLL operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_ENABLE",
        "Set this bit to 1 to enable the GPMI DLL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_MODE",
        "This bit selects which error correction unit will access GPMI.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GANGED_RDYBUSY",
        "Set this bit to 1 will force all Nand RDY_BUSY inputs to be sourced fr"
        "om (tied to) RDY_BUSY0.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ_EN",
        "Setting this bit to '1' will enable timeout IRQ for transfers in ATA m"
        "ode only, and for WAIT_FOR_READY commands in both ATA and Nand mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_TRIGGER",
        "Test Trigger Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRN_DLY_SEL",
        "Since the GPMI write strobe (WRN) is a fast clock pin, the delay on th"
        "is signal can be programmed to match the load on this pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECOUPLE_CS",
        "Decouple Chip Select from DMA Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNCMODE",
        "source synchronouse mode 1 or asynchrous mode 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_CS",
        "force the CS value is be updated to external chip select pin, even GPM"
        "I is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_DIV2_EN",
        "This bit should be reset to 0 in asynchronous mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOGGLE_MODE",
        "enable samsung toggle mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRITE_CLK_STOP",
        "In onfi source synchronous mode, host may save power during the data w"
        "rite cycles by holding the CLK signal high (i.e.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNC_CLK_STOP",
        "set this bit to 1 will stop the source synchronous mode clk.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_CLK_STOP",
        "set this bit to 1 will stop gpmi io working clk.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL1_CLR.
static const field_t hw_gpmi_ctrl1_clr[] =
{
    {
        "GPMI_MODE",
        "ATA mode is only supported on channel zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAMERA_MODE",
        "When set to 1 and ATA UDMA is enabled the UDMA interface becomes a cam"
        "era interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATA_IRQRDY_POLARITY",
        "For ATA MODE: Note NAND_RDY_BUSY[3:2] are not affected by this bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_RESET",
        "ENABLED = 0x0 NANDF_WP_B(WPN) pin is held low (asserted).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_FOR_READY_CHANNEL",
        "Abort a wait for ready command on selected channel.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_REQUEST",
        "Request to abort \"wait for ready\" command on channel indicated by AB"
        "ORT_WAIT_FOR_READY_CHANNEL.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_EN",
        "When set to 1 each DMA request will generate a 4-transfer burst on the"
        " APB bus.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ",
        "This bit is set when a timeout occurs using the Device_Busy_Timeout va"
        "lue.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ",
        "This bit is set when an Interrupt is received from the ATA device.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA2ECC_MODE",
        "This is mainly for testing HWECC without involving the Nand device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDN_DELAY",
        "This variable is a factor in the calculated delay to apply to the inte"
        "rnal read strobe for correct read data sampling.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_PERIOD",
        "Set this bit to 1 if the GPMI clock period is greater than 16ns for pr"
        "oper DLL operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_ENABLE",
        "Set this bit to 1 to enable the GPMI DLL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_MODE",
        "This bit selects which error correction unit will access GPMI.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GANGED_RDYBUSY",
        "Set this bit to 1 will force all Nand RDY_BUSY inputs to be sourced fr"
        "om (tied to) RDY_BUSY0.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ_EN",
        "Setting this bit to '1' will enable timeout IRQ for transfers in ATA m"
        "ode only, and for WAIT_FOR_READY commands in both ATA and Nand mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_TRIGGER",
        "Test Trigger Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRN_DLY_SEL",
        "Since the GPMI write strobe (WRN) is a fast clock pin, the delay on th"
        "is signal can be programmed to match the load on this pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECOUPLE_CS",
        "Decouple Chip Select from DMA Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNCMODE",
        "source synchronouse mode 1 or asynchrous mode 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_CS",
        "force the CS value is be updated to external chip select pin, even GPM"
        "I is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_DIV2_EN",
        "This bit should be reset to 0 in asynchronous mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOGGLE_MODE",
        "enable samsung toggle mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRITE_CLK_STOP",
        "In onfi source synchronous mode, host may save power during the data w"
        "rite cycles by holding the CLK signal high (i.e.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNC_CLK_STOP",
        "set this bit to 1 will stop the source synchronous mode clk.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_CLK_STOP",
        "set this bit to 1 will stop gpmi io working clk.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL1_TOG.
static const field_t hw_gpmi_ctrl1_tog[] =
{
    {
        "GPMI_MODE",
        "ATA mode is only supported on channel zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAMERA_MODE",
        "When set to 1 and ATA UDMA is enabled the UDMA interface becomes a cam"
        "era interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATA_IRQRDY_POLARITY",
        "For ATA MODE: Note NAND_RDY_BUSY[3:2] are not affected by this bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_RESET",
        "ENABLED = 0x0 NANDF_WP_B(WPN) pin is held low (asserted).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_FOR_READY_CHANNEL",
        "Abort a wait for ready command on selected channel.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_REQUEST",
        "Request to abort \"wait for ready\" command on channel indicated by AB"
        "ORT_WAIT_FOR_READY_CHANNEL.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_EN",
        "When set to 1 each DMA request will generate a 4-transfer burst on the"
        " APB bus.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ",
        "This bit is set when a timeout occurs using the Device_Busy_Timeout va"
        "lue.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ",
        "This bit is set when an Interrupt is received from the ATA device.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA2ECC_MODE",
        "This is mainly for testing HWECC without involving the Nand device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDN_DELAY",
        "This variable is a factor in the calculated delay to apply to the inte"
        "rnal read strobe for correct read data sampling.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_PERIOD",
        "Set this bit to 1 if the GPMI clock period is greater than 16ns for pr"
        "oper DLL operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_ENABLE",
        "Set this bit to 1 to enable the GPMI DLL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_MODE",
        "This bit selects which error correction unit will access GPMI.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GANGED_RDYBUSY",
        "Set this bit to 1 will force all Nand RDY_BUSY inputs to be sourced fr"
        "om (tied to) RDY_BUSY0.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ_EN",
        "Setting this bit to '1' will enable timeout IRQ for transfers in ATA m"
        "ode only, and for WAIT_FOR_READY commands in both ATA and Nand mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_TRIGGER",
        "Test Trigger Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRN_DLY_SEL",
        "Since the GPMI write strobe (WRN) is a fast clock pin, the delay on th"
        "is signal can be programmed to match the load on this pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECOUPLE_CS",
        "Decouple Chip Select from DMA Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNCMODE",
        "source synchronouse mode 1 or asynchrous mode 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_CS",
        "force the CS value is be updated to external chip select pin, even GPM"
        "I is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_DIV2_EN",
        "This bit should be reset to 0 in asynchronous mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOGGLE_MODE",
        "enable samsung toggle mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRITE_CLK_STOP",
        "In onfi source synchronous mode, host may save power during the data w"
        "rite cycles by holding the CLK signal high (i.e.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNC_CLK_STOP",
        "set this bit to 1 will stop the source synchronous mode clk.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_CLK_STOP",
        "set this bit to 1 will stop gpmi io working clk.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_TIMING0.
static const field_t hw_gpmi_timing0[] =
{
    {
        "DATA_SETUP",
        "Data bus setup time in GPMICLK cycles.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_HOLD",
        "Data bus hold time in GPMICLK cycles.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_SETUP",
        "Number of GPMICLK cycles that the CE/ADDR signals are active before a "
        "strobe is asserted.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Always write zeroes to this bit field.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_TIMING1.
static const field_t hw_gpmi_timing1[] =
{
    {
        "RSVD1",
        "Always write zeroes to this bit field.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVICE_BUSY_TIMEOUT",
        "Timeout waiting for NAND Ready/Busy or ATA IRQ.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_TIMING2.
static const field_t hw_gpmi_timing2[] =
{
    {
        "DATA_PAUSE",
        "GPMI delay time from data pause to data resume in GPMICLK cycles.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDADD_PAUSE",
        "GPMI delay time from command or addres pause to command or address res"
        "ume in GPMICLK cycles.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTAMBLE_DELAY",
        "GPMI post-amble delay in GPMICLK cycles.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREAMBLE_DELAY",
        "GPMI pre-amble delay in GPMICLK cycles.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CE_DELAY",
        "GPMI dealy from CEn assert to W/Rn changing edge.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Always write zeroes to this bit field.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "READ_LATENCY",
        "This field is for double data rate read latency configuration.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCR",
        "Only for Toggle NAND timing control delay (TCR+1) GPMICLK cycles for C"
        "En_B low to RE_B low, 0 is less than or equal to TCR, which is less th"
        "an the PREAMBLE_DELAY",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPSTH",
        "Only for Toggle NAND timing control delay TRPSTH GPMICLK cycles for CE"
        "n_B high to RE_B high, A value of zero is interpreted as 8",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_DATA.
static const field_t hw_gpmi_data[] =
{
    {
        "DATA",
        "In 8-bit mode, one, two, three or four bytes can can be accessed to se"
        "nd the same number of bus cycles.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_STAT.
static const field_t hw_gpmi_stat[] =
{
    {
        "PRESENT",
        "UNAVAILABLE = 0x0 GPMI is not present in this product.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIFO_FULL",
        "NOT_FULL = 0x0 FIFO is not full.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIFO_EMPTY",
        "NOT_EMPTY = 0x0 FIFO is not empty.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INVALID_BUFFER_MASK",
        "Buffer Mask Validity bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ATA_IRQ",
        "Status of the ATA_IRQ input pin.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Always write zeroes to this bit field.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV0_ERROR",
        "DMA channel 0 (Timeout or compare failure, depending on COMMAND_MODE).",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV1_ERROR",
        "DMA channel 1 (Timeout or compare failure, depending on COMMAND_MODE).",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV2_ERROR",
        "DMA channel 2 (Timeout or compare failure, depending on COMMAND_MODE).",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV3_ERROR",
        "DMA channel 3 (Timeout or compare failure, depending on COMMAND_MODE).",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV4_ERROR",
        "DMA channel 4 (Timeout or compare failure, depending on COMMAND_MODE).",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV5_ERROR",
        "DMA channel 5 (Timeout or compare failure, depending on COMMAND_MODE).",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV6_ERROR",
        "DMA channel 6 (Timeout or compare failure, depending on COMMAND_MODE).",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV7_ERROR",
        "DMA channel 7 (Timeout or compare failure, depending on COMMAND_MODE).",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDY_TIMEOUT",
        "State of the RDY/BUSY Timeout Flags.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "READY_BUSY",
        "Read-only view of NAND Ready_Busy Input pins.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_DEBUG.
static const field_t hw_gpmi_debug[] =
{
    {
        "CMD_END",
        "Read Only view of the Command End toggle signals to DMA.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMAREQ",
        "Read-only view of DMA request line for 8 DMA channels.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_SENSE",
        "Read-only view of sense state of the 8 DMA channels.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT_FOR_READY_END",
        "Read Only view of the Wait_For_Ready End toggle signals to DMA.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_VERSION.
static const field_t hw_gpmi_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_DEBUG2.
static const field_t hw_gpmi_debug2[] =
{
    {
        "RDN_TAP",
        "This is the DLL tap calculated by the DLL controller.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UPDATE_WINDOW",
        "A 1 indicates that the DLL is busy generating the required delay.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VIEW_DELAYED_RDN",
        "Set to a 1 to select the delayed feedback RE_B to drive the GPMI_ADDR["
        "0] (Nand CLE) pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYND2GPMI_READY",
        "Data handshake Input from BCH.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYND2GPMI_VALID",
        "Data handshake Input from BCH.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPMI2SYND_READY",
        "Data handshake output to BCH.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPMI2SYND_VALID",
        "Data handshake output to BCH.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYND2GPMI_BE",
        "Data byte enable Input from BCH.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAIN_STATE",
        "parameter MSM_IDLE = 4'h0, MSM_BYTCNT = 4'h1, MSM_WAITFE = 4'h2, MSM_W"
        "AITFR = 4'h3, MSM_DMAREQ = 4'h4, MSM_DMAACK = 4'h5, MSM_WAITFF = 4'h6,"
        " MSM_LDFIFO = 4'h7, MSM_LDDMAR = 4'h8, MSM_RDCMP = 4'h9, MSM_DONE = 4'"
        "hA.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIN_STATE",
        "parameter PSM_IDLE = 3'h0, PSM_BYTCNT = 3'h1, PSM_ADDR = 3'h2, PSM_STA"
        "LL = 3'h3, PSM_STROBE = 3'h4, PSM_ATARDY = 3'h5, PSM_DHOLD = 3'h6, PSM"
        "_DONE = 3'h7.",
        20, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        "When asserted the GPMI is busy.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UDMA_STATE",
        "USM_IDLE = 4'h0, idle USM_DMARQ = 4'h1, DMA req USM_ACK = 4'h2, DMA AC"
        "K USM_FIFO_E = 4'h3, Fifo empty USM_WPAUSE = 4'h4, WR DMA Paused by de"
        "vice USM_TSTRB = 4'h5, Toggle HSTROBE USM_CAPTUR = 4'h6, Capture Stage"
        ", (data sampled with DSTROBE is valid) USM_DATOUT = 4'h7, Change Burst"
        " DATAOUT USM_CRC = 4'h8, Source CRC to Device USM_WAIT_R = 4'h9, Waiti"
        "ng for DDMARDY- USM_END = 4'ha; Negate DMAACK (end of DMA) USM_WAIT_S "
        "= 4'hb, Waiting for DSTROBE USM_RPAUSE = 4'hc, Rd DMA Paused by Host U"
        "SM_RSTOP = 4'hd, Rd DMA Stopped by Host USM_WTERM = 4'he, Wr DMA Termi"
        "nation State USM_RTERM = 4'hf, Rd DMA Termination state",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Always write zeroes to this bit field.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_DEBUG3.
static const field_t hw_gpmi_debug3[] =
{
    {
        "DEV_WORD_CNTR",
        "Reflects the number of bytes remains to be transferred on the ATA/Nand"
        " bus.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_WORD_CNTR",
        "Reflects the number of bytes remains to be transferred on the APB bus.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_READ_DDR_DLL_CTRL.
static const field_t hw_gpmi_read_ddr_dll_ctrl[] =
{
    {
        "ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_DLY_TARGET",
        "The delay target for the read clock is can be programmed in 1/16th inc"
        "rements of an GPMICLK half-period.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GATE_UPDATE",
        "Setting this bit to 1, forces the slave delay line not update",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFCLK_ON",
        "set this bit to 1 will turn on the reference clock",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE=1 This field is used to select 1 of 256 physical tap"
        "s manually.",
        10, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLV_UPDATE_INT",
        "Setting a value greater than 0 in this field, shall over-ride the defa"
        "ult slave delay-line update interval of 256 GPMICLK cycles.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_UPDATE_INT",
        "This field allows the user to add additional delay cycles to the DLL c"
        "ontrol loop (reference delay line control).",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_WRITE_DDR_DLL_CTRL.
static const field_t hw_gpmi_write_ddr_dll_ctrl[] =
{
    {
        "ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_DLY_TARGET",
        "The delay target for the read clock can be programmed in 1/16th increm"
        "ents of an GPMICLK half-period.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GATE_UPDATE",
        "Setting this bit to 1, forces the slave delay line not update",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFCLK_ON",
        "set this bit to 1 will turn on the reference clock",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE=1 This field is used to select 1 of 256 physical tap"
        "s manually.",
        10, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLV_UPDATE_INT",
        "Setting a value greater than 0 in this field, shall over-ride the defa"
        "ult slave delay-line update interval of 256 GPMICLK cycles.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_UPDATE_INT",
        "This field allows the user to add additional delay cycles to the DLL c"
        "ontrol loop (reference delay line control).",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_READ_DDR_DLL_STS.
static const field_t hw_gpmi_read_ddr_dll_sts[] =
{
    {
        "SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLV_SEL",
        "Slave delay line select status",
        1, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD0",
        "Reserved",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REF_LOCK",
        "Reference DLL lock status.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REF_SEL",
        "Reference delay line select status.",
        17, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_WRITE_DDR_DLL_STS.
static const field_t hw_gpmi_write_ddr_dll_sts[] =
{
    {
        "SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLV_SEL",
        "Slave delay line select status",
        1, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD0",
        "Reserved",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REF_LOCK",
        "Reference DLL lock status.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REF_SEL",
        "Reference delay line select status.",
        17, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPMI module.
static const reg_t hw_gpmi[] =
{
    {
        "CTRL0",
        "The GPMI control register 0 specifies the GPMI transaction to perform "
        "for the current command chain item.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpmi_ctrl0
    },
    {
        "CTRL0_SET",
        "The GPMI control register 0 specifies the GPMI transaction to perform "
        "for the current command chain item.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpmi_ctrl0_set
    },
    {
        "CTRL0_CLR",
        "The GPMI control register 0 specifies the GPMI transaction to perform "
        "for the current command chain item.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpmi_ctrl0_clr
    },
    {
        "CTRL0_TOG",
        "The GPMI control register 0 specifies the GPMI transaction to perform "
        "for the current command chain item.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpmi_ctrl0_tog
    },
    {
        "COMPARE",
        "The GPMI compare register specifies the expect data and the xor mask f"
        "or comparing to the status values read from the device.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_compare
    },
    {
        "ECCCTRL",
        "The GPMI ECC control register handles configuration of the integrated "
        "ECC / Randomizer accelerator.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpmi_eccctrl
    },
    {
        "ECCCTRL_SET",
        "The GPMI ECC control register handles configuration of the integrated "
        "ECC / Randomizer accelerator.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpmi_eccctrl_set
    },
    {
        "ECCCTRL_CLR",
        "The GPMI ECC control register handles configuration of the integrated "
        "ECC / Randomizer accelerator.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpmi_eccctrl_clr
    },
    {
        "ECCCTRL_TOG",
        "The GPMI ECC control register handles configuration of the integrated "
        "ECC / Randomizer accelerator.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpmi_eccctrl_tog
    },
    {
        "ECCCOUNT",
        "The GPMI ECC Transfer Count Register contains the count of bytes that "
        "flow through the ECC / Randomizer subsystem.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_ecccount
    },
    {
        "PAYLOAD",
        "The GPMI payload address register specifies the location of the data b"
        "uffers in system memory.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_payload
    },
    {
        "AUXILIARY",
        "The GPMI auxiliary address register specifies the location of the auxi"
        "liary buffers in system memory.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_auxiliary
    },
    {
        "CTRL1",
        "The GPMI control register 1 specifies additional control fields that a"
        "re not used on a per-transaction basis.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_gpmi_ctrl1
    },
    {
        "CTRL1_SET",
        "The GPMI control register 1 specifies additional control fields that a"
        "re not used on a per-transaction basis.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_gpmi_ctrl1_set
    },
    {
        "CTRL1_CLR",
        "The GPMI control register 1 specifies additional control fields that a"
        "re not used on a per-transaction basis.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_gpmi_ctrl1_clr
    },
    {
        "CTRL1_TOG",
        "The GPMI control register 1 specifies additional control fields that a"
        "re not used on a per-transaction basis.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_gpmi_ctrl1_tog
    },
    {
        "TIMING0",
        "The GPMI timing register 0 specifies the timing parameters that are us"
        "ed by the cycle state machine to guarantee the various setup, hold and"
        " cycle times for the external media type.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpmi_timing0
    },
    {
        "TIMING1",
        "The GPMI timing register 1 specifies the timeouts used when monitoring"
        " the NAND READY pin or the ATA IRQ and IOWAIT signals.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_timing1
    },
    {
        "TIMING2",
        "The GPMI timing register 2 specifies the double data rate timing param"
        "eters that are used by the cycle state machine to guarantee the variou"
        "s cs delay, pre-amble delay, post-amble delay, command/address delay, "
        "data delay, TCR, TRPSTH, and read latency cycle times for the external"
        " media type.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_gpmi_timing2
    },
    {
        "DATA",
        "The GPMI DMA data transfer register is used by the DMA to read or writ"
        "e data to or from the ATA/NAND control state machine.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpmi_data
    },
    {
        "STAT",
        "The GPMI control and status register provides a read back path for var"
        "ious operational states of the GPMI controller.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        false, // Writable
        16, // Number of bitfields
        hw_gpmi_stat
    },
    {
        "DEBUG",
        "The GPMI debug information register provides a read back path for diag"
        "nostics to determine the current operating state of the GPMI controlle"
        "r.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_gpmi_debug
    },
    {
        "VERSION",
        "This register reflects the version number for the GPMI.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_gpmi_version
    },
    {
        "DEBUG2",
        "The GPMI Debug2 information register provides a read back path for dia"
        "gnostics to determine the current operating state of the GPMI contro"
        "ller.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_gpmi_debug2
    },
    {
        "DEBUG3",
        "The GPMI Debug3 information register provides a read back path for dia"
        "gnostics to determine the current operating state of the GPMI contro"
        "ller.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_gpmi_debug3
    },
    {
        "READ_DDR_DLL_CTRL",
        "GPMI DDR Read Delay Loop Lock Control Register.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_gpmi_read_ddr_dll_ctrl
    },
    {
        "WRITE_DDR_DLL_CTRL",
        "GPMI DDR Write Delay Loop Lock Control Register.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_gpmi_write_ddr_dll_ctrl
    },
    {
        "READ_DDR_DLL_STS",
        "GPMI Double Rate Read DLL Status Register, Read Only.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_gpmi_read_ddr_dll_sts
    },
    {
        "WRITE_DDR_DLL_STS",
        "GPMI Double Rate Write DLL Status Register, Read Only.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_gpmi_write_ddr_dll_sts
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPT
#endif

// Bitfields in register GPT_CR.
static const field_t hw_gpt_cr[] =
{
    {
        "EN",
        "GPT Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENMOD",
        "GPT Enable mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "GPT debug mode enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "GPT Wait Mode enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEEN",
        "GPT Doze Mode Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "GPT Stop Mode enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Clock Source select.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRR",
        "Free-Run or Restart mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "24MEN",
        "Enable 24MHz clock input from crystal.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software reset.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IM1",
        "See IM2",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IM2",
        "IM2 (bits 19-18, Input Capture Channel 2 operating mode) IM1 (bits 17-"
        "16, Input Capture Channel 1 operating mode) The IMn bit field determin"
        "es the transition on the input pin (for Input capture channel n), whic"
        "h will trigger a capture event.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM1",
        "See OM3",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM2",
        "See OM3",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM3",
        "OM3 (bits 28-26) controls the Output Compare Channel 3 operating mode.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FO1",
        "See F03",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FO2",
        "See F03",
        30, // LSB
        30, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FO3",
        "FO3 Force Output Compare Channel 3 FO2 Force Output Compare Channel 2 "
        "FO1 Force Output Compare Channel 1 The FOn bit causes the pin action p"
        "rogrammed for the timer Output Compare n pin (according to the OMn bit"
        "s in this register).",
        31, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_PR.
static const field_t hw_gpt_pr[] =
{
    {
        "PRESCALER",
        "Prescaler bits.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER24M",
        "Prescaler bits.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_SR.
static const field_t hw_gpt_sr[] =
{
    {
        "OF1",
        "See OF3",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2",
        "See OF3",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF3",
        "OF3 Output Compare 3 Flag OF2 Output Compare 2 Flag OF1 Output Compare"
        " 1 Flag The OFn bit indicates that a compare event has occurred on Out"
        "put Compare channel n.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF1",
        "See IF2",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF2",
        "IF2 Input capture 2 Flag IF1 Input capture 1 Flag The IFn bit indicate"
        "s that a capture event has occurred on Input Capture channel n.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROV",
        "Rollover Flag.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_IR.
static const field_t hw_gpt_ir[] =
{
    {
        "OF1IE",
        "See OF3IE",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2IE",
        "See OF3IE",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF3IE",
        "OF3IE Output Compare 3 Interrupt Enable OF2IE Output Compare 2 Interru"
        "pt Enable OF1IE Output Compare 1 Interrupt Enable The OFnIE bit contro"
        "ls the Output Compare Channel n interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF1IE",
        "See IF2IE",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF2IE",
        "IF2IE Input capture 2 Interrupt Enable IF1IE Input capture 1 Interrupt"
        " Enable The IFnIE bit controls the IFnIE Input Capture n Interrupt Ena"
        "ble.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROVIE",
        "Rollover Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR1.
static const field_t hw_gpt_ocr1[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR2.
static const field_t hw_gpt_ocr2[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR3.
static const field_t hw_gpt_ocr3[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_ICR1.
static const field_t hw_gpt_icr1[] =
{
    {
        "CAPT",
        "Capture Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_ICR2.
static const field_t hw_gpt_icr2[] =
{
    {
        "CAPT",
        "Capture Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_CNT.
static const field_t hw_gpt_cnt[] =
{
    {
        "COUNT",
        "Counter Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPT module.
static const reg_t hw_gpt[] =
{
    {
        "CR",
        "The GPT Control Register (GPT_CR) is used to program and configure GPT"
        " operations.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_gpt_cr
    },
    {
        "PR",
        "The GPT Prescaler Register (GPT_PR) contains bits that determine the d"
        "ivide value of the clock that runs the counter.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpt_pr
    },
    {
        "SR",
        "The GPT Status Register (GPT_SR) contains bits that indicate that a co"
        "unter has rolled over, and if any event has occurred on the Input Capt"
        "ure and Output Compare channels.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpt_sr
    },
    {
        "IR",
        "The GPT Interrupt Register (GPT_IR) contains bits that control whether"
        " interrupts are generated after rollover, input capture and output com"
        "pare events.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpt_ir
    },
    {
        "OCR1",
        "The GPT Compare Register 1 (GPT_OCR1) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 1.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr1
    },
    {
        "OCR2",
        "The GPT Compare Register 2 (GPT_OCR2) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 2.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr2
    },
    {
        "OCR3",
        "The GPT Compare Register 3 (GPT_OCR3) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 3.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr3
    },
    {
        "ICR1",
        "The GPT Input Capture Register 1 (GPT_ICR1) is a read-only register th"
        "at holds the value that was in the counter during the last capture eve"
        "nt on Input Capture Channel 1.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_icr1
    },
    {
        "ICR2",
        "The GPT Input capture Register 2 (GPT_ICR2) is a read-only register wh"
        "ich holds the value that was in the counter during the last capture ev"
        "ent on input capture channel 2.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_icr2
    },
    {
        "CNT",
        "The GPT Counter Register (GPT_CNT) is the main counter's register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_cnt
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark I2C
#endif

// Bitfields in register I2C_IADR.
static const field_t hw_i2c_iadr[] =
{
    {
        "ADR",
        "Slave address.",
        1, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_IFDR.
static const field_t hw_i2c_ifdr[] =
{
    {
        "IC",
        "I2C clock rate.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2CR.
static const field_t hw_i2c_i2cr[] =
{
    {
        "RSTA",
        "Repeat start.",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXAK",
        "Transmit acknowledge enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MTX",
        "Transmit/Receive mode select bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSTA",
        "Master/Slave mode select bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IIEN",
        "I2C interrupt enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IEN",
        "I2C enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2SR.
static const field_t hw_i2c_i2sr[] =
{
    {
        "RXAK",
        "Received acknowledge.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IIF",
        "I2C interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRW",
        "Slave read/write.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAL",
        "Arbitration lost.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBB",
        "I2C bus busy bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAAS",
        "I2C addressed as a slave bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ICF",
        "Data transferring bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2DR.
static const field_t hw_i2c_i2dr[] =
{
    {
        "DATA",
        "Data Byte.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a I2C module.
static const reg_t hw_i2c[] =
{
    {
        "IADR",
        "",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_iadr
    },
    {
        "IFDR",
        "The I2C_IFDR provides a programmable prescaler to configure the clock "
        "for bit-rate selection.",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_ifdr
    },
    {
        "I2CR",
        "The I2C_I2CR is used to enable the I2C and the I2C interrupt.",
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_i2c_i2cr
    },
    {
        "I2SR",
        "The I2C_I2SR contains bits that indicate transaction direction and sta"
        "tus.",
        2, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_i2c_i2sr
    },
    {
        "I2DR",
        "In Master Receive mode, reading the data register allows a read to occ"
        "ur and initiates the next byte to be received.",
        2, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_i2dr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark I2S
#endif

// Bitfields in register I2S_TCSR.
static const field_t hw_i2s_tcsr[] =
{
    {
        "FRDE",
        "Enables/disables DMA requests.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWDE",
        "Enables/disables DMA requests.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRIE",
        "Enables/disables FIFO request interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWIE",
        "Enables/disables FIFO warning interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "Enables/disables FIFO error interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEIE",
        "Enables/disables sync error interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSIE",
        "Enables/disables word start interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRF",
        "Indicates that the number of words in an enabled transmit channel FIFO"
        " is less than or equal to the transmit FIFO watermark.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWF",
        "Indicates that an enabled transmit FIFO is empty.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FEF",
        "Indicates that an enabled transmit FIFO has underrun.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEF",
        "Indicates that an error in the externally-generated frame sync has bee"
        "n detected.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSF",
        "Indicates that the start of the configured word has been detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SR",
        "When set, resets the internal transmitter logic including the FIFO poi"
        "nters.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "Resets the FIFO pointers.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BCE",
        "Enables the transmit bit clock, separately from the TE.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables/disables transmitter operation in Debug mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPE",
        "Configures transmitter operation in Stop mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        "Enables/disables the transmitter.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR1.
static const field_t hw_i2s_tcr1[] =
{
    {
        "TFW",
        "Configures the watermark level for all enabled transmit channels.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR2.
static const field_t hw_i2s_tcr2[] =
{
    {
        "DIV",
        "Divides down the audio master clock to generate the bit clock when con"
        "figured for an internal bit clock.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Configures the direction of the bit clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCP",
        "Configures the polarity of the bit clock.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "Selects the audio Master Clock option used to generate an internally g"
        "enerated bit clock.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCI",
        "When this field is set and using an internally generated bit clock in "
        "either synchronous or asynchronous mode, the bit clock actually used b"
        "y the transmitter is delayed by the pad output delay (the transmitter "
        "is clocked by the pad input as if the clock was externally generated).",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "This field swaps the bit clock used by the transmitter.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "Configures between asynchronous and synchronous modes of operation.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR3.
static const field_t hw_i2s_tcr3[] =
{
    {
        "WDFL",
        "Configures which word sets the start of word flag.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE",
        "Enables the corresponding data channel for transmit operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR4.
static const field_t hw_i2s_tcr4[] =
{
    {
        "FSD",
        "Configures the direction of the frame sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSP",
        "Configures the polarity of the frame sync.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MF",
        "Configures whether the LSB or the MSB is transmitted first.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYWD",
        "Configures the length of the frame sync in number of bit clocks.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRSZ",
        "Configures the number of words in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR5.
static const field_t hw_i2s_tcr5[] =
{
    {
        "FBT",
        "Configures the bit index for the first bit transmitted for each word i"
        "n the frame.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W0W",
        "Configures the number of bits in the first word in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNW",
        "Configures the number of bits in each word, for each word except the f"
        "irst in the frame.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TDR0.
static const field_t hw_i2s_tdr0[] =
{
    {
        "TDR",
        "The corresponding TCR3[TCE] bit must be set before accessing the chann"
        "el's transmit data register.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TFR0.
static const field_t hw_i2s_tfr0[] =
{
    {
        "RFP",
        "FIFO read pointer for transmit data channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for transmit data channel.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TMR.
static const field_t hw_i2s_tmr[] =
{
    {
        "TWM",
        "Configures whether the transmit word is masked (transmit data pin tris"
        "tated and transmit data not read from FIFO) for the corresponding word"
        " in the frame.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCSR.
static const field_t hw_i2s_rcsr[] =
{
    {
        "FRDE",
        "Enables/disables DMA requests.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWDE",
        "Enables/disables DMA requests.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRIE",
        "Enables/disables FIFO request interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWIE",
        "Enables/disables FIFO warning interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "Enables/disables FIFO error interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEIE",
        "Enables/disables sync error interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSIE",
        "Enables/disables word start interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRF",
        "Indicates that the number of words in an enabled receive channel FIFO "
        "is greater than the receive FIFO watermark.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWF",
        "Indicates that an enabled receive FIFO is full.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FEF",
        "Indicates that an enabled receive FIFO has overflowed.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEF",
        "Indicates that an error in the externally-generated frame sync has bee"
        "n detected.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSF",
        "Indicates that the start of the configured word has been detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SR",
        "Resets the internal receiver logic including the FIFO pointers.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "Resets the FIFO pointers.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BCE",
        "Enables the receive bit clock, separately from RE.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables/disables receiver operation in Debug mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPE",
        "Configures receiver operation in Stop mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        "Enables/disables the receiver.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR1.
static const field_t hw_i2s_rcr1[] =
{
    {
        "RFW",
        "Configures the watermark level for all enabled receiver channels.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR2.
static const field_t hw_i2s_rcr2[] =
{
    {
        "DIV",
        "Divides down the audio master clock to generate the bit clock when con"
        "figured for an internal bit clock.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Configures the direction of the bit clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCP",
        "Configures the polarity of the bit clock.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "Selects the audio Master Clock option used to generate an internally g"
        "enerated bit clock.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCI",
        "When this field is set and using an internally generated bit clock in "
        "either synchronous or asynchronous mode, the bit clock actually used b"
        "y the receiver is delayed by the pad output delay (the receiver is clo"
        "cked by the pad input as if the clock was externally generated).",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "This field swaps the bit clock used by the receiver.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "Configures between asynchronous and synchronous modes of operation.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR3.
static const field_t hw_i2s_rcr3[] =
{
    {
        "WDFL",
        "Configures which word the start of word flag is set.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCE",
        "Enables the corresponding data channel for receive operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR4.
static const field_t hw_i2s_rcr4[] =
{
    {
        "FSD",
        "Configures the direction of the frame sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSP",
        "Configures the polarity of the frame sync.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MF",
        "Configures whether the LSB or the MSB is received first.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYWD",
        "Configures the length of the frame sync in number of bit clocks.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRSZ",
        "Configures the number of words in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR5.
static const field_t hw_i2s_rcr5[] =
{
    {
        "FBT",
        "Configures the bit index for the first bit received for each word in t"
        "he frame.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W0W",
        "Configures the number of bits in the first word in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNW",
        "Configures the number of bits in each word, for each word except the f"
        "irst in the frame.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RDR0.
static const field_t hw_i2s_rdr0[] =
{
    {
        "RDR",
        "The corresponding RCR3[RCE] bit must be set before accessing the chann"
        "el's receive data register.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RFR0.
static const field_t hw_i2s_rfr0[] =
{
    {
        "RFP",
        "FIFO read pointer for receive data channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for receive data channel.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RMR.
static const field_t hw_i2s_rmr[] =
{
    {
        "RWM",
        "Configures whether the receive word is masked (received data ignored a"
        "nd not written to receive FIFO) for the corresponding word in the fram"
        "e.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a I2S module.
static const reg_t hw_i2s[] =
{
    {
        "TCSR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_i2s_tcsr
    },
    {
        "TCR1",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_tcr1
    },
    {
        "TCR2",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_i2s_tcr2
    },
    {
        "TCR3",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_i2s_tcr3
    },
    {
        "TCR4",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_i2s_tcr4
    },
    {
        "TCR5",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_i2s_tcr5
    },
    {
        "TDR0",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_tdr0
    },
    {
        "TFR0",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_i2s_tfr0
    },
    {
        "TMR",
        "This register is double-buffered and updates: When TCSR[TE] is first s"
        "et At the end of each frame.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_tmr
    },
    {
        "RCSR",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_i2s_rcsr
    },
    {
        "RCR1",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_rcr1
    },
    {
        "RCR2",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_i2s_rcr2
    },
    {
        "RCR3",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_i2s_rcr3
    },
    {
        "RCR4",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_i2s_rcr4
    },
    {
        "RCR5",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_i2s_rcr5
    },
    {
        "RDR0",
        "Reading this register introduces one additional peripheral clock wait "
        "state on each read.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_i2s_rdr0
    },
    {
        "RFR0",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_i2s_rfr0
    },
    {
        "RMR",
        "This register is double-buffered and updates: When RCSR[RE] is first s"
        "et At the end of each frame This allows the masked words in each frame"
        " to change from frame to frame.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_rmr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC
#endif

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io00[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: GPIO1_IO00.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io01[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: GPIO1_IO01.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO02.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io02[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: GPIO1_IO02.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io03[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: GPIO1_IO03.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io04[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: GPIO1_IO04.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io05[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: GPIO1_IO05.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io06[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: GPIO1_IO06.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io07[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: GPIO1_IO07.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io08[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: GPIO1_IO08.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io09[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: GPIO1_IO09.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO10.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io10[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: GPIO1_IO10.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO11.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io11[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: GPIO1_IO11.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO12.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io12[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: GPIO1_IO12.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO13.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io13[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: GPIO1_IO13.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA00.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data00[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_DATA00.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA01.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data01[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_DATA01.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA02.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data02[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_DATA02.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA03.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data03[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_DATA03.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA04.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data04[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_DATA04.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA05.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data05[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_DATA05.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA06.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data06[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_DATA06.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA07.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data07[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_DATA07.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_HSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_hsync[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: CSI_HSYNC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_MCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_mclk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: CSI_MCLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_PIXCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_pixclk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: CSI_PIXCLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_VSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_vsync[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: CSI_VSYNC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_COL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_col[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET1_COL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_CRS.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_crs[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET1_CRS.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_MDC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_mdc[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET1_MDC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_MDIO.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_mdio[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: ENET1_MDIO.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_RX_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_rx_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET1_RX_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_TX_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_tx_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET1_TX_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_COL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_col[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET2_COL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_CRS.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_crs[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET2_CRS.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_RX_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_rx_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET2_RX_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_TX_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_tx_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: ENET2_TX_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_COL0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_COL1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_COL2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_COL3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col4[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_COL4.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_ROW0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: KEY_ROW1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_ROW2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_ROW3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row4[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: KEY_ROW4.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA00.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data00[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA00.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA01.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data01[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA01.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA02.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data02[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA02.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA03.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data03[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA03.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA04.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data04[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA04.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA05.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data05[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA05.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA06.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data06[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA06.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA07.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data07[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA07.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA08.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data08[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA08.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA09.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data09[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA09.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA10.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data10[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA10.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA11.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data11[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA11.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA12.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data12[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA12.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA13.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data13[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA13.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA14.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data14[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA14.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA15.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data15[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA15.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA16.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data16[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA16.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA17.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data17[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA17.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA18.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data18[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA18.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA19.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data19[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: LCD1_DATA19.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA20.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data20[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA20.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA21.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data21[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA21.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA22.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data22[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA22.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_DATA23.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_data23[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_DATA23.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_ENABLE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_enable[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_ENABLE.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_HSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_hsync[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_HSYNC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_RESET.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_reset[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_RESET.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD1_VSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd1_vsync[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: LCD1_VSYNC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_ALE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_ale[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_ALE.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_CE0_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_ce0_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_CE0_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_ce1_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_CE1_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_CLE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_cle[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_CLE.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA00.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data00[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_DATA00.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA01.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data01[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_DATA01.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA02.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data02[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_DATA02.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA03.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data03[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_DATA03.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA04.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data04[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_DATA04.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA05.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data05[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_DATA05.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA06.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data06[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_DATA06.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA07.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data07[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_DATA07.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_RE_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_re_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_RE_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_READY_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_ready_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_READY_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_WE_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_we_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_WE_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_WP_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_wp_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: NAND_WP_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1A_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1a_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1A_DATA0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1A_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1a_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1A_DATA1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1A_DATA2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1a_data2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1A_DATA2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1A_DATA3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1a_data3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1A_DATA3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1A_DQS.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1a_dqs[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1A_DQS.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1A_SCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1a_sclk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1A_SCLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1A_SS0_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1a_ss0_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1A_SS0_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1A_SS1_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1a_ss1_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1A_SS1_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1B_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1b_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1B_DATA0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1B_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1b_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1B_DATA1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1B_DATA2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1b_data2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1B_DATA2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1B_DATA3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1b_data3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1B_DATA3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1B_DQS.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1b_dqs[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1B_DQS.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1B_SCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1b_sclk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1B_SCLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1B_SS0_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1b_ss0_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1B_SS0_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_QSPI1B_SS1_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_qspi1b_ss1_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: QSPI1B_SS1_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_RD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_rd0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 3 iomux modes to be used for pad: RGMII1_RD0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_RD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_rd1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 3 iomux modes to be used for pad: RGMII1_RD1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_RD2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_rd2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 3 iomux modes to be used for pad: RGMII1_RD2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_RD3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_rd3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 3 iomux modes to be used for pad: RGMII1_RD3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_RX_CTL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_rx_ctl[] =
{
    {
        "MUX_MODE",
        "Select 1 of 3 iomux modes to be used for pad: RGMII1_RX_CTL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_RXC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_rxc[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII1_RXC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_TD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_td0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII1_TD0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_TD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_td1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII1_TD1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_TD2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_td2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII1_TD2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_TD3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_td3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII1_TD3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_TX_CTL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_tx_ctl[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII1_TX_CTL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII1_TXC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii1_txc[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: RGMII1_TXC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_RD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_rd0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII2_RD0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_RD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_rd1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII2_RD1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_RD2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_rd2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII2_RD2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_RD3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_rd3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII2_RD3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_RX_CTL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_rx_ctl[] =
{
    {
        "MUX_MODE",
        "Select 1 of 3 iomux modes to be used for pad: RGMII2_RX_CTL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_RXC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_rxc[] =
{
    {
        "MUX_MODE",
        "Select 1 of 4 iomux modes to be used for pad: RGMII2_RXC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_TD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_td0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: RGMII2_TD0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_TD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_td1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: RGMII2_TD1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_TD2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_td2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: RGMII2_TD2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_TD3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_td3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: RGMII2_TD3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_TX_CTL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_tx_ctl[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: RGMII2_TX_CTL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_RGMII2_TXC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_rgmii2_txc[] =
{
    {
        "MUX_MODE",
        "Select 1 of 5 iomux modes to be used for pad: RGMII2_TXC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD1_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_cmd[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD1_CMD.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: SD1_DATA0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD1_DATA1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DATA2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_data2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD1_DATA2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DATA3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_data3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD1_DATA3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD2_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_cmd[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD2_CMD.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD2_DATA0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD2_DATA1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DATA2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_data2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD2_DATA2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DATA3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_data3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD2_DATA3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_cmd[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_CMD.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_DATA0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_DATA1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DATA2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_data2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_DATA2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DATA3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_data3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_DATA3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DATA4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_data4[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_DATA4.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DATA5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_data5[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_DATA5.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DATA6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_data6[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_DATA6.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DATA7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_data7[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD3_DATA7.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_CLK.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_cmd[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_CMD.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_DATA0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_DATA1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DATA2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_data2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_DATA2.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DATA3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_data3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_DATA3.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DATA4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_data4[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD4_DATA4.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DATA5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_data5[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_DATA5.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DATA6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_data6[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_DATA6.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_DATA7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_data7[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: SD4_DATA7.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD4_RESET_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd4_reset_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: SD4_RESET_B.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_USB_H_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_usb_h_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: USB_H_DATA.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_USB_H_STROBE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_usb_h_strobe[] =
{
    {
        "MUX_MODE",
        "Select 1 of 6 iomux modes to be used for pad: USB_H_STROBE.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr00[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR00.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR00.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR00.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr01[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR01.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR01.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR01.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr02[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR02.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR02.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR02.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr03[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR03.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR03.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR03.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr04[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR04.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR04.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR04.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr05[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR05.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR05.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR05.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr06[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR06.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR06.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR06.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr07[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR07.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR07.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR07.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR08.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr08[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR08.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR08.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR08.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR09.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr09[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR09.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR09.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR09.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr10[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR10.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR10.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR10.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_ADDR10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr11[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR11.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR11.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR11.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_ADDR11.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr12[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR12.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR12.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR12.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_ADDR12.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr13[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR13.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR13.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR13.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_ADDR13.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr14[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR14.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR14.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR14.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_ADDR14.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr15[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ADDR15.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ADDR15.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ADDR15.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_ADDR15.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm0[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_DQM0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_DQM0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_DQM0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_DQM0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm1[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_DQM1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_DQM1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_DQM1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_DQM1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm2[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_DQM2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_DQM2.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_DQM2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_DQM2.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm3[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_DQM3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_DQM3.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_DQM3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_DQM3.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_ras_b[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_RAS_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_RAS_B.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_RAS_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_RAS_B.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_RAS_B.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cas_b[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_CAS_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_CAS_B.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_CAS_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_CAS_B.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_CAS_B.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cs0_b[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_CTLDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_CS0_B.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_CS0_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_CS0_B.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_CS0_B.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cs1_b[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_CTLDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_CS1_B.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_CS1_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_CS1_B.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_CS1_B.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdwe_b[] =
{
    {
        "DSE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_SDWE_B.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_SDWE_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_SDWE_B.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDWE_B.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ODT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_odt0[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_ODT0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ODT0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_ODT0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_ODT0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_ODT0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ODT0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ODT0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_ODT0.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ODT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_odt1[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_ODT1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_ODT1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_ODT1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_ODT1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_ODT1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_ODT1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_ODT1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_ODT1.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba0[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_ADDDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_SDBA0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_SDBA0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_SDBA0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDBA0.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba1[] =
{
    {
        "DSE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_SDBA1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_SDBA1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_SDBA1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDBA1.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba2[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_CTLDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_SDBA2.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_SDBA2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_SDBA2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_SDBA2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_SDBA2.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDBA2.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdcke0[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_CTLDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_SDCKE0.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_SDCKE0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_SDCKE0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_SDCKE0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_SDCKE0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_SDCKE0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDCKE0.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdcke1[] =
{
    {
        "DSE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_CTLDSPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_SDCKE1.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_SDCKE1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_SDCKE1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_SDCKE1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_SDCKE1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_SDCKE1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDCKE1.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK0_P.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdclk0_p[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_SDCLK0_P.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_SDCLK0_P.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKEPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRPKPad Group Control Register Note: The value of this "
        "field does not reflect the value of the Group Control Register.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_SDCLK0_P.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_SDCLK0_P.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDCLK0_P.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM_PADN",
        "Select one of next values for pad: DRAM_SDCLK0_P.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_P.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs0_p[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_SDQS0_P.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_SDQS0_P.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_SDQS0_P.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_SDQS0_P.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRHYSPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRMODE_CTLPad Group Control Register Note: The value of"
        " this field does not reflect the value of the Group Control Register.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDQS0_P.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM_PADN",
        "Select one of next values for pad: DRAM_SDQS0_P.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_P.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs1_p[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_SDQS1_P.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_SDQS1_P.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_SDQS1_P.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_SDQS1_P.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRHYSPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRMODE_CTLPad Group Control Register Note: The value of"
        " this field does not reflect the value of the Group Control Register.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDQS1_P.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM_PADN",
        "Select one of next values for pad: DRAM_SDQS1_P.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_P.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs2_p[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_SDQS2_P.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_SDQS2_P.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_SDQS2_P.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_SDQS2_P.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRHYSPad Group Control Register Note: The value of this"
        " field does not reflect the value of the Group Control Register.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDRMODE_CTLPad Group Control Register Note: The value of"
        " this field does not reflect the value of the Group Control Register.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDQS2_P.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM_PADN",
        "Select one of next values for pad: DRAM_SDQS2_P.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_P.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs3_p[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_SDQS3_P.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_SDQS3_P.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_SDQS3_P.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_SDQS3_P.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "This property can be configured using Group Control Register: IOMUXC_S"
        "W_PAD_CTL_GRP_DDR_TYPEPad Group Control Register Note: The value of th"
        "is field does not reflect the value of the Group Control Register.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_SDQS3_P.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM_PADN",
        "Select one of next values for pad: DRAM_SDQS3_P.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_reset[] =
{
    {
        "DSE",
        "Select one of next values for pad: DRAM_RESET.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: DRAM_RESET.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: DRAM_RESET.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: DRAM_RESET.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: DRAM_RESET.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: DRAM_RESET.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: DRAM_RESET.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Select one of next values for pad: DRAM_RESET.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: DRAM_RESET.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_mod[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: JTAG_MOD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: JTAG_MOD.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: JTAG_MOD.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tck[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: JTAG_TCK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: JTAG_TCK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: JTAG_TCK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tdi[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: JTAG_TDI.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: JTAG_TDI.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: JTAG_TDI.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tdo[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: JTAG_TDO.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tms[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: JTAG_TMS.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: JTAG_TMS.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: JTAG_TMS.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TRST_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_trst_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPEED",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: JTAG_TRST_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: JTAG_TRST_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: JTAG_TRST_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io00[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO00.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO00.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO00.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO00.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO00.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO00.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io01[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO01.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO01.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO01.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO01.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO01.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO01.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io02[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO02.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO02.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO02.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO02.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO02.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO02.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io03[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO03.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO03.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO03.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO03.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO03.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO03.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io04[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO04.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO04.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO04.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO04.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO04.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO04.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io05[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO05.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO05.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO05.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO05.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO05.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO05.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io06[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO06.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO06.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO06.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO06.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO06.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO06.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io07[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO07.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO07.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO07.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO07.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO07.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO07.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO08.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io08[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO08.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO08.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO08.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO08.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO08.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO08.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO09.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io09[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO09.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO09.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO09.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO09.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO09.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO09.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io10[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO10.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO10.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO10.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO10.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO10.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO10.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io11[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO11.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO11.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO11.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO11.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO11.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO11.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io12[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO12.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO12.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO12.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO12.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO12.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io13[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: GPIO1_IO13.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: GPIO1_IO13.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: GPIO1_IO13.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: GPIO1_IO13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: GPIO1_IO13.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: GPIO1_IO13.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data00[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_DATA00.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_DATA00.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_DATA00.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_DATA00.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_DATA00.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_DATA00.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data01[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_DATA01.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_DATA01.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_DATA01.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_DATA01.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_DATA01.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_DATA01.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data02[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_DATA02.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_DATA02.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_DATA02.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_DATA02.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_DATA02.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_DATA02.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data03[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_DATA03.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_DATA03.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_DATA03.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_DATA03.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_DATA03.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_DATA03.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data04[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_DATA04.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_DATA04.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_DATA04.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_DATA04.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_DATA04.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_DATA04.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data05[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_DATA05.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_DATA05.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_DATA05.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_DATA05.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_DATA05.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_DATA05.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data06[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_DATA06.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_DATA06.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_DATA06.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_DATA06.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_DATA06.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_DATA06.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data07[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_DATA07.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_DATA07.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_DATA07.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_DATA07.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_DATA07.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_DATA07.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_HSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_hsync[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_HSYNC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_HSYNC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_HSYNC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_HSYNC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_HSYNC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_HSYNC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_MCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_mclk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_MCLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_MCLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_MCLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_MCLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_MCLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_MCLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_PIXCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_pixclk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_PIXCLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_PIXCLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_PIXCLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_PIXCLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_PIXCLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_PIXCLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_VSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_vsync[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: CSI_VSYNC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: CSI_VSYNC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: CSI_VSYNC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: CSI_VSYNC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: CSI_VSYNC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: CSI_VSYNC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_COL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_col[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET1_COL.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET1_COL.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET1_COL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET1_COL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET1_COL.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET1_COL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_CRS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_crs[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET1_CRS.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET1_CRS.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET1_CRS.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET1_CRS.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET1_CRS.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET1_CRS.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_MDC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_mdc[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET1_MDC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET1_MDC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET1_MDC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET1_MDC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET1_MDC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET1_MDC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_MDIO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_mdio[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET1_MDIO.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET1_MDIO.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET1_MDIO.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET1_MDIO.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET1_MDIO.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET1_MDIO.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_RX_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_rx_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET1_RX_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET1_RX_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET1_RX_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET1_RX_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET1_RX_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET1_RX_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_TX_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_tx_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET1_TX_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET1_TX_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET1_TX_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET1_TX_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET1_TX_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET1_TX_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_COL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_col[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET2_COL.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET2_COL.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET2_COL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET2_COL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET2_COL.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET2_COL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_CRS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_crs[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET2_CRS.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET2_CRS.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET2_CRS.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET2_CRS.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET2_CRS.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET2_CRS.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_RX_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_rx_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET2_RX_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET2_RX_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET2_RX_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET2_RX_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET2_RX_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET2_RX_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_TX_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_tx_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: ENET2_TX_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: ENET2_TX_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: ENET2_TX_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: ENET2_TX_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: ENET2_TX_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: ENET2_TX_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_COL0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_COL0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_COL0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_COL0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_COL0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_COL0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_COL1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_COL1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_COL1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_COL1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_COL1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_COL1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_COL2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_COL2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_COL2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_COL2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_COL2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_COL2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_COL3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_COL3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_COL3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_COL3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_COL3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_COL3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col4[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_COL4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_COL4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_COL4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_COL4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_COL4.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_COL4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_ROW0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_ROW0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_ROW0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_ROW0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_ROW0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_ROW0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_ROW1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_ROW1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_ROW1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_ROW1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_ROW1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_ROW1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_ROW2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_ROW2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_ROW2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_ROW2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_ROW2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_ROW2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_ROW3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_ROW3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_ROW3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_ROW3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_ROW3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_ROW3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row4[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: KEY_ROW4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: KEY_ROW4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: KEY_ROW4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: KEY_ROW4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: KEY_ROW4.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: KEY_ROW4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data00[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA00.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA00.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA00.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA00.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA00.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA00.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data01[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA01.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA01.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA01.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA01.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA01.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA01.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data02[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA02.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA02.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA02.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA02.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA02.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA02.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data03[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA03.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA03.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA03.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA03.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA03.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA03.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data04[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA04.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA04.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA04.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA04.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA04.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA04.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data05[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA05.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA05.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA05.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA05.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA05.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA05.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data06[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA06.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA06.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA06.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA06.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA06.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA06.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data07[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA07.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA07.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA07.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA07.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA07.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA07.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA08.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data08[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA08.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA08.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA08.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA08.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA08.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA08.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA09.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data09[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA09.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA09.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA09.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA09.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA09.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA09.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data10[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA10.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA10.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA10.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA10.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA10.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA10.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data11[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA11.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA11.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA11.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA11.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA11.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA11.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data12[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA12.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA12.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA12.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA12.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA12.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data13[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA13.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA13.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA13.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA13.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA13.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data14[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA14.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA14.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA14.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA14.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA14.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA14.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data15[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA15.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA15.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA15.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA15.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA15.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA15.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA16.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data16[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA16.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA16.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA16.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA16.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA16.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA16.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA17.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data17[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA17.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA17.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA17.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA17.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA17.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA17.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA18.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data18[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA18.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA18.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA18.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA18.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA18.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA18.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA19.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data19[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA19.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA19.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA19.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA19.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA19.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA19.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA20.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data20[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA20.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA20.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA20.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA20.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA20.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA20.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA21.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data21[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA21.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA21.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA21.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA21.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA21.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA21.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA22.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data22[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA22.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA22.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA22.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA22.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA22.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA22.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_DATA23.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_data23[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_DATA23.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_DATA23.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_DATA23.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_DATA23.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_DATA23.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_DATA23.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_ENABLE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_enable[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_ENABLE.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_ENABLE.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_ENABLE.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_ENABLE.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_ENABLE.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_ENABLE.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_HSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_hsync[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_HSYNC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_HSYNC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_HSYNC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_HSYNC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_HSYNC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_HSYNC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_RESET.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_reset[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_RESET.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_RESET.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_RESET.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_RESET.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_RESET.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_RESET.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD1_VSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd1_vsync[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: LCD1_VSYNC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: LCD1_VSYNC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: LCD1_VSYNC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: LCD1_VSYNC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: LCD1_VSYNC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: LCD1_VSYNC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_ALE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_ale[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_ALE.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_ALE.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_ALE.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_ALE.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_ALE.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_ALE.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_CE0_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_ce0_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_CE0_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_CE0_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_CE0_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_CE0_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_CE0_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_CE0_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_CE1_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_ce1_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_CE1_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_CE1_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_CE1_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_CE1_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_CE1_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_CE1_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_CLE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_cle[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_CLE.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_CLE.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_CLE.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_CLE.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_CLE.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_CLE.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data00[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_DATA00.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_DATA00.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_DATA00.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_DATA00.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_DATA00.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_DATA00.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data01[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_DATA01.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_DATA01.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_DATA01.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_DATA01.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_DATA01.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_DATA01.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data02[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_DATA02.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_DATA02.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_DATA02.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_DATA02.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_DATA02.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_DATA02.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data03[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_DATA03.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_DATA03.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_DATA03.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_DATA03.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_DATA03.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_DATA03.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data04[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_DATA04.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_DATA04.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_DATA04.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_DATA04.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_DATA04.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_DATA04.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data05[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_DATA05.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_DATA05.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_DATA05.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_DATA05.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_DATA05.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_DATA05.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data06[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_DATA06.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_DATA06.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_DATA06.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_DATA06.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_DATA06.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_DATA06.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data07[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_DATA07.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_DATA07.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_DATA07.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_DATA07.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_DATA07.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_DATA07.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_RE_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_re_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_RE_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_RE_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_RE_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_RE_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_RE_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_RE_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_READY_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_ready_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_READY_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_READY_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_READY_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_READY_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_READY_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_READY_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_WE_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_we_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_WE_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_WE_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_WE_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_WE_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_WE_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_WE_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_WP_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_wp_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: NAND_WP_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: NAND_WP_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: NAND_WP_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: NAND_WP_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: NAND_WP_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: NAND_WP_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1A_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1a_data0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1A_DATA0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1A_DATA0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1A_DATA0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1A_DATA0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1A_DATA0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1A_DATA0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1A_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1a_data1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1A_DATA1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1A_DATA1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1A_DATA1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1A_DATA1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1A_DATA1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1A_DATA1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1A_DATA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1a_data2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1A_DATA2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1A_DATA2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1A_DATA2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1A_DATA2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1A_DATA2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1A_DATA2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1A_DATA3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1a_data3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1A_DATA3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1A_DATA3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1A_DATA3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1A_DATA3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1A_DATA3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1A_DATA3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1A_DQS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1a_dqs[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1A_DQS.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1A_DQS.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1A_DQS.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1A_DQS.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1A_DQS.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1A_DQS.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1A_SCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1a_sclk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1A_SCLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1A_SCLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1A_SCLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1A_SCLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1A_SCLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1A_SCLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1A_SS0_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1a_ss0_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1A_SS0_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1A_SS0_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1A_SS0_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1A_SS0_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1A_SS0_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1A_SS0_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1A_SS1_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1a_ss1_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1A_SS1_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1A_SS1_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1A_SS1_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1A_SS1_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1A_SS1_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1A_SS1_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1B_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1b_data0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1B_DATA0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1B_DATA0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1B_DATA0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1B_DATA0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1B_DATA0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1B_DATA0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1B_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1b_data1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1B_DATA1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1B_DATA1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1B_DATA1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1B_DATA1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1B_DATA1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1B_DATA1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1B_DATA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1b_data2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1B_DATA2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1B_DATA2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1B_DATA2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1B_DATA2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1B_DATA2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1B_DATA2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1B_DATA3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1b_data3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1B_DATA3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1B_DATA3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1B_DATA3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1B_DATA3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1B_DATA3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1B_DATA3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1B_DQS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1b_dqs[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1B_DQS.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1B_DQS.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1B_DQS.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1B_DQS.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1B_DQS.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1B_DQS.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1B_SCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1b_sclk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1B_SCLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1B_SCLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1B_SCLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1B_SCLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1B_SCLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1B_SCLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1B_SS0_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1b_ss0_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1B_SS0_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1B_SS0_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1B_SS0_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1B_SS0_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1B_SS0_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1B_SS0_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_QSPI1B_SS1_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_qspi1b_ss1_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: QSPI1B_SS1_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: QSPI1B_SS1_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: QSPI1B_SS1_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: QSPI1B_SS1_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: QSPI1B_SS1_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: QSPI1B_SS1_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_RD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_rd0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_RD0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_RD0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_RD0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_RD0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_RD0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_RD0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_RD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_rd1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_RD1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_RD1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_RD1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_RD1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_RD1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_RD1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_RD2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_rd2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_RD2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_RD2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_RD2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_RD2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_RD2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_RD2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_RD3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_rd3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_RD3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_RD3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_RD3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_RD3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_RD3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_RD3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_RX_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_rx_ctl[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_RX_CTL.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_RX_CTL.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_RX_CTL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_RX_CTL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_RX_CTL.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_RX_CTL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_RXC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_rxc[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_RXC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_RXC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_RXC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_RXC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_RXC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_RXC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_TD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_td0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_TD0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_TD0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_TD0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_TD0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_TD0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_TD0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_TD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_td1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_TD1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_TD1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_TD1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_TD1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_TD1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_TD1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_TD2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_td2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_TD2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_TD2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_TD2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_TD2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_TD2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_TD2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_TD3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_td3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_TD3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_TD3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_TD3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_TD3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_TD3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_TD3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_TX_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_tx_ctl[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_TX_CTL.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_TX_CTL.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_TX_CTL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_TX_CTL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_TX_CTL.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_TX_CTL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII1_TXC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii1_txc[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII1_TXC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII1_TXC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII1_TXC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII1_TXC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII1_TXC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII1_TXC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_RD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_rd0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_RD0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_RD0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_RD0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_RD0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_RD0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_RD0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_RD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_rd1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_RD1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_RD1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_RD1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_RD1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_RD1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_RD1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_RD2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_rd2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_RD2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_RD2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_RD2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_RD2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_RD2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_RD2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_RD3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_rd3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_RD3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_RD3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_RD3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_RD3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_RD3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_RD3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_RX_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_rx_ctl[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_RX_CTL.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_RX_CTL.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_RX_CTL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_RX_CTL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_RX_CTL.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_RX_CTL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_RXC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_rxc[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_RXC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_RXC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_RXC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_RXC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_RXC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_RXC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_TD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_td0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_TD0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_TD0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_TD0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_TD0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_TD0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_TD0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_TD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_td1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_TD1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_TD1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_TD1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_TD1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_TD1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_TD1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_TD2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_td2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_TD2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_TD2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_TD2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_TD2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_TD2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_TD2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_TD3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_td3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_TD3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_TD3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_TD3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_TD3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_TD3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_TD3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_TX_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_tx_ctl[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_TX_CTL.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_TX_CTL.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_TX_CTL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_TX_CTL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_TX_CTL.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_TX_CTL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_RGMII2_TXC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_rgmii2_txc[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: RGMII2_TXC.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: RGMII2_TXC.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: RGMII2_TXC.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: RGMII2_TXC.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: RGMII2_TXC.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: RGMII2_TXC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD1_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD1_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD1_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD1_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD1_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD1_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_cmd[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD1_CMD.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD1_CMD.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD1_CMD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD1_CMD.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD1_CMD.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD1_CMD.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_data0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD1_DATA0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD1_DATA0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD1_DATA0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD1_DATA0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD1_DATA0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD1_DATA0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_data1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD1_DATA1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD1_DATA1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD1_DATA1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD1_DATA1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD1_DATA1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD1_DATA1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DATA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_data2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD1_DATA2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD1_DATA2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD1_DATA2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD1_DATA2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD1_DATA2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD1_DATA2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DATA3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_data3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD1_DATA3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD1_DATA3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD1_DATA3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD1_DATA3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD1_DATA3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD1_DATA3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD2_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD2_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD2_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD2_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD2_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD2_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_cmd[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD2_CMD.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD2_CMD.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD2_CMD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD2_CMD.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD2_CMD.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD2_CMD.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_data0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD2_DATA0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD2_DATA0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD2_DATA0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD2_DATA0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD2_DATA0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD2_DATA0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_data1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD2_DATA1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD2_DATA1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD2_DATA1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD2_DATA1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD2_DATA1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD2_DATA1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DATA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_data2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD2_DATA2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD2_DATA2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD2_DATA2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD2_DATA2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD2_DATA2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD2_DATA2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DATA3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_data3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD2_DATA3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD2_DATA3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD2_DATA3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD2_DATA3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD2_DATA3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD2_DATA3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_CLK.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_cmd[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_CMD.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_CMD.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_CMD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_CMD.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_CMD.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_CMD.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_CMD.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_data0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_DATA0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_DATA0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_DATA0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_DATA0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_DATA0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_DATA0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_DATA0.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_data1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_DATA1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_DATA1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_DATA1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_DATA1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_DATA1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_DATA1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_DATA1.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DATA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_data2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_DATA2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_DATA2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_DATA2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_DATA2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_DATA2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_DATA2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_DATA2.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DATA3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_data3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_DATA3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_DATA3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_DATA3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_DATA3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_DATA3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_DATA3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_DATA3.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DATA4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_data4[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_DATA4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_DATA4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_DATA4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_DATA4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_DATA4.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_DATA4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_DATA4.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DATA5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_data5[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_DATA5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_DATA5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_DATA5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_DATA5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_DATA5.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_DATA5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_DATA5.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_data6[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_DATA6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_DATA6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_DATA6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_DATA6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_DATA6.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_DATA6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_DATA6.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_data7[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD3_DATA7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD3_DATA7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD3_DATA7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD3_DATA7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD3_DATA7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD3_DATA7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        "Select one of next values for pad: SD3_DATA7.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_clk[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_CLK.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_CLK.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_CLK.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_CLK.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_CLK.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_CLK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_cmd[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_CMD.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_CMD.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_CMD.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_CMD.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_CMD.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_CMD.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_data0[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_DATA0.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_DATA0.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_DATA0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_DATA0.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_DATA0.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_DATA0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_data1[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_DATA1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_DATA1.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_DATA1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_DATA1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_DATA1.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_DATA1.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DATA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_data2[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_DATA2.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_DATA2.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_DATA2.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_DATA2.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_DATA2.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_DATA2.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DATA3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_data3[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_DATA3.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_DATA3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_DATA3.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_DATA3.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_DATA3.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_DATA3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DATA4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_data4[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_DATA4.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_DATA4.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_DATA4.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_DATA4.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_DATA4.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_DATA4.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DATA5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_data5[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_DATA5.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_DATA5.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_DATA5.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_DATA5.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_DATA5.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_DATA5.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DATA6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_data6[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_DATA6.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_DATA6.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_DATA6.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_DATA6.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_DATA6.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_DATA6.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_DATA7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_data7[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_DATA7.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_DATA7.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_DATA7.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_DATA7.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_DATA7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_DATA7.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD4_RESET_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd4_reset_b[] =
{
    {
        "SRE",
        "Slew rate control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one of next values for pad: SD4_RESET_B.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one of next values for pad: SD4_RESET_B.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Enables open drain of the pin.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: SD4_RESET_B.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: SD4_RESET_B.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: SD4_RESET_B.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: SD4_RESET_B.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_USB_H_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_usb_h_data[] =
{
    {
        "DSE",
        "Select one of next values for pad: USB_H_DATA.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: USB_H_DATA.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: USB_H_DATA.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: USB_H_DATA.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: USB_H_DATA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: USB_H_DATA.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "CANNOT BE CONFIGURED - NO GROUP REGISTER ERROR!",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "Select one of next values for pad: USB_H_DATA.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: USB_H_DATA.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_USB_H_STROBE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_usb_h_strobe[] =
{
    {
        "DSE",
        "Select one of next values for pad: USB_H_STROBE.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one of next values for pad: USB_H_STROBE.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one of next values for pad: USB_H_STROBE.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one of next values for pad: USB_H_STROBE.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one of next values for pad: USB_H_STROBE.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one of next values for pad: USB_H_STROBE.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one of next values for pad: USB_H_STROBE.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Select one of next values for pad: USB_H_STROBE.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        "Select one of next values for pad: USB_H_STROBE.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_ADDDS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_addds[] =
{
    {
        "DSE",
        "Select one of next values for group: .",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrmode_ctl[] =
{
    {
        "DDR_INPUT",
        "Select one of next values for group: .",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRPKE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrpke[] =
{
    {
        "PKE",
        "Select one of next values for group: .",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRPK.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrpk[] =
{
    {
        "PUE",
        "Select one of next values for group: .",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRHYS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrhys[] =
{
    {
        "HYS",
        "Select one of next values for group: .",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRMODE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrmode[] =
{
    {
        "DDR_INPUT",
        "Select one of next values for group: .",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B0DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b0ds[] =
{
    {
        "DSE",
        "Select one of next values for group: .",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B1DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b1ds[] =
{
    {
        "DSE",
        "Select one of next values for group: .",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_CTLDS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ctlds[] =
{
    {
        "DSE",
        "Select one of next values for group: .",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddr_type[] =
{
    {
        "DDR_SEL",
        "Select one of next values for group: .",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B2DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b2ds[] =
{
    {
        "DSE",
        "Select one of next values for group: .",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B3DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b3ds[] =
{
    {
        "DSE",
        "Select one of next values for group: .",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT.
static const field_t hw_iomuxc_anatop_usb_otg_id_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT.
static const field_t hw_iomuxc_anatop_usb_uh1_id_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P3_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p3_input_da_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P3_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p3_input_db_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P3_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p3_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P3_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p3_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P3_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p3_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P3_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p3_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_da_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_db_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_da_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_db_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_da_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_db_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CAN1_IPP_IND_CANRX_SELECT_INPUT.
static const field_t hw_iomuxc_can1_ipp_ind_canrx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CAN2_IPP_IND_CANRX_SELECT_INPUT.
static const field_t hw_iomuxc_can2_ipp_ind_canrx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CANFD_IPD_M_CAN_0_RX_SELECT_INPUT.
static const field_t hw_iomuxc_canfd_ipd_m_can_0_rx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CANFD_IPD_M_CAN_1_RX_SELECT_INPUT.
static const field_t hw_iomuxc_canfd_ipd_m_can_1_rx_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT.
static const field_t hw_iomuxc_ccm_pmic_vfuncional_ready_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_0.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_0[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_1.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_1[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_2.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_2[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_3.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_3[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_4.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_4[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_5.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_5[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_6.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_6[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_7.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_7[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_8.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_8[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_9.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_9[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_11.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_11[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_12.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_12[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_13.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_13[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_14.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_14[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_15.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_15[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_16.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_16[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_17.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_17[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_18.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_18[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_19.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_19[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_20.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_20[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_21.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_21[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_22.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_22[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_23.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_23[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_D_SELECT_INPUT_10.
static const field_t hw_iomuxc_csi1_ipp_csi_d_select_input_10[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_HSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_csi1_ipp_csi_hsync_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_PIXCLK_SELECT_INPUT.
static const field_t hw_iomuxc_csi1_ipp_csi_pixclk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_IPP_CSI_VSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_csi1_ipp_csi_vsync_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI1_TVDECODER_IN_FIELD_SELECT_INPUT.
static const field_t hw_iomuxc_csi1_tvdecoder_in_field_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_SELECT_INPUT_0.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_select_input_0[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_SS_B_SELECT_INPUT_0.
static const field_t hw_iomuxc_ecspi2_ipp_ind_ss_b_select_input_0[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_SS_B_SELECT_INPUT_0.
static const field_t hw_iomuxc_ecspi3_ipp_ind_ss_b_select_input_0[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_SS_B_SELECT_INPUT_0.
static const field_t hw_iomuxc_ecspi4_ipp_ind_ss_b_select_input_0[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi5_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi5_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi5_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI5_IPP_IND_SS_B_SELECT_INPUT_0.
static const field_t hw_iomuxc_ecspi5_ipp_ind_ss_b_select_input_0[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET1_IPG_CLK_RMII_SELECT_INPUT.
static const field_t hw_iomuxc_enet1_ipg_clk_rmii_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET1_IPP_IND_MAC0_MDIO_SELECT_INPUT.
static const field_t hw_iomuxc_enet1_ipp_ind_mac0_mdio_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET1_IPP_IND_MAC0_RXCLK_SELECT_INPUT.
static const field_t hw_iomuxc_enet1_ipp_ind_mac0_rxclk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET2_IPG_CLK_RMII_SELECT_INPUT.
static const field_t hw_iomuxc_enet2_ipg_clk_rmii_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT.
static const field_t hw_iomuxc_enet2_ipp_ind_mac0_mdio_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET2_IPP_IND_MAC0_RXCLK_SELECT_INPUT.
static const field_t hw_iomuxc_enet2_ipp_ind_mac0_rxclk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_FSR_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_fsr_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_FST_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_fst_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_HCKR_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_hckr_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_HCKT_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_hckt_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SCKR_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sckr_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SCKT_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sckt_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO0_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO1_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO2_SDI3_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo2_sdi3_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO3_SDI2_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo3_sdi2_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO4_SDI1_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo4_sdi1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ESAI_IPP_IND_SDO5_SDI0_SELECT_INPUT.
static const field_t hw_iomuxc_esai_ipp_ind_sdo5_sdi0_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c1_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c1_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c2_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c2_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c3_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c3_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C4_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c4_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C4_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c4_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_SELECT_INPUT_5.
static const field_t hw_iomuxc_kpp_ipp_ind_col_select_input_5[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_SELECT_INPUT_6.
static const field_t hw_iomuxc_kpp_ipp_ind_col_select_input_6[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_SELECT_INPUT_7.
static const field_t hw_iomuxc_kpp_ipp_ind_col_select_input_7[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_SELECT_INPUT_5.
static const field_t hw_iomuxc_kpp_ipp_ind_row_select_input_5[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_SELECT_INPUT_6.
static const field_t hw_iomuxc_kpp_ipp_ind_row_select_input_6[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_SELECT_INPUT_7.
static const field_t hw_iomuxc_kpp_ipp_ind_row_select_input_7[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCD1_BUSY_SELECT_INPUT.
static const field_t hw_iomuxc_lcd1_busy_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCD2_BUSY_SELECT_INPUT.
static const field_t hw_iomuxc_lcd2_busy_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_MLB_MLB_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_mlb_mlb_clk_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_MLB_MLB_DATA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_mlb_mlb_data_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_MLB_MLB_SIG_IN_SELECT_INPUT.
static const field_t hw_iomuxc_mlb_mlb_sig_in_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_IPP_IND_SAI_RXBCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai1_ipp_ind_sai_rxbclk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_IPP_IND_SAI_RXDATA_SELECT_INPUT_0.
static const field_t hw_iomuxc_sai1_ipp_ind_sai_rxdata_select_input_0[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_IPP_IND_SAI_RXSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_sai1_ipp_ind_sai_rxsync_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_IPP_IND_SAI_TXBCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai1_ipp_ind_sai_txbclk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_IPP_IND_SAI_TXSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_sai1_ipp_ind_sai_txsync_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_IPP_IND_SAI_RXBCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai2_ipp_ind_sai_rxbclk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_IPP_IND_SAI_RXDATA_SELECT_INPUT_0.
static const field_t hw_iomuxc_sai2_ipp_ind_sai_rxdata_select_input_0[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_IPP_IND_SAI_RXSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_sai2_ipp_ind_sai_rxsync_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_IPP_IND_SAI_TXBCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai2_ipp_ind_sai_txbclk_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_IPP_IND_SAI_TXSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_sai2_ipp_ind_sai_txsync_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SDMA_EVENTS_SELECT_INPUT_14.
static const field_t hw_iomuxc_sdma_events_select_input_14[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SDMA_EVENTS_SELECT_INPUT_15.
static const field_t hw_iomuxc_sdma_events_select_input_15[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT.
static const field_t hw_iomuxc_spdif_spdif_in1_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT.
static const field_t hw_iomuxc_spdif_tx_clk2_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart1_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart1_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart2_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart2_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart3_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart3_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart4_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart4_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart5_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart5_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART6_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart6_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART6_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart6_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT.
static const field_t hw_iomuxc_usb_ipp_ind_otg2_oc_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT.
static const field_t hw_iomuxc_usb_ipp_ind_otg_oc_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc1_ipp_card_det_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc1_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_ipp_card_det_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_card_det_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        "Selecting Pads Involved in Daisy Chain.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC module.
static const reg_t hw_iomuxc[] =
{
    {
        "SW_MUX_CTL_PAD_GPIO1_IO00",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io00
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO01",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io01
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO02",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io02
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO03",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io03
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO04",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io04
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO05",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io05
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO06",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io06
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO07",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io07
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO08",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io08
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO09",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io09
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO10",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io10
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO11",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io11
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO12",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io12
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO13",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io13
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA00",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data00
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA01",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data01
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA02",
        "",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data02
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA03",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data03
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA04",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data04
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA05",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data05
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA06",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data06
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA07",
        "",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data07
    },
    {
        "SW_MUX_CTL_PAD_CSI_HSYNC",
        "",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_hsync
    },
    {
        "SW_MUX_CTL_PAD_CSI_MCLK",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_mclk
    },
    {
        "SW_MUX_CTL_PAD_CSI_PIXCLK",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_pixclk
    },
    {
        "SW_MUX_CTL_PAD_CSI_VSYNC",
        "",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_vsync
    },
    {
        "SW_MUX_CTL_PAD_ENET1_COL",
        "",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_col
    },
    {
        "SW_MUX_CTL_PAD_ENET1_CRS",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_crs
    },
    {
        "SW_MUX_CTL_PAD_ENET1_MDC",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_mdc
    },
    {
        "SW_MUX_CTL_PAD_ENET1_MDIO",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_mdio
    },
    {
        "SW_MUX_CTL_PAD_ENET1_RX_CLK",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_rx_clk
    },
    {
        "SW_MUX_CTL_PAD_ENET1_TX_CLK",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_tx_clk
    },
    {
        "SW_MUX_CTL_PAD_ENET2_COL",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_col
    },
    {
        "SW_MUX_CTL_PAD_ENET2_CRS",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_crs
    },
    {
        "SW_MUX_CTL_PAD_ENET2_RX_CLK",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_rx_clk
    },
    {
        "SW_MUX_CTL_PAD_ENET2_TX_CLK",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_tx_clk
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL0",
        "",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col0
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL1",
        "",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col1
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL2",
        "",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col2
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL3",
        "",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col3
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL4",
        "",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col4
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW0",
        "",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row0
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW1",
        "",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row1
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW2",
        "",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row2
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW3",
        "",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row3
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW4",
        "",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row4
    },
    {
        "SW_MUX_CTL_PAD_LCD1_CLK",
        "",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_clk
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA00",
        "",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data00
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA01",
        "",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data01
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA02",
        "",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data02
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA03",
        "",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data03
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA04",
        "",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data04
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA05",
        "",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data05
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA06",
        "",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data06
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA07",
        "",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data07
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA08",
        "",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data08
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA09",
        "",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data09
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA10",
        "",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data10
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA11",
        "",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data11
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA12",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data12
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA13",
        "",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data13
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA14",
        "",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data14
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA15",
        "",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data15
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA16",
        "",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data16
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA17",
        "",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data17
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA18",
        "",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data18
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA19",
        "",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data19
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA20",
        "",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data20
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA21",
        "",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data21
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA22",
        "",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data22
    },
    {
        "SW_MUX_CTL_PAD_LCD1_DATA23",
        "",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_data23
    },
    {
        "SW_MUX_CTL_PAD_LCD1_ENABLE",
        "",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_enable
    },
    {
        "SW_MUX_CTL_PAD_LCD1_HSYNC",
        "",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_hsync
    },
    {
        "SW_MUX_CTL_PAD_LCD1_RESET",
        "",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_reset
    },
    {
        "SW_MUX_CTL_PAD_LCD1_VSYNC",
        "",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd1_vsync
    },
    {
        "SW_MUX_CTL_PAD_NAND_ALE",
        "",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_ale
    },
    {
        "SW_MUX_CTL_PAD_NAND_CE0_B",
        "",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_ce0_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_CE1_B",
        "",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_ce1_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_CLE",
        "",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_cle
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA00",
        "",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data00
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA01",
        "",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data01
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA02",
        "",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data02
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA03",
        "",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data03
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA04",
        "",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data04
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA05",
        "",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data05
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA06",
        "",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data06
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA07",
        "",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data07
    },
    {
        "SW_MUX_CTL_PAD_NAND_RE_B",
        "",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_re_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_READY_B",
        "",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_ready_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_WE_B",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_we_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_WP_B",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_wp_b
    },
    {
        "SW_MUX_CTL_PAD_QSPI1A_DATA0",
        "",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1a_data0
    },
    {
        "SW_MUX_CTL_PAD_QSPI1A_DATA1",
        "",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1a_data1
    },
    {
        "SW_MUX_CTL_PAD_QSPI1A_DATA2",
        "",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1a_data2
    },
    {
        "SW_MUX_CTL_PAD_QSPI1A_DATA3",
        "",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1a_data3
    },
    {
        "SW_MUX_CTL_PAD_QSPI1A_DQS",
        "",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1a_dqs
    },
    {
        "SW_MUX_CTL_PAD_QSPI1A_SCLK",
        "",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1a_sclk
    },
    {
        "SW_MUX_CTL_PAD_QSPI1A_SS0_B",
        "",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1a_ss0_b
    },
    {
        "SW_MUX_CTL_PAD_QSPI1A_SS1_B",
        "",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1a_ss1_b
    },
    {
        "SW_MUX_CTL_PAD_QSPI1B_DATA0",
        "",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1b_data0
    },
    {
        "SW_MUX_CTL_PAD_QSPI1B_DATA1",
        "",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1b_data1
    },
    {
        "SW_MUX_CTL_PAD_QSPI1B_DATA2",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1b_data2
    },
    {
        "SW_MUX_CTL_PAD_QSPI1B_DATA3",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1b_data3
    },
    {
        "SW_MUX_CTL_PAD_QSPI1B_DQS",
        "",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1b_dqs
    },
    {
        "SW_MUX_CTL_PAD_QSPI1B_SCLK",
        "",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1b_sclk
    },
    {
        "SW_MUX_CTL_PAD_QSPI1B_SS0_B",
        "",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1b_ss0_b
    },
    {
        "SW_MUX_CTL_PAD_QSPI1B_SS1_B",
        "",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_qspi1b_ss1_b
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_RD0",
        "",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_rd0
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_RD1",
        "",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_rd1
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_RD2",
        "",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_rd2
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_RD3",
        "",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_rd3
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_RX_CTL",
        "",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_rx_ctl
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_RXC",
        "",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_rxc
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_TD0",
        "",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_td0
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_TD1",
        "",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_td1
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_TD2",
        "",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_td2
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_TD3",
        "",
        4, // Width in bytes
        0x000001e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_td3
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_TX_CTL",
        "",
        4, // Width in bytes
        0x000001e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_tx_ctl
    },
    {
        "SW_MUX_CTL_PAD_RGMII1_TXC",
        "",
        4, // Width in bytes
        0x000001ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii1_txc
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_RD0",
        "",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_rd0
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_RD1",
        "",
        4, // Width in bytes
        0x000001f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_rd1
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_RD2",
        "",
        4, // Width in bytes
        0x000001f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_rd2
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_RD3",
        "",
        4, // Width in bytes
        0x000001fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_rd3
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_RX_CTL",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_rx_ctl
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_RXC",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_rxc
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_TD0",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_td0
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_TD1",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_td1
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_TD2",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_td2
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_TD3",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_td3
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_TX_CTL",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_tx_ctl
    },
    {
        "SW_MUX_CTL_PAD_RGMII2_TXC",
        "",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_rgmii2_txc
    },
    {
        "SW_MUX_CTL_PAD_SD1_CLK",
        "",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_clk
    },
    {
        "SW_MUX_CTL_PAD_SD1_CMD",
        "",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD1_DATA0",
        "",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_data0
    },
    {
        "SW_MUX_CTL_PAD_SD1_DATA1",
        "",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_data1
    },
    {
        "SW_MUX_CTL_PAD_SD1_DATA2",
        "",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_data2
    },
    {
        "SW_MUX_CTL_PAD_SD1_DATA3",
        "",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_data3
    },
    {
        "SW_MUX_CTL_PAD_SD2_CLK",
        "",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_clk
    },
    {
        "SW_MUX_CTL_PAD_SD2_CMD",
        "",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD2_DATA0",
        "",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_data0
    },
    {
        "SW_MUX_CTL_PAD_SD2_DATA1",
        "",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_data1
    },
    {
        "SW_MUX_CTL_PAD_SD2_DATA2",
        "",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_data2
    },
    {
        "SW_MUX_CTL_PAD_SD2_DATA3",
        "",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_data3
    },
    {
        "SW_MUX_CTL_PAD_SD3_CLK",
        "",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_clk
    },
    {
        "SW_MUX_CTL_PAD_SD3_CMD",
        "",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD3_DATA0",
        "",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_data0
    },
    {
        "SW_MUX_CTL_PAD_SD3_DATA1",
        "",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_data1
    },
    {
        "SW_MUX_CTL_PAD_SD3_DATA2",
        "",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_data2
    },
    {
        "SW_MUX_CTL_PAD_SD3_DATA3",
        "",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_data3
    },
    {
        "SW_MUX_CTL_PAD_SD3_DATA4",
        "",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_data4
    },
    {
        "SW_MUX_CTL_PAD_SD3_DATA5",
        "",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_data5
    },
    {
        "SW_MUX_CTL_PAD_SD3_DATA6",
        "",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_data6
    },
    {
        "SW_MUX_CTL_PAD_SD3_DATA7",
        "",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_data7
    },
    {
        "SW_MUX_CTL_PAD_SD4_CLK",
        "",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_clk
    },
    {
        "SW_MUX_CTL_PAD_SD4_CMD",
        "",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD4_DATA0",
        "",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_data0
    },
    {
        "SW_MUX_CTL_PAD_SD4_DATA1",
        "",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_data1
    },
    {
        "SW_MUX_CTL_PAD_SD4_DATA2",
        "",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_data2
    },
    {
        "SW_MUX_CTL_PAD_SD4_DATA3",
        "",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_data3
    },
    {
        "SW_MUX_CTL_PAD_SD4_DATA4",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_data4
    },
    {
        "SW_MUX_CTL_PAD_SD4_DATA5",
        "",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_data5
    },
    {
        "SW_MUX_CTL_PAD_SD4_DATA6",
        "",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_data6
    },
    {
        "SW_MUX_CTL_PAD_SD4_DATA7",
        "",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_data7
    },
    {
        "SW_MUX_CTL_PAD_SD4_RESET_B",
        "",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd4_reset_b
    },
    {
        "SW_MUX_CTL_PAD_USB_H_DATA",
        "",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_usb_h_data
    },
    {
        "SW_MUX_CTL_PAD_USB_H_STROBE",
        "",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_usb_h_strobe
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR00",
        "",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr00
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR01",
        "",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr01
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR02",
        "",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr02
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR03",
        "",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr03
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR04",
        "",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr04
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR05",
        "",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr05
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR06",
        "",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr06
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR07",
        "",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr07
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR08",
        "",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr08
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR09",
        "",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr09
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR10",
        "",
        4, // Width in bytes
        0x000002d4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr10
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR11",
        "",
        4, // Width in bytes
        0x000002d8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr11
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR12",
        "",
        4, // Width in bytes
        0x000002dc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr12
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR13",
        "",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr13
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR14",
        "",
        4, // Width in bytes
        0x000002e4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr14
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR15",
        "",
        4, // Width in bytes
        0x000002e8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr15
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM0",
        "",
        4, // Width in bytes
        0x000002ec, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM1",
        "",
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM2",
        "",
        4, // Width in bytes
        0x000002f4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM3",
        "",
        4, // Width in bytes
        0x000002f8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm3
    },
    {
        "SW_PAD_CTL_PAD_DRAM_RAS_B",
        "",
        4, // Width in bytes
        0x000002fc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_ras_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CAS_B",
        "",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cas_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CS0_B",
        "",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cs0_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CS1_B",
        "",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cs1_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDWE_B",
        "",
        4, // Width in bytes
        0x0000030c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdwe_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ODT0",
        "",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_odt0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ODT1",
        "",
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_odt1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA0",
        "",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA1",
        "",
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA2",
        "",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCKE0",
        "",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdcke0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCKE1",
        "",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdcke1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCLK0_P",
        "",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdclk0_p
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS0_P",
        "",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs0_p
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS1_P",
        "",
        4, // Width in bytes
        0x00000334, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs1_p
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS2_P",
        "",
        4, // Width in bytes
        0x00000338, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs2_p
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS3_P",
        "",
        4, // Width in bytes
        0x0000033c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs3_p
    },
    {
        "SW_PAD_CTL_PAD_DRAM_RESET",
        "",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_reset
    },
    {
        "SW_PAD_CTL_PAD_JTAG_MOD",
        "",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_mod
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TCK",
        "",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tck
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TDI",
        "",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tdi
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TDO",
        "",
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tdo
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TMS",
        "",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tms
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TRST_B",
        "",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_trst_b
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO00",
        "",
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io00
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO01",
        "",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io01
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO02",
        "",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io02
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO03",
        "",
        4, // Width in bytes
        0x00000368, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io03
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO04",
        "",
        4, // Width in bytes
        0x0000036c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io04
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO05",
        "",
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io05
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO06",
        "",
        4, // Width in bytes
        0x00000374, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io06
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO07",
        "",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io07
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO08",
        "",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io08
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO09",
        "",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io09
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO10",
        "",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io10
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO11",
        "",
        4, // Width in bytes
        0x00000388, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io11
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO12",
        "",
        4, // Width in bytes
        0x0000038c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io12
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO13",
        "",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io13
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA00",
        "",
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data00
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA01",
        "",
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data01
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA02",
        "",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data02
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA03",
        "",
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data03
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA04",
        "",
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data04
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA05",
        "",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data05
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA06",
        "",
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data06
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA07",
        "",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data07
    },
    {
        "SW_PAD_CTL_PAD_CSI_HSYNC",
        "",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_hsync
    },
    {
        "SW_PAD_CTL_PAD_CSI_MCLK",
        "",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_mclk
    },
    {
        "SW_PAD_CTL_PAD_CSI_PIXCLK",
        "",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_pixclk
    },
    {
        "SW_PAD_CTL_PAD_CSI_VSYNC",
        "",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_vsync
    },
    {
        "SW_PAD_CTL_PAD_ENET1_COL",
        "",
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_col
    },
    {
        "SW_PAD_CTL_PAD_ENET1_CRS",
        "",
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_crs
    },
    {
        "SW_PAD_CTL_PAD_ENET1_MDC",
        "",
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_mdc
    },
    {
        "SW_PAD_CTL_PAD_ENET1_MDIO",
        "",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_mdio
    },
    {
        "SW_PAD_CTL_PAD_ENET1_RX_CLK",
        "",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_rx_clk
    },
    {
        "SW_PAD_CTL_PAD_ENET1_TX_CLK",
        "",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_tx_clk
    },
    {
        "SW_PAD_CTL_PAD_ENET2_COL",
        "",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_col
    },
    {
        "SW_PAD_CTL_PAD_ENET2_CRS",
        "",
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_crs
    },
    {
        "SW_PAD_CTL_PAD_ENET2_RX_CLK",
        "",
        4, // Width in bytes
        0x000003e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_rx_clk
    },
    {
        "SW_PAD_CTL_PAD_ENET2_TX_CLK",
        "",
        4, // Width in bytes
        0x000003e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_tx_clk
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL0",
        "",
        4, // Width in bytes
        0x000003ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col0
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL1",
        "",
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col1
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL2",
        "",
        4, // Width in bytes
        0x000003f4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col2
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL3",
        "",
        4, // Width in bytes
        0x000003f8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col3
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL4",
        "",
        4, // Width in bytes
        0x000003fc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col4
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW0",
        "",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row0
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW1",
        "",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row1
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW2",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row2
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW3",
        "",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row3
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW4",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row4
    },
    {
        "SW_PAD_CTL_PAD_LCD1_CLK",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_clk
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA00",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data00
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA01",
        "",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data01
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA02",
        "",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data02
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA03",
        "",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data03
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA04",
        "",
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data04
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA05",
        "",
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data05
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA06",
        "",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data06
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA07",
        "",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data07
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA08",
        "",
        4, // Width in bytes
        0x00000438, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data08
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA09",
        "",
        4, // Width in bytes
        0x0000043c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data09
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA10",
        "",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data10
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA11",
        "",
        4, // Width in bytes
        0x00000444, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data11
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA12",
        "",
        4, // Width in bytes
        0x00000448, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data12
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA13",
        "",
        4, // Width in bytes
        0x0000044c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data13
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA14",
        "",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data14
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA15",
        "",
        4, // Width in bytes
        0x00000454, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data15
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA16",
        "",
        4, // Width in bytes
        0x00000458, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data16
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA17",
        "",
        4, // Width in bytes
        0x0000045c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data17
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA18",
        "",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data18
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA19",
        "",
        4, // Width in bytes
        0x00000464, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data19
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA20",
        "",
        4, // Width in bytes
        0x00000468, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data20
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA21",
        "",
        4, // Width in bytes
        0x0000046c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data21
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA22",
        "",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data22
    },
    {
        "SW_PAD_CTL_PAD_LCD1_DATA23",
        "",
        4, // Width in bytes
        0x00000474, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_data23
    },
    {
        "SW_PAD_CTL_PAD_LCD1_ENABLE",
        "",
        4, // Width in bytes
        0x00000478, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_enable
    },
    {
        "SW_PAD_CTL_PAD_LCD1_HSYNC",
        "",
        4, // Width in bytes
        0x0000047c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_hsync
    },
    {
        "SW_PAD_CTL_PAD_LCD1_RESET",
        "",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_reset
    },
    {
        "SW_PAD_CTL_PAD_LCD1_VSYNC",
        "",
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd1_vsync
    },
    {
        "SW_PAD_CTL_PAD_NAND_ALE",
        "",
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_ale
    },
    {
        "SW_PAD_CTL_PAD_NAND_CE0_B",
        "",
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_ce0_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_CE1_B",
        "",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_ce1_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_CLE",
        "",
        4, // Width in bytes
        0x00000494, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_cle
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA00",
        "",
        4, // Width in bytes
        0x00000498, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data00
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA01",
        "",
        4, // Width in bytes
        0x0000049c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data01
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA02",
        "",
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data02
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA03",
        "",
        4, // Width in bytes
        0x000004a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data03
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA04",
        "",
        4, // Width in bytes
        0x000004a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data04
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA05",
        "",
        4, // Width in bytes
        0x000004ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data05
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA06",
        "",
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data06
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA07",
        "",
        4, // Width in bytes
        0x000004b4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data07
    },
    {
        "SW_PAD_CTL_PAD_NAND_RE_B",
        "",
        4, // Width in bytes
        0x000004b8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_re_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_READY_B",
        "",
        4, // Width in bytes
        0x000004bc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_ready_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_WE_B",
        "",
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_we_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_WP_B",
        "",
        4, // Width in bytes
        0x000004c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_wp_b
    },
    {
        "SW_PAD_CTL_PAD_QSPI1A_DATA0",
        "",
        4, // Width in bytes
        0x000004c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1a_data0
    },
    {
        "SW_PAD_CTL_PAD_QSPI1A_DATA1",
        "",
        4, // Width in bytes
        0x000004cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1a_data1
    },
    {
        "SW_PAD_CTL_PAD_QSPI1A_DATA2",
        "",
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1a_data2
    },
    {
        "SW_PAD_CTL_PAD_QSPI1A_DATA3",
        "",
        4, // Width in bytes
        0x000004d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1a_data3
    },
    {
        "SW_PAD_CTL_PAD_QSPI1A_DQS",
        "",
        4, // Width in bytes
        0x000004d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1a_dqs
    },
    {
        "SW_PAD_CTL_PAD_QSPI1A_SCLK",
        "",
        4, // Width in bytes
        0x000004dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1a_sclk
    },
    {
        "SW_PAD_CTL_PAD_QSPI1A_SS0_B",
        "",
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1a_ss0_b
    },
    {
        "SW_PAD_CTL_PAD_QSPI1A_SS1_B",
        "",
        4, // Width in bytes
        0x000004e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1a_ss1_b
    },
    {
        "SW_PAD_CTL_PAD_QSPI1B_DATA0",
        "",
        4, // Width in bytes
        0x000004e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1b_data0
    },
    {
        "SW_PAD_CTL_PAD_QSPI1B_DATA1",
        "",
        4, // Width in bytes
        0x000004ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1b_data1
    },
    {
        "SW_PAD_CTL_PAD_QSPI1B_DATA2",
        "",
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1b_data2
    },
    {
        "SW_PAD_CTL_PAD_QSPI1B_DATA3",
        "",
        4, // Width in bytes
        0x000004f4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1b_data3
    },
    {
        "SW_PAD_CTL_PAD_QSPI1B_DQS",
        "",
        4, // Width in bytes
        0x000004f8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1b_dqs
    },
    {
        "SW_PAD_CTL_PAD_QSPI1B_SCLK",
        "",
        4, // Width in bytes
        0x000004fc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1b_sclk
    },
    {
        "SW_PAD_CTL_PAD_QSPI1B_SS0_B",
        "",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1b_ss0_b
    },
    {
        "SW_PAD_CTL_PAD_QSPI1B_SS1_B",
        "",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_qspi1b_ss1_b
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_RD0",
        "",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_rd0
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_RD1",
        "",
        4, // Width in bytes
        0x0000050c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_rd1
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_RD2",
        "",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_rd2
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_RD3",
        "",
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_rd3
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_RX_CTL",
        "",
        4, // Width in bytes
        0x00000518, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_rx_ctl
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_RXC",
        "",
        4, // Width in bytes
        0x0000051c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_rxc
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_TD0",
        "",
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_td0
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_TD1",
        "",
        4, // Width in bytes
        0x00000524, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_td1
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_TD2",
        "",
        4, // Width in bytes
        0x00000528, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_td2
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_TD3",
        "",
        4, // Width in bytes
        0x0000052c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_td3
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_TX_CTL",
        "",
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_tx_ctl
    },
    {
        "SW_PAD_CTL_PAD_RGMII1_TXC",
        "",
        4, // Width in bytes
        0x00000534, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii1_txc
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_RD0",
        "",
        4, // Width in bytes
        0x00000538, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_rd0
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_RD1",
        "",
        4, // Width in bytes
        0x0000053c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_rd1
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_RD2",
        "",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_rd2
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_RD3",
        "",
        4, // Width in bytes
        0x00000544, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_rd3
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_RX_CTL",
        "",
        4, // Width in bytes
        0x00000548, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_rx_ctl
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_RXC",
        "",
        4, // Width in bytes
        0x0000054c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_rxc
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_TD0",
        "",
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_td0
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_TD1",
        "",
        4, // Width in bytes
        0x00000554, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_td1
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_TD2",
        "",
        4, // Width in bytes
        0x00000558, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_td2
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_TD3",
        "",
        4, // Width in bytes
        0x0000055c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_td3
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_TX_CTL",
        "",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_tx_ctl
    },
    {
        "SW_PAD_CTL_PAD_RGMII2_TXC",
        "",
        4, // Width in bytes
        0x00000564, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_rgmii2_txc
    },
    {
        "SW_PAD_CTL_PAD_SD1_CLK",
        "",
        4, // Width in bytes
        0x00000568, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_clk
    },
    {
        "SW_PAD_CTL_PAD_SD1_CMD",
        "",
        4, // Width in bytes
        0x0000056c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD1_DATA0",
        "",
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_data0
    },
    {
        "SW_PAD_CTL_PAD_SD1_DATA1",
        "",
        4, // Width in bytes
        0x00000574, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_data1
    },
    {
        "SW_PAD_CTL_PAD_SD1_DATA2",
        "",
        4, // Width in bytes
        0x00000578, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_data2
    },
    {
        "SW_PAD_CTL_PAD_SD1_DATA3",
        "",
        4, // Width in bytes
        0x0000057c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_data3
    },
    {
        "SW_PAD_CTL_PAD_SD2_CLK",
        "",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_clk
    },
    {
        "SW_PAD_CTL_PAD_SD2_CMD",
        "",
        4, // Width in bytes
        0x00000584, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD2_DATA0",
        "",
        4, // Width in bytes
        0x00000588, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_data0
    },
    {
        "SW_PAD_CTL_PAD_SD2_DATA1",
        "",
        4, // Width in bytes
        0x0000058c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_data1
    },
    {
        "SW_PAD_CTL_PAD_SD2_DATA2",
        "",
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_data2
    },
    {
        "SW_PAD_CTL_PAD_SD2_DATA3",
        "",
        4, // Width in bytes
        0x00000594, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_data3
    },
    {
        "SW_PAD_CTL_PAD_SD3_CLK",
        "",
        4, // Width in bytes
        0x00000598, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_clk
    },
    {
        "SW_PAD_CTL_PAD_SD3_CMD",
        "",
        4, // Width in bytes
        0x0000059c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD3_DATA0",
        "",
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_data0
    },
    {
        "SW_PAD_CTL_PAD_SD3_DATA1",
        "",
        4, // Width in bytes
        0x000005a4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_data1
    },
    {
        "SW_PAD_CTL_PAD_SD3_DATA2",
        "",
        4, // Width in bytes
        0x000005a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_data2
    },
    {
        "SW_PAD_CTL_PAD_SD3_DATA3",
        "",
        4, // Width in bytes
        0x000005ac, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_data3
    },
    {
        "SW_PAD_CTL_PAD_SD3_DATA4",
        "",
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_data4
    },
    {
        "SW_PAD_CTL_PAD_SD3_DATA5",
        "",
        4, // Width in bytes
        0x000005b4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_data5
    },
    {
        "SW_PAD_CTL_PAD_SD3_DATA6",
        "",
        4, // Width in bytes
        0x000005b8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_data6
    },
    {
        "SW_PAD_CTL_PAD_SD3_DATA7",
        "",
        4, // Width in bytes
        0x000005bc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_data7
    },
    {
        "SW_PAD_CTL_PAD_SD4_CLK",
        "",
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_clk
    },
    {
        "SW_PAD_CTL_PAD_SD4_CMD",
        "",
        4, // Width in bytes
        0x000005c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD4_DATA0",
        "",
        4, // Width in bytes
        0x000005c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_data0
    },
    {
        "SW_PAD_CTL_PAD_SD4_DATA1",
        "",
        4, // Width in bytes
        0x000005cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_data1
    },
    {
        "SW_PAD_CTL_PAD_SD4_DATA2",
        "",
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_data2
    },
    {
        "SW_PAD_CTL_PAD_SD4_DATA3",
        "",
        4, // Width in bytes
        0x000005d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_data3
    },
    {
        "SW_PAD_CTL_PAD_SD4_DATA4",
        "",
        4, // Width in bytes
        0x000005d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_data4
    },
    {
        "SW_PAD_CTL_PAD_SD4_DATA5",
        "",
        4, // Width in bytes
        0x000005dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_data5
    },
    {
        "SW_PAD_CTL_PAD_SD4_DATA6",
        "",
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_data6
    },
    {
        "SW_PAD_CTL_PAD_SD4_DATA7",
        "",
        4, // Width in bytes
        0x000005e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_data7
    },
    {
        "SW_PAD_CTL_PAD_SD4_RESET_B",
        "",
        4, // Width in bytes
        0x000005e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd4_reset_b
    },
    {
        "SW_PAD_CTL_PAD_USB_H_DATA",
        "",
        4, // Width in bytes
        0x000005ec, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_usb_h_data
    },
    {
        "SW_PAD_CTL_PAD_USB_H_STROBE",
        "",
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_usb_h_strobe
    },
    {
        "SW_PAD_CTL_GRP_ADDDS",
        "",
        4, // Width in bytes
        0x000005f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_addds
    },
    {
        "SW_PAD_CTL_GRP_DDRMODE_CTL",
        "",
        4, // Width in bytes
        0x000005f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrmode_ctl
    },
    {
        "SW_PAD_CTL_GRP_DDRPKE",
        "",
        4, // Width in bytes
        0x000005fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrpke
    },
    {
        "SW_PAD_CTL_GRP_DDRPK",
        "",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrpk
    },
    {
        "SW_PAD_CTL_GRP_DDRHYS",
        "",
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrhys
    },
    {
        "SW_PAD_CTL_GRP_DDRMODE",
        "",
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrmode
    },
    {
        "SW_PAD_CTL_GRP_B0DS",
        "",
        4, // Width in bytes
        0x0000060c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b0ds
    },
    {
        "SW_PAD_CTL_GRP_B1DS",
        "",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b1ds
    },
    {
        "SW_PAD_CTL_GRP_CTLDS",
        "",
        4, // Width in bytes
        0x00000614, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ctlds
    },
    {
        "SW_PAD_CTL_GRP_DDR_TYPE",
        "",
        4, // Width in bytes
        0x00000618, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddr_type
    },
    {
        "SW_PAD_CTL_GRP_B2DS",
        "",
        4, // Width in bytes
        0x0000061c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b2ds
    },
    {
        "SW_PAD_CTL_GRP_B3DS",
        "",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b3ds
    },
    {
        "ANATOP_USB_OTG_ID_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000624, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_anatop_usb_otg_id_select_input
    },
    {
        "ANATOP_USB_UH1_ID_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000628, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_anatop_usb_uh1_id_select_input
    },
    {
        "AUDMUX_P3_INPUT_DA_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000062c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p3_input_da_amx_select_input
    },
    {
        "AUDMUX_P3_INPUT_DB_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p3_input_db_amx_select_input
    },
    {
        "AUDMUX_P3_INPUT_RXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000634, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p3_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P3_INPUT_RXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000638, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p3_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P3_INPUT_TXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000063c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p3_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P3_INPUT_TXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p3_input_txfs_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000644, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_da_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000648, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_db_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000064c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000650, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000654, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000658, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_txfs_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000065c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_da_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_db_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000664, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000668, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000066c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_txfs_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000674, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_da_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000678, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_db_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000067c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000684, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000688, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_txfs_amx_select_input
    },
    {
        "CAN1_IPP_IND_CANRX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000068c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_can1_ipp_ind_canrx_select_input
    },
    {
        "CAN2_IPP_IND_CANRX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_can2_ipp_ind_canrx_select_input
    },
    {
        "CANFD_IPD_M_CAN_0_RX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000694, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_canfd_ipd_m_can_0_rx_select_input
    },
    {
        "CANFD_IPD_M_CAN_1_RX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000698, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_canfd_ipd_m_can_1_rx_select_input
    },
    {
        "CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000069c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ccm_pmic_vfuncional_ready_select_input
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_0",
        "",
        4, // Width in bytes
        0x000006a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_0
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_1",
        "",
        4, // Width in bytes
        0x000006a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_1
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_2",
        "",
        4, // Width in bytes
        0x000006a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_2
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_3",
        "",
        4, // Width in bytes
        0x000006ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_3
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_4",
        "",
        4, // Width in bytes
        0x000006b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_4
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_5",
        "",
        4, // Width in bytes
        0x000006b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_5
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_6",
        "",
        4, // Width in bytes
        0x000006b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_6
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_7",
        "",
        4, // Width in bytes
        0x000006bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_7
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_8",
        "",
        4, // Width in bytes
        0x000006c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_8
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_9",
        "",
        4, // Width in bytes
        0x000006c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_9
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_11",
        "",
        4, // Width in bytes
        0x000006c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_11
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_12",
        "",
        4, // Width in bytes
        0x000006cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_12
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_13",
        "",
        4, // Width in bytes
        0x000006d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_13
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_14",
        "",
        4, // Width in bytes
        0x000006d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_14
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_15",
        "",
        4, // Width in bytes
        0x000006d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_15
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_16",
        "",
        4, // Width in bytes
        0x000006dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_16
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_17",
        "",
        4, // Width in bytes
        0x000006e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_17
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_18",
        "",
        4, // Width in bytes
        0x000006e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_18
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_19",
        "",
        4, // Width in bytes
        0x000006e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_19
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_20",
        "",
        4, // Width in bytes
        0x000006ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_20
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_21",
        "",
        4, // Width in bytes
        0x000006f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_21
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_22",
        "",
        4, // Width in bytes
        0x000006f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_22
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_23",
        "",
        4, // Width in bytes
        0x000006f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_23
    },
    {
        "CSI1_IPP_CSI_D_SELECT_INPUT_10",
        "",
        4, // Width in bytes
        0x000006fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_d_select_input_10
    },
    {
        "CSI1_IPP_CSI_HSYNC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_hsync_select_input
    },
    {
        "CSI1_IPP_CSI_PIXCLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000704, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_pixclk_select_input
    },
    {
        "CSI1_IPP_CSI_VSYNC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000708, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_ipp_csi_vsync_select_input
    },
    {
        "CSI1_TVDECODER_IN_FIELD_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000070c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi1_tvdecoder_in_field_select_input
    },
    {
        "ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000710, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI1_IPP_IND_MISO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000714, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_miso_select_input
    },
    {
        "ECSPI1_IPP_IND_MOSI_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000718, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_mosi_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_SELECT_INPUT_0",
        "",
        4, // Width in bytes
        0x0000071c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_select_input_0
    },
    {
        "ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000720, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI2_IPP_IND_MISO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000724, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_miso_select_input
    },
    {
        "ECSPI2_IPP_IND_MOSI_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000728, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_mosi_select_input
    },
    {
        "ECSPI2_IPP_IND_SS_B_SELECT_INPUT_0",
        "",
        4, // Width in bytes
        0x0000072c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_ss_b_select_input_0
    },
    {
        "ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000730, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI3_IPP_IND_MISO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000734, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_miso_select_input
    },
    {
        "ECSPI3_IPP_IND_MOSI_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000738, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_mosi_select_input
    },
    {
        "ECSPI3_IPP_IND_SS_B_SELECT_INPUT_0",
        "",
        4, // Width in bytes
        0x0000073c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_ss_b_select_input_0
    },
    {
        "ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000740, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI4_IPP_IND_MISO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000744, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_miso_select_input
    },
    {
        "ECSPI4_IPP_IND_MOSI_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000748, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_mosi_select_input
    },
    {
        "ECSPI4_IPP_IND_SS_B_SELECT_INPUT_0",
        "",
        4, // Width in bytes
        0x0000074c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_ss_b_select_input_0
    },
    {
        "ECSPI5_IPP_CSPI_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000750, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI5_IPP_IND_MISO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000754, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_ind_miso_select_input
    },
    {
        "ECSPI5_IPP_IND_MOSI_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000758, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_ind_mosi_select_input
    },
    {
        "ECSPI5_IPP_IND_SS_B_SELECT_INPUT_0",
        "",
        4, // Width in bytes
        0x0000075c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi5_ipp_ind_ss_b_select_input_0
    },
    {
        "ENET1_IPG_CLK_RMII_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000760, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet1_ipg_clk_rmii_select_input
    },
    {
        "ENET1_IPP_IND_MAC0_MDIO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000764, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet1_ipp_ind_mac0_mdio_select_input
    },
    {
        "ENET1_IPP_IND_MAC0_RXCLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000768, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet1_ipp_ind_mac0_rxclk_select_input
    },
    {
        "ENET2_IPG_CLK_RMII_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000076c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet2_ipg_clk_rmii_select_input
    },
    {
        "ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000770, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet2_ipp_ind_mac0_mdio_select_input
    },
    {
        "ENET2_IPP_IND_MAC0_RXCLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000774, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet2_ipp_ind_mac0_rxclk_select_input
    },
    {
        "ESAI_IPP_IND_FSR_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000778, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_fsr_select_input
    },
    {
        "ESAI_IPP_IND_FST_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000077c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_fst_select_input
    },
    {
        "ESAI_IPP_IND_HCKR_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000780, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_hckr_select_input
    },
    {
        "ESAI_IPP_IND_HCKT_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000784, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_hckt_select_input
    },
    {
        "ESAI_IPP_IND_SCKR_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000788, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sckr_select_input
    },
    {
        "ESAI_IPP_IND_SCKT_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000078c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sckt_select_input
    },
    {
        "ESAI_IPP_IND_SDO0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000790, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo0_select_input
    },
    {
        "ESAI_IPP_IND_SDO1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000794, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo1_select_input
    },
    {
        "ESAI_IPP_IND_SDO2_SDI3_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000798, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo2_sdi3_select_input
    },
    {
        "ESAI_IPP_IND_SDO3_SDI2_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000079c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo3_sdi2_select_input
    },
    {
        "ESAI_IPP_IND_SDO4_SDI1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo4_sdi1_select_input
    },
    {
        "ESAI_IPP_IND_SDO5_SDI0_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_esai_ipp_ind_sdo5_sdi0_select_input
    },
    {
        "I2C1_IPP_SCL_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c1_ipp_scl_in_select_input
    },
    {
        "I2C1_IPP_SDA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c1_ipp_sda_in_select_input
    },
    {
        "I2C2_IPP_SCL_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c2_ipp_scl_in_select_input
    },
    {
        "I2C2_IPP_SDA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c2_ipp_sda_in_select_input
    },
    {
        "I2C3_IPP_SCL_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c3_ipp_scl_in_select_input
    },
    {
        "I2C3_IPP_SDA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c3_ipp_sda_in_select_input
    },
    {
        "I2C4_IPP_SCL_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c4_ipp_scl_in_select_input
    },
    {
        "I2C4_IPP_SDA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c4_ipp_sda_in_select_input
    },
    {
        "KPP_IPP_IND_COL_SELECT_INPUT_5",
        "",
        4, // Width in bytes
        0x000007c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_select_input_5
    },
    {
        "KPP_IPP_IND_COL_SELECT_INPUT_6",
        "",
        4, // Width in bytes
        0x000007cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_select_input_6
    },
    {
        "KPP_IPP_IND_COL_SELECT_INPUT_7",
        "",
        4, // Width in bytes
        0x000007d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_select_input_7
    },
    {
        "KPP_IPP_IND_ROW_SELECT_INPUT_5",
        "",
        4, // Width in bytes
        0x000007d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_select_input_5
    },
    {
        "KPP_IPP_IND_ROW_SELECT_INPUT_6",
        "",
        4, // Width in bytes
        0x000007d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_select_input_6
    },
    {
        "KPP_IPP_IND_ROW_SELECT_INPUT_7",
        "",
        4, // Width in bytes
        0x000007dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_select_input_7
    },
    {
        "LCD1_BUSY_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcd1_busy_select_input
    },
    {
        "LCD2_BUSY_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcd2_busy_select_input
    },
    {
        "MLB_MLB_CLK_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_mlb_mlb_clk_in_select_input
    },
    {
        "MLB_MLB_DATA_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_mlb_mlb_data_in_select_input
    },
    {
        "MLB_MLB_SIG_IN_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_mlb_mlb_sig_in_select_input
    },
    {
        "SAI1_IPP_IND_SAI_RXBCLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_ipp_ind_sai_rxbclk_select_input
    },
    {
        "SAI1_IPP_IND_SAI_RXDATA_SELECT_INPUT_0",
        "",
        4, // Width in bytes
        0x000007f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_ipp_ind_sai_rxdata_select_input_0
    },
    {
        "SAI1_IPP_IND_SAI_RXSYNC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x000007fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_ipp_ind_sai_rxsync_select_input
    },
    {
        "SAI1_IPP_IND_SAI_TXBCLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_ipp_ind_sai_txbclk_select_input
    },
    {
        "SAI1_IPP_IND_SAI_TXSYNC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_ipp_ind_sai_txsync_select_input
    },
    {
        "SAI2_IPP_IND_SAI_RXBCLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_ipp_ind_sai_rxbclk_select_input
    },
    {
        "SAI2_IPP_IND_SAI_RXDATA_SELECT_INPUT_0",
        "",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_ipp_ind_sai_rxdata_select_input_0
    },
    {
        "SAI2_IPP_IND_SAI_RXSYNC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_ipp_ind_sai_rxsync_select_input
    },
    {
        "SAI2_IPP_IND_SAI_TXBCLK_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_ipp_ind_sai_txbclk_select_input
    },
    {
        "SAI2_IPP_IND_SAI_TXSYNC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_ipp_ind_sai_txsync_select_input
    },
    {
        "SDMA_EVENTS_SELECT_INPUT_14",
        "",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sdma_events_select_input_14
    },
    {
        "SDMA_EVENTS_SELECT_INPUT_15",
        "",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sdma_events_select_input_15
    },
    {
        "SPDIF_SPDIF_IN1_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_spdif_spdif_in1_select_input
    },
    {
        "SPDIF_TX_CLK2_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000828, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_spdif_tx_clk2_select_input
    },
    {
        "UART1_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000082c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart1_ipp_uart_rts_b_select_input
    },
    {
        "UART1_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart1_ipp_uart_rxd_mux_select_input
    },
    {
        "UART2_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000834, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart2_ipp_uart_rts_b_select_input
    },
    {
        "UART2_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000838, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart2_ipp_uart_rxd_mux_select_input
    },
    {
        "UART3_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart3_ipp_uart_rts_b_select_input
    },
    {
        "UART3_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart3_ipp_uart_rxd_mux_select_input
    },
    {
        "UART4_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart4_ipp_uart_rts_b_select_input
    },
    {
        "UART4_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart4_ipp_uart_rxd_mux_select_input
    },
    {
        "UART5_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart5_ipp_uart_rts_b_select_input
    },
    {
        "UART5_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart5_ipp_uart_rxd_mux_select_input
    },
    {
        "UART6_IPP_UART_RTS_B_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart6_ipp_uart_rts_b_select_input
    },
    {
        "UART6_IPP_UART_RXD_MUX_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart6_ipp_uart_rxd_mux_select_input
    },
    {
        "USB_IPP_IND_OTG2_OC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_ipp_ind_otg2_oc_select_input
    },
    {
        "USB_IPP_IND_OTG_OC_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_ipp_ind_otg_oc_select_input
    },
    {
        "USDHC1_IPP_CARD_DET_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc1_ipp_card_det_select_input
    },
    {
        "USDHC1_IPP_WP_ON_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc1_ipp_wp_on_select_input
    },
    {
        "USDHC2_IPP_CARD_DET_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x0000086c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_ipp_card_det_select_input
    },
    {
        "USDHC2_IPP_WP_ON_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_ipp_wp_on_select_input
    },
    {
        "USDHC4_IPP_CARD_DET_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000874, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_card_det_select_input
    },
    {
        "USDHC4_IPP_WP_ON_SELECT_INPUT",
        "",
        4, // Width in bytes
        0x00000878, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_wp_on_select_input
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC_GPR
#endif

// Bitfields in register IOMUXC_GPR_GPR_GPR0.
static const field_t hw_iomuxc_gpr_gpr_gpr0[] =
{
    {
        "DMAREQ_MUX_SEL0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL6",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL7",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL8",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL9",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL10",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL11",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL12",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL13",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL14",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL15",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL16",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL17",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL18",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL19",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL20",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL21",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL22",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR1.
static const field_t hw_iomuxc_gpr_gpr_gpr1[] =
{
    {
        "ACT_CS0",
        "See description for ADDRS3[10]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS0",
        "See description for ADDRS3[10]",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS1",
        "See description for ADDRS3[10]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS1",
        "See description for ADDRS3[10]",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS2",
        "See description for ADDRS3[10]",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS2",
        "See description for ADDRS3[10]",
        7, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS3",
        "See description for ADDRS3[10]",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS3",
        "Active Chip Select and Address Space.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GINT",
        "Global interrupt \"0\" bit (connected to ARM A9 IRQ#0 and GPC)",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_CLK_SEL",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_CLK_SEL",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB_EXP_MODE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADD_DS",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_TX_CLK_DIR",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_TX_CLK_DIR",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADC_SW_RST",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDEC_SW_RST",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_MON",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZASC1_BOOT_LOCK",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMA9_CLK_APB_DBG_EN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMA9_CLK_ATB_EN",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMA9_CLK_AHB_EN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMA9_IPG_CLK_EN",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR2.
static const field_t hw_iomuxc_gpr_gpr_gpr2[] =
{
    {
        "PXP_MEM_EN_POWERSAVING",
        "enable power saving features on PXP memory",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_SHUTDOWN",
        "set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_DEEPSLEEP",
        "control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_LIGHTSLEEP",
        "set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_MEM_EN_POWERSAVING",
        "enable power saving features on LCDIF memory",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_MEM_SHUTDOWN",
        "set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_MEM_DEEPSLEEP",
        "control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_MEM_LIGHTSLEEP",
        "set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_MEM_EN_POWERSAVING",
        "enable power saving features on LCDIF memory",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_MEM_SHUTDOWN",
        "set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_MEM_DEEPSLEEP",
        "control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_MEM_LIGHTSLEEP",
        "set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_EN_POWERSAVING",
        "enable power saving features on L2 memory",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_SHUTDOWN",
        "set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_DEEPSLEEP",
        "control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_LIGHTSLEEP",
        "set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_RESET_BYPASS",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_RESET",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_CKE0",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_CKE1",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_CKE_BYPASS",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR3.
static const field_t hw_iomuxc_gpr_gpr_gpr3[] =
{
    {
        "OCRAM_CTL",
        "OCRAM_CTL[24] write address pipeline control bit.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_S_CTL",
        "OCRAM_S_CTL[3] write address pipeline control bit.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_L2_CTL",
        "OCRAM_L2_CTL[3] write address pipeline control bit.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE_DBG_ACK_EN",
        "Mask control of Core debug acknowledge to global debug acknowledge",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_STATUS",
        "This field shows the OCRAM pipeline settings status, controlled by OCR"
        "AM_CTL[24:21] bits respectively.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCRAM_S_STATUS",
        "This field shows the OCRAM_L2 pipeline settings status, controlled by "
        "OCRAM_L2_CTL[3:0] bits respectively.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCRAM_L2_STATUS",
        "This field shows the OCRAM_L2 pipeline settings status, controlled by "
        "OCRAM_L2_CTL[3:0] bits respectively.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR4.
static const field_t hw_iomuxc_gpr_gpr_gpr4[] =
{
    {
        "SDMA_STOP_REQ",
        "SDMA stop request.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAN1_STOP_REQ",
        "CAN1 stop request.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAN2_STOP_REQ",
        "CAN2 stop request.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET1_STOP_REQ",
        "ENET1 stop request.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET2_STOP_REQ",
        "ENET2 stop request.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI1_STOP_REQ",
        "SAI1 stop request.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI2_STOP_REQ",
        "SAI2 stop request.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDMA_STOP_ACK",
        "SDMA stop acknowledge.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAN1_STOP_ACK",
        "CAN1 stop acknowledge.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAN2_STOP_ACK",
        "CAN2 stop acknowledge.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET1_STOP_ACK",
        "ENET1 stop acknowledge.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET2_STOP_ACK",
        "ENET2 stop acknowledge.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI1_STOP_ACK",
        "SAI1 stop acknowledge.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI2_STOP_ACK",
        "SAI2 stop acknowledge.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "L2_CLK_STOP",
        "L2 cache clock stop indication (this is a status, read only bit)",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_WFI",
        "ARM A9 WFI event out indicating on WFI state of the cores (these are s"
        "tatus, read only bits)",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_WFE",
        "ARM A9 WFE event out indication on WFE state of the cores (these are s"
        "tatus, read only bits)",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR5.
static const field_t hw_iomuxc_gpr_gpr_gpr5[] =
{
    {
        "SVADC_TEST_GPR1",
        "VADC Clamp Test Input Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISP_MUX_DCIC1_CTRL",
        "DCIC1 Input Select",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISP_MUX_DCIC2_CTRL",
        "DCIC2 Input Select",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISP_MUX_LDB_CTRL",
        "LDB Input Select",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI1_MUX_CTRL",
        "CSI1 input mux control",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG1_MASK",
        "WDOG1 Timeout Mask",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG2_MASK",
        "WDOG2 Timeout Mask",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_HANDSHAKE_CSI1",
        "CSI1 Input Handshake Select",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_HANDSHAKE_CSI2",
        "CSI2 Input Handshake Select",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_HANDSHAKE_LCDIF1",
        "LCDIF1 Input Handshake Select",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_HANDSHAKE_LCDIF2",
        "LCDIF2 Input Handshake Select",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_HANDSHAKE_PXP",
        "PXP Input Handshake Select",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_PERST",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_BTNRST",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG3_MASK",
        "WDOG3 Timeout Mask",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_CSI_VSYNC_SEL",
        "LCDIF1 VSYNC Select",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_CSI_VSYNC_SEL",
        "LCDIF2 VSYNC Select",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADC_TEST_GPR3",
        "Video Decoder Debug Mux select[0] - Selects the source of the 45 bits "
        "of video decoder debug signals available on pins via ALT8 IOMUX config"
        "uration Additional detail TBD",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADC_TEST_6SX_GPR5",
        "Video Decoder Debug Mux select[1] - Selects the source of the 45 bits "
        "of video decoder debug signals available on pins via ALT8 IOMUX config"
        "uration Additional detail TBD",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADC_TEST_GPR2",
        "VADC Test Input Enable",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADC_TO_CSI_CAPTURE_EN",
        "VADC to CSI Capture Circuit Enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI2_MUX_CTRL",
        "CSI2 input mux control",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VREF_1M_CLK_GPT",
        "GPT 1MHz clock source select",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_1M_CLK_EPIT1",
        "EPIT1 1MHz clock source select",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_1M_CLK_EPIT2",
        "EPIT2 1MHz clock source select",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR6.
static const field_t hw_iomuxc_gpr_gpr_gpr6[] =
{
    {
        "CH0_MODE",
        "LVDS channel 0 operation mode",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_WIDTH_CH0",
        "Data width for LVDS channel 0.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BIT_MAPPING_CH0",
        "Data mapping for LVDS channel 0.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_VS_POLARITY",
        "Vsync polarity for LCDIF interface.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_CLK_SHIFT",
        "Shifts the LVDS output clock in relation to the data.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNTER_RESET_VAL",
        "Reset value for the LDB counter which determines when the shift regist"
        "ers are loaded with data.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR7.
static const field_t hw_iomuxc_gpr_gpr_gpr7[] =
{
    {
        "ASRC_SEL_ESAI_RX",
        "ASRC ASRCK_CLOCK_0 select",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_ESAI_TX",
        "ASRC ASRCK_CLOCK_8 select",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_SSI1_RX",
        "ASRC ASRCK_CLOCK_1 select",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_SSI1_TX",
        "ASRC ASRCK_CLOCK_9 select",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_SSI2_RX",
        "ASRC ASRCK_CLOCK_2 select",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_SSI2_TX",
        "ASRC ASRCK_CLOCK_A select",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_SSI3_RX",
        "ASRC ASRCK_CLOCK_3 select",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_SSI3_TX",
        "ASRC ASRCK_CLOCK_B select",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_SPDIF_TX",
        "SPDIF TX_CLK1 select",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_CLK_1",
        "ASRC CLK 1 Select",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_CLK_4",
        "ASRC CLK 4 Select",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_CLK_9",
        "ASRC CLK 9 Select",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASRC_SEL_CLK_C",
        "ASRC CLK C Select",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR8.
static const field_t hw_iomuxc_gpr_gpr_gpr8[] =
{
    {
        "PCS_TX_DEEMPH_GEN1",
        "PCIe_PHY - This static value sets the Tx driver de-emphasis value in t"
        "he case where pipe0_tx_deemph is set to 1'b1 (the default setting) and"
        " the PHY is running at the Gen1 rate.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS_TX_DEEMPH_GEN2_3P5DB",
        "PCIe_PHY - This static value sets the Tx driver de-emphasis value in t"
        "he case where pipe0_tx_deemph is set to 1'b1 (the default setting) and"
        " the PHY is running at the Gen2 rate.",
        6, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS_TX_DEEMPH_GEN2_6DB",
        "PCIe_PHY - This static value sets the Tx driver de-emphasis value in t"
        "he case where pipe0_tx_deemph is set to 1'b0 and the PHY is running at"
        " the Gen2 rate.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS_TX_SWING_FULL",
        "PCIe_PHY - This static value sets the Tx driver de-emphasis value in t"
        "he case where pipe0_tx_deemph is set to 1'b0 and the PHY is running at"
        " the Gen2 rate.",
        18, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS_TX_SWING_LOW",
        "PCIe_PHY - This static value sets the launch amplitude of the transmit"
        "ter when pipe0_tx_swing is set to 1'b0 (default state).",
        25, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR9.
static const field_t hw_iomuxc_gpr_gpr_gpr9[] =
{
    {
        "TZASC1_BYP",
        "TZASC-1 BYPASS MUX control",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR10.
static const field_t hw_iomuxc_gpr_gpr_gpr10[] =
{
    {
        "DBG_EN",
        "ARM non secure (non-invasive) debug enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_CLK_EN",
        "ARM Debug clock enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEC_ERR_RESP",
        "Security error response enable for all security gaskets (on both AHB a"
        "nd AXI busses)",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_L2_TZ_EN",
        "OCRAM_L2 TrustZone (TZ) enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_L2_TZ_ADDR",
        "OCRAM_L2 TrustZone (TZ) start address.",
        4, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_TZ_EN",
        "OCRAM TrustZone (TZ) enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_TZ_ADDR",
        "OCRAM TrustZone (TZ) start address.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR11.
static const field_t hw_iomuxc_gpr_gpr_gpr11[] =
{
    {
        "OCRAM_L2_EN",
        "set to use L2 cache as ocram",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_S_TZ_EN",
        "OCRAM_S TrustZone (TZ) enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_S_TZ_ADDR",
        "OCRAM_S TrustZone (TZ) start address.",
        11, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR12.
static const field_t hw_iomuxc_gpr_gpr_gpr12[] =
{
    {
        "PCIE_RX0_EQ",
        "control pcie phy's rx0_eq bits",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOS_LEVEL",
        "PCIe_PHY - Loss-of-Signal Detector Sensitivity Level Control Function:"
        " Sets the sensitivity level for the Loss-of-Signal detector.",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APPS_PM_XMT_PME",
        "PCIe_CTL - Wake Up.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_LTSSM_ENABLE",
        "PCIe_CTL - Driven low by the application after reset to hold the LTSSM"
        " in the Detect state until the application is ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_INIT_RST",
        "PCIe_CTL - Request from the application to send a Hot Reset to the dow"
        "nstream device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVICE_TYPE",
        "PCIe_CTL - Device/Port Type.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APPS_PM_XMT_TURNOFF",
        "PCIe_CTL - Request from the application to generate a PM_Turn_Off Mess"
        "age.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIAG_STATUS_BUS_SELECT",
        "PCIe_CTL - used for debug to select what part of diag_status_bus will "
        "be reflected on the 32 bits of the iomux",
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_CTL_7",
        "PCIe control of diagnostic bus select TBD",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYS_INT",
        "PCIe_CTL - When SYS_INT goes from low to high, the core generates an A"
        "ssert_INTx Message.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_REQ_ENTR_L1",
        "PCIe_CTL - Application Request to Enter L1.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_REQ_EXIT_L1",
        "PCIe_CTL - Application Request to Exit L1.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_PCIE_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_READY_ENTR_L23",
        "PCIe_CTL - Application Ready to Enter L23.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APP_CLK_REQ_N",
        "PCIe_CTL (CLK LOGIC CONTROLLER GLUE) - Indicates that application logi"
        "c is ready to have reference clock removed.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_POWERDOWN",
        "PCIe_PHY - All Circuits Power-Down Control Function: Powers down all c"
        "ircuitry in the PHY for IDDQ testing.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_PCIE_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR13.
static const field_t hw_iomuxc_gpr_gpr_gpr13[] =
{
    {
        "USDHC_RD_CACHE_VAL",
        "USDHC block cacheable attribute value of AXI read transactions The val"
        "ue of USDHC_RD_CACHE_VAL is affecting the transactions only if USDHC_R"
        "D_CACHE_SEL is set.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC_WR_CACHE_VAL",
        "USDHC block cacheable attribute value of AXI write transactions The va"
        "lue of USDHC_WR_CACHE_VAL is affecting the transactions only if USDHC_"
        "WR_CACHE_SEL is set.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_RD_CACHE_VAL",
        "PXP block cacheable attribute value of AXI read transactions The value"
        " of PXP_RD_CACHE_VAL is affecting the transactions only if PXP_RD_CACH"
        "E_SEL is set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_WR_CACHE_VAL",
        "PXP block cacheable attribute value of AXI write transactions The valu"
        "e of PXP_WR_CACHE_VAL is affecting the transactions only if PXP_WR_CAC"
        "HE_SEL is set.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_RD_CACHE_VAL",
        "PCIE block cacheable attribute value of AXI read transactions The valu"
        "e of PCIE_RD_CACHE_VAL is affecting the transactions only if PCIE_RD_C"
        "ACHE_SEL is set.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_WR_CACHE_VAL",
        "PCIE block cacheable attribute value of AXI write transactions The val"
        "ue of PCIE_WR_CACHE_VAL is affecting the transactions only if PCIE_WR_"
        "CACHE_SEL is set.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_RD_CACHE_VAL",
        "LCDIF block cacheable attribute value of AXI read transactions The val"
        "ue of LCDIF1_RD_CACHE_VAL is affecting the transactions only if LCDIF1"
        "_RD_CACHE_SEL is set.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_RD_CACHE_VAL",
        "LCDIF block cacheable attribute value of AXI read transactions The val"
        "ue of LCDIF2_RD_CACHE_VAL is affecting the transactions only if LCDIF2"
        "_RD_CACHE_SEL is set.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_RD_CACHE_SEL",
        "This bit selects the cacheable attribute of PXP AXI read transcations)",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_WR_CACHE_SEL",
        "This bit selects the cacheable attribute of PXP AXI write transcations",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_RD_CACHE_SEL",
        "This bit selects the cacheable attribute of PCIE AXI read transcations"
        ")",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_WR_CACHE_SEL",
        "This bit selects the cacheable attribute of PCIE AXI write transcation"
        "s",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_RD_CACHE_SEL",
        "This bit selects the cacheable attribute of LCDIF AXI read transcation"
        "s)",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_RD_CACHE_SEL",
        "This bit selects the cacheable attribute of LCDIF AXI read transcation"
        "s)",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_PCIE_CLK_RST_FIX_LNKRST_DISABLE",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_PCIE_CLK_RST_FIX_PERST_DISABLE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC_GPR module.
static const reg_t hw_iomuxc_gpr[] =
{
    {
        "GPR_GPR0",
        "GPR Register",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        23, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr0
    },
    {
        "GPR_GPR1",
        "GPR Register",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        23, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr1
    },
    {
        "GPR_GPR2",
        "GPR Register",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr2
    },
    {
        "GPR_GPR3",
        "GPR Register",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr3
    },
    {
        "GPR_GPR4",
        "GPR Register",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        17, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr4
    },
    {
        "GPR_GPR5",
        "GPR Register",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr5
    },
    {
        "GPR_GPR6",
        "GPR Register",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr6
    },
    {
        "GPR_GPR7",
        "GPR Register",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr7
    },
    {
        "GPR_GPR8",
        "GPR Register",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr8
    },
    {
        "GPR_GPR9",
        "GPR Register",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr9
    },
    {
        "GPR_GPR10",
        "GPR Register",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr10
    },
    {
        "GPR_GPR11",
        "GPR Register",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr11
    },
    {
        "GPR_GPR12",
        "GPR Register",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr12
    },
    {
        "GPR_GPR13",
        "GPR Register",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr13
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark KPP
#endif

// Bitfields in register KPP_KPCR.
static const field_t hw_kpp_kpcr[] =
{
    {
        "KRE",
        "Keypad Row Enable.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCO",
        "Keypad Column Strobe Open-Drain Enable.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KPSR.
static const field_t hw_kpp_kpsr[] =
{
    {
        "KPKD",
        "Keypad Key Depress.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KPKR",
        "Keypad Key Release.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KDSC",
        "Key Depress Synchronizer Clear.",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "KRSS",
        "Key Release Synchronizer Set.",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "KDIE",
        "Keypad Key Depress Interrupt Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KRIE",
        "Keypad Release Interrupt Enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KDDR.
static const field_t hw_kpp_kddr[] =
{
    {
        "KRDD",
        "Keypad Row Data Direction.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCDD",
        "Keypad Column Data Direction Register.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KPDR.
static const field_t hw_kpp_kpdr[] =
{
    {
        "KRD",
        "Keypad Row Data.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCD",
        "Keypad Column Data.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a KPP module.
static const reg_t hw_kpp[] =
{
    {
        "KPCR",
        "The Keypad Control Register determines which of the eight possible col"
        "umn strobes are to be open drain when configured as outputs, and which"
        " of the eight row sense lines are considered in generating an interrup"
        "t to the core.",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kpcr
    },
    {
        "KPSR",
        "The Keypad Status Register reflects the state of the key press detect "
        "circuit.",
        2, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_kpp_kpsr
    },
    {
        "KDDR",
        "The bits in the KPP_KDDR control the direction of the keypad port pins"
        ".",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kddr
    },
    {
        "KPDR",
        "This 16-bit register is used to access the column and row data.",
        2, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kpdr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LCDIF
#endif

// Bitfields in register LCDIF_RL.
static const field_t hw_lcdif_rl[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        "If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        "Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Command Mode polarity bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        "Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        "Set this bit to 1 to get into the ITU-R BT.656 digital video interface"
        " mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        "Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        "By default, eLCDIF is in the write mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_RL_SET.
static const field_t hw_lcdif_rl_set[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        "If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        "Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Command Mode polarity bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        "Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        "Set this bit to 1 to get into the ITU-R BT.656 digital video interface"
        " mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        "Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        "By default, eLCDIF is in the write mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_RL_CLR.
static const field_t hw_lcdif_rl_clr[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        "If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        "Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Command Mode polarity bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        "Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        "Set this bit to 1 to get into the ITU-R BT.656 digital video interface"
        " mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        "Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        "By default, eLCDIF is in the write mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_RL_TOG.
static const field_t hw_lcdif_rl_tog[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        "If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        "Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Command Mode polarity bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        "Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        "Set this bit to 1 to get into the ITU-R BT.656 digital video interface"
        " mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        "Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        "By default, eLCDIF is in the write mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1.
static const field_t hw_lcdif_ctrl1[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        "This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        "This bit enables the use of the interface's busy signal input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        "If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_SET.
static const field_t hw_lcdif_ctrl1_set[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        "This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        "This bit enables the use of the interface's busy signal input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        "If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_CLR.
static const field_t hw_lcdif_ctrl1_clr[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        "This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        "This bit enables the use of the interface's busy signal input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        "If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_TOG.
static const field_t hw_lcdif_ctrl1_tog[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        "This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        "This bit enables the use of the interface's busy signal input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        "If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2.
static const field_t hw_lcdif_ctrl2[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INITIAL_DUMMY_READ",
        "The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        "Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        "Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        "Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        "The default value of 0 indicates data is stored in the little endian f"
        "ormat.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_SET.
static const field_t hw_lcdif_ctrl2_set[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INITIAL_DUMMY_READ",
        "The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        "Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        "Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        "Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        "The default value of 0 indicates data is stored in the little endian f"
        "ormat.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_CLR.
static const field_t hw_lcdif_ctrl2_clr[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INITIAL_DUMMY_READ",
        "The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        "Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        "Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        "Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        "The default value of 0 indicates data is stored in the little endian f"
        "ormat.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_TOG.
static const field_t hw_lcdif_ctrl2_tog[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INITIAL_DUMMY_READ",
        "The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        "Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        "Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        "Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        "The default value of 0 indicates data is stored in the little endian f"
        "ormat.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_TRANSFER_COUNT.
static const field_t hw_lcdif_transfer_count[] =
{
    {
        "H_COUNT",
        "Total valid data (pixels) in each horizontal line.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V_COUNT",
        "Number of horizontal lines per frame which contain valid data.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CUR_BUF.
static const field_t hw_lcdif_cur_buf[] =
{
    {
        "ADDR",
        "-",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_NEXT_BUF.
static const field_t hw_lcdif_next_buf[] =
{
    {
        "ADDR",
        "-",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_TIMING.
static const field_t hw_lcdif_timing[] =
{
    {
        "DATA_SETUP",
        "Data bus setup time in CLK_DIS_LCDIFn cycles.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_HOLD",
        "Data bus hold time in CLK_DIS_LCDIFn cycles.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_SETUP",
        "Number of CLK_DIS_LCDIFn cycles that the DCn signal is active before C"
        "En is asserted.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_HOLD",
        "Number of CLK_DIS_LCDIFn cycles that the DCn signal is active after CE"
        "n is deasserted.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0.
static const field_t hw_lcdif_vdctrl0[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_SET.
static const field_t hw_lcdif_vdctrl0_set[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_CLR.
static const field_t hw_lcdif_vdctrl0_clr[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_TOG.
static const field_t hw_lcdif_vdctrl0_tog[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL1.
static const field_t hw_lcdif_vdctrl1[] =
{
    {
        "VSYNC_PERIOD",
        "Total number of units between two positive or two negative edges of th"
        "e VSYNC signal.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL2.
static const field_t hw_lcdif_vdctrl2[] =
{
    {
        "HSYNC_PERIOD",
        "Total number of CLK_DIS_LCDIFn cycles between two positive or two nega"
        "tive edges of the HSYNC signal.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_PULSE_WIDTH",
        "Number of CLK_DIS_LCDIFn cycles for which HSYNC signal is active.",
        18, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL3.
static const field_t hw_lcdif_vdctrl3[] =
{
    {
        "VERTICAL_WAIT_CNT",
        "In the VSYNC interface mode, wait for this number of CLK_DIS_LCDIFn cy"
        "cles from the falling VSYNC edge (or rising if VSYNC_POL is 1) before "
        "starting LCD transactions and is applicable only if WAIT_FOR_VSYNC_EDG"
        "E is set.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HORIZONTAL_WAIT_CNT",
        "In the DOTCLK mode, wait for this number of clocks from falling edge ("
        "or rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal"
        " back porch plus the number of DOTCLKs before the moving picture infor"
        "mation begins.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_ONLY",
        "This bit must be set to 1 in the VSYNC mode of operation, and 0 in the"
        " DOTCLK mode of operation.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_SYNC_SIGNALS",
        "When this bit is set, the eLCDIF block will internally mux HSYNC with "
        "LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these "
        "signals will go out on separate pins.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL4.
static const field_t hw_lcdif_vdctrl4[] =
{
    {
        "DOTCLK_H_VALID_DATA_CNT",
        "Total number of CLK_DIS_LCDIFn cycles on each horizontal line that car"
        "ry valid data in DOTCLK mode.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_SIGNALS_ON",
        "Set this field to 1 if the LCD controller requires that the VSYNC or V"
        "SYNC/HSYNC/DOTCLK control signals should be active at least one frame "
        "before the data transfers actually start and remain active at least on"
        "e frame after the data transfers end.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        19, // LSB
        28, // MSB
        false, // Readable
        false // Writable
    },
    {
        "DOTCLK_DLY_SEL",
        "This bitfield selects the amount of time by which the DOTCLK signal sh"
        "ould be delayed before coming out of the LCD_DOTCK pin.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL0.
static const field_t hw_lcdif_dvictrl0[] =
{
    {
        "H_BLANKING_CNT",
        "Number of blanking samples to be inserted between EAV and SAV during h"
        "orizontal blanking interval.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        12, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "H_ACTIVE_CNT",
        "Number of active video samples to be transmitted.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL1.
static const field_t hw_lcdif_dvictrl1[] =
{
    {
        "F2_START_LINE",
        "Vertical line number from which Field 2 begins.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_END_LINE",
        "Vertical line number at which Field1 ends.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_START_LINE",
        "Vertical line number from which Field 1 begins.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL2.
static const field_t hw_lcdif_dvictrl2[] =
{
    {
        "V1_BLANK_END_LINE",
        "Vertical line number in the beginning part of Field2 where first Verti"
        "cal Blanking interval ends.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V1_BLANK_START_LINE",
        "Vertical line number towards the end of Field1 where first Vertical Bl"
        "anking interval starts.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F2_END_LINE",
        "Vertical line number at which Field 2 ends.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL3.
static const field_t hw_lcdif_dvictrl3[] =
{
    {
        "V_LINES_CNT",
        "Total number of vertical lines per frame (generally 525 or 625)",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V2_BLANK_END_LINE",
        "Vertical line number in the beginning part of Field1 where second Vert"
        "ical Blanking interval ends.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V2_BLANK_START_LINE",
        "Vertical line number towards the end of Field2 where second Vertical B"
        "lanking interval starts.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL4.
static const field_t hw_lcdif_dvictrl4[] =
{
    {
        "H_FILL_CNT",
        "Number of active video samples that have to be filled with the filler "
        "data in the front and back portions of the active horizontal interval.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CR_FILL_VALUE",
        "Value of CR component of filler data.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB_FILL_VALUE",
        "Value of CB component of filler data",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "Y_FILL_VALUE",
        "Value of Y component of filler data",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF0.
static const field_t hw_lcdif_csc_coeff0[] =
{
    {
        "CSC_SUBSAMPLE_FILTER",
        "This register describes the filtering and subsampling scheme to be per"
        "formed on the chroma components in order to convert from YCbCr 4:4:4 t"
        "o YCbCr 4:2:2 space.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        2, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C0",
        "Two's complement red multiplier coefficient for Y",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF1.
static const field_t hw_lcdif_csc_coeff1[] =
{
    {
        "C1",
        "Two's complement green multiplier coefficient for Y",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        10, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C2",
        "Two's complement blue multiplier coefficient for Y",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF2.
static const field_t hw_lcdif_csc_coeff2[] =
{
    {
        "C3",
        "Two's complement red multiplier coefficient for Cb",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        10, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C4",
        "Two's complement green multiplier coefficient for Cb",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF3.
static const field_t hw_lcdif_csc_coeff3[] =
{
    {
        "C5",
        "Two's complement blue multiplier coefficient for Cb",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        10, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C6",
        "Two's complement red multiplier coefficient for Cr",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF4.
static const field_t hw_lcdif_csc_coeff4[] =
{
    {
        "C7",
        "Two's complement green multiplier coefficient for Cr",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        10, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C8",
        "Two's complement blue multiplier coefficient for Cr",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_OFFSET.
static const field_t hw_lcdif_csc_offset[] =
{
    {
        "Y_OFFSET",
        "Two's complement offset for the Y component",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        9, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CBCR_OFFSET",
        "Two's complement offset for the Cb and Cr components",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        25, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_LIMIT.
static const field_t hw_lcdif_csc_limit[] =
{
    {
        "Y_MAX",
        "Upper limit of Y after RGB to 4:2:2 YCbCr conversion",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "Y_MIN",
        "Lower limit of Y after RGB to 4:2:2 YCbCr conversion",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CBCR_MAX",
        "Upper limit of Cb and Cr after RGB to 4:2:2 YCbCr conversion",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CBCR_MIN",
        "Lower limit of Cb and Cr after RGB to 4:2:2 YCbCr conversion",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DATA.
static const field_t hw_lcdif_data[] =
{
    {
        "DATA_ZERO",
        "Byte 0 (least significant byte) of data written to eLCDIF.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ONE",
        "Byte 1 of data written to eLCDIF.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_TWO",
        "Byte 2 of data written to eLCDIF.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_THREE",
        "Byte 3 (most significant byte) of data written to LCDIF.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_BM_ERROR_STAT.
static const field_t hw_lcdif_bm_error_stat[] =
{
    {
        "ADDR",
        "Virtual address at which bus master error occurred.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CRC_STAT.
static const field_t hw_lcdif_crc_stat[] =
{
    {
        "CRC_VALUE",
        "Calculated CRC value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_STAT.
static const field_t hw_lcdif_stat[] =
{
    {
        "LFIFO_COUNT",
        "Read only view of the current count in Latency buffer (LFIFO).",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        9, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "DVI_CURRENT_FIELD",
        "Read only view of the current field being transmitted.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        "Read only view of the input busy signal from the external LCD controll"
        "er.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFIFO_EMPTY",
        "Read only view of the signal that indicates that LCD write dapatath FI"
        "FO is empty, will be generally used in the read mode of the LCD interf"
        "ace.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFIFO_FULL",
        "Read only view of the signal that indicates that LCD write datapath FI"
        "FO is full, will be generally used in the write mode of the LCD interf"
        "ace.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LFIFO_EMPTY",
        "Read only view of the signal that indicates that LCD read dapatath FIF"
        "O is empty, will be generally used in the read mode of the LCD interfa"
        "ce.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LFIFO_FULL",
        "Read only view of the signal that indicates that LCD read datapath FIF"
        "O is full, will be generally used in the write mode of the LCD interfa"
        "ce.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRESENT",
        "0: eLCDIF not present on this product 1: eLCDIF is present.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VERSION.
static const field_t hw_lcdif_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG0.
static const field_t hw_lcdif_debug0[] =
{
    {
        "MST_WORDS",
        "Read only view of the current bursts issued by the AXI bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_OUTSTANDING_REQS",
        "Read only view of the current outstanding requests issued by the AXI b"
        "us master.",
        4, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_AVALID",
        "Read only view of the mst_avalid signal issued by the AXI bus master.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_REQ_STATE",
        "Read only view of the request state machine.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_B1_DONE",
        "Buffer1 done signal issued by eLCDIF.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_LCDIF_B1_READY",
        "Buffer1 ready signal issued by ePXP.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_B0_DONE",
        "Buffer0 done signal issued by eLCDIF.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_LCDIF_B0_READY",
        "Buffer0 ready signal issued by ePXP.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_STATE",
        "Read only view of the current state machine state in the current mode "
        "of operation.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EMPTY_WORD",
        "Indicates that the current word is empty.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_FRAME_TX",
        "This bit is 1 for the time the current frame is being transmitted in t"
        "he VSYNC mode.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VSYNC",
        "Read only view of VSYNC signal.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HSYNC",
        "Read only view of HSYNC signal.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE",
        "Read only view of ENABLE signal.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYNC_SIGNALS_ON_REG",
        "Read only view of internal sync_signals_on_reg signal.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE_OUT",
        "Read only view of WAIT_FOR_VSYNC_EDGE bit in the VSYNC mode after it c"
        "omes out of the TXFIFO.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STREAMING_END_DETECTED",
        "Read only view of the DOTCLK_MODE or DVI_MODE bit going from 1 to 0.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG1.
static const field_t hw_lcdif_debug1[] =
{
    {
        "V_DATA_COUNT",
        "Read only view of the current state of the vertical data counter.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "H_DATA_COUNT",
        "Read only view of the current state of the horizontal data counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG2.
static const field_t hw_lcdif_debug2[] =
{
    {
        "MST_ADDRESS",
        "Read only view of the current address issued by the AXI bus master.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_THRES.
static const field_t hw_lcdif_thres[] =
{
    {
        "PANIC",
        "",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        9, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FASTCLOCK",
        "This value should be set to a value of pixels, from 0 to 511.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        25, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CTRL.
static const field_t hw_lcdif_as_ctrl[] =
{
    {
        "AS_ENABLE",
        "When this bit is set by software, the LCDIF will start fetching AS buf"
        "fer data in bus master mode and combine it with another buffer.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_CTRL",
        "Determines how the alpha value is constructed for this alpha surface.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_COLORKEY",
        "Indicates that colorkey functionality is enabled for this alpha surfac"
        "e.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORMAT",
        "Indicates the input buffer format for AS.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        "Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values a"
        "re programmed in REG_AS_CTRL[ALPHA_CTRL].",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROP",
        "Indicates a raster operation to perform when enabled.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_INVERT",
        "Setting this bit to logic 0 will not alter the alpha value.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes either in the HW_LCDIF_DATA"
        " register or those fetched by the AXI master part of LCDIF.",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS_DISABLE",
        "When this bit is set by software, the LCDIF will disable PS buffer dat"
        "a.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RVDS1",
        "Reserved, always set to zero.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSI_SYNC_ON_IRQ",
        "this bit is set by software to decide which vsync generate mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SYNC_ON_IRQ_EN",
        "This bit is set to enable an interrupt when LCDIF lock with CSI vsync "
        "input.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_VSYNC_MODE",
        "this bit is set by software to decide which vsync generate mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_VSYNC_ENABLE",
        "When this bit is set by software, the LCDIF work as sync mode with CSI"
        " input.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_BUF.
static const field_t hw_lcdif_as_buf[] =
{
    {
        "ADDR",
        "Address pointer for the alpha surface 0 buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_NEXT_BUF.
static const field_t hw_lcdif_as_next_buf[] =
{
    {
        "ADDR",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CLRKEYLOW.
static const field_t hw_lcdif_as_clrkeylow[] =
{
    {
        "PIXEL",
        "Low range of RGB color key applied to AS buffer",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CLRKEYHIGH.
static const field_t hw_lcdif_as_clrkeyhigh[] =
{
    {
        "PIXEL",
        "High range of RGB color key applied to AS buffer",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_SYNC_DELAY.
static const field_t hw_lcdif_sync_delay[] =
{
    {
        "H_COUNT_DELAY",
        "LCDIF VSYNC delayed counter for CSI_VSYNC.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V_COUNT_DELAY",
        "LCDIF VSYNC delayed counter for CSI_VSYNC.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG3.
static const field_t hw_lcdif_debug3[] =
{
    {
        "MST_WORDS",
        "Read only view of the current bursts issued by the AXI bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_OUTSTANDING_REQS",
        "Read only view of the current outstanding requests issued by the AXI b"
        "us master",
        4, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_AVALID",
        "Read only view of the mst_avalid signal issued by the AXI bus master",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_REQ_STATE",
        "Read only view of the request state machine",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD0",
        "Reserved bits, write as 0.",
        12, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG4.
static const field_t hw_lcdif_debug4[] =
{
    {
        "V_DATA_COUNT",
        "Read only view of the current AS state of the vertical data counter.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "H_DATA_COUNT",
        "Read only view of the current AS state of the horizontal data counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG5.
static const field_t hw_lcdif_debug5[] =
{
    {
        "MST_ADDRESS",
        "Read only view of the AS channel address issued by the AXI bus master.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a LCDIF module.
static const reg_t hw_lcdif[] =
{
    {
        "RL",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_lcdif_rl
    },
    {
        "RL_SET",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_lcdif_rl_set
    },
    {
        "RL_CLR",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_lcdif_rl_clr
    },
    {
        "RL_TOG",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_lcdif_rl_tog
    },
    {
        "CTRL1",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_lcdif_ctrl1
    },
    {
        "CTRL1_SET",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_lcdif_ctrl1_set
    },
    {
        "CTRL1_CLR",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_lcdif_ctrl1_clr
    },
    {
        "CTRL1_TOG",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_lcdif_ctrl1_tog
    },
    {
        "CTRL2",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_ctrl2
    },
    {
        "CTRL2_SET",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_ctrl2_set
    },
    {
        "CTRL2_CLR",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_ctrl2_clr
    },
    {
        "CTRL2_TOG",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_ctrl2_tog
    },
    {
        "TRANSFER_COUNT",
        "This register tells the eLCDIF how much data will be sent for this fra"
        "me, or transaction.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_transfer_count
    },
    {
        "CUR_BUF",
        "This register indicates the address of the current frame being transmi"
        "tted by eLCDIF.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_cur_buf
    },
    {
        "NEXT_BUF",
        "This register indicates the address of next frame that will be transmi"
        "tted by eLCDIF.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_next_buf
    },
    {
        "TIMING",
        "The LCD interface timing register controls the various setup and hold "
        "times enforced by the LCD interface in the 6800/8080 MPU and VSYNC mod"
        "es of operation.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_timing
    },
    {
        "VDCTRL0",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0
    },
    {
        "VDCTRL0_SET",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_set
    },
    {
        "VDCTRL0_CLR",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_clr
    },
    {
        "VDCTRL0_TOG",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_tog
    },
    {
        "VDCTRL1",
        "This register is used to control the VSYNC signal in the VSYNC and DOT"
        "CLK modes of the block.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_vdctrl1
    },
    {
        "VDCTRL2",
        "This register is used to control the HSYNC signal in the DOTCLK mode o"
        "f the block.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_vdctrl2
    },
    {
        "VDCTRL3",
        "This register is used to determine the vertical and horizontal wait co"
        "unts.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_lcdif_vdctrl3
    },
    {
        "VDCTRL4",
        "This register is used to control the DOTCLK mode of the block.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_vdctrl4
    },
    {
        "DVICTRL0",
        "The Digital Video interface Control0 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl0
    },
    {
        "DVICTRL1",
        "The Digital Video interface Control1 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl1
    },
    {
        "DVICTRL2",
        "The Digital Video interface Control2 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl2
    },
    {
        "DVICTRL3",
        "The Digital Video interface Control3 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl3
    },
    {
        "DVICTRL4",
        "The Digital Video interface Control4 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl4
    },
    {
        "CSC_COEFF0",
        "LCDIF_CSC_COEFF0 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff0
    },
    {
        "CSC_COEFF1",
        "LCDIF_CSC_COEFF1 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff1
    },
    {
        "CSC_COEFF2",
        "LCDIF_CSC_COEFF2 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff2
    },
    {
        "CSC_COEFF3",
        "LCDIF_CSC_COEFF3 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff3
    },
    {
        "CSC_COEFF4",
        "LCDIF_CSC_COEFF4 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff4
    },
    {
        "CSC_OFFSET",
        "LCDIF_CSC_ register provides overall control over color space conversi"
        "on from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_offset
    },
    {
        "CSC_LIMIT",
        "LCDIF_CSC_CTRL0 register provides overall control over color space con"
        "version from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_limit
    },
    {
        "DATA",
        "This register is used to transfer data using the PIO interface mode of"
        " operation.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_data
    },
    {
        "BM_ERROR_STAT",
        "This register reflects the virtual address at which the AXI master rec"
        "eived an error response from the slave.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_bm_error_stat
    },
    {
        "CRC_STAT",
        "This register reflects the CRC value of each frame sent out by eLCDIF.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_crc_stat
    },
    {
        "STAT",
        "The LCD interface status register can be used to check the current sta"
        "tus of the eLCDIF block.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_lcdif_stat
    },
    {
        "VERSION",
        "The LCD interface version register can be used to read the version of "
        "the eLCDIF IP being used in this SoC.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lcdif_version
    },
    {
        "DEBUG0",
        "The LCD interface debug0 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        false, // Writable
        17, // Number of bitfields
        hw_lcdif_debug0
    },
    {
        "DEBUG1",
        "The LCD interface debug1 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lcdif_debug1
    },
    {
        "DEBUG2",
        "The LCD interface debug2 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lcdif_debug2
    },
    {
        "THRES",
        "This register is used to activate control signals when the number of p"
        "ixels reaches the programmed threshold.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_thres
    },
    {
        "AS_CTRL",
        "The Alpha Surface Parameter register provides additional controls for "
        "AS.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_as_ctrl
    },
    {
        "AS_BUF",
        "This register is used to indicate the base address of the AS buffer.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_as_buf
    },
    {
        "AS_NEXT_BUF",
        "When the LCDIF is behaving as a master, this address points to the add"
        "ress of the next frame of data that will be sent out via the LCDIF.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_as_next_buf
    },
    {
        "AS_CLRKEYLOW",
        "If a pixel in the current overlay image with a color that falls in the"
        " range from the ASCOLORKEYLOW to ASCOLORKEYHIGH range, it will use the"
        " PS pixel value for that location.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_as_clrkeylow
    },
    {
        "AS_CLRKEYHIGH",
        "If a pixel in the current overlay image with a color that falls in the"
        " range from the ASCOLORKEYLOW to ASCOLORKEYHIGH range, it will use the"
        " PS pixel value for that location.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_as_clrkeyhigh
    },
    {
        "SYNC_DELAY",
        "The LCDIF DOTCLK mode VSYNC will delay from CSI_VSYNC as ( V_COUNT_DEL"
        "AY * HSYNC_PERIOD + H_COUNT_DELAY) PIXCLK cycles",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_sync_delay
    },
    {
        "DEBUG3",
        "The LCD interface debug register is for diagnostic use only.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_lcdif_debug3
    },
    {
        "DEBUG4",
        "The LCD interface debug register is for diagnostic use only.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lcdif_debug4
    },
    {
        "DEBUG5",
        "The LCD interface debug register is for diagnostic use only.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lcdif_debug5
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LDB
#endif

// Bitfields in register LDB_CTRL.
static const field_t hw_ldb_ctrl[] =
{
    {
        "CH0_MODE",
        "LVDS channel 0 operation mode",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_WIDTH_CH0",
        "Data width for LVDS channel 0.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BIT_MAPPING_CH0",
        "Data mapping for LVDS channel 0.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_VS_POLARITY",
        "Vsync polarity for lcdif1 interface.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_CLK_SHIFT",
        "Shifts the LVDS output clock in relation to the data.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNTER_RESET_VAL",
        "Reset value for the LDB counter which determines when the shift regist"
        "ers are loaded with data.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LDB module.
static const reg_t hw_ldb[] =
{
    {
        "CTRL",
        "The register is implemented in the IOMUX Controller block (IOMUXC), as"
        " the register IOMUXC_GPR6.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ldb_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LMEM
#endif

// Bitfields in register LMEM_PCCCR.
static const field_t hw_lmem_pcccr[] =
{
    {
        "ENCACHE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENWRBUF",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCCR2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCCR3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVW0",
        "If the PUSHW0 and INVW0 bits are set, then after setting the GO bit, p"
        "ush all modified lines in way 0 and invalidate all lines in way 0 (cle"
        "ar way 0).",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUSHW0",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVW1",
        "If the PUSHW1 and INVW1 bits are set, then after setting the GO bit, p"
        "ush all modified lines in way 1 and invalidate all lines in way 1 (cle"
        "ar way 1).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUSHW1",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GO",
        "Setting this bit initiates the cache command indicated by bits 27-24.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PCCLCR.
static const field_t hw_lmem_pcclcr[] =
{
    {
        "LGO",
        "Setting this bit initiates the cache line command indicated by bits 27"
        "-24.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CACHEADDR",
        "CLCR[11:4] bits are used to access the tag arrays CLCR[11:2] bits are "
        "used to access the data arrays",
        2, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSEL",
        "Selects the way for line commands.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDSEL",
        "Selects tag or data for search and read or write commands.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCIVB",
        "If command used cache address and way, then this bit shows the initial"
        " state of the valid bit If command used physical address and a hit, th"
        "en this bit shows the initial state of the valid bit.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LCIMB",
        "If command used cache address and way, then this bit shows the initial"
        " state of the modified bit If command used physical address and a hit,"
        " then this bit shows the initial state of the modified bit.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LCWAY",
        "Indicates the way used by the line command.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LCMD",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LADSEL",
        "When using the cache address, the way must also be specified in CLCR[W"
        "SEL].",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LACC",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PCCSAR.
static const field_t hw_lmem_pccsar[] =
{
    {
        "LGO",
        "Setting this bit initiates the cache line command indicated by bits 27"
        "-24.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYADDR",
        "PHYADDR represents bits [31:2] of the system address.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PCCCVR.
static const field_t hw_lmem_pcccvr[] =
{
    {
        "DATA",
        "For tag search, read or write: CCVR[31:12] bits are used for tag array"
        " R/W value CCVR[11:4] bits are used for tag set address on reads; unus"
        "ed on writes CCVR[3:2] bits are reserved For data search, read or writ"
        "e: CCVR[31:0] bits are used for data array R/W value",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PSCCR.
static const field_t hw_lmem_psccr[] =
{
    {
        "ENCACHE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENWRBUF",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVW0",
        "If the PUSHW0 and INVW0 bits are set, then after setting the GO bit, p"
        "ush all modified lines in way 0 and invalidate all lines in way 0 (cle"
        "ar way 0).",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUSHW0",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVW1",
        "If the PUSHW1 and INVW1 bits are set, then after setting the GO bit, p"
        "ush all modified lines in way 1 and invalidate all lines in way 1 (cle"
        "ar way 1).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUSHW1",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GO",
        "Setting this bit initiates the cache command indicated by bits 27-24.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PSCLCR.
static const field_t hw_lmem_psclcr[] =
{
    {
        "LGO",
        "Setting this bit initiates the cache line command indicated by bits 27"
        "-24.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CACHEADDR",
        "CLCR[11:4] bits are used to access the tag arrays CLCR[11:2] bits are "
        "used to access the data arrays",
        2, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSEL",
        "Selects the way for line commands.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDSEL",
        "Selects tag or data for search and read or write commands.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCIVB",
        "If command used cache address and way, then this bit shows the initial"
        " state of the valid bit If command used physical address and a hit, th"
        "en this bit shows the initial state of the valid bit.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LCIMB",
        "If command used cache address and way, then this bit shows the initial"
        " state of the modified bit If command used physical address and a hit,"
        " then this bit shows the initial state of the modified bit.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LCWAY",
        "Indicates the way used by the line command.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LCMD",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LADSEL",
        "When using the cache address, the way must also be specified in CLCR[W"
        "SEL].",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LACC",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PSCSAR.
static const field_t hw_lmem_pscsar[] =
{
    {
        "LGO",
        "Setting this bit initiates the cache line command indicated by bits 27"
        "-24.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYADDR",
        "PHYADDR represents bits [31:2] of the system address.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PSCCVR.
static const field_t hw_lmem_psccvr[] =
{
    {
        "DATA",
        "For tag search, read or write: CCVR[31:12] bits are used for tag array"
        " R/W value CCVR[11:4] bits are used for tag set address on reads; unus"
        "ed on writes CCVR[3:2] bits are reserved For data search, read or writ"
        "e: CCVR[31:0] bits are used for data array R/W value",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LMEM module.
static const reg_t hw_lmem[] =
{
    {
        "PCCCR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lmem_pcccr
    },
    {
        "PCCLCR",
        "This register defines specific line-sized cache operations to be perfo"
        "rmed using a specific cache line address or a physical address.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_lmem_pcclcr
    },
    {
        "PCCSAR",
        "The CSAR register is used to define the explicit cache address or the "
        "physical address for line-sized commands specified in the CLCR[LADSEL]"
        " bit.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lmem_pccsar
    },
    {
        "PCCCVR",
        "The CCVR register is used to source write data or return read data for"
        " the commands specified in the CLCR register.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lmem_pcccvr
    },
    {
        "PSCCR",
        "",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lmem_psccr
    },
    {
        "PSCLCR",
        "This register defines specific line-sized cache operations to be perfo"
        "rmed using a specific cache line address or a physical address.",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_lmem_psclcr
    },
    {
        "PSCSAR",
        "The CSAR register is used to define the explicit cache address or the "
        "physical address for line-sized commands specified in the CLCR[LADSEL]"
        " bit.",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lmem_pscsar
    },
    {
        "PSCCVR",
        "The CCVR register is used to source write data or return read data for"
        " the commands specified in the CLCR register.",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lmem_psccvr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MCM
#endif

// Bitfields in register MCM_PLASC.
static const field_t hw_mcm_plasc[] =
{
    {
        "ASC",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_PLAMC.
static const field_t hw_mcm_plamc[] =
{
    {
        "AMC",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_FADR.
static const field_t hw_mcm_fadr[] =
{
    {
        "ADDRESS",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_FATR.
static const field_t hw_mcm_fatr[] =
{
    {
        "BEDA",
        "Indicates the type of cache write buffer access when the error was det"
        "ected.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BEMD",
        "Indicates the privilege level of the cache write buffer access when th"
        "e error was detected.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BESZ",
        "Indicates the size of the cache write buffer access when the error was"
        " detected.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BEWT",
        "Indicates the type of system bus access when the error was detected.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BEMN",
        "Crossbar switch bus master number of the captured cache write buffer b"
        "us error.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BEOVR",
        "Indicates if anothercache write buffer bus error is detected before sy"
        "stem software has retrieved all the error information from the origina"
        "l event, this overrun flag is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_FDR.
static const field_t hw_mcm_fdr[] =
{
    {
        "DATA",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a MCM module.
static const reg_t hw_mcm[] =
{
    {
        "PLASC",
        "PLASC is a 16-bit read-only register identifying the presence/absence "
        "of bus slave connections to the device's crossbar switch.",
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mcm_plasc
    },
    {
        "PLAMC",
        "PLAMC is a 16-bit read-only register identifying the presence/absence "
        "of bus master connections to the device's crossbar switch.",
        2, // Width in bytes
        0x0000000a, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mcm_plamc
    },
    {
        "FADR",
        "When a properly-enabled cache write buffer error interrupt event is de"
        "tected, the faulting address is captured in the MCM_FADR register.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mcm_fadr
    },
    {
        "FATR",
        "When a properly-enabled cache write buffer error interrupt event is de"
        "tected, the faulting attributes are captured in the MCM_FATR register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_mcm_fatr
    },
    {
        "FDR",
        "When a properly-enabled cache write buffer error interrupt event is de"
        "tected, the faulting data is captured in the MCM_FDR register.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mcm_fdr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MLB
#endif

// Bitfields in register MLB_MLBC0.
static const field_t hw_mlb_mlbc0[] =
{
    {
        "MLBEN",
        "MediaLB enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLBCLK_2_0",
        "MLB_CLK (MediaLB clock) speed select.",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLBLK",
        "MediaLB lock status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASYRETRY",
        "Asynchronous Tx packet retry.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTLRETRY",
        "Control Tx packet retry.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCNT",
        "The number of frames per sub-buffer for synchronous channels.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MS0.
static const field_t hw_mlb_ms0[] =
{
    {
        "MCS_31_0",
        "MediaLB channel status.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MLBPC2.
static const field_t hw_mlb_mlbpc2[] =
{
    {
        "SDOPC",
        "MLB 3-pin interface: Signal/Data output phase control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MORCD",
        "Divider factor of MLB output reference clock.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MORCE",
        "Output reference clock (for SPDIF and ASRC) enable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MS1.
static const field_t hw_mlb_ms1[] =
{
    {
        "MCS_63_32",
        "MediaLB channel status.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MSS.
static const field_t hw_mlb_mss[] =
{
    {
        "RSTSYSCMD",
        "Reset system command detected (in the system quadlet).",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LKSYSCMD",
        "Network lock system command detected (in the system quadlet).",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ULKSYSCMD",
        "Network unlock system command detected (in the system quadlet).",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSSYSCMD",
        "Channel scan system command detected (in the system quadlet).",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWSYSCMD",
        "Software system command detected (in the system quadlet).",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SERVREQ",
        "Service request enabled.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MSD.
static const field_t hw_mlb_msd[] =
{
    {
        "SD0_7_0",
        "System data (byte 0).",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SD1_7_0",
        "System data (byte 1).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SD2_7_0",
        "System data (byte 2).",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SD3_7_0",
        "System data (byte 3).",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MIEN.
static const field_t hw_mlb_mien[] =
{
    {
        "ISOC_PE",
        "Isochronous Rx protocol error enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISOC_BUFO",
        "Isochronous Rx buffer overflow enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_PE",
        "Synchronous protocol error enable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARX_DONE",
        "Asynchronous Rx done enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARX_PE",
        "Asynchronous Rx protocol error enable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARX_BREAK",
        "Asynchronous Rx break enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATX_DONE",
        "Asynchronous Tx packet done enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATX_PE",
        "Asynchronous Tx protocol error enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATX_BREAK",
        "Asynchronous Tx break enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRX_DONE",
        "Control Rx packet done enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRX_PE",
        "Control Rx protocol error enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRX_BREAK",
        "Control Rx break enable.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTX_DONE",
        "Control Tx packet done enable.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTX_PE",
        "Control Tx protocol error enable.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTX_BREAK",
        "Control Tx break enable.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MLBC1.
static const field_t hw_mlb_mlbc1[] =
{
    {
        "LOCK",
        "MediaLB lock error status.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKM",
        "MediaLB clock missing status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NDA_7_0",
        "Node device address.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_HCTL.
static const field_t hw_mlb_hctl[] =
{
    {
        "RST0",
        "AGU0 software reset",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST1",
        "AGU1 software reset",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN",
        "HBI enable",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_HCMR0.
static const field_t hw_mlb_hcmr0[] =
{
    {
        "CHM_31_0_P",
        "Bitwise channel mask bit",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_HCMR1.
static const field_t hw_mlb_hcmr1[] =
{
    {
        "CHM_63_32",
        "Bitwise channel mask bit",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_HCER0.
static const field_t hw_mlb_hcer0[] =
{
    {
        "CERR_31_0",
        "Bitwise channel error bit",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_HCER1.
static const field_t hw_mlb_hcer1[] =
{
    {
        "CERR_63_32",
        "Bitwise channel error bit",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_HCBR0.
static const field_t hw_mlb_hcbr0[] =
{
    {
        "CHB_31_0",
        "Bitwise channel busy bit",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_HCBR1.
static const field_t hw_mlb_hcbr1[] =
{
    {
        "CHB_63_32",
        "Bitwise channel busy bit",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MDAT0.
static const field_t hw_mlb_mdat0[] =
{
    {
        "DATA_31_0",
        "CTR data - bits[31:0] of 128-bit entry or DBR data - bits[7:0] of 8-bi"
        "t entry",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MDAT1.
static const field_t hw_mlb_mdat1[] =
{
    {
        "DATA_63_32",
        "CTR data - bits[63:32] of 128-bit entry",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MDAT2.
static const field_t hw_mlb_mdat2[] =
{
    {
        "DATA_95_64",
        "CTR data - bits[95:64] of 128-bit entry",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MDAT3.
static const field_t hw_mlb_mdat3[] =
{
    {
        "DATA_127_96",
        "CTR data - bits[127:96] of 128-bit entry",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MDWE0.
static const field_t hw_mlb_mdwe0[] =
{
    {
        "MASK_31_0",
        "Bitwise write enable for CTR data - bits[31:0]",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MDWE1.
static const field_t hw_mlb_mdwe1[] =
{
    {
        "MASK_63_32",
        "Bitwise write enable for CTR data - bits[63:32]",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MDWE2.
static const field_t hw_mlb_mdwe2[] =
{
    {
        "MASK_95_64",
        "Bitwise write enable for CTR data - bits[95:64]",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MDWE3.
static const field_t hw_mlb_mdwe3[] =
{
    {
        "MASK_127_96",
        "Bitwise write enable for CTR data - bits[127:96]",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MCTL.
static const field_t hw_mlb_mctl[] =
{
    {
        "XCMP",
        "Transfer complete (write 0 to clear)",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_MADR.
static const field_t hw_mlb_madr[] =
{
    {
        "ADDR_7_0",
        "CTR address of 128-bit entry or DBR address of 8-bit entry - bits[7:0]",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_13_8",
        "DBR address of 8-bit entry - bits[13:8]",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TB",
        "Target location bit",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNR",
        "Write-Not-Read selection",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_ACTL.
static const field_t hw_mlb_actl[] =
{
    {
        "SCE",
        "Software clear enable:",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMX",
        "AHB interrupt mux enable:",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_MODE",
        "DMA Mode:",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPB",
        "DMA Packet buffering mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_ACSR0.
static const field_t hw_mlb_acsr0[] =
{
    {
        "CHS",
        "Interrupt status for logical channels 31 to 0:",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_ACSR1.
static const field_t hw_mlb_acsr1[] =
{
    {
        "CHS",
        "Interrupt status for logical channels 63 to 32:",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_ACMR0.
static const field_t hw_mlb_acmr0[] =
{
    {
        "CHM_31_0",
        "Bitwise channel mask bit:",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MLB_ACMR1.
static const field_t hw_mlb_acmr1[] =
{
    {
        "CHM",
        "Bitwise channel mask bit:",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MLB module.
static const reg_t hw_mlb[] =
{
    {
        "MLBC0",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mlb_mlbc0
    },
    {
        "MS0",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_ms0
    },
    {
        "MLBPC2",
        "",
        4, // Width in bytes
        0x0000000d, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mlb_mlbpc2
    },
    {
        "MS1",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_ms1
    },
    {
        "MSS",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mlb_mss
    },
    {
        "MSD",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mlb_msd
    },
    {
        "MIEN",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_mlb_mien
    },
    {
        "MLBC1",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mlb_mlbc1
    },
    {
        "HCTL",
        "The HC can control and monitor general operation of the HBI block by r"
        "eading and writing the HBI Control Register (HCTL) through the I/O int"
        "erface.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mlb_hctl
    },
    {
        "HCMR0",
        "The HC can control which channel(s) are able to generate an HBI interr"
        "upt by writing the HBI Channel Mask Registers (HCMRn).",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_hcmr0
    },
    {
        "HCMR1",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_hcmr1
    },
    {
        "HCER0",
        "The HBI Channel Error Registers (HCERn) indicate which channel(s) have"
        " encountered fatal errors.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_hcer0
    },
    {
        "HCER1",
        "HCERn status bits are set when hardware detects hardware errors on the"
        " given logical channel, including: Channel opened, but not enabled, Ch"
        "annel programmed with invalid channel type, or Out-of-range PML for as"
        "ynchronous or control Tx channels",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_hcer1
    },
    {
        "HCBR0",
        "The HC can determine which channel(s) are busy by reading the HBI Chan"
        "nel Busy Registers (HCBRn).",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_hcbr0
    },
    {
        "HCBR1",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_hcbr1
    },
    {
        "MDAT0",
        "",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_mdat0
    },
    {
        "MDAT1",
        "",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_mdat1
    },
    {
        "MDAT2",
        "",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_mdat2
    },
    {
        "MDAT3",
        "",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_mdat3
    },
    {
        "MDWE0",
        "",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_mdwe0
    },
    {
        "MDWE1",
        "",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_mdwe1
    },
    {
        "MDWE2",
        "",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_mdwe2
    },
    {
        "MDWE3",
        "",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_mdwe3
    },
    {
        "MCTL",
        "",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_mctl
    },
    {
        "MADR",
        "",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mlb_madr
    },
    {
        "ACTL",
        "The AHB Control (ACTL) register is written by the HC to configure the "
        "AMBA AHB block for channel interrupts.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mlb_actl
    },
    {
        "ACSR0",
        "The AHB Channel Status (ACSRn) registers contain interrupt bits for ea"
        "ch of the 64 physical channels.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_acsr0
    },
    {
        "ACSR1",
        "",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mlb_acsr1
    },
    {
        "ACMR0",
        "Using the AHB Channel Mask (ACMRn) register, the HC can control which "
        "channel(s) generate interrupts on ahb_int[1:0].",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_acmr0
    },
    {
        "ACMR1",
        "",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mlb_acmr1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MMDC
#endif

// Bitfields in register MMDC_MDCTL.
static const field_t hw_mmdc_mdctl[] =
{
    {
        "DSIZ",
        "DDR data bus size.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COL",
        "Column Address Width.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROW",
        "Row Address Width.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_1",
        "MMDC Enable CS1.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_0",
        "MMDC Enable CS0.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDPDC.
static const field_t hw_mmdc_mdpdc[] =
{
    {
        "TCKSRE",
        "Valid clock cycles after self-refresh entry.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKSRX",
        "Valid clock cycles before self-refresh exit.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOTH_CS_PD",
        "Parallel power down entry to both chip selects.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOW_PD",
        "Slow/fast power down.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_0",
        "Power Down Timer - Chip Select 0.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_1",
        "Power Down Timer - Chip Select 1.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKE",
        "CKE minimum pulse width.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_0",
        "Precharge Timer - Chip Select 0.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_1",
        "Precharge Timer - Chip Select 1.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOTC.
static const field_t hw_mmdc_mdotc[] =
{
    {
        "TODT_IDLE_OFF",
        "ODT turn off latency.",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TODTLON",
        "ODT turn on latency.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAXPD",
        "Asynchronous ODT to power down exit delay.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TANPD",
        "Asynchronous ODT to power down entry delay.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAONPD",
        "Asynchronous RTT turn-on delay (power down with DLL frozen).",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAOFPD",
        "Asynchronous RTT turn-off delay (power down with DLL frozen).",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG0.
static const field_t hw_mmdc_mdcfg0[] =
{
    {
        "TCL",
        "CAS Read Latency.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFAW",
        "Four Active Window (all banks).",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPDLL",
        "Exit precharge power down with DLL frozen to commands requiring DLL.",
        9, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXP",
        "Exit power down with DLL-on to any valid command.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "Exit self refresh to non READ command.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRFC",
        "Refresh command to Active or Refresh command time.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG1.
static const field_t hw_mmdc_mdcfg1[] =
{
    {
        "TCWL",
        "CAS Write Latency.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMRD",
        "Mode Register Set command cycle (all banks).",
        5, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWR",
        "WRITE recovery time (same bank).",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPA",
        "Precharge-all command period.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS",
        "Active to Precharge command period (same bank).",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC",
        "Active to Active or Refresh command period (same bank).",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP",
        "Precharge command period (same bank).",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD",
        "Active command to internal read or write delay time (same bank).",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG2.
static const field_t hw_mmdc_mdcfg2[] =
{
    {
        "TRRD",
        "Active to Active command period (all banks).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWTR",
        "Internal WRITE to READ command delay (same bank).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRTP",
        "Internal READ command to Precharge command delay (same bank).",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDLLK",
        "DLL locking time.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMISC.
static const field_t hw_mmdc_mdmisc[] =
{
    {
        "RST",
        "Software Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TYPE",
        "DDR TYPE.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_4_BANK",
        "Number of banks per DDR device.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RALAT",
        "Read Additional Latency.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIF3_MODE",
        "Command prediction working mode.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPDDR2_S2",
        "LPDDR2 S2 device type indication.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BI_ON",
        "Bank Interleaving On.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WALAT",
        "Write Additional latency.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LHD",
        "Latency hiding disable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_MIRROR",
        "Address mirroring.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CALIB_PER_CS",
        "Number of chip-select for calibration process.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CK1_GATING",
        "Gating the secondary DDR clock.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_RDY",
        "External status device on CS1.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CS0_RDY",
        "External status device on CS0.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDSCR.
static const field_t hw_mmdc_mdscr[] =
{
    {
        "CMD_BA",
        "Bank Address.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_CS",
        "Chip Select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD",
        "Command.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_EN",
        "DQS pads direction.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRR_READ_DATA_VALID",
        "MRR read data valid.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_ACK",
        "Configuration acknowledge.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_REQ",
        "Configuration request.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_LSB_MR_ADDR",
        "Command/Address LSB.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_MSB_MR_OP",
        "Command/Address MSB.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDREF.
static const field_t hw_mmdc_mdref[] =
{
    {
        "START_REF",
        "Manual start of refresh cycle.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFR",
        "Refresh Rate.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_SEL",
        "Refresh Selector.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_CNT",
        "Refresh Counter at DDR clock period If REF_SEL equals '2' a refresh cy"
        "cle will begin every amount of DDR cycles configured in this field.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDRWD.
static const field_t hw_mmdc_mdrwd[] =
{
    {
        "RTR_DIFF",
        "Read to read delay for different chip-select.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_DIFF",
        "Read to write delay for different chip-select.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTW_DIFF",
        "Write to write delay for different chip-select.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTR_DIFF",
        "Write to read delay for different chip-select.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_SAME",
        "Read to write delay for the same chip-select.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDAI",
        "Device auto initialization period.",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOR.
static const field_t hw_mmdc_mdor[] =
{
    {
        "RST_TO_CKE",
        "DDR3: Time from SDE enable to CKE rise.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_TO_RST",
        "DDR3: Time from SDE enable until DDR reset# is high.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPR",
        "DDR3: CKE HIGH to a valid command.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMRR.
static const field_t hw_mmdc_mdmrr[] =
{
    {
        "MRR_READ_DATA0",
        "MRR DATA that arrived on DQ[7:0]",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA1",
        "MRR DATA that arrived on DQ[15:8]",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA2",
        "MRR DATA that arrived on DQ[23:16]",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA3",
        "MRR DATA that arrived on DQ[31:24]",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG3LP.
static const field_t hw_mmdc_mdcfg3lp[] =
{
    {
        "TRPAB_LP",
        "Precharge (all banks) command period.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPPB_LP",
        "Precharge (per bank) command period (same bank).",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD_LP",
        "Active command to internal read or write delay time (same bank).",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_LP",
        "Active to Active or Refresh command period (same bank).",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMR4.
static const field_t hw_mmdc_mdmr4[] =
{
    {
        "UPDATE_DE_REQ",
        "Update Derated Values Request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DE_ACK",
        "Update Derated Values Acknowledge.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRCD_DE",
        "tRCD derating value.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC_DE",
        "tRC derating value.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS_DE",
        "tRAS derating value.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP_DE",
        "tRP derating value.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRRD_DE",
        "tRRD derating value.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDASP.
static const field_t hw_mmdc_mdasp[] =
{
    {
        "CS0_END",
        "CS0_END.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAARCR.
static const field_t hw_mmdc_maarcr[] =
{
    {
        "ARCR_GUARD",
        "ARCR Guard.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_MAX",
        "ARCR Dynamic Maximum.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_JMP",
        "ARCR Dynamic Jump.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_ACC_HIT",
        "ARCR Access Hit Rate.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_PAG_HIT",
        "ARCR Page Hit Rate.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_RCH_EN",
        "This bit defines whether Real time channel is activated and bypassed a"
        "ll other pending accesses, So accesses with QoS=='F' will be granted t"
        "he highest prioritiy in the optimization/reordering mechanism Default "
        "value is 0x1 - encoding 1 (Enabled)",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_EXC_ERR_EN",
        "This bit defines whether exclusive read/write access violation of AXI "
        "6.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_EN",
        "This bit defines whether security read/write access violation result i"
        "n SLV Error response or in OKAY response Default value is 0x1 - encodi"
        "ng 1(response is SLV Error, rresp/bresp=2'b10)",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_LOCK",
        "Once set, this bit locks ARCR_SEC_ERR_EN and prevents from its updatin"
        "g.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAPSR.
static const field_t hw_mmdc_mapsr[] =
{
    {
        "PSD",
        "Automatic Power Saving Disable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSS",
        "Power Saving Status.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIS",
        "Read Idle Status.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WIS",
        "Write Idle Status.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "Automatic Power saving timer.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPMD",
        "General LPMD request.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS",
        "General DVFS request.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPACK",
        "General low-power acknowledge.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DVACK",
        "General DVFS acknowledge.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR0.
static const field_t hw_mmdc_maexidr0[] =
{
    {
        "EXC_ID_MONITOR0",
        "This feild defines ID for Exclusive monitor#0.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR1",
        "This feild defines ID for Exclusive monitor#1.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR1.
static const field_t hw_mmdc_maexidr1[] =
{
    {
        "EXC_ID_MONITOR2",
        "This feild defines ID for Exclusive monitor#2.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR3",
        "This feild defines ID for Exclusive monitor#3.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR0.
static const field_t hw_mmdc_madpcr0[] =
{
    {
        "DBG_EN",
        "Debug and Profiling Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST",
        "Debug and Profiling Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_FRZ",
        "Profiling freeze.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CYC_OVF",
        "Total Profiling Cycles Count Overflow.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS_EN",
        "Step By Step debug Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS",
        "Step By Step trigger.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR1.
static const field_t hw_mmdc_madpcr1[] =
{
    {
        "PRF_AXI_ID",
        "Profiling AXI ID.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_AXI_ID_MASK",
        "Profiling AXI ID Mask.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR0.
static const field_t hw_mmdc_madpsr0[] =
{
    {
        "CYC_COUNT",
        "Total Profiling cycle Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR1.
static const field_t hw_mmdc_madpsr1[] =
{
    {
        "BUSY_COUNT",
        "Profiling Busy Cycles Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR2.
static const field_t hw_mmdc_madpsr2[] =
{
    {
        "RD_ACC_COUNT",
        "Profiling Read Access Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR3.
static const field_t hw_mmdc_madpsr3[] =
{
    {
        "WR_ACC_COUNT",
        "Profiling Write Access Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR4.
static const field_t hw_mmdc_madpsr4[] =
{
    {
        "RD_BYTES_COUNT",
        "Profiling Read Bytes Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR5.
static const field_t hw_mmdc_madpsr5[] =
{
    {
        "WR_BYTES_COUNT",
        "Profiling Write Bytes Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS0.
static const field_t hw_mmdc_masbs0[] =
{
    {
        "SBS_ADDR",
        "Step By Step Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS1.
static const field_t hw_mmdc_masbs1[] =
{
    {
        "SBS_VLD",
        "Step By Step Valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_TYPE",
        "Step By Step Request Type.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LOCK",
        "Step By Step Lock.",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_PROT",
        "Step By Step Protection.",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_SIZE",
        "Step By Step Size.",
        7, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BURST",
        "Step By Step Burst.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BUFF",
        "Step By Step Buffered.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LEN",
        "Step By Step Length.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_AXI_ID",
        "Step By Step AXI ID.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAGENP.
static const field_t hw_mmdc_magenp[] =
{
    {
        "GP31_GP0",
        "General purpose read/write bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQHWCTRL.
static const field_t hw_mmdc_mpzqhwctrl[] =
{
    {
        "ZQ_MODE",
        "ZQ calibration mode:",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PER",
        "ZQ periodic calibration time.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PU_RES",
        "ZQ automatic calibration pull-up result.",
        6, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_PD_RES",
        "ZQ HW calibration pull-down result.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_FOR",
        "Force ZQ automatic calibration process with the i.MX ZQ calibration pa"
        "d.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_INIT",
        "Device ZQ long/init time.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_OPER",
        "Device ZQ long/oper time.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_CS",
        "Device ZQ short time.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_EARLY_COMPARATOR_EN_TIMER",
        "ZQ early comparator enable timer.",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQSWCTRL.
static const field_t hw_mmdc_mpzqswctrl[] =
{
    {
        "ZQ_SW_FOR",
        "ZQ SW calibration enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_RES",
        "ZQ software calibration result.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_SW_PU_VAL",
        "ZQ software pull-up resistence.",
        2, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD_VAL",
        "ZQ software pull-down resistence.",
        7, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD",
        "ZQ software PU/PD calibration.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_ZQ_SW_VAL",
        "Use SW ZQ configured value for I/O pads resistor controls.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_CMP_OUT_SMP",
        "Defines the amount of cycles between driving the ZQ signals to the ZQ "
        "pad and till sampling the comparator enable output while performing ZQ"
        " calibration process with the i.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLGCR.
static const field_t hw_mmdc_mpwlgcr[] =
{
    {
        "HW_WL_EN",
        "Write-Leveling HW (automatic) enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_WL_EN",
        "Write-Leveling SW enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_WL_CNT_EN",
        "SW write-leveling count down enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_SW_RES0",
        "Byte0 write-leveling software result.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES1",
        "Byte1 write-leveling software result.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES2",
        "Byte2 write-leveling software result.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES3",
        "Byte3 write-leveling software result.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR0",
        "Byte0 write-leveling HW calibration error.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR1",
        "Byte1 write-leveling HW calibration error.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR2",
        "Byte2 write-leveling HW calibration error.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR3",
        "Byte3 write-leveling HW calibration error.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDECTRL0.
static const field_t hw_mmdc_mpwldectrl0[] =
{
    {
        "WL_DL_ABS_OFFSET0",
        "Absolute write-leveling delay offset for Byte 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL0",
        "Write leveling half cycle delay for Byte 0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL0",
        "Write leveling cycle delay for Byte 0.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_DL_ABS_OFFSET1",
        "Absolute write-leveling delay offset for Byte 1.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL1",
        "Write leveling half cycle delay for Byte 1.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL1",
        "Write leveling cycle delay for Byte 1.",
        25, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDECTRL1.
static const field_t hw_mmdc_mpwldectrl1[] =
{
    {
        "WL_DL_ABS_OFFSET2",
        "Absolute write-leveling delay offset for Byte 2.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL2",
        "Write leveling half cycle delay for Byte 2.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL2",
        "Write leveling cycle delay for Byte 2.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_DL_ABS_OFFSET3",
        "Absolute write-leveling delay offset for Byte 3.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL3",
        "Write leveling half cycle delay for Byte 3.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL3",
        "Write leveling cycle delay for Byte 3.",
        25, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDLST.
static const field_t hw_mmdc_mpwldlst[] =
{
    {
        "WL_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPODTCTRL.
static const field_t hw_mmdc_mpodtctrl[] =
{
    {
        "ODT_WR_PAS_EN",
        "Inactive write CS ODT enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_WR_ACT_EN",
        "Active write CS ODT enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_RD_PAS_EN",
        "Inactive read CS ODT enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_RD_ACT_EN",
        "Active read CS ODT enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT0_INT_RES",
        "On chip ODT byte0 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte0 resistor during read accesses.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT1_INT_RES",
        "On chip ODT byte1 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte1 resistor during read accesses.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT2_INT_RES",
        "On chip ODT byte2 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte2 resistor during read accesses.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT3_INT_RES",
        "On chip ODT byte3 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte3 resistor during read accesses.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY0DL.
static const field_t hw_mmdc_mprddqby0dl[] =
{
    {
        "RD_DQ0_DEL",
        "Read dqs0 to dq0 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ1_DEL",
        "Read dqs0 to dq1 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ2_DEL",
        "Read dqs0 to dq2 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ3_DEL",
        "Read dqs0 to dq3 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ4_DEL",
        "Read dqs0 to dq4 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ5_DEL",
        "Read dqs0 to dq5 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ6_DEL",
        "Read dqs0 to dq6 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ7_DEL",
        "Read dqs0 to dq7 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY1DL.
static const field_t hw_mmdc_mprddqby1dl[] =
{
    {
        "RD_DQ8_DEL",
        "Read dqs1 to dq8 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ9_DEL",
        "Read dqs1 to dq9 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ10_DEL",
        "Read dqs1 to dq10 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ11_DEL",
        "Read dqs1 to dq11 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ12_DEL",
        "Read dqs1 to dq12 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ13_DEL",
        "Read dqs1 to dq13 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ14_DEL",
        "Read dqs1 to dq14 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ15_DEL",
        "Read dqs1 to dq15 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY2DL.
static const field_t hw_mmdc_mprddqby2dl[] =
{
    {
        "RD_DQ16_DEL",
        "Read dqs2 to dq16 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ17_DEL",
        "Read dqs2 to dq17 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ18_DEL",
        "Read dqs2 to dq18 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ19_DEL",
        "Read dqs2 to dq19 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ20_DEL",
        "Read dqs2 to dq20 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ21_DEL",
        "Read dqs2 to dq21 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ22_DEL",
        "Read dqs2 to dq22 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ23_DEL",
        "Read dqs2 to dq23 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY3DL.
static const field_t hw_mmdc_mprddqby3dl[] =
{
    {
        "RD_DQ24_DEL",
        "Read dqs3 to dq24 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ25_DEL",
        "Read dqs3 to dq25 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ26_DEL",
        "Read dqs3 to dq26 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ27_DEL",
        "Read dqs3 to dq27 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ28_DEL",
        "Read dqs3 to dq28 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ29_DEL",
        "Read dqs3 to dq29 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ30_DEL",
        "Read dqs3 to dq30 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ31_DEL",
        "Read dqs3 to dq31 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY0DL.
static const field_t hw_mmdc_mpwrdqby0dl[] =
{
    {
        "WR_DQ0_DEL",
        "Write dq0 delay fine-tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ1_DEL",
        "Write dq1 delay fine-tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ2_DEL",
        "Write dq2 delay fine-tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ3_DEL",
        "Write dq3 delay fine-tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ4_DEL",
        "Write dq4 delay fine-tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ5_DEL",
        "Write dq5 delay fine-tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ6_DEL",
        "Write dq6 delay fine-tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ7_DEL",
        "Write dq7 delay fine-tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM0_DEL",
        "Write dm0 delay fine-tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY1DL.
static const field_t hw_mmdc_mpwrdqby1dl[] =
{
    {
        "WR_DQ8_DEL",
        "Write dq8 delay fine-tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ9_DEL",
        "Write dq9 delay fine-tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ10_DEL",
        "Write dq10 delay fine-tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ11_DEL",
        "Write dq11 delay fine-tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ12_DEL",
        "Write dq12 delay fine-tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ13_DEL",
        "Write dq13 delay fine-tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ14_DEL",
        "Write dq14 delay fine-tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ15_DEL",
        "Write dq15 delay fine-tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM1_DEL",
        "Write dm1 delay fine-tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY2DL.
static const field_t hw_mmdc_mpwrdqby2dl[] =
{
    {
        "WR_DQ16_DEL",
        "Write dq16 delay fine tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ17_DEL",
        "Write dq17 delay fine tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ18_DEL",
        "Write dq18 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ19_DEL",
        "Write dq19 delay fine tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ20_DEL",
        "Write dq20 delay fine tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ21_DEL",
        "Write dq21 delay fine tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ22_DEL",
        "Write dq22 delay fine tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ23_DEL",
        "Write dq23 delay fine tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM2_DEL",
        "Write dm2 delay fine-tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY3DL.
static const field_t hw_mmdc_mpwrdqby3dl[] =
{
    {
        "WR_DQ24_DEL",
        "Write dq24 delay fine tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ25_DEL",
        "Write dq25 delay fine tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ26_DEL",
        "Write dq26 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ27_DEL",
        "Write dq27 delay fine tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ28_DEL",
        "Write dq28 delay fine tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ29_DEL",
        "Write dq29 delay fine tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ30_DEL",
        "Write dq30 delay fine tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ31_DEL",
        "Write dq31 delay fine tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM3_DEL",
        "Write dm3 delay fine tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL0.
static const field_t hw_mmdc_mpdgctrl0[] =
{
    {
        "DG_DL_ABS_OFFSET0",
        "Absolute read DQS gating delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL0",
        "Read DQS gating half cycles delay for Byte0 .",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_ERR",
        "HW DQS gating error.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_ABS_OFFSET1",
        "Absolute read DQS gating delay offset for Byte1.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_EXT_UP",
        "DG extend upper boundary.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL1",
        "Read DQS gating half cycles delay for Byte1 .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_EN",
        "Enable automatic read DQS gating calibration.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DIS",
        "Read DQS gating disable.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_CMP_CYC",
        "Read DQS gating sample cycle.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST_RD_FIFO",
        "Reset Read Data FIFO and associated pointers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL1.
static const field_t hw_mmdc_mpdgctrl1[] =
{
    {
        "DG_DL_ABS_OFFSET2",
        "Absolute read DQS gating delay offset for Byte2.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL2",
        "Read DQS gating half cycles delay for Byte2 .",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DL_ABS_OFFSET3",
        "Absolute read DQS gating delay offset for Byte3.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL3",
        "Read DQS gating half cycles delay for Byte3 .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGDLST0.
static const field_t hw_mmdc_mpdgdlst0[] =
{
    {
        "DG_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLCTL.
static const field_t hw_mmdc_mprddlctl[] =
{
    {
        "RD_DL_ABS_OFFSET0",
        "Absolute read delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET1",
        "Absolute read delay offset for Byte1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET2",
        "Absolute read delay offset for Byte2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET3",
        "Absolute read delay offset for Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLST.
static const field_t hw_mmdc_mprddlst[] =
{
    {
        "RD_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLCTL.
static const field_t hw_mmdc_mpwrdlctl[] =
{
    {
        "WR_DL_ABS_OFFSET0",
        "Absolute write delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET1",
        "Absolute write delay offset for Byte1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET2",
        "Absolute write delay offset for Byte2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET3",
        "Absolute write delay offset for Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLST.
static const field_t hw_mmdc_mpwrdlst[] =
{
    {
        "WR_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSDCTRL.
static const field_t hw_mmdc_mpsdctrl[] =
{
    {
        "SDCLK0_DEL",
        "DDR clock0 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLK1_DEL",
        "DDR clock1 delay fine tuning.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQLP2CTL.
static const field_t hw_mmdc_mpzqlp2ctl[] =
{
    {
        "ZQ_LP2_HW_ZQINIT",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a Init ZQ calibration.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCL",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a long ZQ calibration.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCS",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a Short ZQ calibration.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWCTL.
static const field_t hw_mmdc_mprddlhwctl[] =
{
    {
        "HW_RD_DL_ERR0",
        "Automatic (HW) read calibration error of Byte0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR1",
        "Automatic (HW) read calibration error of Byte1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR2",
        "Automatic (HW) read calibration error of Byte2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR3",
        "Automatic (HW) read calibration error of Byte3.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_EN",
        "Enable automatic (HW) read calibration.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_RD_DL_CMP_CYC",
        "Automatic (HW) read sample cycle.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWCTL.
static const field_t hw_mmdc_mpwrdlhwctl[] =
{
    {
        "HW_WR_DL_ERR0",
        "Automatic (HW) write calibration error of Byte0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR1",
        "Automatic (HW) write calibration error of Byte1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR2",
        "Automatic (HW) write calibration error of Byte2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR3",
        "Automatic (HW) write calibration error of Byte3.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_EN",
        "Enable automatic (HW) write calibration.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_WR_DL_CMP_CYC",
        "Write sample cycle.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST0.
static const field_t hw_mmdc_mprddlhwst0[] =
{
    {
        "HW_RD_DL_LOW0",
        "Automatic (HW) read calibration result of the lower boundary of Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP0",
        "Automatic (HW) read calibration result of the upper boundary of Byte0.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW1",
        "Automatic (HW) read calibration result of the lower boundary of Byte1.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP1",
        "Automatic (HW) read calibration result of the upper boundary of Byte1.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST1.
static const field_t hw_mmdc_mprddlhwst1[] =
{
    {
        "HW_RD_DL_LOW2",
        "Automatic (HW) read calibration result of the lower boundary of Byte2.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP2",
        "Automatic (HW) read calibration result of the upper boundary of Byte2.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW3",
        "Automatic (HW) read calibration result of the lower boundary of Byte3.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP3",
        "Automatic (HW) read calibration result of the upper boundary of Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST0.
static const field_t hw_mmdc_mpwrdlhwst0[] =
{
    {
        "HW_WR_DL_LOW0",
        "Automatic (HW) write calibration result of the lower boundary of Byte0"
        ".",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP0",
        "Automatic (HW) write calibration result of the upper boundary of Byte0"
        ".",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW1",
        "Automatic (HW) write calibration result of the lower boundary of Byte1"
        ".",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP1",
        "Aautomatic (HW) write utomatic (HW) write calibration result of the up"
        "per boundary of Byte1.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST1.
static const field_t hw_mmdc_mpwrdlhwst1[] =
{
    {
        "HW_WR_DL_LOW2",
        "Automatic (HW) write calibration result of the lower boundary of Byte2"
        ".",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP2",
        "Automatic (HW) write calibration result of the upper boundary of Byte2"
        ".",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW3",
        "Automatic (HW) write calibration result of the lower boundary of Byte3"
        ".",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP3",
        "Automatic (HW) write calibration result of the upper boundary of Byte3"
        ".",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLHWERR.
static const field_t hw_mmdc_mpwlhwerr[] =
{
    {
        "HW_WL0_DQ",
        "HW write-leveling calibration result of Byte0.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL1_DQ",
        "HW write-leveling calibration result of Byte1.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL2_DQ",
        "HW write-leveling calibration result of Byte2.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL3_DQ",
        "HW write-leveling calibration result of Byte3.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST0.
static const field_t hw_mmdc_mpdghwst0[] =
{
    {
        "HW_DG_LOW0",
        "HW DQS gating calibration result of the lower boundary of Byte0.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP0",
        "HW DQS gating calibration result of the upper boundary of Byte0.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST1.
static const field_t hw_mmdc_mpdghwst1[] =
{
    {
        "HW_DG_LOW1",
        "HW DQS gating calibration result of the lower boundary of Byte1.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP1",
        "HW DQS gating calibration result of the upper boundary of Byte1.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST2.
static const field_t hw_mmdc_mpdghwst2[] =
{
    {
        "HW_DG_LOW2",
        "HW DQS gating calibration result of the lower boundary of Byte2.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP2",
        "HW DQS gating calibration result of the upper boundary of Byte2.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST3.
static const field_t hw_mmdc_mpdghwst3[] =
{
    {
        "HW_DG_LOW3",
        "HW DQS gating calibration result of the lower boundary of Byte3.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP3",
        "HW DQS gating calibration result of the upper boundary of Byte3.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR1.
static const field_t hw_mmdc_mppdcmpr1[] =
{
    {
        "PDV1",
        "MMDC Pre defined compare value2.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDV2",
        "MMDC Pre defined compare value2.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR2.
static const field_t hw_mmdc_mppdcmpr2[] =
{
    {
        "MPR_CMP",
        "MPR(DDR3)/DQ calibration (LPDDR2) compare enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPR_FULL_CMP",
        "MPR(DDR3)/DQ calibration (LPDDR2) full compare enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_LEVEL_PATTERN",
        "MPR(DDR3)/DQ calibration(LPDDR2) read compare pattern.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CA_DL_ABS_OFFSET",
        "Absolute CA (Command/Address of LPDDRR2) offset.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_CA_DL_UNIT",
        "This field reflects the number of delay units that are actually used b"
        "y CA (Command/Address of LPDDR2) delay-line",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDAR0.
static const field_t hw_mmdc_mpswdar0[] =
{
    {
        "SW_DUMMY_WR",
        "SW dummy write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUMMY_RD",
        "SW dummy read.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUM_CMP0",
        "SW dummy read byte0 compare results.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP1",
        "SW dummy read byte1 compare results.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP2",
        "SW dummy read byte2 compare results.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP3",
        "SW dummy read byte3 compare results.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR0.
static const field_t hw_mmdc_mpswdrdr0[] =
{
    {
        "DUM_RD0",
        "Dummy read data0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR1.
static const field_t hw_mmdc_mpswdrdr1[] =
{
    {
        "DUM_RD1",
        "Dummy read data1.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR2.
static const field_t hw_mmdc_mpswdrdr2[] =
{
    {
        "DUM_RD2",
        "Dummy read data2.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR3.
static const field_t hw_mmdc_mpswdrdr3[] =
{
    {
        "DUM_RD3",
        "Dummy read data3.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR4.
static const field_t hw_mmdc_mpswdrdr4[] =
{
    {
        "DUM_RD4",
        "Dummy read data4.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR5.
static const field_t hw_mmdc_mpswdrdr5[] =
{
    {
        "DUM_RD5",
        "Dummy read data5.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR6.
static const field_t hw_mmdc_mpswdrdr6[] =
{
    {
        "DUM_RD6",
        "Dummy read data6.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR7.
static const field_t hw_mmdc_mpswdrdr7[] =
{
    {
        "DUM_RD7",
        "Dummy read data7.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPMUR0.
static const field_t hw_mmdc_mpmur0[] =
{
    {
        "MU_BYP_VAL",
        "Number of delay units for measurement bypass.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_BYP_EN",
        "Measure unit bypass enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_MSR",
        "Force measuement on delay-lines.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_UNIT_DEL_NUM",
        "Number of delay units measured per cycle.",
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRCADL.
static const field_t hw_mmdc_mpwrcadl[] =
{
    {
        "WR_CA0_DEL",
        "CA (Command/Address LPDDR2 bus) bit 0 delay fine tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA1_DEL",
        "CA (Command/Address LPDDR2 bus) bit 1 delay fine tuning.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA2_DEL",
        "CA (Command/Address LPDDR2 bus) bit 2 delay fine tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA3_DEL",
        "CA (Command/Address LPDDR2 bus) bit 3 delay fine tuning.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA4_DEL",
        "CA (Command/Address LPDDR2 bus) bit 4 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA5_DEL",
        "CA (Command/Address LPDDR2 bus) bit 5 delay fine tuning.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA6_DEL",
        "CA (Command/Address LPDDR2 bus) bit 6 delay fine tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA7_DEL",
        "CA (Command/Address LPDDR2 bus) bit 7 delay fine tuning.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA8_DEL",
        "CA (Command/Address LPDDR2 bus) bit 8 delay fine tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA9_DEL",
        "CA (Command/Address LPDDR2 bus) bit 9 delay fine tuning.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDCCR.
static const field_t hw_mmdc_mpdccr[] =
{
    {
        "WR_DQS0_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte0.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS1_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte1.",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS2_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte1.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS3_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte0.",
        9, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CK_FT0_DCC",
        "Primary duty cycle fine tuning control of DDR clock.",
        12, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CK_FT1_DCC",
        "Secondary duty cycle fine tuning control of DDR clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS0_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte0.",
        19, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS1_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte1.",
        22, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS2_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte2.",
        25, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS3_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte3.",
        28, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a MMDC module.
static const reg_t hw_mmdc[] =
{
    {
        "MDCTL",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdctl
    },
    {
        "MDPDC",
        "PRCT field encoding PRCT[2:0] Precharge Timer 000 Disabled (Bit field "
        "reset value) 001 2 clocks 010 4 clocks 011 8 clocks 100 16 clocks 101 "
        "32 clocks 110 64 clocks 111 128 clocks PWDT field encoding PWDT[3:0] P"
        "ower Down Time-out 0000 Disabled (bit field reset value) 0001 16 cycle"
        "s 0010 32 cycles 0011 64 cycles 0100 128 cycles 0101 256 cycles 0110 5"
        "12 cycles 0111 1024 cycles 1000 2048 cycles 1001 4096 cycles 1010 8196"
        " cycles 1011 16384 cycles 1100 32768 cycles 1101-1111 Reserved",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdpdc
    },
    {
        "MDOTC",
        "For further information see ODT ConfigurationThe MMDC supports one DRA"
        "M_ODT signal (DRAM_ODT for each DRAM_CS) in DDR3 mode in order to allo"
        "w the DDR device to turn on/off its termination resistors.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdotc
    },
    {
        "MDCFG0",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdcfg0
    },
    {
        "MDCFG1",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mdcfg1
    },
    {
        "MDCFG2",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg2
    },
    {
        "MDMISC",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_mmdc_mdmisc
    },
    {
        "MDSCR",
        "This register is used to issue special commands manually toward the ex"
        "ternal DDR device (such as load mode register, manual self refresh, ma"
        "nual precharge and so on).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdscr
    },
    {
        "MDREF",
        "This register determines the refresh scheme that will be executed towa"
        "rd the DDR device.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdref
    },
    {
        "MDRWD",
        "This register determines the delay between back to back read and write"
        " accesses.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdrwd
    },
    {
        "MDOR",
        "This register defines delays that must be kept when MMDC exits reset.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mdor
    },
    {
        "MDMRR",
        "This register contains data that was collected after issuing MRR comma"
        "nd.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mdmrr
    },
    {
        "MDCFG3LP",
        "This register is relevant only for LPDDR2 mode.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg3lp
    },
    {
        "MDMR4",
        "This register is relevant only for LPDDR2 mode.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mdmr4
    },
    {
        "MDASP",
        "This register defines the partitioning between chip select 0 and chip "
        "select 1.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_mdasp
    },
    {
        "MAARCR",
        "This register determines the values of the weights used for the re-ord"
        "ering arbitration engine.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_maarcr
    },
    {
        "MAPSR",
        "The MAPSR determines the power saving features of MMDC.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mapsr
    },
    {
        "MAEXIDR0",
        "This register defines the ID to be monitored for exclusive accesses of"
        " monitor0 and monitor1.",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr0
    },
    {
        "MAEXIDR1",
        "This register defines the ID to be monitored for exclusive accesses of"
        " monitor2 and monitor3.",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr1
    },
    {
        "MADPCR0",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_madpcr0
    },
    {
        "MADPCR1",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_madpcr1
    },
    {
        "MADPSR0",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr0
    },
    {
        "MADPSR1",
        "The register reflects the total cycles during which the MMDC state mac"
        "hines were busy (both writes and reads).",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr1
    },
    {
        "MADPSR2",
        "This register reflects the total number of read accesses (per AXI ID) "
        "toward MMDC.",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr2
    },
    {
        "MADPSR3",
        "This register reflects the total number of write accesses (per AXI ID)"
        " toward MMDC.",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr3
    },
    {
        "MADPSR4",
        "This register reflects the total number of bytes that were transferred"
        " during read access (per AXI ID) toward MMDC.",
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr4
    },
    {
        "MADPSR5",
        "This register reflects the total number of bytes that were transferred"
        " during write access (per AXI ID) toward MMDC.",
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr5
    },
    {
        "MASBS0",
        "",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_masbs0
    },
    {
        "MASBS1",
        "",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_mmdc_masbs1
    },
    {
        "MAGENP",
        "This register is a general 32 bit read/write register.",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_magenp
    },
    {
        "MPZQHWCTRL",
        "",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpzqhwctrl
    },
    {
        "MPZQSWCTRL",
        "",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mpzqswctrl
    },
    {
        "MPWLGCR",
        "",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_mmdc_mpwlgcr
    },
    {
        "MPWLDECTRL0",
        "",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwldectrl0
    },
    {
        "MPWLDECTRL1",
        "",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwldectrl1
    },
    {
        "MPWLDLST",
        "This register holds the status of the four write leveling delay-lines.",
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwldlst
    },
    {
        "MPODTCTRL",
        "In LPDDR2 mode this register should be cleared, so no termination will"
        " be activated",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mpodtctrl
    },
    {
        "MPRDDQBY0DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte0 relative to the read DQS.",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby0dl
    },
    {
        "MPRDDQBY1DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte1 relative to the read DQS",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby1dl
    },
    {
        "MPRDDQBY2DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte2 relative to the read DQS",
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby2dl
    },
    {
        "MPRDDQBY3DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte3 relative to the read DQS.",
        4, // Width in bytes
        0x00000828, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby3dl
    },
    {
        "MPWRDQBY0DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte0 relative to the write DQS",
        4, // Width in bytes
        0x0000082c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby0dl
    },
    {
        "MPWRDQBY1DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte1 relative to the write DQS",
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby1dl
    },
    {
        "MPWRDQBY2DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte2 relative to the write DQS",
        4, // Width in bytes
        0x00000834, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby2dl
    },
    {
        "MPWRDQBY3DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte3 relative to the write DQS",
        4, // Width in bytes
        0x00000838, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby3dl
    },
    {
        "MPDGCTRL0",
        "",
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdgctrl0
    },
    {
        "MPDGCTRL1",
        "",
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpdgctrl1
    },
    {
        "MPDGDLST0",
        "This register holds the status of the 4 dqs gating delay-lines.",
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpdgdlst0
    },
    {
        "MPRDDLCTL",
        "This register controls read delay-lines functionality; it determines D"
        "QS delay relative to the associated DQ read access.",
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlctl
    },
    {
        "MPRDDLST",
        "This register holds the status of the 4 read delay-lines.",
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlst
    },
    {
        "MPWRDLCTL",
        "This register controls write delay-lines functionality, it determines "
        "DQ/DM delay relative to the associated DQS in write access.",
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlctl
    },
    {
        "MPWRDLST",
        "This register holds the status of the 4 write delay-line.",
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlst
    },
    {
        "MPSDCTRL",
        "This register controls the fine tuning of the primary clock (CK0).",
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mpsdctrl
    },
    {
        "MPZQLP2CTL",
        "This register controls the idle time that takes the LPDDR2 device to p"
        "erform ZQ calibration",
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mpzqlp2ctl
    },
    {
        "MPRDDLHWCTL",
        "",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mprddlhwctl
    },
    {
        "MPWRDLHWCTL",
        "",
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwrdlhwctl
    },
    {
        "MPRDDLHWST0",
        "",
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst0
    },
    {
        "MPRDDLHWST1",
        "",
        4, // Width in bytes
        0x0000086c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst1
    },
    {
        "MPWRDLHWST0",
        "",
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst0
    },
    {
        "MPWRDLHWST1",
        "",
        4, // Width in bytes
        0x00000874, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst1
    },
    {
        "MPWLHWERR",
        "",
        4, // Width in bytes
        0x00000878, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwlhwerr
    },
    {
        "MPDGHWST0",
        "",
        4, // Width in bytes
        0x0000087c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst0
    },
    {
        "MPDGHWST1",
        "",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst1
    },
    {
        "MPDGHWST2",
        "",
        4, // Width in bytes
        0x00000884, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst2
    },
    {
        "MPDGHWST3",
        "",
        4, // Width in bytes
        0x00000888, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst3
    },
    {
        "MPPDCMPR1",
        "This register holds the MMDC pre-defined compare value that will be us"
        "ed during automatic read, read DQS gating and write calibration proces"
        "s.",
        4, // Width in bytes
        0x0000088c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mppdcmpr1
    },
    {
        "MPPDCMPR2",
        "",
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_mmdc_mppdcmpr2
    },
    {
        "MPSWDAR0",
        "",
        4, // Width in bytes
        0x00000894, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpswdar0
    },
    {
        "MPSWDRDR0",
        "",
        4, // Width in bytes
        0x00000898, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr0
    },
    {
        "MPSWDRDR1",
        "",
        4, // Width in bytes
        0x0000089c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr1
    },
    {
        "MPSWDRDR2",
        "",
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr2
    },
    {
        "MPSWDRDR3",
        "",
        4, // Width in bytes
        0x000008a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr3
    },
    {
        "MPSWDRDR4",
        "",
        4, // Width in bytes
        0x000008a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr4
    },
    {
        "MPSWDRDR5",
        "",
        4, // Width in bytes
        0x000008ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr5
    },
    {
        "MPSWDRDR6",
        "",
        4, // Width in bytes
        0x000008b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr6
    },
    {
        "MPSWDRDR7",
        "",
        4, // Width in bytes
        0x000008b4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr7
    },
    {
        "MPMUR0",
        "",
        4, // Width in bytes
        0x000008b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpmur0
    },
    {
        "MPWRCADL",
        "This register is used to add fine-tuning adjustment to the CA (command"
        "/Address of LPDDR2 bus) relative to the DDR clock",
        4, // Width in bytes
        0x000008bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpwrcadl
    },
    {
        "MPDCCR",
        "This register is used to control the duty cycle of the DQS and the pri"
        "mary clock (CK0) .",
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MU
#endif

// Bitfields in register MU_ATR0.
static const field_t hw_mu_atr0[] =
{
    {
        "ATR0",
        "Processor A Transmit Register 0.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ATR1.
static const field_t hw_mu_atr1[] =
{
    {
        "ATR1",
        "Processor A Transmit Register 1.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ATR2.
static const field_t hw_mu_atr2[] =
{
    {
        "ATR2",
        "Processor A Transmit Register 2.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ATR3.
static const field_t hw_mu_atr3[] =
{
    {
        "ATR3",
        "Processor A Transmit Register 3.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ARR0.
static const field_t hw_mu_arr0[] =
{
    {
        "ARR0",
        "Processor A Receive Register 0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ARR1.
static const field_t hw_mu_arr1[] =
{
    {
        "ARR1",
        "Processor A Receive Register 1.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ARR2.
static const field_t hw_mu_arr2[] =
{
    {
        "ARR2",
        "Processor A Receive Register 2.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ARR3.
static const field_t hw_mu_arr3[] =
{
    {
        "ARR3",
        "Processor A Receive Register 3.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ASR.
static const field_t hw_mu_asr[] =
{
    {
        "FN",
        "For n = {0, 1, 2} Processor A-Side Flag n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EP",
        "Processor A-Side Event Pending.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRS",
        "Processor B-side Reset State.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FUP",
        "Processor A Flags Update Pending.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRDIP",
        "Processor B Reset De-asserted Interrupt Pending.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEN",
        "For n = {0, 1, 2, 3} Processor A Transmit Register n Empty.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFN",
        "For n = {0, 1, 2, 3} Processor A Receive Register n Full.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GIPN",
        "For n = {0, 1, 2, 3} Processor A General Interrupt Request n Pending.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MU_ACR.
static const field_t hw_mu_acr[] =
{
    {
        "ABFN",
        "For n = {0, 1, 2} Processor A to Processor B Flag n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUR",
        "Processor A MU Reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRDIE",
        "Processor B Reset De-assertion Interrupt Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GIRN",
        "For n = {0, 1, 2, 3} Processor A General Purpose Interrupt Request n.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIEN",
        "For n = {0, 1, 2, 3} Processor A Transmit Interrupt Enable n.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIEN",
        "For n = {0, 1, 2, 3} Processor A Receive Interrupt Enable n.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GIEN",
        "For n = {0, 1, 2, 3} Processor A General Purpose Interrupt Enable n.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MU module.
static const reg_t hw_mu[] =
{
    {
        "ATR0",
        "Use Processor A Transmit Register 0 (ATR0, 32-bit, write-only) to tran"
        "smit a message or data to the Processor B.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mu_atr0
    },
    {
        "ATR1",
        "Use Processor A Transmit Register 1 (ATR1, 32-bit, write-only) to tran"
        "smit a message or data to the Processor B.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mu_atr1
    },
    {
        "ATR2",
        "Use Processor A Transmit Register 2 (ATR2, 32-bit, write-only) to tran"
        "smit a message or data to the Processor B.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mu_atr2
    },
    {
        "ATR3",
        "Use Processor A Transmit Register 3 (ATR3, 32-bit, write-only) to tran"
        "smit a message or data to the Processor B.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mu_atr3
    },
    {
        "ARR0",
        "Use Processor A Receive Register 0 (ARR0, 32-bit, read-only) to receiv"
        "e a message or data from the Processor B.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mu_arr0
    },
    {
        "ARR1",
        "Use Processor A Receive Register 1 (ARR1, 32-bit, read-only) to receiv"
        "e a message or data from the Processor B.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mu_arr1
    },
    {
        "ARR2",
        "Use Processor A Receive Register 2 (ARR2, 32-bit, read-only) to receiv"
        "e a message or data from the Processor B.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mu_arr2
    },
    {
        "ARR3",
        "Use Processor A Receive Register 3 (ARR3, 32-bit, read-only) to receiv"
        "e a message or data from the Processor B.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mu_arr3
    },
    {
        "ASR",
        "Use the Processor A Status Register (ASR, 32-bit, read-write) to show "
        "interrupt status from the Processor B, general purpose flags, and to s"
        "et dual function control-status bits.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mu_asr
    },
    {
        "ACR",
        "Use the Processor A Control Register (ACR, 32-bit, read-write) to enab"
        "le the MU interrupts on the Processor A-side, and trigger events and i"
        "nterrupts on the Processor B-side (general purpose interrupt, flag upd"
        "ate).",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mu_acr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark M_CAN
#endif

// Bitfields in register M_CAN_CAN1_CREL.
static const field_t hw_m_can_can1_crel[] =
{
    {
        "DAY",
        "Two digits, BCD-coded.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MON",
        "Two digits, BCD-coded.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YEAR",
        "One digit, BCD-coded.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SUBSTEP",
        "One digit, BCD-coded.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STEP",
        "One digit, BCD-coded.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REL",
        "One digit, BCD-coded.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_ENDN.
static const field_t hw_m_can_can1_endn[] =
{
    {
        "ETV",
        "The endianness test value is 0x87654321.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_FBTP.
static const field_t hw_m_can_can1_fbtp[] =
{
    {
        "FSJW",
        "(0x0-0x3)- Valid values are 0 to 3.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FTSEG2",
        "(0x0-0x7)- Valid values are 0 to 7.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FTSEG1",
        "(0x1-0xF)- Valid values are 1 to 15.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBRP",
        "(0x000-0x1F)- The value by which the oscillator frequency is divided f"
        "or generating the bit time quanta.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDC",
        "This field has Protected Write status.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDCO",
        "This field has Protected Write status.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TEST.
static const field_t hw_m_can_can1_test[] =
{
    {
        "LBCK",
        "This field has Protected Write status.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX",
        "This field has Protected Write status.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX",
        "Monitors the actual value of M_CAN Rx",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDCV",
        "(0x00-0x3F)- Position of the secondary sample point, defined by the su"
        "m of the measured delay from M_CAN Tx to M_CAN Rx and FBTP[TDCO].",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RWD.
static const field_t hw_m_can_can1_rwd[] =
{
    {
        "WDC",
        "Start value of the Message RAM Watchdog Counter.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDV",
        "Actual Message RAM Watchdog Counter Value.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_CCCR.
static const field_t hw_m_can_can1_cccr[] =
{
    {
        "INIT",
        "Due to the synchronization mechanism between the two clock domains, th"
        "ere may be a delay until the value written to INIT can be read back.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCE",
        "This field has Protected Write status.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASM",
        "Bit ASM is only set by the CPU when both CCE and INIT are set to 1.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSA",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSR",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON",
        "Bit MON can only be set by the CPU when both CCE and INIT are set to 1"
        ".",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAR",
        "This field has Protected Write status.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST",
        "Bit TEST can only be set by the CPU when both CCE and INIT are set to "
        "1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CME",
        "When CME = 00, received frames are strictly interpreted according to I"
        "SO11898-1, which leads to the transmission of an error frame when rece"
        "iving a CAN FD frame.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMR",
        "A change of the CAN operation mode is requested by writing to this bit"
        " field.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FDO",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FDBS",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXP",
        "If this bit is set, the M_CAN pauses for two CAN bit times before star"
        "ting the next transmission after itself has successfully transmitted a"
        " frame (see Tx Handling).",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_BTP.
static const field_t hw_m_can_can1_btp[] =
{
    {
        "SJW",
        "(0x0-0xF)- Valid values are 0 to 15.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSEG2",
        "(0x0-0xF)- Valid values are 0 to 15.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSEG1",
        "(0x01-0x3F)- Valid values are 1 to 63.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRP",
        "(0x000-0x3FF)- The value by which the oscillator frequency is divided "
        "for generating the bit time quanta.",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TSCC.
static const field_t hw_m_can_can1_tscc[] =
{
    {
        "TSS",
        "This field has Protected Write status.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCP",
        "(0x0-0xF)- Configures the timestamp and timeout counters time unit in "
        "multiples of CAN bit times [116].",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TSCV.
static const field_t hw_m_can_can1_tscv[] =
{
    {
        "TSC",
        "The internal/external Timestamp Counter value is captured on start of "
        "frame (both Rx and Tx).",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TOCC.
static const field_t hw_m_can_can1_tocc[] =
{
    {
        "ETOC",
        "This field has Protected Write status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOS",
        "When operating in Continuous mode, a write to TOCV presets the counter"
        " to the value configured by TOCC[TOP] and continues down-counting.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOP",
        "Start value of the Timeout Counter (down-counter).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TOCV.
static const field_t hw_m_can_can1_tocv[] =
{
    {
        "TOC",
        "The Timeout Counter is decremented in multiples of CAN bit times [1"
        "16] depending on the configuration of TSCC[TCP].",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_ECR.
static const field_t hw_m_can_can1_ecr[] =
{
    {
        "TEC",
        "Actual state of the Transmit Error Counter, values between 0 and 255.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REC",
        "Actual state of the Receive Error Counter, values between 0 and 127.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RP",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CEL",
        "The counter is incremented each time when a CAN protocol error causes "
        "the Transmit Error Counter or the Receive Error Counter to be incremen"
        "ted.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_PSR.
static const field_t hw_m_can_can1_psr[] =
{
    {
        "LEC",
        "The LEC indicates the type of the last error to occur on the CAN bus.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ACT",
        "Monitors the module's CAN communication state.",
        3, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EW",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BO",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FLEC",
        "Type of last error that occurred in the data phase of a CAN FD format "
        "frame with its BRS flag set.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RESI",
        "This bit is set together with REDL, independent of acceptance filterin"
        "g.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RBRS",
        "This bit is set together with REDL, independent of acceptance filterin"
        "g.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REDL",
        "This bit is set independent of acceptance filtering.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_IR.
static const field_t hw_m_can_can1_ir[] =
{
    {
        "RF0N",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0W",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0F",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0L",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1N",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1W",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1F",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1L",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPM",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        "Transmission Completed",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCF",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFE",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFN",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFW",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFF",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFL",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSW",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRAF",
        "The flag is set, when the Rx Handler has not completed acceptance filt"
        "ering or storage of an accepted message until the arbitration field of"
        " the following message has been received.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOO",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRX",
        "The flag is set whenever a received message has been stored into a ded"
        "icated Rx Buffer.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEC",
        "Message RAM bit error detected and corrected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEU",
        "Message RAM bit error detected, uncorrected.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELO",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EP",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EW",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDI",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCE",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BE",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACKE",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FOE",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STE",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_IE.
static const field_t hw_m_can_can1_ie[] =
{
    {
        "RF0NE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0WE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0FE",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0LE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1NE",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1WE",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1FE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1LE",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPME",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCFE",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEE",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFNE",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFWE",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFFE",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFLE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSWE",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRAFE",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOOE",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRXE",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BECE",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEUE",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELOE",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPE",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EWE",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOE",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDIE",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCEE",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEE",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACKEE",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FOEE",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STEE",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_ILS.
static const field_t hw_m_can_can1_ils[] =
{
    {
        "RF0NL",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0WL",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0FL",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF0LL",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1NL",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1WL",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1FL",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF1LL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPML",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCL",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCFL",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEL",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFNL",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFWL",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFFL",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEFLL",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSWL",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRAFL",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOOL",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRXL",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BECL",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEUL",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELOL",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EWL",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDIL",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCEL",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEL",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACKEL",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FOEL",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STEL",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_ILE.
static const field_t hw_m_can_can1_ile[] =
{
    {
        "EINT0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EINT1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_GFC.
static const field_t hw_m_can_can1_gfc[] =
{
    {
        "RRFE",
        "This field has Protected Write status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRFS",
        "This field has Protected Write status.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANFE",
        "Defines how received messages with 29-bit IDs that do not match any el"
        "ement of the filter list are treated.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANFS",
        "Defines how received messages with 11-bit IDs that do not match any el"
        "ement of the filter list are treated.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_SIDFC.
static const field_t hw_m_can_can1_sidfc[] =
{
    {
        "FLSSA",
        "Start address of standard Message ID filter list (32-bit word address,"
        " see Message RAM).",
        2, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LSS",
        "This field has Protected Write status.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_XIDFC.
static const field_t hw_m_can_can1_xidfc[] =
{
    {
        "FLESA",
        "Start address of extended Message ID filter list (32-bit word address,"
        " see Message RAM).",
        2, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LSE",
        "This field has Protected Write status.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_XIDAM.
static const field_t hw_m_can_can1_xidam[] =
{
    {
        "EIDM",
        "For acceptance filtering of extended frames the Extended ID and Mask i"
        "s ANDed with the Message ID of a received frame.",
        0, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_HPMS.
static const field_t hw_m_can_can1_hpms[] =
{
    {
        "BIDX",
        "Index of Rx FIFO element to which the message was stored.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MSI",
        "",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIDX",
        "Index of matching filter element.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FLST",
        "Indicates the filter list of the matching filter element.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_NDAT1.
static const field_t hw_m_can_can1_ndat1[] =
{
    {
        "ND1",
        "The register holds the New Data flags of Rx Buffers 0 to 31.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_NDAT2.
static const field_t hw_m_can_can1_ndat2[] =
{
    {
        "ND2",
        "The register holds the New Data flags of Rx Buffers 32 to 63.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RXF0C.
static const field_t hw_m_can_can1_rxf0c[] =
{
    {
        "F0SA",
        "Start address of Rx FIFO 0 in Message RAM (32-bit word address, see Me"
        "ssage RAM ).",
        2, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F0S",
        "The Rx FIFO 0 elements are indexed from 0 to F0S-1.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F0WM",
        "This field has Protected Write status.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F0OM",
        "FIFO 0 can be operated in blocking or in overwrite mode (see Rx FIFOs)"
        ".",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RXF0S.
static const field_t hw_m_can_can1_rxf0s[] =
{
    {
        "F0FL",
        "Rx FIFO 0 Fill Level Number of elements stored in Rx FIFO 0, range 0 t"
        "o 64.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "F0GI",
        "Rx FIFO 0 Get Index Rx FIFO 0 read index pointer, range 0 to 63.",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "F0PI",
        "Rx FIFO 0 write index pointer, range 0 to 63",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "F0F",
        "Rx FIFO 0 Full",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RF0L",
        "Rx FIFO 0 Message Lost This bit is a copy of interrupt flag IR[RF0L].",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RXF0A.
static const field_t hw_m_can_can1_rxf0a[] =
{
    {
        "F0AI",
        "After the CPU has read a message or a sequence of messages from Rx FIF"
        "O 0 it has to write the buffer index of the last element read from Rx "
        "FIFO 0 to F0AI.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RXBC.
static const field_t hw_m_can_can1_rxbc[] =
{
    {
        "RBSA",
        "Configures the start address of the Rx Buffers section in the Message "
        "RAM (32-bit word address).",
        2, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RXF1C.
static const field_t hw_m_can_can1_rxf1c[] =
{
    {
        "F1SA",
        "Start address of Rx FIFO 1 in Message RAM (32-bit word address, see Me"
        "ssage RAM).",
        2, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1S",
        "The Rx FIFO 1 elements are indexed from 0 to F1S - 1.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1WM",
        "This field has Protected Write status.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1OM",
        "FIFO 1 can be operated in blocking or in overwrite mode (see Rx FIFOs)"
        ".",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RXF1S.
static const field_t hw_m_can_can1_rxf1s[] =
{
    {
        "F1FL",
        "Number of elements stored in Rx FIFO 1, range 0 to 64.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "F1GI",
        "Rx FIFO 1 read index pointer, range 0 to 63.",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "F1PI",
        "Rx FIFO 1 write index pointer, range 0 to 63.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "F1F",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RF1L",
        "This bit is a copy of interrupt flag IR[RF1L].",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMS",
        "",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RXF1A.
static const field_t hw_m_can_can1_rxf1a[] =
{
    {
        "F1AI",
        "After the CPU has read a message or a sequence of messages from Rx FIF"
        "O 1 it has to write the buffer index of the last element read from Rx "
        "FIFO 1 to F1AI.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_RXESC.
static const field_t hw_m_can_can1_rxesc[] =
{
    {
        "F0DS",
        "This field has Protected Write status.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1DS",
        "This field has Protected Write status.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDS",
        "This field has Protected Write status.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXBC.
static const field_t hw_m_can_can1_txbc[] =
{
    {
        "TBSA",
        "Start address of Tx Buffers section in Message RAM (32-bit word addres"
        "s, see Message RAM ).",
        2, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDTB",
        "This field has Protected Write status.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFQS",
        "This field has Protected Write status.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFQM",
        "This field has Protected Write status.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXFQS.
static const field_t hw_m_can_can1_txfqs[] =
{
    {
        "TFFL",
        "Number of consecutive free Tx FIFO elements starting from TFGI, range "
        "0 to 32.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFGI",
        "Tx FIFO read index pointer, range 0 to 31.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFQPI",
        "Tx FIFO/Queue write index pointer, range 0 to 31.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFQF",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXESC.
static const field_t hw_m_can_can1_txesc[] =
{
    {
        "TBDS",
        "In case the data length code DLC of a Tx Buffer element is configured "
        "to a value higher than the Tx Buffer data field size TXESC[TBDS], the "
        "bytes not defined by the Tx Buffer are transmitted as 0xCC (padding by"
        "tes).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXBRP.
static const field_t hw_m_can_can1_txbrp[] =
{
    {
        "TRP",
        "Each Tx Buffer has its own Transmission Request Pending bit.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXBAR.
static const field_t hw_m_can_can1_txbar[] =
{
    {
        "AR",
        "Each Tx Buffer has its own Add Request bit.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXBCR.
static const field_t hw_m_can_can1_txbcr[] =
{
    {
        "CR",
        "Each Tx Buffer has its own Cancellation Request bit.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXBTO.
static const field_t hw_m_can_can1_txbto[] =
{
    {
        "TO",
        "Each Tx Buffer has its own Transmission Occurred bit.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXBCF.
static const field_t hw_m_can_can1_txbcf[] =
{
    {
        "CF",
        "Each Tx Buffer has its own Cancellation Finished bit.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXBTIE.
static const field_t hw_m_can_can1_txbtie[] =
{
    {
        "TIE",
        "Each Tx Buffer has its own Transmission Interrupt Enable bit.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXBCIE.
static const field_t hw_m_can_can1_txbcie[] =
{
    {
        "CFIE",
        "Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXEFC.
static const field_t hw_m_can_can1_txefc[] =
{
    {
        "EFSA",
        "Start address of Tx Event FIFO in Message RAM (32-bit word address, Me"
        "ssage RAM).",
        2, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EFS",
        "The Tx Event FIFO elements are indexed from 0 to EFS - 1 This field ha"
        "s Protected Write status.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EFWM",
        "This field has Protected Write status.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXEFS.
static const field_t hw_m_can_can1_txefs[] =
{
    {
        "EFFL",
        "Number of elements stored in Tx Event FIFO, range 0 to 32.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EFGI",
        "Tx Event FIFO read index pointer, range 0 to 31.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EFPI",
        "Tx Event FIFO write index pointer, range 0 to 31.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EFF",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEFL",
        "This bit is a copy of interrupt flag IR[TEFL].",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register M_CAN_CAN1_TXEFA.
static const field_t hw_m_can_can1_txefa[] =
{
    {
        "EFAI",
        "After the CPU has read an element or a sequence of elements from the T"
        "x Event FIFO it has to write the index of the last element read from T"
        "x Event FIFO to EFAI.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a M_CAN module.
static const reg_t hw_m_can[] =
{
    {
        "CAN1_CREL",
        "The following table shows example field values for this register and e"
        "xplains how they encode a particular M_CAN core release.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_m_can_can1_crel
    },
    {
        "CAN1_ENDN",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_m_can_can1_endn
    },
    {
        "CAN1_FBTP",
        "The CAN bit time may be programed in the range of 4 to 25 time quanta.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_m_can_can1_fbtp
    },
    {
        "CAN1_TEST",
        "Write access to the Test Register has to be enabled by setting CCCR[TE"
        "ST] to 1.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_m_can_can1_test
    },
    {
        "CAN1_RWD",
        "The RAM Watchdog monitors when the Message RAM output is available to "
        "M_CAN.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_m_can_can1_rwd
    },
    {
        "CAN1_CCCR",
        "For details about setting and resetting of single bits see Software In"
        "itialization.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_m_can_can1_cccr
    },
    {
        "CAN1_BTP",
        "The CAN bit time may be programed in the range of [4....81] time quant"
        "a.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_m_can_can1_btp
    },
    {
        "CAN1_TSCC",
        "For a description of the Timestamp Counter see Timestamp Generation",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_m_can_can1_tscc
    },
    {
        "CAN1_TSCV",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_tscv
    },
    {
        "CAN1_TOCC",
        "See Timeout Counter for a description of the Timeout Counter or for us"
        "e of timeout function with CAN FD.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_m_can_can1_tocc
    },
    {
        "CAN1_TOCV",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_tocv
    },
    {
        "CAN1_ECR",
        "When CCCR[ASM] is set, the CAN protocol controller does not increment "
        "TEC and REC when a CAN protocol error is detected, but CEL is still in"
        "cremented.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_m_can_can1_ecr
    },
    {
        "CAN1_PSR",
        "When a frame in CAN FD format has reached the data phase with BRS flag"
        " set, the next CAN event (error or valid frame) will be shown in FLEC "
        "instead of LEC.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_m_can_can1_psr
    },
    {
        "CAN1_IR",
        "The flags are set when one of the listed conditions is detected (edge-"
        "sensitive).",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_m_can_can1_ir
    },
    {
        "CAN1_IE",
        "The settings in the Interrupt Enable register determine which status c"
        "hanges in the Interrupt Register will be signaled on an interrupt line"
        ".",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_m_can_can1_ie
    },
    {
        "CAN1_ILS",
        "The Interrupt Line Select register assigns an interrupt generated by a"
        " specific interrupt flag from the Interrupt Register to one of the two"
        " module interrupt lines.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_m_can_can1_ils
    },
    {
        "CAN1_ILE",
        "Each of the two interrupt lines to the CPU can be enabled / disabled s"
        "eparately by programming bits EINT0 and EINT1.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_m_can_can1_ile
    },
    {
        "CAN1_GFC",
        "Global settings for Message ID filtering.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_m_can_can1_gfc
    },
    {
        "CAN1_SIDFC",
        "Settings for 11-bit standard Message ID filtering.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_m_can_can1_sidfc
    },
    {
        "CAN1_XIDFC",
        "Settings for 29-bit extended Message ID filtering.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_m_can_can1_xidfc
    },
    {
        "CAN1_XIDAM",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_xidam
    },
    {
        "CAN1_HPMS",
        "This register is updated every time a Message ID filter element config"
        "ured to generate a priority event matches.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_m_can_can1_hpms
    },
    {
        "CAN1_NDAT1",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_ndat1
    },
    {
        "CAN1_NDAT2",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_ndat2
    },
    {
        "CAN1_RXF0C",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_m_can_can1_rxf0c
    },
    {
        "CAN1_RXF0S",
        "",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_m_can_can1_rxf0s
    },
    {
        "CAN1_RXF0A",
        "",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_rxf0a
    },
    {
        "CAN1_RXBC",
        "",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_rxbc
    },
    {
        "CAN1_RXF1C",
        "",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_m_can_can1_rxf1c
    },
    {
        "CAN1_RXF1S",
        "",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_m_can_can1_rxf1s
    },
    {
        "CAN1_RXF1A",
        "",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_rxf1a
    },
    {
        "CAN1_RXESC",
        "Configures the number of data bytes belonging to an Rx Buffer / Rx FIF"
        "O element.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_m_can_can1_rxesc
    },
    {
        "CAN1_TXBC",
        "Be aware that the sum of TFQS and NDTB may be not greater than 32.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_m_can_can1_txbc
    },
    {
        "CAN1_TXFQS",
        "The Tx FIFO/Queue status is related to the pending Tx requests listed "
        "in register TXBRP.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_m_can_can1_txfqs
    },
    {
        "CAN1_TXESC",
        "Configures the number of data bytes belonging to a Tx Buffer element.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txesc
    },
    {
        "CAN1_TXBRP",
        "TXBRP bits which are set while a Tx scan is in progress are not consid"
        "ered during this particular Tx scan.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txbrp
    },
    {
        "CAN1_TXBAR",
        "If an add request is applied for a Tx Buffer with pending transmission"
        " request (corresponding TXBRP bit already set), this add request is ig"
        "nored.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txbar
    },
    {
        "CAN1_TXBCR",
        "",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txbcr
    },
    {
        "CAN1_TXBTO",
        "",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txbto
    },
    {
        "CAN1_TXBCF",
        "",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txbcf
    },
    {
        "CAN1_TXBTIE",
        "",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txbtie
    },
    {
        "CAN1_TXBCIE",
        "",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txbcie
    },
    {
        "CAN1_TXEFC",
        "",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_m_can_can1_txefc
    },
    {
        "CAN1_TXEFS",
        "",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_m_can_can1_txefs
    },
    {
        "CAN1_TXEFA",
        "",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_m_can_can1_txefa
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark OCOTP
#endif

// Bitfields in register OCOTP_CTRL.
static const field_t hw_ocotp_ctrl[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_SET.
static const field_t hw_ocotp_ctrl_set[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_CLR.
static const field_t hw_ocotp_ctrl_clr[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_TOG.
static const field_t hw_ocotp_ctrl_tog[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_TIMING.
static const field_t hw_ocotp_timing[] =
{
    {
        "STROBE_PROG",
        "This count value specifies the strobe period in one time write OTP.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELAX",
        "This count value specifies the time to add to all default timing param"
        "eters other than the Tpgm and Trd.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_READ",
        "This count value specifies the strobe period in one time read OTP.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT",
        "This count value specifies time interval between auto read and write a"
        "ccess in one time program.",
        22, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DATA.
static const field_t hw_ocotp_data[] =
{
    {
        "DATA",
        "Used to initiate a write to OTP.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_READ_CTRL.
static const field_t hw_ocotp_read_ctrl[] =
{
    {
        "READ_FUSE",
        "Used to initiate a read to OTP.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_READ_FUSE_DATA.
static const field_t hw_ocotp_read_fuse_data[] =
{
    {
        "DATA",
        "The data read from OTP",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_STICKY.
static const field_t hw_ocotp_sw_sticky[] =
{
    {
        "BLOCK_DTCP_KEY",
        "Shadow register read and OTP read lock for DTCP_KEY region.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRK_REVOKE_LOCK",
        "Shadow register write and OTP write lock for SRK_REVOKE, MC_ERA and AP"
        "_BI_VER regions.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_RETURN_LOCK",
        "Shadow register write and OTP write lock for FIELD_RETURN region.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLOCK_ROM_PART",
        "Set by ARM during Boot after DTCP is initialized and before test mode "
        "entry, if ROM_PART_LOCK=1.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_BLOCK_RELEASE",
        "Set by ARM during Boot after DTCP is initialized and before test mode "
        "entry.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS.
static const field_t hw_ocotp_scs[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS_SET.
static const field_t hw_ocotp_scs_set[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS_CLR.
static const field_t hw_ocotp_scs_clr[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS_TOG.
static const field_t hw_ocotp_scs_tog[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_VERSION.
static const field_t hw_ocotp_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_LOCK.
static const field_t hw_ocotp_lock[] =
{
    {
        "TESTER",
        "Status of shadow register and OTP write lock for tester region.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG",
        "Status of shadow register and OTP write lock for boot_cfg region.",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEM_TRIM",
        "Status of shadow register and OTP write lock for mem_trim region.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SJC_RESP",
        "Status of shadow register read and write, OTP read and write lock for "
        "sjc_resp region.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAC_ADDR",
        "Status of shadow register and OTP write lock for mac_addr region.",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP1",
        "Status of shadow register and OTP write lock for gp2 region.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP2",
        "Status of shadow register and OTP write lock for gp2 region.",
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRK",
        "Status of shadow register and OTP write lock for srk region.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ANALOG",
        "Status of shadow register and OTP write lock for analog region.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MISC_CONF",
        "Status of shadow register and OTP write lock for misc_conf region.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP3",
        "Status of shadow register and OTP write lock for gp3 region.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG0.
static const field_t hw_ocotp_cfg0[] =
{
    {
        "BITS",
        "This register contains 32 bits of the Unique ID and SJC_CHALLENGE fiel"
        "d.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG1.
static const field_t hw_ocotp_cfg1[] =
{
    {
        "BITS",
        "This register contains 32 bits of the Unique ID and SJC_CHALLENGE fiel"
        "d.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG2.
static const field_t hw_ocotp_cfg2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 3 (ADDR = 0x03).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG3.
static const field_t hw_ocotp_cfg3[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 4 (ADDR = 0x04).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG4.
static const field_t hw_ocotp_cfg4[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 5 (ADDR = 0x05).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG5.
static const field_t hw_ocotp_cfg5[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 6 (ADDR = 0x06).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG6.
static const field_t hw_ocotp_cfg6[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 7 (ADDR = 0x07).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM0.
static const field_t hw_ocotp_mem0[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 0 (ADDR = 0x08).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM1.
static const field_t hw_ocotp_mem1[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 1 (ADDR = 0x09).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM2.
static const field_t hw_ocotp_mem2[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 2 (ADDR = 0x0A).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM3.
static const field_t hw_ocotp_mem3[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 3 (ADDR = 0x0B).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM4.
static const field_t hw_ocotp_mem4[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 4 (ADDR = 0x0C).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA0.
static const field_t hw_ocotp_ana0[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 5 (ADDR = 0x0D).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA1.
static const field_t hw_ocotp_ana1[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 6 (ADDR = 0x0E).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA2.
static const field_t hw_ocotp_ana2[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 7 (ADDR = 0x0F).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK0.
static const field_t hw_ocotp_srk0[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word0 (Copy of OTP "
        "Bank 3, word 0 (ADDR = 0x1C)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK1.
static const field_t hw_ocotp_srk1[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word1 (Copy of OTP "
        "Bank 3, word 1 (ADDR = 0x1D)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK2.
static const field_t hw_ocotp_srk2[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word2 (Copy of OTP "
        "Bank 3, word 2 (ADDR = 0x1E)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK3.
static const field_t hw_ocotp_srk3[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word3 (Copy of OTP "
        "Bank 3, word 3 (ADDR = 0x1F)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK4.
static const field_t hw_ocotp_srk4[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word4 (Copy of OTP "
        "Bank 3, word 4 (ADDR = 0x20)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK5.
static const field_t hw_ocotp_srk5[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word5 (Copy of OTP "
        "Bank 3, word 5 (ADDR = 0x21)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK6.
static const field_t hw_ocotp_srk6[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word6 (Copy of OTP "
        "Bank 3, word 6 (ADDR = 0x22)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK7.
static const field_t hw_ocotp_srk7[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word7 (Copy of OTP "
        "Bank 3, word 7 (ADDR = 0x23)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_RESP0.
static const field_t hw_ocotp_resp0[] =
{
    {
        "BITS",
        "Shadow register for the SJC_RESP Key word0 (Copy of OTP Bank 4, word 0"
        " (ADDR = 0x20)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_HSJC_RESP1.
static const field_t hw_ocotp_hsjc_resp1[] =
{
    {
        "BITS",
        "Shadow register for the SJC_RESP Key word1 (Copy of OTP Bank 4, word 1"
        " (ADDR = 0x21)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC0.
static const field_t hw_ocotp_mac0[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 2 (ADDR = 0x22).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC1.
static const field_t hw_ocotp_mac1[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 3 (ADDR = 0x23).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC2.
static const field_t hw_ocotp_mac2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 4 (ADDR = 0x24).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP1.
static const field_t hw_ocotp_gp1[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 6 (ADDR = 0x26).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP2.
static const field_t hw_ocotp_gp2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 7 (ADDR = 0x27).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MISC_CONF.
static const field_t hw_ocotp_misc_conf[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 5 (ADDR = 0x2d).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_FIELD_RETURN.
static const field_t hw_ocotp_field_return[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 6 (ADDR = 0x2e).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK_REVOKE.
static const field_t hw_ocotp_srk_revoke[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 7 (ADDR = 0x2f).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP30.
static const field_t hw_ocotp_gp30[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 1 (ADDR = 0x51).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP31.
static const field_t hw_ocotp_gp31[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 2 (ADDR = 0x52).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP32.
static const field_t hw_ocotp_gp32[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 3 (ADDR = 0x53).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP33.
static const field_t hw_ocotp_gp33[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 4 (ADDR = 0x54).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP34.
static const field_t hw_ocotp_gp34[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 5 (ADDR = 0x55).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP35.
static const field_t hw_ocotp_gp35[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 6 (ADDR = 0x56).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP36.
static const field_t hw_ocotp_gp36[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 7 (ADDR = 0x57).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a OCOTP module.
static const reg_t hw_ocotp[] =
{
    {
        "CTRL",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 The OCOTP Control and Status Register provides the necessary"
        " software interface for performing read and write operations to the On"
        "-Chip OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ocotp_ctrl
    },
    {
        "CTRL_SET",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 The OCOTP Control and Status Register provides the necessary"
        " software interface for performing read and write operations to the On"
        "-Chip OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ocotp_ctrl_set
    },
    {
        "CTRL_CLR",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 The OCOTP Control and Status Register provides the necessary"
        " software interface for performing read and write operations to the On"
        "-Chip OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ocotp_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 The OCOTP Control and Status Register provides the necessary"
        " software interface for performing read and write operations to the On"
        "-Chip OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ocotp_ctrl_tog
    },
    {
        "TIMING",
        "The OCOTP Data Register is used for OTP Programming This register spec"
        "ifies timing parameters for programming and reading the OCOTP fuse arr"
        "ay.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ocotp_timing
    },
    {
        "DATA",
        "The OCOTP Data Register is used for OTP Programming This register is u"
        "sed in conjuction with HW_OCOTP_CTRL to perform one-time writes to the"
        " OTP.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_data
    },
    {
        "READ_CTRL",
        "The OCOTP Register is used for OTP Read This register is used in conju"
        "ction with HW_OCOTP_CTRL to perform one time read to the OTP.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_read_ctrl
    },
    {
        "READ_FUSE_DATA",
        "The OCOTP Data Register is used for OTP Read The data read from OTP EX"
        "AMPLE Empty Example.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_read_fuse_data
    },
    {
        "SW_STICKY",
        "Some SW sticky bits .",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ocotp_sw_sticky
    },
    {
        "SCS",
        "HW_OCOTP_SCS: 0x060 This register holds volatile configuration values "
        "that can be set and locked by trusted software.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs
    },
    {
        "SCS_SET",
        "HW_OCOTP_SCS: 0x060 This register holds volatile configuration values "
        "that can be set and locked by trusted software.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs_set
    },
    {
        "SCS_CLR",
        "HW_OCOTP_SCS: 0x060 This register holds volatile configuration values "
        "that can be set and locked by trusted software.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs_clr
    },
    {
        "SCS_TOG",
        "HW_OCOTP_SCS: 0x060 This register holds volatile configuration values "
        "that can be set and locked by trusted software.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs_tog
    },
    {
        "VERSION",
        "This register always returns a known read value for debug purposes it "
        "indicates the version of the block.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_ocotp_version
    },
    {
        "LOCK",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        11, // Number of bitfields
        hw_ocotp_lock
    },
    {
        "CFG0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg0
    },
    {
        "CFG1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg1
    },
    {
        "CFG2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg2
    },
    {
        "CFG3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg3
    },
    {
        "CFG4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg4
    },
    {
        "CFG5",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg5
    },
    {
        "CFG6",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg6
    },
    {
        "MEM0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem0
    },
    {
        "MEM1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem1
    },
    {
        "MEM2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem2
    },
    {
        "MEM3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem3
    },
    {
        "MEM4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem4
    },
    {
        "ANA0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana0
    },
    {
        "ANA1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana1
    },
    {
        "ANA2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana2
    },
    {
        "SRK0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk0
    },
    {
        "SRK1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk1
    },
    {
        "SRK2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk2
    },
    {
        "SRK3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk3
    },
    {
        "SRK4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk4
    },
    {
        "SRK5",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk5
    },
    {
        "SRK6",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk6
    },
    {
        "SRK7",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk7
    },
    {
        "RESP0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_resp0
    },
    {
        "HSJC_RESP1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_hsjc_resp1
    },
    {
        "MAC0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac0
    },
    {
        "MAC1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac1
    },
    {
        "MAC2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac2
    },
    {
        "GP1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp1
    },
    {
        "GP2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp2
    },
    {
        "MISC_CONF",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_misc_conf
    },
    {
        "FIELD_RETURN",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_field_return
    },
    {
        "SRK_REVOKE",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk_revoke
    },
    {
        "GP30",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp30
    },
    {
        "GP31",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a20, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp31
    },
    {
        "GP32",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a30, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp32
    },
    {
        "GP33",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a40, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp33
    },
    {
        "GP34",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a50, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp34
    },
    {
        "GP35",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a60, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp35
    },
    {
        "GP36",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a70, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp36
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PGC
#endif

// Bitfields in register PGC_ARM_PCIE_PHY_CTRL.
static const field_t hw_pgc_arm_pcie_phy_ctrl[] =
{
    {
        "PCR",
        "Power Control PCR must not change from power-down request (pdn_req) as"
        "sertion until the target subsystem is completely powered up.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_PCIE_PHY_PUPSCR.
static const field_t hw_pgc_arm_pcie_phy_pupscr[] =
{
    {
        "SW",
        "After a power-up request (pup_req assertion), the PGC waits a number o"
        "f IPG clocks equal to the value of SW before asserting power toggle on"
        "/off signal (switch_b).",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        "After asserting power toggle on/off signal (switch_b), the PGC waits a"
        " number of IPG clocks equal to the value of SW2ISO before negating iso"
        "lation.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_PCIE_PHY_PDNSCR.
static const field_t hw_pgc_arm_pcie_phy_pdnscr[] =
{
    {
        "ISO",
        "After a power-down request (pdn_req assertion), the PGC waits a number"
        " of IPG clocks equal to the value of ISO before asserting isolation.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        "After asserting isolation, the PGC waits a number of IPG clocks equal "
        "to the value of ISO2SW before negating power toggle on/off signal (swi"
        "tch_b).",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_PCIE_PHY_SR.
static const field_t hw_pgc_arm_pcie_phy_sr[] =
{
    {
        "PSR",
        "Power status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_MEGA_CTRL.
static const field_t hw_pgc_arm_mega_ctrl[] =
{
    {
        "PCR",
        "Power Control PCR must not change from power-down request (pdn_req) as"
        "sertion until the target subsystem is completely powered up.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_MEGA_PUPSCR.
static const field_t hw_pgc_arm_mega_pupscr[] =
{
    {
        "SW",
        "After a power-up request (pup_req assertion), the PGC waits a number o"
        "f IPG clocks equal to the value of SW before asserting power toggle on"
        "/off signal (switch_b).",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        "After asserting power toggle on/off signal (switch_b), the PGC waits a"
        " number of IPG clocks equal to the value of SW2ISO before negating iso"
        "lation.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_MEGA_PDNSCR.
static const field_t hw_pgc_arm_mega_pdnscr[] =
{
    {
        "ISO",
        "After a power-down request (pdn_req assertion), the PGC waits a number"
        " of IPG clocks equal to the value of ISO before asserting isolation.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        "After asserting isolation, the PGC waits a number of IPG clocks equal "
        "to the value of ISO2SW before negating power toggle on/off signal (swi"
        "tch_b).",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_MEGA_SR.
static const field_t hw_pgc_arm_mega_sr[] =
{
    {
        "PSR",
        "Power status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_DISPLAY_CTRL.
static const field_t hw_pgc_arm_display_ctrl[] =
{
    {
        "PCR",
        "Power Control PCR must not change from power-down request (pdn_req) as"
        "sertion until the target subsystem is completely powered up.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_DISPLAY_PUPSCR.
static const field_t hw_pgc_arm_display_pupscr[] =
{
    {
        "SW",
        "After a power-up request (pup_req assertion), the PGC waits a number o"
        "f IPG clocks equal to the value of SW before asserting power toggle on"
        "/off signal (switch_b).",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        "After asserting power toggle on/off signal (switch_b), the PGC waits a"
        " number of IPG clocks equal to the value of SW2ISO before negating iso"
        "lation.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_DISPLAY_PDNSCR.
static const field_t hw_pgc_arm_display_pdnscr[] =
{
    {
        "ISO",
        "After a power-down request (pdn_req assertion), the PGC waits a number"
        " of IPG clocks equal to the value of ISO before asserting isolation.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        "After asserting isolation, the PGC waits a number of IPG clocks equal "
        "to the value of ISO2SW before negating power toggle on/off signal (swi"
        "tch_b).",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_DISPLAY_SR.
static const field_t hw_pgc_arm_display_sr[] =
{
    {
        "PSR",
        "Power status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_GPU_CTRL.
static const field_t hw_pgc_arm_gpu_ctrl[] =
{
    {
        "PCR",
        "Power Control PCR must not change from power-down request (pdn_req) as"
        "sertion until the target subsystem is completely powered up.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_GPU_PUPSCR.
static const field_t hw_pgc_arm_gpu_pupscr[] =
{
    {
        "SW",
        "After a power-up request (pup_req assertion), the PGC waits a number o"
        "f IPG clocks equal to the value of SW before asserting power toggle on"
        "/off signal (switch_b).",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        "After asserting power toggle on/off signal (switch_b), the PGC waits a"
        " number of IPG clocks equal to the value of SW2ISO before negating iso"
        "lation.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_GPU_PDNSCR.
static const field_t hw_pgc_arm_gpu_pdnscr[] =
{
    {
        "ISO",
        "After a power-down request (pdn_req assertion), the PGC waits a number"
        " of IPG clocks equal to the value of ISO before asserting isolation.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        "After asserting isolation, the PGC waits a number of IPG clocks equal "
        "to the value of ISO2SW before negating power toggle on/off signal (swi"
        "tch_b).",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_GPU_SR.
static const field_t hw_pgc_arm_gpu_sr[] =
{
    {
        "PSR",
        "Power status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_CPU_CTRL.
static const field_t hw_pgc_arm_cpu_ctrl[] =
{
    {
        "PCR",
        "Power Control PCR must not change from power-down request (pdn_req) as"
        "sertion until the target subsystem is completely powered up.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_CPU_PUPSCR.
static const field_t hw_pgc_arm_cpu_pupscr[] =
{
    {
        "SW",
        "After a power-up request (pup_req assertion), the PGC waits a number o"
        "f 32k clocks equal to the value of SW before asserting .",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        "After asserting , the PGC waits a number of 32k clocks equal to the va"
        "lue of SW2ISO before negating isolation.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_CPU_PDNSCR.
static const field_t hw_pgc_arm_cpu_pdnscr[] =
{
    {
        "ISO",
        "After a power-down request (pdn_req assertion), the PGC waits a number"
        " of 32k clocks equal to the value of ISO before asserting isolation.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        "After asserting isolation, the PGC waits a number of 32k clocks equal "
        "to the value of ISO2SW before negating .",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_ARM_CPU_SR.
static const field_t hw_pgc_arm_cpu_sr[] =
{
    {
        "PSR",
        "Power status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PGC module.
static const reg_t hw_pgc[] =
{
    {
        "ARM_PCIE_PHY_CTRL",
        "The PGCR enables the response to a power-down request.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_pcie_phy_ctrl
    },
    {
        "ARM_PCIE_PHY_PUPSCR",
        "The PUPSCR contains the power-up timing parameters.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_pcie_phy_pupscr
    },
    {
        "ARM_PCIE_PHY_PDNSCR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_pcie_phy_pdnscr
    },
    {
        "ARM_PCIE_PHY_SR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_pcie_phy_sr
    },
    {
        "ARM_MEGA_CTRL",
        "The PGCR enables the response to a power-down request.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_mega_ctrl
    },
    {
        "ARM_MEGA_PUPSCR",
        "The PUPSCR contains the power-up timing parameters.",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_mega_pupscr
    },
    {
        "ARM_MEGA_PDNSCR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_mega_pdnscr
    },
    {
        "ARM_MEGA_SR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_mega_sr
    },
    {
        "ARM_DISPLAY_CTRL",
        "The PGCR enables the response to a power-down request.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_display_ctrl
    },
    {
        "ARM_DISPLAY_PUPSCR",
        "The PUPSCR contains the power-up timing parameters.",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_display_pupscr
    },
    {
        "ARM_DISPLAY_PDNSCR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_display_pdnscr
    },
    {
        "ARM_DISPLAY_SR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_display_sr
    },
    {
        "ARM_GPU_CTRL",
        "The PGCR enables the response to a power-down request.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_gpu_ctrl
    },
    {
        "ARM_GPU_PUPSCR",
        "The PUPSCR contains the power-up timing parameters.",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_gpu_pupscr
    },
    {
        "ARM_GPU_PDNSCR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_gpu_pdnscr
    },
    {
        "ARM_GPU_SR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_gpu_sr
    },
    {
        "ARM_CPU_CTRL",
        "The PGCR enables the response to a power-down request.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_cpu_ctrl
    },
    {
        "ARM_CPU_PUPSCR",
        "The PUPSCR contains the power-up timing parameters.",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_cpu_pupscr
    },
    {
        "ARM_CPU_PDNSCR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_arm_cpu_pdnscr
    },
    {
        "ARM_CPU_SR",
        "The PDNSCR contains the power-down timing parameters.",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_arm_cpu_sr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PMU
#endif

// Bitfields in register PMU_REG_1P1.
static const field_t hw_pmu_reg_1p1[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brownout circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PULLDOWN",
        "Control bit to enable the pull-down circuitry in the regulator",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brownout offset voltage in 25mV s"
        "teps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD1P1",
        "Status bit that signals when a brownout is detected on the regulator o"
        "utput.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD1P1",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_WEAK_LINREG",
        "Enables the weak 1p1 regulator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SELREF_WEAK_LINREG",
        "Selects the source for the reference voltage of the weak 1p1 regulator"
        ".",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_3P0.
static const field_t hw_pmu_reg_3p0[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output to be set by the programmed"
        " target voltage setting and internal bandgap reference.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brownout circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brownout offset voltage in 25mV s"
        "teps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_SEL",
        "Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or U"
        "SB_OTG2_VBUS.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD3P0",
        "Status bit that signals when a brownout is detected on the regulator o"
        "utput.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD3P0",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_2P5.
static const field_t hw_pmu_reg_2p5[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brownout circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PULLDOWN",
        "Control bit to enable the pull-down circuitry in the regulator",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brownout offset voltage in 25mV s"
        "teps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD2P5",
        "Status bit that signals when a brownout is detected on the regulator o"
        "utput.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD2P5",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_WEAK_LINREG",
        "Enables the weak 2p5 regulator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_CORE.
static const field_t hw_pmu_reg_core[] =
{
    {
        "REG0_TARG",
        "This field defines the target voltage for the ARM core power domain.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_TARG",
        "This field defines the target voltage for the PCIe power domain.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_TARG",
        "This field defines the target voltage for the SOC power domain.",
        18, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAMP_RATE",
        "Regulator voltage ramp rate.",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FET_ODRIVE",
        "If set, increases the gate drive on power gating FETs to reduce leakag"
        "e in the off state.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC0.
static const field_t hw_pmu_misc0[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_RINGOSC_EN",
        "Enables the internal ring oscillator that can be used in lieu of an ex"
        "ternal 32k crystal.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1.
static const field_t hw_pmu_misc1[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the LVDS output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the LVDS output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the LVDS input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the LVDS input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1_SET.
static const field_t hw_pmu_misc1_set[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the LVDS output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the LVDS output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the LVDS input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the LVDS input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1_CLR.
static const field_t hw_pmu_misc1_clr[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the LVDS output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the LVDS output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the LVDS input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the LVDS input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1_TOG.
static const field_t hw_pmu_misc1_tog[] =
{
    {
        "LVDS1_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS2_CLK_SEL",
        "This field selects the clk to be routed to anaclk2/2b.",
        5, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        "This enables the LVDS output buffer for anaclk1/1b.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_OBEN",
        "This enables the LVDS output buffer for anaclk2/2b.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        "This enables the LVDS input buffer for anaclk1/1b.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK2_IBEN",
        "This enables the LVDS input buffer for anaclk2/2b.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2.
static const field_t hw_pmu_misc2[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2_SET.
static const field_t hw_pmu_misc2_set[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2_CLR.
static const field_t hw_pmu_misc2_clr[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2_TOG.
static const field_t hw_pmu_misc2_tog[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_LOWPWR_CTRL_SET.
static const field_t hw_pmu_lowpwr_ctrl_set[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_LOWPWR_CTRL_CLR.
static const field_t hw_pmu_lowpwr_ctrl_clr[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_LOWPWR_CTRL_TOG.
static const field_t hw_pmu_lowpwr_ctrl_tog[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PMU module.
static const reg_t hw_pmu[] =
{
    {
        "REG_1P1",
        "This register defines the control and status bits for the 1.1V regulat"
        "or.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_pmu_reg_1p1
    },
    {
        "REG_3P0",
        "This register defines the control and status bits for the 3.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pmu_reg_3p0
    },
    {
        "REG_2P5",
        "This register defines the control and status bits for the 2.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_pmu_reg_2p5
    },
    {
        "REG_CORE",
        "This register defines the function of the digital regulators",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pmu_reg_core
    },
    {
        "MISC0",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_pmu_misc0
    },
    {
        "MISC1",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pmu_misc1
    },
    {
        "MISC1_SET",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pmu_misc1_set
    },
    {
        "MISC1_CLR",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pmu_misc1_clr
    },
    {
        "MISC1_TOG",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pmu_misc1_tog
    },
    {
        "MISC2",
        "This register defines the control for miscellaneous PMU Analog blocks.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pmu_misc2
    },
    {
        "MISC2_SET",
        "This register defines the control for miscellaneous PMU Analog blocks.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pmu_misc2_set
    },
    {
        "MISC2_CLR",
        "This register defines the control for miscellaneous PMU Analog blocks.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pmu_misc2_clr
    },
    {
        "MISC2_TOG",
        "This register defines the control for miscellaneous PMU Analog blocks.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pmu_misc2_tog
    },
    {
        "LOWPWR_CTRL_SET",
        "This register defines the low power configuration bits.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_pmu_lowpwr_ctrl_set
    },
    {
        "LOWPWR_CTRL_CLR",
        "This register defines the low power configuration bits.",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_pmu_lowpwr_ctrl_clr
    },
    {
        "LOWPWR_CTRL_TOG",
        "This register defines the low power configuration bits.",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_pmu_lowpwr_ctrl_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PWM
#endif

// Bitfields in register PWM_PWMCR.
static const field_t hw_pwm_pwmcr[] =
{
    {
        "EN",
        "PWM Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REPEAT",
        "Sample Repeat.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software Reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER",
        "Counter Clock Prescaler Value.",
        4, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Select Clock Source.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POUTC",
        "PWM Output Configuration.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCTR",
        "Half-word Data Swap Control.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCTR",
        "Byte Data Swap Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "Debug Mode Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "Wait Mode Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        "Doze Mode Enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "Stop Mode Enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWM",
        "FIFO Water Mark.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMSR.
static const field_t hw_pwm_pwmsr[] =
{
    {
        "FIFOAV",
        "FIFO Available.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FE",
        "FIFO Empty Status Bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROV",
        "Roll-over Status.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP",
        "Compare Status.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWE",
        "FIFO Write Error Status.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMIR.
static const field_t hw_pwm_pwmir[] =
{
    {
        "FIE",
        "FIFO Empty Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "Roll-over Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        "Compare Interrupt Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMSAR.
static const field_t hw_pwm_pwmsar[] =
{
    {
        "SAMPLE",
        "Sample Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMPR.
static const field_t hw_pwm_pwmpr[] =
{
    {
        "PERIOD",
        "Period Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMCNR.
static const field_t hw_pwm_pwmcnr[] =
{
    {
        "COUNT",
        "Counter Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PWM module.
static const reg_t hw_pwm[] =
{
    {
        "PWMCR",
        "The PWM control register (PWM_PWMCR) is used to configure the operatin"
        "g settings of the PWM.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pwm_pwmcr
    },
    {
        "PWMSR",
        "The PWM status register (PWM_PWMSR) contains seven bits which display "
        "the state of the FIFO and the occurrence of rollover and compare event"
        "s.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pwm_pwmsr
    },
    {
        "PWMIR",
        "The PWM Interrupt register (PWM_PWMIR) contains three bits which contr"
        "ol the generation of the compare, rollover and FIFO empty interrupts.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pwm_pwmir
    },
    {
        "PWMSAR",
        "The PWM sample register (PWM_PWMSAR) is the input to the FIFO.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pwm_pwmsar
    },
    {
        "PWMPR",
        "The PWM period register (PWM_PWMPR) determines the period of the PWM o"
        "utput signal.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pwm_pwmpr
    },
    {
        "PWMCNR",
        "The read-only pulse-width modulator counter register (PWM_PWMCNR) cont"
        "ains the current count value and can be read at any time without distu"
        "rbing the counter.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_pwm_pwmcnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PXP
#endif

// Bitfields in register PXP_CTRL.
static const field_t hw_pxp_ctrl[] =
{
    {
        "ENABLE",
        "Enables PXP operation with specified parameters.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ENABLE",
        "Interrupt enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT_IRQ_ENABLE",
        "Next command interrupt enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_DMA_IRQ_ENABLE",
        "LUT DMA interrupt enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_LCD_HANDSHAKE",
        "Enable handshake with LCD controller.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROTATE",
        "Indicates the clockwise rotation to be applied at the output buffer.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HFLIP",
        "Indicates that the output buffer should be flipped horizontally (effec"
        "t applied before rotation).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VFLIP",
        "Indicates that the output buffer should be flipped vertically (effect "
        "applied before rotation).",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        12, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROT_POS",
        "This bit controls where rotation will occur in the PXP datapath.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLOCK_SIZE",
        "Select the block size to process.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EN_REPEAT",
        "Enable the PXP to run continuously.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set to zero.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal PXP operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_STAT.
static const field_t hw_pxp_stat[] =
{
    {
        "IRQ",
        "Indicates current PXP interrupt status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_WRITE_ERROR",
        "Indicates PXP encountered an AXI write error and processing has been t"
        "erminated.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_READ_ERROR",
        "Indicates PXP encountered an AXI read error and processing has been te"
        "rminated.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT_IRQ",
        "Indicates that a command issued with the \"Next Command\" functionalit"
        "y has been issued and that a new command may be initiated with a write"
        " to the PXP_NEXT register.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_ERROR_ID",
        "Indicates the AXI ID of the failing bus operation.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LUT_DMA_LOAD_DONE_IRQ",
        "Indicates that the LUT DMA transfer has completed.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BLOCKY",
        "Indicates the X coordinate of the block currently being rendered.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BLOCKX",
        "Indicates the X coordinate of the block currently being rendered.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_CTRL.
static const field_t hw_pxp_out_ctrl[] =
{
    {
        "FORMAT",
        "Output framebuffer format.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTERLACED_OUTPUT",
        "Determines how the PXP writes it's output data.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        10, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALPHA_OUTPUT",
        "Indicates that alpha component in output buffer pixels should be overw"
        "ritten by PXP_OUT_CTRL[ALPHA].",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        "When generating an output buffer with an alpha component, the value in"
        " this field will be used when enabled to override the alpha passed thr"
        "ough the pixel data pipeline.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_BUF.
static const field_t hw_pxp_out_buf[] =
{
    {
        "ADDR",
        "Current address pointer for the output frame buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_BUF2.
static const field_t hw_pxp_out_buf2[] =
{
    {
        "ADDR",
        "Current address pointer for the output frame buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PITCH.
static const field_t hw_pxp_out_pitch[] =
{
    {
        "PITCH",
        "Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_LRC.
static const field_t hw_pxp_out_lrc[] =
{
    {
        "Y",
        "Indicates the number of vertical PIXELS in the output surface (non-rot"
        "ated).",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "Indicates number of horizontal PIXELS in the output surface (non-rotat"
        "ed).",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PS_ULC.
static const field_t hw_pxp_out_ps_ulc[] =
{
    {
        "Y",
        "This field indicates the upper left Y-coordinate (in pixels) of the pr"
        "ocessed surface in the output buffer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "This field indicates the upper left X-coordinate (in pixels) of the pr"
        "ocessed surface (PS) in the output buffer.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PS_LRC.
static const field_t hw_pxp_out_ps_lrc[] =
{
    {
        "Y",
        "This field indicates the lower right Y-coordinate (in pixels) of the p"
        "rocessed surface in the output frame buffer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "This field indicates the lower right X-coordinate (in pixels) of the p"
        "rocessed surface (PS) in the output frame buffer.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_AS_ULC.
static const field_t hw_pxp_out_as_ulc[] =
{
    {
        "Y",
        "This field indicates the upper left Y-coordinate (in pixels) of the al"
        "pha surface in the output frame buffer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "This field indicates the upper left X-coordinate (in pixels) of the al"
        "pha surface (AS) in the output frame buffer.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_AS_LRC.
static const field_t hw_pxp_out_as_lrc[] =
{
    {
        "Y",
        "This field indicates the lower right Y-coordinate (in pixels) of the a"
        "lpha surface in the output frame buffer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "This field indicates the lower right X-coordinate (in pixels) of the a"
        "lpha surface (AS) in the output frame buffer.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CTRL.
static const field_t hw_pxp_ps_ctrl[] =
{
    {
        "FORMAT",
        "PS buffer format.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WB_SWAP",
        "Swap bytes in words.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DECY",
        "Verticle pre decimation filter control.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECX",
        "Horizontal pre decimation filter control.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        12, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_BUF.
static const field_t hw_pxp_ps_buf[] =
{
    {
        "ADDR",
        "Address pointer for the PS RGB or Y (luma) input buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_UBUF.
static const field_t hw_pxp_ps_ubuf[] =
{
    {
        "ADDR",
        "Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_VBUF.
static const field_t hw_pxp_ps_vbuf[] =
{
    {
        "ADDR",
        "Address pointer for the PS V/Cr Chroma input buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_PITCH.
static const field_t hw_pxp_ps_pitch[] =
{
    {
        "PITCH",
        "Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_BACKGROUND.
static const field_t hw_pxp_ps_background[] =
{
    {
        "COLOR",
        "Background color (in 24bpp format) for any pixels not within the buffe"
        "r range specified by the PS ULC/LRC.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_SCALE.
static const field_t hw_pxp_ps_scale[] =
{
    {
        "XSCALE",
        "This is a two bit integer and 12 bit fractional representation (##.###"
        "#_####_####) of the X scaling factor for the PS source buffer.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YSCALE",
        "This is a two bit integer and 12 bit fractional representation (##.###"
        "#_####_####) of the Y scaling factor for the PS source buffer.",
        16, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_OFFSET.
static const field_t hw_pxp_ps_offset[] =
{
    {
        "XOFFSET",
        "This is a 12 bit fractional representation (0.####_####_####) of the X"
        " scaling offset.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YOFFSET",
        "This is a 12 bit fractional representation (0.####_####_####) of the Y"
        " scaling offset.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CLRKEYLOW.
static const field_t hw_pxp_ps_clrkeylow[] =
{
    {
        "PIXEL",
        "Low range of color key applied to PS buffer.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CLRKEYHIGH.
static const field_t hw_pxp_ps_clrkeyhigh[] =
{
    {
        "PIXEL",
        "High range of color key applied to PS buffer.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CTRL.
static const field_t hw_pxp_as_ctrl[] =
{
    {
        "RSVD0",
        "Reserved, always set to zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALPHA_CTRL",
        "Determines how the alpha value is constructed for this alpha surface.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_COLORKEY",
        "Indicates that colorkey functionality is enabled for this alpha surfac"
        "e.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORMAT",
        "Indicates the input buffer format for AS.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        "Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values a"
        "re programmed in PXP_AS_CTRL[ALPHA_CTRL].",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROP",
        "Indicates a raster operation to perform when enabled.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_INVERT",
        "Setting this bit to logic 0 will not alter the alpha value.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_BUF.
static const field_t hw_pxp_as_buf[] =
{
    {
        "ADDR",
        "Address pointer for the alpha surface 0 buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_PITCH.
static const field_t hw_pxp_as_pitch[] =
{
    {
        "PITCH",
        "Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CLRKEYLOW.
static const field_t hw_pxp_as_clrkeylow[] =
{
    {
        "PIXEL",
        "Low range of RGB color key applied to AS buffer.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CLRKEYHIGH.
static const field_t hw_pxp_as_clrkeyhigh[] =
{
    {
        "PIXEL",
        "High range of RGB color key applied to AS buffer.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF0.
static const field_t hw_pxp_csc1_coef0[] =
{
    {
        "Y_OFFSET",
        "Two's compliment amplitude offset implicit in the Y data.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UV_OFFSET",
        "Two's compliment phase offset implicit for CbCr data.",
        9, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C0",
        "Two's compliment Y multiplier coefficient.",
        18, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYPASS",
        "Bypass the CSC unit in the scaling engine.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR_MODE",
        "Set to 1 when performing YCbCr conversion to RGB.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF1.
static const field_t hw_pxp_csc1_coef1[] =
{
    {
        "C4",
        "Two's compliment Blue U/Cb multiplier coefficient.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C1",
        "Two's compliment Red V/Cr multiplier coefficient.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF2.
static const field_t hw_pxp_csc1_coef2[] =
{
    {
        "C3",
        "Two's complement Green U/Cb multiplier coefficient.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C2",
        "Two's complement Green V/Cr multiplier coefficient.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_CTRL.
static const field_t hw_pxp_csc2_ctrl[] =
{
    {
        "BYPASS",
        "This bit controls whether the pixels entering the CSC2 unit get conver"
        "ted or not.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_MODE",
        "This field controls how the CSC unit operates on pixels when the CSC i"
        "s not bypassed.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        3, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF0.
static const field_t hw_pxp_csc2_coef0[] =
{
    {
        "A1",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A2",
        "Two's complement coefficient offset.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF1.
static const field_t hw_pxp_csc2_coef1[] =
{
    {
        "A3",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "B1",
        "Two's complement coefficient offset.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF2.
static const field_t hw_pxp_csc2_coef2[] =
{
    {
        "B2",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "B3",
        "Two's complement coefficient offset.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF3.
static const field_t hw_pxp_csc2_coef3[] =
{
    {
        "C1",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C2",
        "Two's complement coefficient offset.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF4.
static const field_t hw_pxp_csc2_coef4[] =
{
    {
        "C3",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "D1",
        "Two's complement coefficient integer offset to be added.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF5.
static const field_t hw_pxp_csc2_coef5[] =
{
    {
        "D2",
        "Two's complement D1 coefficient integer offset to be added.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "D3",
        "Two's complement coefficient integer offset to be added.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_CTRL.
static const field_t hw_pxp_lut_ctrl[] =
{
    {
        "DMA_START",
        "Setting this bit will result in the DMA operation to load the PXP LUT "
        "memory based on PXP_LUT_ADDR_NUM_BYTES, PXP_LUT_ADDR_ADDR, and PXP_LUT"
        "_MEM_ADDR.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        1, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INVALID",
        "Invalidate the cache LRU and valid bits.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LRU_UPD",
        "Least Recently Used Policy Update Control: 1=> block LRU update for hi"
        "t after miss.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL_8KB",
        "Selects which 8KB bank of memory to use for direct 12bpp lookup modes.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUT_MODE",
        "Select the output mode of operation for the LUT resource.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        18, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOOKUP_MODE",
        "Configure the input address for the 16KB LUT memory.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        26, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYPASS",
        "Setting this bit will bypass the LUT memory resource completely.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_ADDR.
static const field_t hw_pxp_lut_addr[] =
{
    {
        "ADDR",
        "LUT indexed address pointer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_BYTES",
        "Indicates the number of bytes to load via a DMA operation.",
        16, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_DATA.
static const field_t hw_pxp_lut_data[] =
{
    {
        "DATA",
        "Writing this field will load 4 bytes, aligned to four byte boundaries,"
        " of data indexed by the ADDR field of the PXP_LUT_CTRL register.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_EXTMEM.
static const field_t hw_pxp_lut_extmem[] =
{
    {
        "ADDR",
        "This register contains the external memory address used for LUT memory"
        " operation.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CFA.
static const field_t hw_pxp_cfa[] =
{
    {
        "DATA",
        "This register contains the Color Filter Array pattern for decimation o"
        "f RGBW4444 16 bit pixels to individual R, G, B, W values.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST_CTRL.
static const field_t hw_pxp_hist_ctrl[] =
{
    {
        "STATUS",
        "Indicates which histogram matched the processed bitmap.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANEL_MODE",
        "This value is used to specify the number of bits used in comparisons w"
        "hen matching pixels to histogram bins.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        6, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST2_PARAM.
static const field_t hw_pxp_hist2_param[] =
{
    {
        "VALUE0",
        "Black value for 2-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE1",
        "White value for 2-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST4_PARAM.
static const field_t hw_pxp_hist4_param[] =
{
    {
        "VALUE0",
        "GRAY0 (Black) value for 4-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE1",
        "GRAY1 value for 4-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE2",
        "GRAY2 value for 4-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE3",
        "GRAY3 (White) value for 4-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST8_PARAM0.
static const field_t hw_pxp_hist8_param0[] =
{
    {
        "VALUE0",
        "GRAY0 (Black) value for 8-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE1",
        "GRAY1 value for 8-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE2",
        "GRAY2 value for 8-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE3",
        "GRAY3 value for 8-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST8_PARAM1.
static const field_t hw_pxp_hist8_param1[] =
{
    {
        "VALUE4",
        "GRAY4 value for 8-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE5",
        "GRAY5 value for 8-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE6",
        "GRAY6 value for 8-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD6",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE7",
        "GRAY7 (White) value for 8-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD7",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM0.
static const field_t hw_pxp_hist16_param0[] =
{
    {
        "VALUE0",
        "GRAY0 (Black) value for 16-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE1",
        "GRAY1 value for 16-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE2",
        "GRAY2 value for 16-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE3",
        "GRAY3 value for 16-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM1.
static const field_t hw_pxp_hist16_param1[] =
{
    {
        "VALUE4",
        "GRAY4 value for 16-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE5",
        "GRAY5 value for 16-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE6",
        "GRAY6 value for 16-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD6",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE7",
        "GRAY7 value for 16-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD7",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM2.
static const field_t hw_pxp_hist16_param2[] =
{
    {
        "VALUE8",
        "GRAY8 value for 16-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD8",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE9",
        "GRAY9 value for 16-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD9",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE10",
        "GRAY10 value for 16-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD10",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE11",
        "GRAY11 value for 16-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD11",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM3.
static const field_t hw_pxp_hist16_param3[] =
{
    {
        "VALUE12",
        "GRAY12 value for 16-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD12",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE13",
        "GRAY13 value for 16-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD13",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE14",
        "GRAY14 value for 16-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD14",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE15",
        "GRAY15 (White) value for 16-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD15",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_POWER.
static const field_t hw_pxp_power[] =
{
    {
        "LUT_LP_STATE_WAY0_BANK0",
        "Select the low power state of the LUT's WAY0-BANK0 memory.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_LP_STATE_WAY0_BANKN",
        "Select the low power state of the LUT's WAY0-BANK1,2,3 memory.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_LP_STATE_WAY1_BANKN",
        "Select the low power state of the LUT's WAY0-BANK0,1,2,3 memory.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROT_MEM_LP_STATE",
        "Select the low power state of the ROT memory.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTRL",
        "This register contains power control for the PXP.",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_NEXT.
static const field_t hw_pxp_next[] =
{
    {
        "ENABLED",
        "Indicates that the \"next frame\" functionality has been enabled.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POINTER",
        "A pointer to a data structure containing register values to be used wh"
        "en processing the next frame.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PXP module.
static const reg_t hw_pxp[] =
{
    {
        "CTRL",
        "The CTRL register contains controls for the PXP module.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pxp_ctrl
    },
    {
        "STAT",
        "The PXP Interrupt Status register provides interrupt status informatio"
        "n.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_pxp_stat
    },
    {
        "OUT_CTRL",
        "The OUT_CTRL register contains controls for the Output Buffer.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pxp_out_ctrl
    },
    {
        "OUT_BUF",
        "Output Framebuffer Pointer.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_out_buf
    },
    {
        "OUT_BUF2",
        "Output Framebuffer Pointer #2.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_out_buf2
    },
    {
        "OUT_PITCH",
        "This register contains the output buffer pitch in bytes.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_out_pitch
    },
    {
        "OUT_LRC",
        "This register contains the size, or lower right coordinate, of the out"
        "put buffer NOT rotated.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_lrc
    },
    {
        "OUT_PS_ULC",
        "This register contains the upper left pixel coordinate for the Process"
        "ed Surface in the OUTPUT buffer.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_ps_ulc
    },
    {
        "OUT_PS_LRC",
        "This register contains the lower right extent for the Processed Surfac"
        "e in the OUTPUT buffer.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_ps_lrc
    },
    {
        "OUT_AS_ULC",
        "This register contains the upper left location for the Alpha Surface i"
        "n the output buffer.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_as_ulc
    },
    {
        "OUT_AS_LRC",
        "This register contains the lower right extent for Alpha Surface in the"
        " output buffer.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_as_lrc
    },
    {
        "PS_CTRL",
        "The PS_CTRL register contains controls for the Processed Surface Buffe"
        "r.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pxp_ps_ctrl
    },
    {
        "PS_BUF",
        "PS Input Buffer Address.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_buf
    },
    {
        "PS_UBUF",
        "PS Chroma (U/Cb/UV) Input Buffer Address.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_ubuf
    },
    {
        "PS_VBUF",
        "PS Chroma (V/Cr) Input Buffer Address.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_vbuf
    },
    {
        "PS_PITCH",
        "This register contains the processed surface pitch in bytes.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_pitch
    },
    {
        "PS_BACKGROUND",
        "PS Background Pixel Color.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_background
    },
    {
        "PS_SCALE",
        "PS Scale Factor.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_ps_scale
    },
    {
        "PS_OFFSET",
        "PS Scale Offset.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_ps_offset
    },
    {
        "PS_CLRKEYLOW",
        "This register contains the color key low value for the PS buffer.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_clrkeylow
    },
    {
        "PS_CLRKEYHIGH",
        "This register contains the color key high value for the PS buffer.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_clrkeyhigh
    },
    {
        "AS_CTRL",
        "This register contains buffer control for the Alpha Surface 0 input bu"
        "ffer.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_as_ctrl
    },
    {
        "AS_BUF",
        "Alpha Surface 0 Buffer Address Pointer.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_as_buf
    },
    {
        "AS_PITCH",
        "This register contains the alpha surface pitch in bytes.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_as_pitch
    },
    {
        "AS_CLRKEYLOW",
        "This register contains the color key low value for the AS buffer.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_as_clrkeylow
    },
    {
        "AS_CLRKEYHIGH",
        "This register contains the color key high value for the AS buffer.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_as_clrkeyhigh
    },
    {
        "CSC1_COEF0",
        "This register contains color space conversion coefficients in two's co"
        "mpliment notation.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pxp_csc1_coef0
    },
    {
        "CSC1_COEF1",
        "This register contains color space conversion coefficients in two's co"
        "mpliment notation.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc1_coef1
    },
    {
        "CSC1_COEF2",
        "This register contains color space conversion coefficients in two's co"
        "mpliment notation.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc1_coef2
    },
    {
        "CSC2_CTRL",
        "This register contains the control registers to configure the CSC modu"
        "le.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pxp_csc2_ctrl
    },
    {
        "CSC2_COEF0",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef0
    },
    {
        "CSC2_COEF1",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef1
    },
    {
        "CSC2_COEF2",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef2
    },
    {
        "CSC2_COEF3",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef3
    },
    {
        "CSC2_COEF4",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef4
    },
    {
        "CSC2_COEF5",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef5
    },
    {
        "LUT_CTRL",
        "This register is used to access/control the Monochrome Lookup table.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_pxp_lut_ctrl
    },
    {
        "LUT_ADDR",
        "This register is used to access/control the Monochrome Lookup table.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_lut_addr
    },
    {
        "LUT_DATA",
        "This register is used to load data into the lookup table.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_lut_data
    },
    {
        "LUT_EXTMEM",
        "For DMA LUT memory loads, this is the base address from which data wil"
        "l be sourced to store into the LUT memory array.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_lut_extmem
    },
    {
        "CFA",
        "There are sixteen 2 bit values in this register each mapping a selecte"
        "d component to the output pixel.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_cfa
    },
    {
        "HIST_CTRL",
        "Provides control and status registers for the PXP's histogram classifi"
        "cation algorithm.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pxp_hist_ctrl
    },
    {
        "HIST2_PARAM",
        "This register specifies the valid values for a 2-level histogram.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pxp_hist2_param
    },
    {
        "HIST4_PARAM",
        "This register specifies the valid values for a 4-level histogram.",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist4_param
    },
    {
        "HIST8_PARAM0",
        "This register specifies four of the valid values for an 8-level histog"
        "ram.",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist8_param0
    },
    {
        "HIST8_PARAM1",
        "This register specifies four of the valid values for an 8-level histog"
        "ram.",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist8_param1
    },
    {
        "HIST16_PARAM0",
        "This register specifies four of the valid values for a 16-level histog"
        "ram.",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist16_param0
    },
    {
        "HIST16_PARAM1",
        "This register specifies four of the valid values for a 16-level histog"
        "ram.",
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist16_param1
    },
    {
        "HIST16_PARAM2",
        "This register specifies four of the valid values for a 16-level histog"
        "ram.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist16_param2
    },
    {
        "HIST16_PARAM3",
        "This register specifies four of the valid values for a 16-level histog"
        "ram.",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist16_param3
    },
    {
        "POWER",
        "",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pxp_power
    },
    {
        "NEXT",
        "This register contains a pointer to a data structure used to reload th"
        "e PXP registers at the end of the current frame.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pxp_next
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark QuadSPI
#endif

// Bitfields in register QuadSPI_MCR.
static const field_t hw_quadspi_mcr[] =
{
    {
        "SWRSTSD",
        "Software reset for Serial Flash domain",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWRSTHD",
        "Software reset for AHB domain",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "END_CFG",
        "Defines the endianness of the QSPI module.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DQS_EN",
        "DQS enable: This field is valid for both SDR and DDR mode.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_EN",
        "DDR mode enable:",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_RXF",
        "Clear RX FIFO.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_TXF",
        "Clear TX FIFO/Buffer.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDIS",
        "Module Disable.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLKCFG",
        "Serial Clock Configuration.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_IPCR.
static const field_t hw_quadspi_ipcr[] =
{
    {
        "IDATSZ",
        "IP data transfer size: Defines the data transfer size in bytes of the "
        "IP command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAR_EN",
        "When set, a transaction to two serial flash devices is triggered in pa"
        "rallel mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEQID",
        "Points to a sequence in the Look-up-table.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_FLSHCR.
static const field_t hw_quadspi_flshcr[] =
{
    {
        "TCSS",
        "Serial flash CS setup time in terms of serial flash clock cycles.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSH",
        "Serial flash CS hold time in terms of serial flash clock cycles.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF0CR.
static const field_t hw_quadspi_buf0cr[] =
{
    {
        "MSTRID",
        "Master ID: The ID of the AHB master associated with BUFFER0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "AHB data transfer size: Defines the data transfer size in 8 bytes of a"
        "n AHB triggered access to serial flash.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_EN",
        "High Priority Enable: When set, the master associated with this buffer"
        " is assigned a priority higher than the rest of the masters.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF1CR.
static const field_t hw_quadspi_buf1cr[] =
{
    {
        "MSTRID",
        "Master ID: The ID of the AHB master associated with BUFFER1.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "AHB data transfer size: Defines the data transfer size in 8 bytes of a"
        "n AHB triggered access to serial flash.For example, a value of 0x2 wil"
        "l set transfer size to 16bytes.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF2CR.
static const field_t hw_quadspi_buf2cr[] =
{
    {
        "MSTRID",
        "Master ID: The ID of the AHB master associated with BUFFER2.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "AHB data transfer size: Defines the data transfer size in 8 Bytes of a"
        "n AHB triggered access to serial flash.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF3CR.
static const field_t hw_quadspi_buf3cr[] =
{
    {
        "MSTRID",
        "Master ID: The ID of the AHB master associated with BUFFER3.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "AHB data transfer size: Defines the data transfer size in 8 Bytes of a"
        "n AHB triggered access to serial flash.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALLMST",
        "All master enable: When set, buffer3 acts as an all-master buffer.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BFGENCR.
static const field_t hw_quadspi_bfgencr[] =
{
    {
        "SEQID",
        "Points to a sequence in the Look-up-table.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAR_EN",
        "When set, a transaction to two serial flash devices is triggered in pa"
        "rallel mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF0IND.
static const field_t hw_quadspi_buf0ind[] =
{
    {
        "TPINDX0",
        "Top index of buffer 0.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF1IND.
static const field_t hw_quadspi_buf1ind[] =
{
    {
        "TPINDX1",
        "Top index of buffer 1.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF2IND.
static const field_t hw_quadspi_buf2ind[] =
{
    {
        "TPINDX2",
        "Top index of buffer 2.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFAR.
static const field_t hw_quadspi_sfar[] =
{
    {
        "SFADR",
        "Serial Flash Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SMPR.
static const field_t hw_quadspi_smpr[] =
{
    {
        "HSENA",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSPHS",
        "Only relevant when HSENA bit is set.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSDLY",
        "Only relevant when HSENA bit is set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSPHS",
        "Select the edge of the sampling clock valid for full speed commands:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLY",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDRSMP",
        "DDR Sampling point.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBSR.
static const field_t hw_quadspi_rbsr[] =
{
    {
        "RDBFL",
        "RX Buffer Fill Level, indicates how many entries of 4 bytes are still "
        "available in the RX Buffer.",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDCTR",
        "Read Counter, indicates how many entries of 4 bytes have been removed "
        "from the RX Buffer.For example a value of 0x2 would indicate 8bytes ha"
        "ve been removed It is incremented by the number (QSPI_RBCT[WMRK] + 1) "
        "on RX Buffer POP event.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBCT.
static const field_t hw_quadspi_rbct[] =
{
    {
        "WMRK",
        "RX Buffer Watermark: This field determines when the readout action of "
        "the RX Buffer is triggered.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXBRD",
        "RX Buffer Readout: This bit specifies the access scheme for the RX Buf"
        "fer readout.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_TBSR.
static const field_t hw_quadspi_tbsr[] =
{
    {
        "TRBFL",
        "TX Buffer Fill Level.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRCTR",
        "Transmit Counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_TBDR.
static const field_t hw_quadspi_tbdr[] =
{
    {
        "TXDATA",
        "TX Data On write access the data is written into the next available en"
        "try of the TX Buffer and the QPSI_TBSR[TRBFL] field is updated accordi"
        "ngly.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SR.
static const field_t hw_quadspi_sr[] =
{
    {
        "BUSY",
        "Module Busy: Asserted when module is currently busy handling a transac"
        "tion to an external flash device.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ACC",
        "IP Access: Asserted when transaction currently executed was initiated "
        "by IP bus.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB_ACC",
        "AHB Access: Asserted when the transaction currently executed was initi"
        "ated by AHB bus.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHBGNT",
        "AHB Command priority Granted: Asserted when another module has been gr"
        "anted priority of AHB Commands against IP Commands.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHBTRN",
        "AHB Access Transaction pending: Asserted when there is a pending reque"
        "st on the AHB interface.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB0NE",
        "AHB 0 Buffer Not Empty: Asserted when AHB 0 buffer contains data.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB1NE",
        "AHB 1 Buffer Not Empty: Asserted when AHB 1 buffer contains data.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB2NE",
        "AHB 2 Buffer Not Empty: Asserted when AHB 2 buffer contains data.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB3NE",
        "AHB 3 Buffer Not Empty: Asserted when AHB 3 buffer contains data.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB0FUL",
        "AHB 0 Buffer Full: Asserted when AHB 0 buffer is full.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB1FUL",
        "AHB 1 Buffer Full: Asserted when AHB 1 buffer is full.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB2FUL",
        "AHB 2 Buffer Full: Asserted when AHB 2 buffer is full.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB3FUL",
        "AHB 3 Buffer Full: Asserted when AHB 3 buffer is full.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXWE",
        "RX Buffer Watermark Exceeded: Asserted when the number of valid entrie"
        "s in the RX Buffer exceeds the number given in the QSPI_RBCT[WMRK] fie"
        "ld.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFULL",
        "RX Buffer Full: Asserted when the RX Buffer is full, i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDMA",
        "RX Buffer DMA: Asserted when RX Buffer read out via DMA is active i.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEDA",
        "Asserted when TX Buffer contains enough data for any pop operation to "
        "take place.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFULL",
        "TX Buffer Full: Asserted when no more data can be stored.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLPSMP",
        "Data learning pattern sampling point: The sampling point found by the "
        "controller with the data learning pattern.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_FR.
static const field_t hw_quadspi_fr[] =
{
    {
        "TFF",
        "IP Command Transaction Finished Flag: Set when the QuadSPI module has "
        "finished a running IP Command.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPGEF",
        "IP Command Trigger during AHB Grant Error Flag: Set when the following"
        " condition occurs: A write access occurs to the QSPI_IPCR[SEQID] field"
        " and the QSPI_SR[AHBGNT] bit is set.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPIEF",
        "IP Command Trigger could not be executed Error Flag.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPAEF",
        "IP Command Trigger during AHB Access Error Flag.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IUEF",
        "IP Command Usage Error Flag: Set when in parallel flash mode the execu"
        "tion of an IP Command is started and the sequence pointed to by the se"
        "quence ID contains a WRITE or a WRITE_DDR command.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABOF",
        "AHB Buffer Overflow Flag: Set when the size of the AHB access exceeds "
        "the size of the AHB buffer.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEF",
        "AHB Sequence Error Flag: Set when the execution of an AHB Command is s"
        "tarted with an WRITE or WRITE_DDR Command in the sequence pointed to b"
        "y the QSPI_BUFxCR QSPI_BUFxCR implies anyone of QSPI_BUF0CR/QSPI_BUF1C"
        "R/QSPI_BUF2CR/QSPI_BUF3CR register Communication with the serial flash"
        " device is terminated before the execution of WRITE/WRITE_DDR command "
        "by the QuadSPI module.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDF",
        "RX Buffer Drain Flag: Will be set if the QuadSPI_SR[RXWE] status bit i"
        "s asserted.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBOF",
        "RX Buffer Overflow Flag: Set when not all the data read from the seria"
        "l flash device could be pushed into the RX Buffer.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILLINE",
        "Illegal Instruction Error Flag: Set when an illegal instruction is enc"
        "ountered by the controller in any of the sequences.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBUF",
        "TX Buffer Underrun Flag: Set when the module tried to pull data althou"
        "gh TX Buffer was emptyor the buffer contains less than 128bits of data"
        ".",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBFF",
        "TX Buffer Fill Flag: Before writing to the TX buffer, this bit should "
        "be cleared.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLPFF",
        "Data Learning Pattern Failure Flag: Set when DATA_LEARN instruction wa"
        "s encountered in a sequence but no sampling point was found for the da"
        "ta learning pattern The controller automatically starts sampling using"
        " the value in QSPI_SMPR[DDRSMP].",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RSER.
static const field_t hw_quadspi_rser[] =
{
    {
        "TFIE",
        "Transaction Finished Interrupt Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPGEIE",
        "IP Command Trigger during AHB Grant Error Interrupt Enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPIEIE",
        "IP Command Trigger during IP Access Error Interrupt Enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPAEIE",
        "IP Command Trigger during AHB Access Error Interrupt Enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IUEIE",
        "IP Command Usage Error Interrupt Enable",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABOIE",
        "AHB Buffer Overflow Interrupt Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEIE",
        "AHB Sequence Error Interrupt Enable: Triggered by ABSEF flags of QSPI_"
        "FR",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDIE",
        "RX Buffer Drain Interrupt Enable: Enables generation of IRQ requests f"
        "or RX Buffer Drain.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBOIE",
        "RX Buffer Overflow Interrupt Enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDDE",
        "RX Buffer Drain DMA Enable: Enables generation of DMA requests for RX "
        "Buffer Drain.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILLINIE",
        "Illegal Instruction Error Interrupt Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBUIE",
        "TX Buffer Underrun Interrupt Enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBFIE",
        "TX Buffer Fill Interrupt Enable",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLPFIE",
        "Data Learning Pattern Failure Interrupt enable .",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SPNDST.
static const field_t hw_quadspi_spndst[] =
{
    {
        "SUSPND",
        "When set, it signifies that a sequence is in suspended state",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPDBUF",
        "Suspended Buffer: Provides the suspended buffer number.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DATLFT",
        "Data left: Provides information about the amount of data left to be re"
        "ad in the suspended sequence.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SPTRCLR.
static const field_t hw_quadspi_sptrclr[] =
{
    {
        "BFPTRC",
        "Buffer Pointer Clear: 1: Clears the sequence pointer for AHB accesses "
        "as defined in QuadSPI_BFGENCR.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPPTRC",
        "IP Pointer Clear: 1: Clears the sequence pointer for IP accesses as de"
        "fined in QuadSPI_IPCR",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFA1AD.
static const field_t hw_quadspi_sfa1ad[] =
{
    {
        "TPADA1",
        "Top address for Serial Flash A1.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFA2AD.
static const field_t hw_quadspi_sfa2ad[] =
{
    {
        "TPADA2",
        "Top address for Serial Flash A2.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFB1AD.
static const field_t hw_quadspi_sfb1ad[] =
{
    {
        "TPADB1",
        "Top address for Serial Flash B1.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFB2AD.
static const field_t hw_quadspi_sfb2ad[] =
{
    {
        "TPADB2",
        "Top address for Serial Flash B2.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR0.
static const field_t hw_quadspi_rbdr0[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR1.
static const field_t hw_quadspi_rbdr1[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR2.
static const field_t hw_quadspi_rbdr2[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR3.
static const field_t hw_quadspi_rbdr3[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR4.
static const field_t hw_quadspi_rbdr4[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR5.
static const field_t hw_quadspi_rbdr5[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR6.
static const field_t hw_quadspi_rbdr6[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR7.
static const field_t hw_quadspi_rbdr7[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR8.
static const field_t hw_quadspi_rbdr8[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR9.
static const field_t hw_quadspi_rbdr9[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR10.
static const field_t hw_quadspi_rbdr10[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR11.
static const field_t hw_quadspi_rbdr11[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR12.
static const field_t hw_quadspi_rbdr12[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR13.
static const field_t hw_quadspi_rbdr13[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR14.
static const field_t hw_quadspi_rbdr14[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR15.
static const field_t hw_quadspi_rbdr15[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR16.
static const field_t hw_quadspi_rbdr16[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR17.
static const field_t hw_quadspi_rbdr17[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR18.
static const field_t hw_quadspi_rbdr18[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR19.
static const field_t hw_quadspi_rbdr19[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR20.
static const field_t hw_quadspi_rbdr20[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR21.
static const field_t hw_quadspi_rbdr21[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR22.
static const field_t hw_quadspi_rbdr22[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR23.
static const field_t hw_quadspi_rbdr23[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR24.
static const field_t hw_quadspi_rbdr24[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR25.
static const field_t hw_quadspi_rbdr25[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR26.
static const field_t hw_quadspi_rbdr26[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR27.
static const field_t hw_quadspi_rbdr27[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR28.
static const field_t hw_quadspi_rbdr28[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR29.
static const field_t hw_quadspi_rbdr29[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR30.
static const field_t hw_quadspi_rbdr30[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR31.
static const field_t hw_quadspi_rbdr31[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUTKEY.
static const field_t hw_quadspi_lutkey[] =
{
    {
        "KEY",
        "The key to lock or unlock the LUT.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LCKCR.
static const field_t hw_quadspi_lckcr[] =
{
    {
        "LOCK",
        "Locks the LUT when the following condition is met: This register is wr"
        "itten just after the LUTKEYLUT Key Register The LUT key register was w"
        "ritten with 0x5AF05AF0 key",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNLOCK",
        "Unlocks the LUT when the following two conditions are met: 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT0.
static const field_t hw_quadspi_lut0[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT1.
static const field_t hw_quadspi_lut1[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT2.
static const field_t hw_quadspi_lut2[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT3.
static const field_t hw_quadspi_lut3[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT4.
static const field_t hw_quadspi_lut4[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT5.
static const field_t hw_quadspi_lut5[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT6.
static const field_t hw_quadspi_lut6[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT7.
static const field_t hw_quadspi_lut7[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT8.
static const field_t hw_quadspi_lut8[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT9.
static const field_t hw_quadspi_lut9[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT10.
static const field_t hw_quadspi_lut10[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT11.
static const field_t hw_quadspi_lut11[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT12.
static const field_t hw_quadspi_lut12[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT13.
static const field_t hw_quadspi_lut13[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT14.
static const field_t hw_quadspi_lut14[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT15.
static const field_t hw_quadspi_lut15[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT16.
static const field_t hw_quadspi_lut16[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT17.
static const field_t hw_quadspi_lut17[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT18.
static const field_t hw_quadspi_lut18[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT19.
static const field_t hw_quadspi_lut19[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT20.
static const field_t hw_quadspi_lut20[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT21.
static const field_t hw_quadspi_lut21[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT22.
static const field_t hw_quadspi_lut22[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT23.
static const field_t hw_quadspi_lut23[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT24.
static const field_t hw_quadspi_lut24[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT25.
static const field_t hw_quadspi_lut25[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT26.
static const field_t hw_quadspi_lut26[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT27.
static const field_t hw_quadspi_lut27[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT28.
static const field_t hw_quadspi_lut28[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT29.
static const field_t hw_quadspi_lut29[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT30.
static const field_t hw_quadspi_lut30[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT31.
static const field_t hw_quadspi_lut31[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT32.
static const field_t hw_quadspi_lut32[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT33.
static const field_t hw_quadspi_lut33[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT34.
static const field_t hw_quadspi_lut34[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT35.
static const field_t hw_quadspi_lut35[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT36.
static const field_t hw_quadspi_lut36[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT37.
static const field_t hw_quadspi_lut37[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT38.
static const field_t hw_quadspi_lut38[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT39.
static const field_t hw_quadspi_lut39[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT40.
static const field_t hw_quadspi_lut40[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT41.
static const field_t hw_quadspi_lut41[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT42.
static const field_t hw_quadspi_lut42[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT43.
static const field_t hw_quadspi_lut43[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT44.
static const field_t hw_quadspi_lut44[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT45.
static const field_t hw_quadspi_lut45[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT46.
static const field_t hw_quadspi_lut46[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT47.
static const field_t hw_quadspi_lut47[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT48.
static const field_t hw_quadspi_lut48[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT49.
static const field_t hw_quadspi_lut49[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT50.
static const field_t hw_quadspi_lut50[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT51.
static const field_t hw_quadspi_lut51[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT52.
static const field_t hw_quadspi_lut52[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT53.
static const field_t hw_quadspi_lut53[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT54.
static const field_t hw_quadspi_lut54[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT55.
static const field_t hw_quadspi_lut55[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT56.
static const field_t hw_quadspi_lut56[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT57.
static const field_t hw_quadspi_lut57[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT58.
static const field_t hw_quadspi_lut58[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT59.
static const field_t hw_quadspi_lut59[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT60.
static const field_t hw_quadspi_lut60[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT61.
static const field_t hw_quadspi_lut61[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT62.
static const field_t hw_quadspi_lut62[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT63.
static const field_t hw_quadspi_lut63[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a QUADSPI module.
static const reg_t hw_quadspi[] =
{
    {
        "MCR",
        "The QuadSPI_MCR holds configuration data associated with QuadSPI opera"
        "tion.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_quadspi_mcr
    },
    {
        "IPCR",
        "The IP configuration register provides all the configuration required "
        "for an IP initiated command.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_ipcr
    },
    {
        "FLSHCR",
        "The Flash configuration register contains the flash device specific ti"
        "mings that must be met by the QuadSPI controller for the device to fun"
        "ction correctly.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_flshcr
    },
    {
        "BUF0CR",
        "This register provides the configuration for any access to buffer0.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_buf0cr
    },
    {
        "BUF1CR",
        "This register provides the configuration for any access to buffer1.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_buf1cr
    },
    {
        "BUF2CR",
        "This register provides the configuration for any access to buffer2.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_buf2cr
    },
    {
        "BUF3CR",
        "This register provides the configuration for any access to buffer3.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_buf3cr
    },
    {
        "BFGENCR",
        "This register provides the generic configuration to any of the buffer "
        "accesses.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_bfgencr
    },
    {
        "BUF0IND",
        "This register specifies the top index of buffer0, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_buf0ind
    },
    {
        "BUF1IND",
        "This register specifies the top index of buffer1, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_buf1ind
    },
    {
        "BUF2IND",
        "This register specifies the top index of buffer2, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_buf2ind
    },
    {
        "SFAR",
        "The module automatically translates this address on the memory map to "
        "the address on the flash itself.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfar
    },
    {
        "SMPR",
        "The Sampling Register allows configuration of how the incoming data fr"
        "om the external serial flash devices are sampled in the QuadSPI module"
        ".",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_smpr
    },
    {
        "RBSR",
        "This register contains information related to the receive data buffer.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_quadspi_rbsr
    },
    {
        "RBCT",
        "This register contains control data related to the receive data buffer"
        ".",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_rbct
    },
    {
        "TBSR",
        "This register contains information related to the transmit data buffer"
        ".",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_quadspi_tbsr
    },
    {
        "TBDR",
        "The QSPI_TBDR register provides access to the circular TX Buffer of de"
        "pth 128 bytes.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_tbdr
    },
    {
        "SR",
        "The QSPI_SR register provides all available status information about S"
        "FM command execution and arbitration, the RX Buffer and TX Buffer and "
        "the AHB Buffer.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_quadspi_sr
    },
    {
        "FR",
        "The QSPI_FR register provides all available flags about SFM command ex"
        "ecution and arbitration which may serve as source for the generation o"
        "f interrupt service requests.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_quadspi_fr
    },
    {
        "RSER",
        "The QuadSPI_RSER register provides enables and selectors for the inter"
        "rupts in the QuadSPI module.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_quadspi_rser
    },
    {
        "SPNDST",
        "The sequence suspend status register provides information specific to "
        "any suspended sequence.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_quadspi_spndst
    },
    {
        "SPTRCLR",
        "The sequence pointer clear register provides bits to reset the IP and "
        "Buffer sequence pointers.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_sptrclr
    },
    {
        "SFA1AD",
        "The QSPI_SFA1AD register provides the address mapping for the serial f"
        "lash A1.The difference between QSPI_SFA1AD[TPADA1] and QSPI_AMBA_BASE "
        "defines the size of the memory map for serial flash A1.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfa1ad
    },
    {
        "SFA2AD",
        "The QSPI_SFA2AD register provides the address mapping for the serial f"
        "lash A2.The difference between QSPI_SFA2AD[TPADA2] and QSPI_SFA1AD[TPA"
        "DA1] defines the size of the memory map for serial flash A2.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfa2ad
    },
    {
        "SFB1AD",
        "The QSPI_SFB1AD register provides the address mapping for the serial f"
        "lash B1.The difference between QSPI_SFB1AD[TPADB1] and QSPI_SFA2AD[TPA"
        "DA2] defines the size of the memory map for serial flash B1.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfb1ad
    },
    {
        "SFB2AD",
        "The QSPI_SFB2AD register provides the address mapping for the serial f"
        "lash B2.The difference between QSPI_SFB2AD[TPADB2] and QSPI_SFB1AD[TPA"
        "DB1] defines the size of the memory map for serial flash B2.",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfb2ad
    },
    {
        "RBDR0",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr0
    },
    {
        "RBDR1",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr1
    },
    {
        "RBDR2",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr2
    },
    {
        "RBDR3",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr3
    },
    {
        "RBDR4",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr4
    },
    {
        "RBDR5",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr5
    },
    {
        "RBDR6",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr6
    },
    {
        "RBDR7",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr7
    },
    {
        "RBDR8",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr8
    },
    {
        "RBDR9",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr9
    },
    {
        "RBDR10",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr10
    },
    {
        "RBDR11",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr11
    },
    {
        "RBDR12",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr12
    },
    {
        "RBDR13",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr13
    },
    {
        "RBDR14",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr14
    },
    {
        "RBDR15",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr15
    },
    {
        "RBDR16",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr16
    },
    {
        "RBDR17",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr17
    },
    {
        "RBDR18",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr18
    },
    {
        "RBDR19",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr19
    },
    {
        "RBDR20",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr20
    },
    {
        "RBDR21",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr21
    },
    {
        "RBDR22",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr22
    },
    {
        "RBDR23",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr23
    },
    {
        "RBDR24",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr24
    },
    {
        "RBDR25",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr25
    },
    {
        "RBDR26",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr26
    },
    {
        "RBDR27",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr27
    },
    {
        "RBDR28",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr28
    },
    {
        "RBDR29",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr29
    },
    {
        "RBDR30",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr30
    },
    {
        "RBDR31",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr31
    },
    {
        "LUTKEY",
        "The LUT Key register contains the key to lock and unlock the Look-up-t"
        "able.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_lutkey
    },
    {
        "LCKCR",
        "The LUT lock configuration register is used along with QSPI_LUTKEY reg"
        "ister to lock or unlock the LUT.",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_lckcr
    },
    {
        "LUT0",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut0
    },
    {
        "LUT1",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut1
    },
    {
        "LUT2",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut2
    },
    {
        "LUT3",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut3
    },
    {
        "LUT4",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut4
    },
    {
        "LUT5",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut5
    },
    {
        "LUT6",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut6
    },
    {
        "LUT7",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut7
    },
    {
        "LUT8",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut8
    },
    {
        "LUT9",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000334, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut9
    },
    {
        "LUT10",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000338, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut10
    },
    {
        "LUT11",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000033c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut11
    },
    {
        "LUT12",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut12
    },
    {
        "LUT13",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut13
    },
    {
        "LUT14",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut14
    },
    {
        "LUT15",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut15
    },
    {
        "LUT16",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut16
    },
    {
        "LUT17",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut17
    },
    {
        "LUT18",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut18
    },
    {
        "LUT19",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut19
    },
    {
        "LUT20",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut20
    },
    {
        "LUT21",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut21
    },
    {
        "LUT22",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000368, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut22
    },
    {
        "LUT23",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000036c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut23
    },
    {
        "LUT24",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut24
    },
    {
        "LUT25",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000374, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut25
    },
    {
        "LUT26",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut26
    },
    {
        "LUT27",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut27
    },
    {
        "LUT28",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut28
    },
    {
        "LUT29",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut29
    },
    {
        "LUT30",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000388, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut30
    },
    {
        "LUT31",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000038c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut31
    },
    {
        "LUT32",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut32
    },
    {
        "LUT33",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut33
    },
    {
        "LUT34",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut34
    },
    {
        "LUT35",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut35
    },
    {
        "LUT36",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut36
    },
    {
        "LUT37",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut37
    },
    {
        "LUT38",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut38
    },
    {
        "LUT39",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut39
    },
    {
        "LUT40",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut40
    },
    {
        "LUT41",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut41
    },
    {
        "LUT42",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut42
    },
    {
        "LUT43",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut43
    },
    {
        "LUT44",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut44
    },
    {
        "LUT45",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut45
    },
    {
        "LUT46",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut46
    },
    {
        "LUT47",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut47
    },
    {
        "LUT48",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut48
    },
    {
        "LUT49",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut49
    },
    {
        "LUT50",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut50
    },
    {
        "LUT51",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut51
    },
    {
        "LUT52",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut52
    },
    {
        "LUT53",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003e4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut53
    },
    {
        "LUT54",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003e8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut54
    },
    {
        "LUT55",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003ec, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut55
    },
    {
        "LUT56",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut56
    },
    {
        "LUT57",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003f4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut57
    },
    {
        "LUT58",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003f8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut58
    },
    {
        "LUT59",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003fc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut59
    },
    {
        "LUT60",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut60
    },
    {
        "LUT61",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut61
    },
    {
        "LUT62",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut62
    },
    {
        "LUT63",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut63
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark RDC
#endif

// Bitfields in register RDC_VIR.
static const field_t hw_rdc_vir[] =
{
    {
        "NDID",
        "Indicates the number of domain ids supported by this instance of the R"
        "DC.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NMSTR",
        "Indicates the number of masters supported by this instance of RDC.",
        4, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPER",
        "Indicates the number of peripherals that can be isolated or safe-share"
        "d",
        12, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NRGN",
        "Indicates the number of memory regions in this instance of the RDC.",
        20, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_STAT.
static const field_t hw_rdc_stat[] =
{
    {
        "DID",
        "The Domain ID of the core or bus master that is reading this.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDS",
        "Indicates if the \"Power Down\" memory regions are powered and availab"
        "le.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_INTCTRL.
static const field_t hw_rdc_intctrl[] =
{
    {
        "RCI_EN",
        "Interrupt generated when the RDC has completed restoring state to a re"
        "cently re-powered memory regions.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_INTSTAT.
static const field_t hw_rdc_intstat[] =
{
    {
        "INT",
        "Indicates state of interrupt signal for state restoration.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA0.
static const field_t hw_rdc_mda0[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_1.
static const field_t hw_rdc_mda_1[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_2.
static const field_t hw_rdc_mda_2[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_3.
static const field_t hw_rdc_mda_3[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_4.
static const field_t hw_rdc_mda_4[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_5.
static const field_t hw_rdc_mda_5[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_6.
static const field_t hw_rdc_mda_6[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_7.
static const field_t hw_rdc_mda_7[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_8.
static const field_t hw_rdc_mda_8[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_9.
static const field_t hw_rdc_mda_9[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_10.
static const field_t hw_rdc_mda_10[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_11.
static const field_t hw_rdc_mda_11[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_12.
static const field_t hw_rdc_mda_12[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_13.
static const field_t hw_rdc_mda_13[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_14.
static const field_t hw_rdc_mda_14[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_15.
static const field_t hw_rdc_mda_15[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_16.
static const field_t hw_rdc_mda_16[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_17.
static const field_t hw_rdc_mda_17[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_18.
static const field_t hw_rdc_mda_18[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_19.
static const field_t hw_rdc_mda_19[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_20.
static const field_t hw_rdc_mda_20[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_21.
static const field_t hw_rdc_mda_21[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_22.
static const field_t hw_rdc_mda_22[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_23.
static const field_t hw_rdc_mda_23[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_24.
static const field_t hw_rdc_mda_24[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_25.
static const field_t hw_rdc_mda_25[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_26.
static const field_t hw_rdc_mda_26[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_27.
static const field_t hw_rdc_mda_27[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_28.
static const field_t hw_rdc_mda_28[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_29.
static const field_t hw_rdc_mda_29[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_30.
static const field_t hw_rdc_mda_30[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MDA_31.
static const field_t hw_rdc_mda_31[] =
{
    {
        "DID",
        "Indicates the domain to which the Master is assigned",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP0.
static const field_t hw_rdc_pdap0[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_1.
static const field_t hw_rdc_pdap_1[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_2.
static const field_t hw_rdc_pdap_2[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_3.
static const field_t hw_rdc_pdap_3[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_4.
static const field_t hw_rdc_pdap_4[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_5.
static const field_t hw_rdc_pdap_5[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_6.
static const field_t hw_rdc_pdap_6[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_7.
static const field_t hw_rdc_pdap_7[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_8.
static const field_t hw_rdc_pdap_8[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_9.
static const field_t hw_rdc_pdap_9[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_10.
static const field_t hw_rdc_pdap_10[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_11.
static const field_t hw_rdc_pdap_11[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_12.
static const field_t hw_rdc_pdap_12[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_13.
static const field_t hw_rdc_pdap_13[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_14.
static const field_t hw_rdc_pdap_14[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_15.
static const field_t hw_rdc_pdap_15[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_16.
static const field_t hw_rdc_pdap_16[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_17.
static const field_t hw_rdc_pdap_17[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_18.
static const field_t hw_rdc_pdap_18[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_19.
static const field_t hw_rdc_pdap_19[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_20.
static const field_t hw_rdc_pdap_20[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_21.
static const field_t hw_rdc_pdap_21[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_22.
static const field_t hw_rdc_pdap_22[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_23.
static const field_t hw_rdc_pdap_23[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_24.
static const field_t hw_rdc_pdap_24[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_25.
static const field_t hw_rdc_pdap_25[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_26.
static const field_t hw_rdc_pdap_26[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_27.
static const field_t hw_rdc_pdap_27[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_28.
static const field_t hw_rdc_pdap_28[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_29.
static const field_t hw_rdc_pdap_29[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_30.
static const field_t hw_rdc_pdap_30[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_31.
static const field_t hw_rdc_pdap_31[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_32.
static const field_t hw_rdc_pdap_32[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_33.
static const field_t hw_rdc_pdap_33[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_34.
static const field_t hw_rdc_pdap_34[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_35.
static const field_t hw_rdc_pdap_35[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_36.
static const field_t hw_rdc_pdap_36[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_37.
static const field_t hw_rdc_pdap_37[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_38.
static const field_t hw_rdc_pdap_38[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_39.
static const field_t hw_rdc_pdap_39[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_40.
static const field_t hw_rdc_pdap_40[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_41.
static const field_t hw_rdc_pdap_41[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_42.
static const field_t hw_rdc_pdap_42[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_43.
static const field_t hw_rdc_pdap_43[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_44.
static const field_t hw_rdc_pdap_44[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_45.
static const field_t hw_rdc_pdap_45[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_46.
static const field_t hw_rdc_pdap_46[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_47.
static const field_t hw_rdc_pdap_47[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_48.
static const field_t hw_rdc_pdap_48[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_49.
static const field_t hw_rdc_pdap_49[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_50.
static const field_t hw_rdc_pdap_50[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_51.
static const field_t hw_rdc_pdap_51[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_52.
static const field_t hw_rdc_pdap_52[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_53.
static const field_t hw_rdc_pdap_53[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_54.
static const field_t hw_rdc_pdap_54[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_55.
static const field_t hw_rdc_pdap_55[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_56.
static const field_t hw_rdc_pdap_56[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_57.
static const field_t hw_rdc_pdap_57[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_58.
static const field_t hw_rdc_pdap_58[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_59.
static const field_t hw_rdc_pdap_59[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_60.
static const field_t hw_rdc_pdap_60[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_61.
static const field_t hw_rdc_pdap_61[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_62.
static const field_t hw_rdc_pdap_62[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_63.
static const field_t hw_rdc_pdap_63[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_64.
static const field_t hw_rdc_pdap_64[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_65.
static const field_t hw_rdc_pdap_65[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_66.
static const field_t hw_rdc_pdap_66[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_67.
static const field_t hw_rdc_pdap_67[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_68.
static const field_t hw_rdc_pdap_68[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_69.
static const field_t hw_rdc_pdap_69[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_70.
static const field_t hw_rdc_pdap_70[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_71.
static const field_t hw_rdc_pdap_71[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_72.
static const field_t hw_rdc_pdap_72[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_73.
static const field_t hw_rdc_pdap_73[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_74.
static const field_t hw_rdc_pdap_74[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_75.
static const field_t hw_rdc_pdap_75[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_76.
static const field_t hw_rdc_pdap_76[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_77.
static const field_t hw_rdc_pdap_77[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_78.
static const field_t hw_rdc_pdap_78[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_79.
static const field_t hw_rdc_pdap_79[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_80.
static const field_t hw_rdc_pdap_80[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_81.
static const field_t hw_rdc_pdap_81[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_82.
static const field_t hw_rdc_pdap_82[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_83.
static const field_t hw_rdc_pdap_83[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_84.
static const field_t hw_rdc_pdap_84[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_85.
static const field_t hw_rdc_pdap_85[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_86.
static const field_t hw_rdc_pdap_86[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_87.
static const field_t hw_rdc_pdap_87[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_88.
static const field_t hw_rdc_pdap_88[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_89.
static const field_t hw_rdc_pdap_89[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_90.
static const field_t hw_rdc_pdap_90[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_91.
static const field_t hw_rdc_pdap_91[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_92.
static const field_t hw_rdc_pdap_92[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_93.
static const field_t hw_rdc_pdap_93[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_94.
static const field_t hw_rdc_pdap_94[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_95.
static const field_t hw_rdc_pdap_95[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_96.
static const field_t hw_rdc_pdap_96[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_97.
static const field_t hw_rdc_pdap_97[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_98.
static const field_t hw_rdc_pdap_98[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_99.
static const field_t hw_rdc_pdap_99[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_100.
static const field_t hw_rdc_pdap_100[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_101.
static const field_t hw_rdc_pdap_101[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_102.
static const field_t hw_rdc_pdap_102[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_103.
static const field_t hw_rdc_pdap_103[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_104.
static const field_t hw_rdc_pdap_104[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_105.
static const field_t hw_rdc_pdap_105[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_106.
static const field_t hw_rdc_pdap_106[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_107.
static const field_t hw_rdc_pdap_107[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_108.
static const field_t hw_rdc_pdap_108[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_PDAP_109.
static const field_t hw_rdc_pdap_109[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SREQ",
        "When set the hardware semaphore state enforces the semaphore lock.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "When set prevents further modification of the Peripheral Domain Access"
        " Permissions (sticky bit until reset)",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA0.
static const field_t hw_rdc_mrsa0[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA0.
static const field_t hw_rdc_mrea0[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC0.
static const field_t hw_rdc_mrc0[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS0.
static const field_t hw_rdc_mrvs0[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_1.
static const field_t hw_rdc_mrsa_1[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_1.
static const field_t hw_rdc_mrea_1[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_1.
static const field_t hw_rdc_mrc_1[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_1.
static const field_t hw_rdc_mrvs_1[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_2.
static const field_t hw_rdc_mrsa_2[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_2.
static const field_t hw_rdc_mrea_2[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_2.
static const field_t hw_rdc_mrc_2[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_2.
static const field_t hw_rdc_mrvs_2[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_3.
static const field_t hw_rdc_mrsa_3[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_3.
static const field_t hw_rdc_mrea_3[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_3.
static const field_t hw_rdc_mrc_3[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_3.
static const field_t hw_rdc_mrvs_3[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_4.
static const field_t hw_rdc_mrsa_4[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_4.
static const field_t hw_rdc_mrea_4[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_4.
static const field_t hw_rdc_mrc_4[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_4.
static const field_t hw_rdc_mrvs_4[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_5.
static const field_t hw_rdc_mrsa_5[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_5.
static const field_t hw_rdc_mrea_5[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_5.
static const field_t hw_rdc_mrc_5[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_5.
static const field_t hw_rdc_mrvs_5[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_6.
static const field_t hw_rdc_mrsa_6[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_6.
static const field_t hw_rdc_mrea_6[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_6.
static const field_t hw_rdc_mrc_6[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_6.
static const field_t hw_rdc_mrvs_6[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_7.
static const field_t hw_rdc_mrsa_7[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_7.
static const field_t hw_rdc_mrea_7[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_7.
static const field_t hw_rdc_mrc_7[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_7.
static const field_t hw_rdc_mrvs_7[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_8.
static const field_t hw_rdc_mrsa_8[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_8.
static const field_t hw_rdc_mrea_8[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_8.
static const field_t hw_rdc_mrc_8[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_8.
static const field_t hw_rdc_mrvs_8[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_9.
static const field_t hw_rdc_mrsa_9[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_9.
static const field_t hw_rdc_mrea_9[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_9.
static const field_t hw_rdc_mrc_9[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_9.
static const field_t hw_rdc_mrvs_9[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_10.
static const field_t hw_rdc_mrsa_10[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_10.
static const field_t hw_rdc_mrea_10[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_10.
static const field_t hw_rdc_mrc_10[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_10.
static const field_t hw_rdc_mrvs_10[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_11.
static const field_t hw_rdc_mrsa_11[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_11.
static const field_t hw_rdc_mrea_11[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_11.
static const field_t hw_rdc_mrc_11[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_11.
static const field_t hw_rdc_mrvs_11[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_12.
static const field_t hw_rdc_mrsa_12[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_12.
static const field_t hw_rdc_mrea_12[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_12.
static const field_t hw_rdc_mrc_12[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_12.
static const field_t hw_rdc_mrvs_12[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_13.
static const field_t hw_rdc_mrsa_13[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_13.
static const field_t hw_rdc_mrea_13[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_13.
static const field_t hw_rdc_mrc_13[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_13.
static const field_t hw_rdc_mrvs_13[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_14.
static const field_t hw_rdc_mrsa_14[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_14.
static const field_t hw_rdc_mrea_14[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_14.
static const field_t hw_rdc_mrc_14[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_14.
static const field_t hw_rdc_mrvs_14[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_15.
static const field_t hw_rdc_mrsa_15[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_15.
static const field_t hw_rdc_mrea_15[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_15.
static const field_t hw_rdc_mrc_15[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_15.
static const field_t hw_rdc_mrvs_15[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_16.
static const field_t hw_rdc_mrsa_16[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_16.
static const field_t hw_rdc_mrea_16[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_16.
static const field_t hw_rdc_mrc_16[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_16.
static const field_t hw_rdc_mrvs_16[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_17.
static const field_t hw_rdc_mrsa_17[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_17.
static const field_t hw_rdc_mrea_17[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_17.
static const field_t hw_rdc_mrc_17[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_17.
static const field_t hw_rdc_mrvs_17[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_18.
static const field_t hw_rdc_mrsa_18[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_18.
static const field_t hw_rdc_mrea_18[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_18.
static const field_t hw_rdc_mrc_18[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_18.
static const field_t hw_rdc_mrvs_18[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_19.
static const field_t hw_rdc_mrsa_19[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_19.
static const field_t hw_rdc_mrea_19[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_19.
static const field_t hw_rdc_mrc_19[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_19.
static const field_t hw_rdc_mrvs_19[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_20.
static const field_t hw_rdc_mrsa_20[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_20.
static const field_t hw_rdc_mrea_20[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_20.
static const field_t hw_rdc_mrc_20[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_20.
static const field_t hw_rdc_mrvs_20[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_21.
static const field_t hw_rdc_mrsa_21[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_21.
static const field_t hw_rdc_mrea_21[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_21.
static const field_t hw_rdc_mrc_21[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_21.
static const field_t hw_rdc_mrvs_21[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_22.
static const field_t hw_rdc_mrsa_22[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_22.
static const field_t hw_rdc_mrea_22[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_22.
static const field_t hw_rdc_mrc_22[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_22.
static const field_t hw_rdc_mrvs_22[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_23.
static const field_t hw_rdc_mrsa_23[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_23.
static const field_t hw_rdc_mrea_23[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_23.
static const field_t hw_rdc_mrc_23[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_23.
static const field_t hw_rdc_mrvs_23[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_24.
static const field_t hw_rdc_mrsa_24[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_24.
static const field_t hw_rdc_mrea_24[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_24.
static const field_t hw_rdc_mrc_24[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_24.
static const field_t hw_rdc_mrvs_24[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_25.
static const field_t hw_rdc_mrsa_25[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_25.
static const field_t hw_rdc_mrea_25[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_25.
static const field_t hw_rdc_mrc_25[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_25.
static const field_t hw_rdc_mrvs_25[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_26.
static const field_t hw_rdc_mrsa_26[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_26.
static const field_t hw_rdc_mrea_26[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_26.
static const field_t hw_rdc_mrc_26[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_26.
static const field_t hw_rdc_mrvs_26[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_27.
static const field_t hw_rdc_mrsa_27[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_27.
static const field_t hw_rdc_mrea_27[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_27.
static const field_t hw_rdc_mrc_27[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_27.
static const field_t hw_rdc_mrvs_27[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_28.
static const field_t hw_rdc_mrsa_28[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_28.
static const field_t hw_rdc_mrea_28[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_28.
static const field_t hw_rdc_mrc_28[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_28.
static const field_t hw_rdc_mrvs_28[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_29.
static const field_t hw_rdc_mrsa_29[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_29.
static const field_t hw_rdc_mrea_29[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_29.
static const field_t hw_rdc_mrc_29[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_29.
static const field_t hw_rdc_mrvs_29[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_30.
static const field_t hw_rdc_mrsa_30[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_30.
static const field_t hw_rdc_mrea_30[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_30.
static const field_t hw_rdc_mrc_30[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_30.
static const field_t hw_rdc_mrvs_30[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_31.
static const field_t hw_rdc_mrsa_31[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_31.
static const field_t hw_rdc_mrea_31[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_31.
static const field_t hw_rdc_mrc_31[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_31.
static const field_t hw_rdc_mrvs_31[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_32.
static const field_t hw_rdc_mrsa_32[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_32.
static const field_t hw_rdc_mrea_32[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_32.
static const field_t hw_rdc_mrc_32[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_32.
static const field_t hw_rdc_mrvs_32[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_33.
static const field_t hw_rdc_mrsa_33[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_33.
static const field_t hw_rdc_mrea_33[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_33.
static const field_t hw_rdc_mrc_33[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_33.
static const field_t hw_rdc_mrvs_33[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_34.
static const field_t hw_rdc_mrsa_34[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_34.
static const field_t hw_rdc_mrea_34[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_34.
static const field_t hw_rdc_mrc_34[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_34.
static const field_t hw_rdc_mrvs_34[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_35.
static const field_t hw_rdc_mrsa_35[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_35.
static const field_t hw_rdc_mrea_35[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_35.
static const field_t hw_rdc_mrc_35[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_35.
static const field_t hw_rdc_mrvs_35[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_36.
static const field_t hw_rdc_mrsa_36[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_36.
static const field_t hw_rdc_mrea_36[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_36.
static const field_t hw_rdc_mrc_36[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_36.
static const field_t hw_rdc_mrvs_36[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_37.
static const field_t hw_rdc_mrsa_37[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_37.
static const field_t hw_rdc_mrea_37[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_37.
static const field_t hw_rdc_mrc_37[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_37.
static const field_t hw_rdc_mrvs_37[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_38.
static const field_t hw_rdc_mrsa_38[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_38.
static const field_t hw_rdc_mrea_38[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_38.
static const field_t hw_rdc_mrc_38[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_38.
static const field_t hw_rdc_mrvs_38[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_39.
static const field_t hw_rdc_mrsa_39[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_39.
static const field_t hw_rdc_mrea_39[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_39.
static const field_t hw_rdc_mrc_39[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_39.
static const field_t hw_rdc_mrvs_39[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_40.
static const field_t hw_rdc_mrsa_40[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_40.
static const field_t hw_rdc_mrea_40[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_40.
static const field_t hw_rdc_mrc_40[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_40.
static const field_t hw_rdc_mrvs_40[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_41.
static const field_t hw_rdc_mrsa_41[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_41.
static const field_t hw_rdc_mrea_41[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_41.
static const field_t hw_rdc_mrc_41[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_41.
static const field_t hw_rdc_mrvs_41[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_42.
static const field_t hw_rdc_mrsa_42[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_42.
static const field_t hw_rdc_mrea_42[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_42.
static const field_t hw_rdc_mrc_42[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_42.
static const field_t hw_rdc_mrvs_42[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_43.
static const field_t hw_rdc_mrsa_43[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_43.
static const field_t hw_rdc_mrea_43[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_43.
static const field_t hw_rdc_mrc_43[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_43.
static const field_t hw_rdc_mrvs_43[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_44.
static const field_t hw_rdc_mrsa_44[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_44.
static const field_t hw_rdc_mrea_44[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_44.
static const field_t hw_rdc_mrc_44[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_44.
static const field_t hw_rdc_mrvs_44[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_45.
static const field_t hw_rdc_mrsa_45[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_45.
static const field_t hw_rdc_mrea_45[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_45.
static const field_t hw_rdc_mrc_45[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_45.
static const field_t hw_rdc_mrvs_45[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_46.
static const field_t hw_rdc_mrsa_46[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_46.
static const field_t hw_rdc_mrea_46[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_46.
static const field_t hw_rdc_mrc_46[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_46.
static const field_t hw_rdc_mrvs_46[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_47.
static const field_t hw_rdc_mrsa_47[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_47.
static const field_t hw_rdc_mrea_47[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_47.
static const field_t hw_rdc_mrc_47[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_47.
static const field_t hw_rdc_mrvs_47[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_48.
static const field_t hw_rdc_mrsa_48[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_48.
static const field_t hw_rdc_mrea_48[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_48.
static const field_t hw_rdc_mrc_48[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_48.
static const field_t hw_rdc_mrvs_48[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_49.
static const field_t hw_rdc_mrsa_49[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_49.
static const field_t hw_rdc_mrea_49[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_49.
static const field_t hw_rdc_mrc_49[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_49.
static const field_t hw_rdc_mrvs_49[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_50.
static const field_t hw_rdc_mrsa_50[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_50.
static const field_t hw_rdc_mrea_50[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_50.
static const field_t hw_rdc_mrc_50[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_50.
static const field_t hw_rdc_mrvs_50[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_51.
static const field_t hw_rdc_mrsa_51[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_51.
static const field_t hw_rdc_mrea_51[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_51.
static const field_t hw_rdc_mrc_51[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_51.
static const field_t hw_rdc_mrvs_51[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_52.
static const field_t hw_rdc_mrsa_52[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_52.
static const field_t hw_rdc_mrea_52[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_52.
static const field_t hw_rdc_mrc_52[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_52.
static const field_t hw_rdc_mrvs_52[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_53.
static const field_t hw_rdc_mrsa_53[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_53.
static const field_t hw_rdc_mrea_53[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_53.
static const field_t hw_rdc_mrc_53[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_53.
static const field_t hw_rdc_mrvs_53[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRSA_54.
static const field_t hw_rdc_mrsa_54[] =
{
    {
        "SADR",
        "Lower bound (inclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MREA_54.
static const field_t hw_rdc_mrea_54[] =
{
    {
        "EADR",
        "Upper bound (exclusive) modulo the defined granularity byte size of a "
        "region.",
        7, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRC_54.
static const field_t hw_rdc_mrc_54[] =
{
    {
        "D0W",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D0R",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1W",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1R",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2W",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2R",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3W",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3R",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENA",
        "Activates the memory region.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCK",
        "Locks all region fields from further modification except ENA, which ca"
        "n be set but not reset after LCK is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_MRVS_54.
static const field_t hw_rdc_mrvs_54[] =
{
    {
        "VDID",
        "The domain ID of the denied access.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AD",
        "Access to a memory region denied.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADR",
        "The address of the denied access.",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a RDC module.
static const reg_t hw_rdc[] =
{
    {
        "VIR",
        "The VIR provides version information including the number of domains, "
        "number of master slots, number of peripheral slots, and number of memo"
        "ry regions.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_rdc_vir
    },
    {
        "STAT",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_stat
    },
    {
        "INTCTRL",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_intctrl
    },
    {
        "INTSTAT",
        "Indication of Interrupt Pending for State Restoration",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_intstat
    },
    {
        "MDA0",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda0
    },
    {
        "MDA_1",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_1
    },
    {
        "MDA_2",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_2
    },
    {
        "MDA_3",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_3
    },
    {
        "MDA_4",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_4
    },
    {
        "MDA_5",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_5
    },
    {
        "MDA_6",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_6
    },
    {
        "MDA_7",
        "",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_7
    },
    {
        "MDA_8",
        "",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_8
    },
    {
        "MDA_9",
        "",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_9
    },
    {
        "MDA_10",
        "",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_10
    },
    {
        "MDA_11",
        "",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_11
    },
    {
        "MDA_12",
        "",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_12
    },
    {
        "MDA_13",
        "",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_13
    },
    {
        "MDA_14",
        "",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_14
    },
    {
        "MDA_15",
        "",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_15
    },
    {
        "MDA_16",
        "",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_16
    },
    {
        "MDA_17",
        "",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_17
    },
    {
        "MDA_18",
        "",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_18
    },
    {
        "MDA_19",
        "",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_19
    },
    {
        "MDA_20",
        "",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_20
    },
    {
        "MDA_21",
        "",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_21
    },
    {
        "MDA_22",
        "",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_22
    },
    {
        "MDA_23",
        "",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_23
    },
    {
        "MDA_24",
        "",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_24
    },
    {
        "MDA_25",
        "",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_25
    },
    {
        "MDA_26",
        "",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_26
    },
    {
        "MDA_27",
        "",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_27
    },
    {
        "MDA_28",
        "",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_28
    },
    {
        "MDA_29",
        "",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_29
    },
    {
        "MDA_30",
        "",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_30
    },
    {
        "MDA_31",
        "",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_mda_31
    },
    {
        "PDAP0",
        "",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap0
    },
    {
        "PDAP_1",
        "",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_1
    },
    {
        "PDAP_2",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_2
    },
    {
        "PDAP_3",
        "",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_3
    },
    {
        "PDAP_4",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_4
    },
    {
        "PDAP_5",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_5
    },
    {
        "PDAP_6",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_6
    },
    {
        "PDAP_7",
        "",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_7
    },
    {
        "PDAP_8",
        "",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_8
    },
    {
        "PDAP_9",
        "",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_9
    },
    {
        "PDAP_10",
        "",
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_10
    },
    {
        "PDAP_11",
        "",
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_11
    },
    {
        "PDAP_12",
        "",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_12
    },
    {
        "PDAP_13",
        "",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_13
    },
    {
        "PDAP_14",
        "",
        4, // Width in bytes
        0x00000438, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_14
    },
    {
        "PDAP_15",
        "",
        4, // Width in bytes
        0x0000043c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_15
    },
    {
        "PDAP_16",
        "",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_16
    },
    {
        "PDAP_17",
        "",
        4, // Width in bytes
        0x00000444, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_17
    },
    {
        "PDAP_18",
        "",
        4, // Width in bytes
        0x00000448, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_18
    },
    {
        "PDAP_19",
        "",
        4, // Width in bytes
        0x0000044c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_19
    },
    {
        "PDAP_20",
        "",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_20
    },
    {
        "PDAP_21",
        "",
        4, // Width in bytes
        0x00000454, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_21
    },
    {
        "PDAP_22",
        "",
        4, // Width in bytes
        0x00000458, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_22
    },
    {
        "PDAP_23",
        "",
        4, // Width in bytes
        0x0000045c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_23
    },
    {
        "PDAP_24",
        "",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_24
    },
    {
        "PDAP_25",
        "",
        4, // Width in bytes
        0x00000464, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_25
    },
    {
        "PDAP_26",
        "",
        4, // Width in bytes
        0x00000468, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_26
    },
    {
        "PDAP_27",
        "",
        4, // Width in bytes
        0x0000046c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_27
    },
    {
        "PDAP_28",
        "",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_28
    },
    {
        "PDAP_29",
        "",
        4, // Width in bytes
        0x00000474, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_29
    },
    {
        "PDAP_30",
        "",
        4, // Width in bytes
        0x00000478, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_30
    },
    {
        "PDAP_31",
        "",
        4, // Width in bytes
        0x0000047c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_31
    },
    {
        "PDAP_32",
        "",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_32
    },
    {
        "PDAP_33",
        "",
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_33
    },
    {
        "PDAP_34",
        "",
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_34
    },
    {
        "PDAP_35",
        "",
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_35
    },
    {
        "PDAP_36",
        "",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_36
    },
    {
        "PDAP_37",
        "",
        4, // Width in bytes
        0x00000494, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_37
    },
    {
        "PDAP_38",
        "",
        4, // Width in bytes
        0x00000498, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_38
    },
    {
        "PDAP_39",
        "",
        4, // Width in bytes
        0x0000049c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_39
    },
    {
        "PDAP_40",
        "",
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_40
    },
    {
        "PDAP_41",
        "",
        4, // Width in bytes
        0x000004a4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_41
    },
    {
        "PDAP_42",
        "",
        4, // Width in bytes
        0x000004a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_42
    },
    {
        "PDAP_43",
        "",
        4, // Width in bytes
        0x000004ac, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_43
    },
    {
        "PDAP_44",
        "",
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_44
    },
    {
        "PDAP_45",
        "",
        4, // Width in bytes
        0x000004b4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_45
    },
    {
        "PDAP_46",
        "",
        4, // Width in bytes
        0x000004b8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_46
    },
    {
        "PDAP_47",
        "",
        4, // Width in bytes
        0x000004bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_47
    },
    {
        "PDAP_48",
        "",
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_48
    },
    {
        "PDAP_49",
        "",
        4, // Width in bytes
        0x000004c4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_49
    },
    {
        "PDAP_50",
        "",
        4, // Width in bytes
        0x000004c8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_50
    },
    {
        "PDAP_51",
        "",
        4, // Width in bytes
        0x000004cc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_51
    },
    {
        "PDAP_52",
        "",
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_52
    },
    {
        "PDAP_53",
        "",
        4, // Width in bytes
        0x000004d4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_53
    },
    {
        "PDAP_54",
        "",
        4, // Width in bytes
        0x000004d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_54
    },
    {
        "PDAP_55",
        "",
        4, // Width in bytes
        0x000004dc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_55
    },
    {
        "PDAP_56",
        "",
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_56
    },
    {
        "PDAP_57",
        "",
        4, // Width in bytes
        0x000004e4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_57
    },
    {
        "PDAP_58",
        "",
        4, // Width in bytes
        0x000004e8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_58
    },
    {
        "PDAP_59",
        "",
        4, // Width in bytes
        0x000004ec, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_59
    },
    {
        "PDAP_60",
        "",
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_60
    },
    {
        "PDAP_61",
        "",
        4, // Width in bytes
        0x000004f4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_61
    },
    {
        "PDAP_62",
        "",
        4, // Width in bytes
        0x000004f8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_62
    },
    {
        "PDAP_63",
        "",
        4, // Width in bytes
        0x000004fc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_63
    },
    {
        "PDAP_64",
        "",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_64
    },
    {
        "PDAP_65",
        "",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_65
    },
    {
        "PDAP_66",
        "",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_66
    },
    {
        "PDAP_67",
        "",
        4, // Width in bytes
        0x0000050c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_67
    },
    {
        "PDAP_68",
        "",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_68
    },
    {
        "PDAP_69",
        "",
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_69
    },
    {
        "PDAP_70",
        "",
        4, // Width in bytes
        0x00000518, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_70
    },
    {
        "PDAP_71",
        "",
        4, // Width in bytes
        0x0000051c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_71
    },
    {
        "PDAP_72",
        "",
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_72
    },
    {
        "PDAP_73",
        "",
        4, // Width in bytes
        0x00000524, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_73
    },
    {
        "PDAP_74",
        "",
        4, // Width in bytes
        0x00000528, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_74
    },
    {
        "PDAP_75",
        "",
        4, // Width in bytes
        0x0000052c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_75
    },
    {
        "PDAP_76",
        "",
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_76
    },
    {
        "PDAP_77",
        "",
        4, // Width in bytes
        0x00000534, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_77
    },
    {
        "PDAP_78",
        "",
        4, // Width in bytes
        0x00000538, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_78
    },
    {
        "PDAP_79",
        "",
        4, // Width in bytes
        0x0000053c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_79
    },
    {
        "PDAP_80",
        "",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_80
    },
    {
        "PDAP_81",
        "",
        4, // Width in bytes
        0x00000544, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_81
    },
    {
        "PDAP_82",
        "",
        4, // Width in bytes
        0x00000548, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_82
    },
    {
        "PDAP_83",
        "",
        4, // Width in bytes
        0x0000054c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_83
    },
    {
        "PDAP_84",
        "",
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_84
    },
    {
        "PDAP_85",
        "",
        4, // Width in bytes
        0x00000554, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_85
    },
    {
        "PDAP_86",
        "",
        4, // Width in bytes
        0x00000558, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_86
    },
    {
        "PDAP_87",
        "",
        4, // Width in bytes
        0x0000055c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_87
    },
    {
        "PDAP_88",
        "",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_88
    },
    {
        "PDAP_89",
        "",
        4, // Width in bytes
        0x00000564, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_89
    },
    {
        "PDAP_90",
        "",
        4, // Width in bytes
        0x00000568, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_90
    },
    {
        "PDAP_91",
        "",
        4, // Width in bytes
        0x0000056c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_91
    },
    {
        "PDAP_92",
        "",
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_92
    },
    {
        "PDAP_93",
        "",
        4, // Width in bytes
        0x00000574, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_93
    },
    {
        "PDAP_94",
        "",
        4, // Width in bytes
        0x00000578, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_94
    },
    {
        "PDAP_95",
        "",
        4, // Width in bytes
        0x0000057c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_95
    },
    {
        "PDAP_96",
        "",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_96
    },
    {
        "PDAP_97",
        "",
        4, // Width in bytes
        0x00000584, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_97
    },
    {
        "PDAP_98",
        "",
        4, // Width in bytes
        0x00000588, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_98
    },
    {
        "PDAP_99",
        "",
        4, // Width in bytes
        0x0000058c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_99
    },
    {
        "PDAP_100",
        "",
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_100
    },
    {
        "PDAP_101",
        "",
        4, // Width in bytes
        0x00000594, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_101
    },
    {
        "PDAP_102",
        "",
        4, // Width in bytes
        0x00000598, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_102
    },
    {
        "PDAP_103",
        "",
        4, // Width in bytes
        0x0000059c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_103
    },
    {
        "PDAP_104",
        "",
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_104
    },
    {
        "PDAP_105",
        "",
        4, // Width in bytes
        0x000005a4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_105
    },
    {
        "PDAP_106",
        "",
        4, // Width in bytes
        0x000005a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_106
    },
    {
        "PDAP_107",
        "",
        4, // Width in bytes
        0x000005ac, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_107
    },
    {
        "PDAP_108",
        "",
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_108
    },
    {
        "PDAP_109",
        "",
        4, // Width in bytes
        0x000005b4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_pdap_109
    },
    {
        "MRSA0",
        "",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa0
    },
    {
        "MREA0",
        "",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea0
    },
    {
        "MRC0",
        "",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc0
    },
    {
        "MRVS0",
        "",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs0
    },
    {
        "MRSA_1",
        "",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_1
    },
    {
        "MREA_1",
        "",
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_1
    },
    {
        "MRC_1",
        "",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_1
    },
    {
        "MRVS_1",
        "",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_1
    },
    {
        "MRSA_2",
        "",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_2
    },
    {
        "MREA_2",
        "",
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_2
    },
    {
        "MRC_2",
        "",
        4, // Width in bytes
        0x00000828, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_2
    },
    {
        "MRVS_2",
        "",
        4, // Width in bytes
        0x0000082c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_2
    },
    {
        "MRSA_3",
        "",
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_3
    },
    {
        "MREA_3",
        "",
        4, // Width in bytes
        0x00000834, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_3
    },
    {
        "MRC_3",
        "",
        4, // Width in bytes
        0x00000838, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_3
    },
    {
        "MRVS_3",
        "",
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_3
    },
    {
        "MRSA_4",
        "",
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_4
    },
    {
        "MREA_4",
        "",
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_4
    },
    {
        "MRC_4",
        "",
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_4
    },
    {
        "MRVS_4",
        "",
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_4
    },
    {
        "MRSA_5",
        "",
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_5
    },
    {
        "MREA_5",
        "",
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_5
    },
    {
        "MRC_5",
        "",
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_5
    },
    {
        "MRVS_5",
        "",
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_5
    },
    {
        "MRSA_6",
        "",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_6
    },
    {
        "MREA_6",
        "",
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_6
    },
    {
        "MRC_6",
        "",
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_6
    },
    {
        "MRVS_6",
        "",
        4, // Width in bytes
        0x0000086c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_6
    },
    {
        "MRSA_7",
        "",
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_7
    },
    {
        "MREA_7",
        "",
        4, // Width in bytes
        0x00000874, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_7
    },
    {
        "MRC_7",
        "",
        4, // Width in bytes
        0x00000878, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_7
    },
    {
        "MRVS_7",
        "",
        4, // Width in bytes
        0x0000087c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_7
    },
    {
        "MRSA_8",
        "",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_8
    },
    {
        "MREA_8",
        "",
        4, // Width in bytes
        0x00000884, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_8
    },
    {
        "MRC_8",
        "",
        4, // Width in bytes
        0x00000888, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_8
    },
    {
        "MRVS_8",
        "",
        4, // Width in bytes
        0x0000088c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_8
    },
    {
        "MRSA_9",
        "",
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_9
    },
    {
        "MREA_9",
        "",
        4, // Width in bytes
        0x00000894, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_9
    },
    {
        "MRC_9",
        "",
        4, // Width in bytes
        0x00000898, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_9
    },
    {
        "MRVS_9",
        "",
        4, // Width in bytes
        0x0000089c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_9
    },
    {
        "MRSA_10",
        "",
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_10
    },
    {
        "MREA_10",
        "",
        4, // Width in bytes
        0x000008a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_10
    },
    {
        "MRC_10",
        "",
        4, // Width in bytes
        0x000008a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_10
    },
    {
        "MRVS_10",
        "",
        4, // Width in bytes
        0x000008ac, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_10
    },
    {
        "MRSA_11",
        "",
        4, // Width in bytes
        0x000008b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_11
    },
    {
        "MREA_11",
        "",
        4, // Width in bytes
        0x000008b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_11
    },
    {
        "MRC_11",
        "",
        4, // Width in bytes
        0x000008b8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_11
    },
    {
        "MRVS_11",
        "",
        4, // Width in bytes
        0x000008bc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_11
    },
    {
        "MRSA_12",
        "",
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_12
    },
    {
        "MREA_12",
        "",
        4, // Width in bytes
        0x000008c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_12
    },
    {
        "MRC_12",
        "",
        4, // Width in bytes
        0x000008c8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_12
    },
    {
        "MRVS_12",
        "",
        4, // Width in bytes
        0x000008cc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_12
    },
    {
        "MRSA_13",
        "",
        4, // Width in bytes
        0x000008d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_13
    },
    {
        "MREA_13",
        "",
        4, // Width in bytes
        0x000008d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_13
    },
    {
        "MRC_13",
        "",
        4, // Width in bytes
        0x000008d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_13
    },
    {
        "MRVS_13",
        "",
        4, // Width in bytes
        0x000008dc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_13
    },
    {
        "MRSA_14",
        "",
        4, // Width in bytes
        0x000008e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_14
    },
    {
        "MREA_14",
        "",
        4, // Width in bytes
        0x000008e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_14
    },
    {
        "MRC_14",
        "",
        4, // Width in bytes
        0x000008e8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_14
    },
    {
        "MRVS_14",
        "",
        4, // Width in bytes
        0x000008ec, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_14
    },
    {
        "MRSA_15",
        "",
        4, // Width in bytes
        0x000008f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_15
    },
    {
        "MREA_15",
        "",
        4, // Width in bytes
        0x000008f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_15
    },
    {
        "MRC_15",
        "",
        4, // Width in bytes
        0x000008f8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_15
    },
    {
        "MRVS_15",
        "",
        4, // Width in bytes
        0x000008fc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_15
    },
    {
        "MRSA_16",
        "",
        4, // Width in bytes
        0x00000900, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_16
    },
    {
        "MREA_16",
        "",
        4, // Width in bytes
        0x00000904, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_16
    },
    {
        "MRC_16",
        "",
        4, // Width in bytes
        0x00000908, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_16
    },
    {
        "MRVS_16",
        "",
        4, // Width in bytes
        0x0000090c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_16
    },
    {
        "MRSA_17",
        "",
        4, // Width in bytes
        0x00000910, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_17
    },
    {
        "MREA_17",
        "",
        4, // Width in bytes
        0x00000914, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_17
    },
    {
        "MRC_17",
        "",
        4, // Width in bytes
        0x00000918, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_17
    },
    {
        "MRVS_17",
        "",
        4, // Width in bytes
        0x0000091c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_17
    },
    {
        "MRSA_18",
        "",
        4, // Width in bytes
        0x00000920, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_18
    },
    {
        "MREA_18",
        "",
        4, // Width in bytes
        0x00000924, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_18
    },
    {
        "MRC_18",
        "",
        4, // Width in bytes
        0x00000928, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_18
    },
    {
        "MRVS_18",
        "",
        4, // Width in bytes
        0x0000092c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_18
    },
    {
        "MRSA_19",
        "",
        4, // Width in bytes
        0x00000930, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_19
    },
    {
        "MREA_19",
        "",
        4, // Width in bytes
        0x00000934, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_19
    },
    {
        "MRC_19",
        "",
        4, // Width in bytes
        0x00000938, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_19
    },
    {
        "MRVS_19",
        "",
        4, // Width in bytes
        0x0000093c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_19
    },
    {
        "MRSA_20",
        "",
        4, // Width in bytes
        0x00000940, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_20
    },
    {
        "MREA_20",
        "",
        4, // Width in bytes
        0x00000944, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_20
    },
    {
        "MRC_20",
        "",
        4, // Width in bytes
        0x00000948, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_20
    },
    {
        "MRVS_20",
        "",
        4, // Width in bytes
        0x0000094c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_20
    },
    {
        "MRSA_21",
        "",
        4, // Width in bytes
        0x00000950, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_21
    },
    {
        "MREA_21",
        "",
        4, // Width in bytes
        0x00000954, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_21
    },
    {
        "MRC_21",
        "",
        4, // Width in bytes
        0x00000958, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_21
    },
    {
        "MRVS_21",
        "",
        4, // Width in bytes
        0x0000095c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_21
    },
    {
        "MRSA_22",
        "",
        4, // Width in bytes
        0x00000960, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_22
    },
    {
        "MREA_22",
        "",
        4, // Width in bytes
        0x00000964, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_22
    },
    {
        "MRC_22",
        "",
        4, // Width in bytes
        0x00000968, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_22
    },
    {
        "MRVS_22",
        "",
        4, // Width in bytes
        0x0000096c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_22
    },
    {
        "MRSA_23",
        "",
        4, // Width in bytes
        0x00000970, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_23
    },
    {
        "MREA_23",
        "",
        4, // Width in bytes
        0x00000974, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_23
    },
    {
        "MRC_23",
        "",
        4, // Width in bytes
        0x00000978, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_23
    },
    {
        "MRVS_23",
        "",
        4, // Width in bytes
        0x0000097c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_23
    },
    {
        "MRSA_24",
        "",
        4, // Width in bytes
        0x00000980, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_24
    },
    {
        "MREA_24",
        "",
        4, // Width in bytes
        0x00000984, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_24
    },
    {
        "MRC_24",
        "",
        4, // Width in bytes
        0x00000988, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_24
    },
    {
        "MRVS_24",
        "",
        4, // Width in bytes
        0x0000098c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_24
    },
    {
        "MRSA_25",
        "",
        4, // Width in bytes
        0x00000990, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_25
    },
    {
        "MREA_25",
        "",
        4, // Width in bytes
        0x00000994, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_25
    },
    {
        "MRC_25",
        "",
        4, // Width in bytes
        0x00000998, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_25
    },
    {
        "MRVS_25",
        "",
        4, // Width in bytes
        0x0000099c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_25
    },
    {
        "MRSA_26",
        "",
        4, // Width in bytes
        0x000009a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_26
    },
    {
        "MREA_26",
        "",
        4, // Width in bytes
        0x000009a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_26
    },
    {
        "MRC_26",
        "",
        4, // Width in bytes
        0x000009a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_26
    },
    {
        "MRVS_26",
        "",
        4, // Width in bytes
        0x000009ac, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_26
    },
    {
        "MRSA_27",
        "",
        4, // Width in bytes
        0x000009b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_27
    },
    {
        "MREA_27",
        "",
        4, // Width in bytes
        0x000009b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_27
    },
    {
        "MRC_27",
        "",
        4, // Width in bytes
        0x000009b8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_27
    },
    {
        "MRVS_27",
        "",
        4, // Width in bytes
        0x000009bc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_27
    },
    {
        "MRSA_28",
        "",
        4, // Width in bytes
        0x000009c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_28
    },
    {
        "MREA_28",
        "",
        4, // Width in bytes
        0x000009c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_28
    },
    {
        "MRC_28",
        "",
        4, // Width in bytes
        0x000009c8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_28
    },
    {
        "MRVS_28",
        "",
        4, // Width in bytes
        0x000009cc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_28
    },
    {
        "MRSA_29",
        "",
        4, // Width in bytes
        0x000009d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_29
    },
    {
        "MREA_29",
        "",
        4, // Width in bytes
        0x000009d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_29
    },
    {
        "MRC_29",
        "",
        4, // Width in bytes
        0x000009d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_29
    },
    {
        "MRVS_29",
        "",
        4, // Width in bytes
        0x000009dc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_29
    },
    {
        "MRSA_30",
        "",
        4, // Width in bytes
        0x000009e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_30
    },
    {
        "MREA_30",
        "",
        4, // Width in bytes
        0x000009e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_30
    },
    {
        "MRC_30",
        "",
        4, // Width in bytes
        0x000009e8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_30
    },
    {
        "MRVS_30",
        "",
        4, // Width in bytes
        0x000009ec, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_30
    },
    {
        "MRSA_31",
        "",
        4, // Width in bytes
        0x000009f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_31
    },
    {
        "MREA_31",
        "",
        4, // Width in bytes
        0x000009f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_31
    },
    {
        "MRC_31",
        "",
        4, // Width in bytes
        0x000009f8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_31
    },
    {
        "MRVS_31",
        "",
        4, // Width in bytes
        0x000009fc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_31
    },
    {
        "MRSA_32",
        "",
        4, // Width in bytes
        0x00000a00, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_32
    },
    {
        "MREA_32",
        "",
        4, // Width in bytes
        0x00000a04, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_32
    },
    {
        "MRC_32",
        "",
        4, // Width in bytes
        0x00000a08, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_32
    },
    {
        "MRVS_32",
        "",
        4, // Width in bytes
        0x00000a0c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_32
    },
    {
        "MRSA_33",
        "",
        4, // Width in bytes
        0x00000a10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_33
    },
    {
        "MREA_33",
        "",
        4, // Width in bytes
        0x00000a14, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_33
    },
    {
        "MRC_33",
        "",
        4, // Width in bytes
        0x00000a18, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_33
    },
    {
        "MRVS_33",
        "",
        4, // Width in bytes
        0x00000a1c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_33
    },
    {
        "MRSA_34",
        "",
        4, // Width in bytes
        0x00000a20, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_34
    },
    {
        "MREA_34",
        "",
        4, // Width in bytes
        0x00000a24, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_34
    },
    {
        "MRC_34",
        "",
        4, // Width in bytes
        0x00000a28, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_34
    },
    {
        "MRVS_34",
        "",
        4, // Width in bytes
        0x00000a2c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_34
    },
    {
        "MRSA_35",
        "",
        4, // Width in bytes
        0x00000a30, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_35
    },
    {
        "MREA_35",
        "",
        4, // Width in bytes
        0x00000a34, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_35
    },
    {
        "MRC_35",
        "",
        4, // Width in bytes
        0x00000a38, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_35
    },
    {
        "MRVS_35",
        "",
        4, // Width in bytes
        0x00000a3c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_35
    },
    {
        "MRSA_36",
        "",
        4, // Width in bytes
        0x00000a40, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_36
    },
    {
        "MREA_36",
        "",
        4, // Width in bytes
        0x00000a44, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_36
    },
    {
        "MRC_36",
        "",
        4, // Width in bytes
        0x00000a48, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_36
    },
    {
        "MRVS_36",
        "",
        4, // Width in bytes
        0x00000a4c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_36
    },
    {
        "MRSA_37",
        "",
        4, // Width in bytes
        0x00000a50, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_37
    },
    {
        "MREA_37",
        "",
        4, // Width in bytes
        0x00000a54, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_37
    },
    {
        "MRC_37",
        "",
        4, // Width in bytes
        0x00000a58, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_37
    },
    {
        "MRVS_37",
        "",
        4, // Width in bytes
        0x00000a5c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_37
    },
    {
        "MRSA_38",
        "",
        4, // Width in bytes
        0x00000a60, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_38
    },
    {
        "MREA_38",
        "",
        4, // Width in bytes
        0x00000a64, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_38
    },
    {
        "MRC_38",
        "",
        4, // Width in bytes
        0x00000a68, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_38
    },
    {
        "MRVS_38",
        "",
        4, // Width in bytes
        0x00000a6c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_38
    },
    {
        "MRSA_39",
        "",
        4, // Width in bytes
        0x00000a70, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_39
    },
    {
        "MREA_39",
        "",
        4, // Width in bytes
        0x00000a74, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_39
    },
    {
        "MRC_39",
        "",
        4, // Width in bytes
        0x00000a78, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_39
    },
    {
        "MRVS_39",
        "",
        4, // Width in bytes
        0x00000a7c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_39
    },
    {
        "MRSA_40",
        "",
        4, // Width in bytes
        0x00000a80, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_40
    },
    {
        "MREA_40",
        "",
        4, // Width in bytes
        0x00000a84, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_40
    },
    {
        "MRC_40",
        "",
        4, // Width in bytes
        0x00000a88, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_40
    },
    {
        "MRVS_40",
        "",
        4, // Width in bytes
        0x00000a8c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_40
    },
    {
        "MRSA_41",
        "",
        4, // Width in bytes
        0x00000a90, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_41
    },
    {
        "MREA_41",
        "",
        4, // Width in bytes
        0x00000a94, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_41
    },
    {
        "MRC_41",
        "",
        4, // Width in bytes
        0x00000a98, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_41
    },
    {
        "MRVS_41",
        "",
        4, // Width in bytes
        0x00000a9c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_41
    },
    {
        "MRSA_42",
        "",
        4, // Width in bytes
        0x00000aa0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_42
    },
    {
        "MREA_42",
        "",
        4, // Width in bytes
        0x00000aa4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_42
    },
    {
        "MRC_42",
        "",
        4, // Width in bytes
        0x00000aa8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_42
    },
    {
        "MRVS_42",
        "",
        4, // Width in bytes
        0x00000aac, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_42
    },
    {
        "MRSA_43",
        "",
        4, // Width in bytes
        0x00000ab0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_43
    },
    {
        "MREA_43",
        "",
        4, // Width in bytes
        0x00000ab4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_43
    },
    {
        "MRC_43",
        "",
        4, // Width in bytes
        0x00000ab8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_43
    },
    {
        "MRVS_43",
        "",
        4, // Width in bytes
        0x00000abc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_43
    },
    {
        "MRSA_44",
        "",
        4, // Width in bytes
        0x00000ac0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_44
    },
    {
        "MREA_44",
        "",
        4, // Width in bytes
        0x00000ac4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_44
    },
    {
        "MRC_44",
        "",
        4, // Width in bytes
        0x00000ac8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_44
    },
    {
        "MRVS_44",
        "",
        4, // Width in bytes
        0x00000acc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_44
    },
    {
        "MRSA_45",
        "",
        4, // Width in bytes
        0x00000ad0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_45
    },
    {
        "MREA_45",
        "",
        4, // Width in bytes
        0x00000ad4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_45
    },
    {
        "MRC_45",
        "",
        4, // Width in bytes
        0x00000ad8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_45
    },
    {
        "MRVS_45",
        "",
        4, // Width in bytes
        0x00000adc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_45
    },
    {
        "MRSA_46",
        "",
        4, // Width in bytes
        0x00000ae0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_46
    },
    {
        "MREA_46",
        "",
        4, // Width in bytes
        0x00000ae4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_46
    },
    {
        "MRC_46",
        "",
        4, // Width in bytes
        0x00000ae8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_46
    },
    {
        "MRVS_46",
        "",
        4, // Width in bytes
        0x00000aec, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_46
    },
    {
        "MRSA_47",
        "",
        4, // Width in bytes
        0x00000af0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_47
    },
    {
        "MREA_47",
        "",
        4, // Width in bytes
        0x00000af4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_47
    },
    {
        "MRC_47",
        "",
        4, // Width in bytes
        0x00000af8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_47
    },
    {
        "MRVS_47",
        "",
        4, // Width in bytes
        0x00000afc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_47
    },
    {
        "MRSA_48",
        "",
        4, // Width in bytes
        0x00000b00, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_48
    },
    {
        "MREA_48",
        "",
        4, // Width in bytes
        0x00000b04, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_48
    },
    {
        "MRC_48",
        "",
        4, // Width in bytes
        0x00000b08, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_48
    },
    {
        "MRVS_48",
        "",
        4, // Width in bytes
        0x00000b0c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_48
    },
    {
        "MRSA_49",
        "",
        4, // Width in bytes
        0x00000b10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_49
    },
    {
        "MREA_49",
        "",
        4, // Width in bytes
        0x00000b14, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_49
    },
    {
        "MRC_49",
        "",
        4, // Width in bytes
        0x00000b18, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_49
    },
    {
        "MRVS_49",
        "",
        4, // Width in bytes
        0x00000b1c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_49
    },
    {
        "MRSA_50",
        "",
        4, // Width in bytes
        0x00000b20, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_50
    },
    {
        "MREA_50",
        "",
        4, // Width in bytes
        0x00000b24, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_50
    },
    {
        "MRC_50",
        "",
        4, // Width in bytes
        0x00000b28, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_50
    },
    {
        "MRVS_50",
        "",
        4, // Width in bytes
        0x00000b2c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_50
    },
    {
        "MRSA_51",
        "",
        4, // Width in bytes
        0x00000b30, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_51
    },
    {
        "MREA_51",
        "",
        4, // Width in bytes
        0x00000b34, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_51
    },
    {
        "MRC_51",
        "",
        4, // Width in bytes
        0x00000b38, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_51
    },
    {
        "MRVS_51",
        "",
        4, // Width in bytes
        0x00000b3c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_51
    },
    {
        "MRSA_52",
        "",
        4, // Width in bytes
        0x00000b40, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_52
    },
    {
        "MREA_52",
        "",
        4, // Width in bytes
        0x00000b44, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_52
    },
    {
        "MRC_52",
        "",
        4, // Width in bytes
        0x00000b48, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_52
    },
    {
        "MRVS_52",
        "",
        4, // Width in bytes
        0x00000b4c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_52
    },
    {
        "MRSA_53",
        "",
        4, // Width in bytes
        0x00000b50, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_53
    },
    {
        "MREA_53",
        "",
        4, // Width in bytes
        0x00000b54, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_53
    },
    {
        "MRC_53",
        "",
        4, // Width in bytes
        0x00000b58, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_53
    },
    {
        "MRVS_53",
        "",
        4, // Width in bytes
        0x00000b5c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_53
    },
    {
        "MRSA_54",
        "",
        4, // Width in bytes
        0x00000b60, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrsa_54
    },
    {
        "MREA_54",
        "",
        4, // Width in bytes
        0x00000b64, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_rdc_mrea_54
    },
    {
        "MRC_54",
        "",
        4, // Width in bytes
        0x00000b68, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_rdc_mrc_54
    },
    {
        "MRVS_54",
        "",
        4, // Width in bytes
        0x00000b6c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_mrvs_54
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark RDC_SEMAPHORE
#endif

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE0.
static const field_t hw_rdc_semaphore_semaphore1_gate0[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE1.
static const field_t hw_rdc_semaphore_semaphore1_gate1[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE2.
static const field_t hw_rdc_semaphore_semaphore1_gate2[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE3.
static const field_t hw_rdc_semaphore_semaphore1_gate3[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE4.
static const field_t hw_rdc_semaphore_semaphore1_gate4[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE5.
static const field_t hw_rdc_semaphore_semaphore1_gate5[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE6.
static const field_t hw_rdc_semaphore_semaphore1_gate6[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE7.
static const field_t hw_rdc_semaphore_semaphore1_gate7[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE8.
static const field_t hw_rdc_semaphore_semaphore1_gate8[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE9.
static const field_t hw_rdc_semaphore_semaphore1_gate9[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE10.
static const field_t hw_rdc_semaphore_semaphore1_gate10[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE11.
static const field_t hw_rdc_semaphore_semaphore1_gate11[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE12.
static const field_t hw_rdc_semaphore_semaphore1_gate12[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE13.
static const field_t hw_rdc_semaphore_semaphore1_gate13[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE14.
static const field_t hw_rdc_semaphore_semaphore1_gate14[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE15.
static const field_t hw_rdc_semaphore_semaphore1_gate15[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE16.
static const field_t hw_rdc_semaphore_semaphore1_gate16[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE17.
static const field_t hw_rdc_semaphore_semaphore1_gate17[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE18.
static const field_t hw_rdc_semaphore_semaphore1_gate18[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE19.
static const field_t hw_rdc_semaphore_semaphore1_gate19[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE20.
static const field_t hw_rdc_semaphore_semaphore1_gate20[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE21.
static const field_t hw_rdc_semaphore_semaphore1_gate21[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE22.
static const field_t hw_rdc_semaphore_semaphore1_gate22[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE23.
static const field_t hw_rdc_semaphore_semaphore1_gate23[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE24.
static const field_t hw_rdc_semaphore_semaphore1_gate24[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE25.
static const field_t hw_rdc_semaphore_semaphore1_gate25[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE26.
static const field_t hw_rdc_semaphore_semaphore1_gate26[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE27.
static const field_t hw_rdc_semaphore_semaphore1_gate27[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE28.
static const field_t hw_rdc_semaphore_semaphore1_gate28[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE29.
static const field_t hw_rdc_semaphore_semaphore1_gate29[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE30.
static const field_t hw_rdc_semaphore_semaphore1_gate30[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE31.
static const field_t hw_rdc_semaphore_semaphore1_gate31[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE32.
static const field_t hw_rdc_semaphore_semaphore1_gate32[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE33.
static const field_t hw_rdc_semaphore_semaphore1_gate33[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE34.
static const field_t hw_rdc_semaphore_semaphore1_gate34[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE35.
static const field_t hw_rdc_semaphore_semaphore1_gate35[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE36.
static const field_t hw_rdc_semaphore_semaphore1_gate36[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE37.
static const field_t hw_rdc_semaphore_semaphore1_gate37[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE38.
static const field_t hw_rdc_semaphore_semaphore1_gate38[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE39.
static const field_t hw_rdc_semaphore_semaphore1_gate39[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE40.
static const field_t hw_rdc_semaphore_semaphore1_gate40[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE41.
static const field_t hw_rdc_semaphore_semaphore1_gate41[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE42.
static const field_t hw_rdc_semaphore_semaphore1_gate42[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE43.
static const field_t hw_rdc_semaphore_semaphore1_gate43[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE44.
static const field_t hw_rdc_semaphore_semaphore1_gate44[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE45.
static const field_t hw_rdc_semaphore_semaphore1_gate45[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE46.
static const field_t hw_rdc_semaphore_semaphore1_gate46[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE47.
static const field_t hw_rdc_semaphore_semaphore1_gate47[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE48.
static const field_t hw_rdc_semaphore_semaphore1_gate48[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE49.
static const field_t hw_rdc_semaphore_semaphore1_gate49[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE50.
static const field_t hw_rdc_semaphore_semaphore1_gate50[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE51.
static const field_t hw_rdc_semaphore_semaphore1_gate51[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE52.
static const field_t hw_rdc_semaphore_semaphore1_gate52[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE53.
static const field_t hw_rdc_semaphore_semaphore1_gate53[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE54.
static const field_t hw_rdc_semaphore_semaphore1_gate54[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE55.
static const field_t hw_rdc_semaphore_semaphore1_gate55[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE56.
static const field_t hw_rdc_semaphore_semaphore1_gate56[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE57.
static const field_t hw_rdc_semaphore_semaphore1_gate57[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE58.
static const field_t hw_rdc_semaphore_semaphore1_gate58[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE59.
static const field_t hw_rdc_semaphore_semaphore1_gate59[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE60.
static const field_t hw_rdc_semaphore_semaphore1_gate60[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE61.
static const field_t hw_rdc_semaphore_semaphore1_gate61[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE62.
static const field_t hw_rdc_semaphore_semaphore1_gate62[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_GATE63.
static const field_t hw_rdc_semaphore_semaphore1_gate63[] =
{
    {
        "GTFSM",
        "The state of the gate reflects the last processor that locked it, whic"
        "h can be useful during system debug.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOM",
        "Bits 6-5 are read-only bits.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_RSTGT_W.
static const field_t hw_rdc_semaphore_semaphore1_rstgt_w[] =
{
    {
        "RSTGDP",
        "Reset Gate Data Pattern.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RSTGTN",
        "Reset Gate Number.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RDC_SEMAPHORE_SEMAPHORE1_RSTGT_R.
static const field_t hw_rdc_semaphore_semaphore1_rstgt_r[] =
{
    {
        "RSTGMS",
        "Reset Gate Bus Master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSTGSM",
        "Reset Gate Finite State Machine.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSTGTN",
        "Reset Gate Number.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a RDC_SEMAPHORE module.
static const reg_t hw_rdc_semaphore[] =
{
    {
        "SEMAPHORE1_GATE0",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate0
    },
    {
        "SEMAPHORE1_GATE1",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000001, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate1
    },
    {
        "SEMAPHORE1_GATE2",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate2
    },
    {
        "SEMAPHORE1_GATE3",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000003, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate3
    },
    {
        "SEMAPHORE1_GATE4",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate4
    },
    {
        "SEMAPHORE1_GATE5",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000005, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate5
    },
    {
        "SEMAPHORE1_GATE6",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate6
    },
    {
        "SEMAPHORE1_GATE7",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000007, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate7
    },
    {
        "SEMAPHORE1_GATE8",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate8
    },
    {
        "SEMAPHORE1_GATE9",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000009, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate9
    },
    {
        "SEMAPHORE1_GATE10",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000a, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate10
    },
    {
        "SEMAPHORE1_GATE11",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000b, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate11
    },
    {
        "SEMAPHORE1_GATE12",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate12
    },
    {
        "SEMAPHORE1_GATE13",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000d, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate13
    },
    {
        "SEMAPHORE1_GATE14",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate14
    },
    {
        "SEMAPHORE1_GATE15",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000f, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate15
    },
    {
        "SEMAPHORE1_GATE16",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate16
    },
    {
        "SEMAPHORE1_GATE17",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000011, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate17
    },
    {
        "SEMAPHORE1_GATE18",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000012, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate18
    },
    {
        "SEMAPHORE1_GATE19",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000013, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate19
    },
    {
        "SEMAPHORE1_GATE20",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate20
    },
    {
        "SEMAPHORE1_GATE21",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000015, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate21
    },
    {
        "SEMAPHORE1_GATE22",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000016, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate22
    },
    {
        "SEMAPHORE1_GATE23",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000017, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate23
    },
    {
        "SEMAPHORE1_GATE24",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate24
    },
    {
        "SEMAPHORE1_GATE25",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000019, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate25
    },
    {
        "SEMAPHORE1_GATE26",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000001a, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate26
    },
    {
        "SEMAPHORE1_GATE27",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000001b, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate27
    },
    {
        "SEMAPHORE1_GATE28",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate28
    },
    {
        "SEMAPHORE1_GATE29",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000001d, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate29
    },
    {
        "SEMAPHORE1_GATE30",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000001e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate30
    },
    {
        "SEMAPHORE1_GATE31",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000001f, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate31
    },
    {
        "SEMAPHORE1_GATE32",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate32
    },
    {
        "SEMAPHORE1_GATE33",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000021, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate33
    },
    {
        "SEMAPHORE1_GATE34",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000022, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate34
    },
    {
        "SEMAPHORE1_GATE35",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000023, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate35
    },
    {
        "SEMAPHORE1_GATE36",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate36
    },
    {
        "SEMAPHORE1_GATE37",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000025, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate37
    },
    {
        "SEMAPHORE1_GATE38",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000026, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate38
    },
    {
        "SEMAPHORE1_GATE39",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000027, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate39
    },
    {
        "SEMAPHORE1_GATE40",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate40
    },
    {
        "SEMAPHORE1_GATE41",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000029, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate41
    },
    {
        "SEMAPHORE1_GATE42",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000002a, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate42
    },
    {
        "SEMAPHORE1_GATE43",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000002b, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate43
    },
    {
        "SEMAPHORE1_GATE44",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate44
    },
    {
        "SEMAPHORE1_GATE45",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000002d, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate45
    },
    {
        "SEMAPHORE1_GATE46",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000002e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate46
    },
    {
        "SEMAPHORE1_GATE47",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000002f, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate47
    },
    {
        "SEMAPHORE1_GATE48",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate48
    },
    {
        "SEMAPHORE1_GATE49",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000031, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate49
    },
    {
        "SEMAPHORE1_GATE50",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000032, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate50
    },
    {
        "SEMAPHORE1_GATE51",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000033, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate51
    },
    {
        "SEMAPHORE1_GATE52",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate52
    },
    {
        "SEMAPHORE1_GATE53",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000035, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate53
    },
    {
        "SEMAPHORE1_GATE54",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000036, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate54
    },
    {
        "SEMAPHORE1_GATE55",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000037, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate55
    },
    {
        "SEMAPHORE1_GATE56",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate56
    },
    {
        "SEMAPHORE1_GATE57",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000039, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate57
    },
    {
        "SEMAPHORE1_GATE58",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000003a, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate58
    },
    {
        "SEMAPHORE1_GATE59",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000003b, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate59
    },
    {
        "SEMAPHORE1_GATE60",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate60
    },
    {
        "SEMAPHORE1_GATE61",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000003d, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate61
    },
    {
        "SEMAPHORE1_GATE62",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000003e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate62
    },
    {
        "SEMAPHORE1_GATE63",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000003f, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_gate63
    },
    {
        "SEMAPHORE1_RSTGT_W",
        "Although the intent of the hardware gate implementation specifies a pr"
        "otocol where the locking processor must unlock the gate, it is recogni"
        "zed that system operation may require a reset function to re-initializ"
        "e the state of any gate(s) without requiring a system-level reset.",
        2, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_rdc_semaphore_semaphore1_rstgt_w
    },
    {
        "SEMAPHORE1_RSTGT_R",
        "Although the intent of the hardware gate implementation specifies a pr"
        "otocol where the locking processor must unlock the gate, it is recogni"
        "zed that system operation may require a reset function to re-initializ"
        "e the state of any gate(s) without requiring a system-level reset.",
        2, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_rdc_semaphore_semaphore1_rstgt_r
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ROMC
#endif

// Bitfields in register ROMC_ROMPATCH0D.
static const field_t hw_romc_rompatch0d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1D.
static const field_t hw_romc_rompatch1d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2D.
static const field_t hw_romc_rompatch2d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3D.
static const field_t hw_romc_rompatch3d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4D.
static const field_t hw_romc_rompatch4d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5D.
static const field_t hw_romc_rompatch5d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6D.
static const field_t hw_romc_rompatch6d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7D.
static const field_t hw_romc_rompatch7d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHCNTL.
static const field_t hw_romc_rompatchcntl[] =
{
    {
        "DATAFIX",
        "Data Fix Enable - Controls the use of the first 8 address comparators "
        "for 1-word data fix or for code patch routine.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS",
        "ROMC Disable -- This bit, when set, disables all ROMC operations.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENH.
static const field_t hw_romc_rompatchenh[] =
{
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENL.
static const field_t hw_romc_rompatchenl[] =
{
    {
        "ENABLE",
        "Enable Address Comparator - This bit enables the corresponding address"
        " comparator to trigger an event.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH0A.
static const field_t hw_romc_rompatch0a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1A.
static const field_t hw_romc_rompatch1a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2A.
static const field_t hw_romc_rompatch2a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3A.
static const field_t hw_romc_rompatch3a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4A.
static const field_t hw_romc_rompatch4a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5A.
static const field_t hw_romc_rompatch5a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6A.
static const field_t hw_romc_rompatch6a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7A.
static const field_t hw_romc_rompatch7a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH8A.
static const field_t hw_romc_rompatch8a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH9A.
static const field_t hw_romc_rompatch9a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH10A.
static const field_t hw_romc_rompatch10a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH11A.
static const field_t hw_romc_rompatch11a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH12A.
static const field_t hw_romc_rompatch12a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH13A.
static const field_t hw_romc_rompatch13a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH14A.
static const field_t hw_romc_rompatch14a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH15A.
static const field_t hw_romc_rompatch15a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHSR.
static const field_t hw_romc_rompatchsr[] =
{
    {
        "SOURCE",
        "ROMC Source Number - Binary encoding of the number of the address comp"
        "arator which has an address match in the most recent patch event on RO"
        "MC AHB.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW",
        "ROMC AHB Multiple Address Comparator matches Indicator - Indicates tha"
        "t multiple address comparator matches occurred.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ROMC module.
static const reg_t hw_romc[] =
{
    {
        "ROMPATCH0D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch0d
    },
    {
        "ROMPATCH1D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch1d
    },
    {
        "ROMPATCH2D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch2d
    },
    {
        "ROMPATCH3D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch3d
    },
    {
        "ROMPATCH4D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch4d
    },
    {
        "ROMPATCH5D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch5d
    },
    {
        "ROMPATCH6D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch6d
    },
    {
        "ROMPATCH7D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch7d
    },
    {
        "ROMPATCHCNTL",
        "The ROMC control register (ROMC_ROMPATCHCNTL) contains the block disab"
        "le bit and the data fix enable bits.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchcntl
    },
    {
        "ROMPATCHENH",
        "The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_romc_rompatchenh
    },
    {
        "ROMPATCHENL",
        "The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatchenl
    },
    {
        "ROMPATCH0A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch0a
    },
    {
        "ROMPATCH1A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch1a
    },
    {
        "ROMPATCH2A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch2a
    },
    {
        "ROMPATCH3A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch3a
    },
    {
        "ROMPATCH4A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch4a
    },
    {
        "ROMPATCH5A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch5a
    },
    {
        "ROMPATCH6A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch6a
    },
    {
        "ROMPATCH7A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch7a
    },
    {
        "ROMPATCH8A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch8a
    },
    {
        "ROMPATCH9A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch9a
    },
    {
        "ROMPATCH10A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch10a
    },
    {
        "ROMPATCH11A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch11a
    },
    {
        "ROMPATCH12A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch12a
    },
    {
        "ROMPATCH13A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch13a
    },
    {
        "ROMPATCH14A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch14a
    },
    {
        "ROMPATCH15A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch15a
    },
    {
        "ROMPATCHSR",
        "The ROMC status register (ROMC_ROMPATCHSR) indicates the current state"
        " of the ROMC and the source number of the most recent address comparat"
        "or event.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchsr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMAARM
#endif

// Bitfields in register SDMAARM_MC0PTR.
static const field_t hw_sdmaarm_mc0ptr[] =
{
    {
        "MC0PTR",
        "Channel 0 Pointer contains the 32-bit address, in ARM platform memory,"
        " of channel 0 control block (the boot channel).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_INTR.
static const field_t hw_sdmaarm_intr[] =
{
    {
        "HI",
        "The ARM platform Interrupts register contains the 32 HI[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_STOP_STAT.
static const field_t hw_sdmaarm_stop_stat[] =
{
    {
        "HE",
        "This 32-bit register gives access to the ARM platform Enable bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_HSTART.
static const field_t hw_sdmaarm_hstart[] =
{
    {
        "HSTART_HE",
        "The HSTART_HE registers are 32 bits wide with one bit for every channe"
        "l.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTOVR.
static const field_t hw_sdmaarm_evtovr[] =
{
    {
        "EO",
        "The Channel Event Override register contains the 32 EO[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_DSPOVR.
static const field_t hw_sdmaarm_dspovr[] =
{
    {
        "DO",
        "This register is reserved.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_HOSTOVR.
static const field_t hw_sdmaarm_hostovr[] =
{
    {
        "HO",
        "The Channel ARM platform Override register contains the 32 HO[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTPEND.
static const field_t hw_sdmaarm_evtpend[] =
{
    {
        "EP",
        "The Channel Event Pending register contains the 32 EP[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_RESET.
static const field_t hw_sdmaarm_reset[] =
{
    {
        "RESET",
        "When set, this bit causes the SDMA to be held in a software reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RESCHED",
        "When set, this bit forces the SDMA to reschedule as if a script had ex"
        "ecuted a done instruction.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTERR.
static const field_t hw_sdmaarm_evterr[] =
{
    {
        "CHNERR",
        "This register is used by the SDMA to warn the ARM platform when an inc"
        "oming DMA request was detected and it triggers a channel that is alrea"
        "dy pending or being serviced.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_INTRMASK.
static const field_t hw_sdmaarm_intrmask[] =
{
    {
        "HIMASK",
        "The Interrupt Mask Register contains 32 interrupt generation mask bits"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_PSW.
static const field_t hw_sdmaarm_psw[] =
{
    {
        "CCR",
        "The Current Channel Register indicates the number of the channel that "
        "is being executed by the SDMA.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CCP",
        "The Current Channel Priority indicates the priority of the current act"
        "ive channel.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCR",
        "The Next Channel Register indicates the number of the next scheduled p"
        "ending channel with the highest priority.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCP",
        "The Next Channel Priority gives the next pending channel priority.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTERRDBG.
static const field_t hw_sdmaarm_evterrdbg[] =
{
    {
        "CHNERR",
        "This register is the same as EVTERR, except reading it does not clear "
        "its contents.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CONFIG.
static const field_t hw_sdmaarm_config[] =
{
    {
        "CSM",
        "Selects the Context Switch Mode.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        "ARM platform DMA / SDMA Core Clock Ratio.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTDOBS",
        "Indicates if Real-Time Debug pins are used: They do not toggle by defa"
        "ult in order to reduce power consumption.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSPDMA",
        "This bit's function is reserved and should be configured as zero.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_LOCK.
static const field_t hw_sdmaarm_sdma_lock[] =
{
    {
        "LOCK",
        "The LOCK bit is used to restrict access to update SDMA script memory t"
        "hrough ROM channel zero scripts and through the OnCE interface under A"
        "RM platform control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRESET_LOCK_CLR",
        "The SRESET_LOCK_CLR bit determine if the LOCK bit is cleared on a soft"
        "ware reset triggered by writing to the RESET register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_ENB.
static const field_t hw_sdmaarm_once_enb[] =
{
    {
        "ENB",
        "The OnCE Enable register selects the OnCE control source: When cleared"
        " (0), the OnCE registers are accessed through the JTAG interface; when"
        " set (1), the OnCE registers may be accessed by the ARM platform throu"
        "gh the addresses described, as follows.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_DATA.
static const field_t hw_sdmaarm_once_data[] =
{
    {
        "DATA",
        "Data register of the OnCE JTAG controller.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_INSTR.
static const field_t hw_sdmaarm_once_instr[] =
{
    {
        "INSTR",
        "Instruction register of the OnCE JTAG controller.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_STAT.
static const field_t hw_sdmaarm_once_stat[] =
{
    {
        "ECDR",
        "Event Cell Debug Request.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST",
        "This flag is raised when the OnCE is controlled from the ARM platform "
        "peripheral interface.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWB",
        "This flag is raised when the SDMA has entered debug mode after a softw"
        "are breakpoint.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODR",
        "This flag is raised when the SDMA has entered debug mode after a OnCE "
        "debug request.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EDR",
        "This flag is raised when the SDMA has entered debug mode after an exte"
        "rnal debug request.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCV",
        "After each write access to the real time buffer (RTB), the RCV bit is "
        "set.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "The Processor Status bits reflect the state of the SDMA RISC engine.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_CMD.
static const field_t hw_sdmaarm_once_cmd[] =
{
    {
        "CMD",
        "Writing to this register will cause the OnCE to execute the command th"
        "at is written.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ILLINSTADDR.
static const field_t hw_sdmaarm_illinstaddr[] =
{
    {
        "ILLINSTADDR",
        "The Illegal Instruction Trap Address is the address where the SDMA jum"
        "ps when an illegal instruction is executed.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHN0ADDR.
static const field_t hw_sdmaarm_chn0addr[] =
{
    {
        "CHN0ADDR",
        "This 14-bit register is used by the boot code of the SDMA.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMSZ",
        "The bit 14 (Scratch Memory Size) determines if scratch memory must be "
        "available after every channel context.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVT_MIRROR.
static const field_t hw_sdmaarm_evt_mirror[] =
{
    {
        "EVENTS",
        "This register reflects the DMA requests received by the SDMA for event"
        "s 31-0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVT_MIRROR2.
static const field_t hw_sdmaarm_evt_mirror2[] =
{
    {
        "EVENTS",
        "This register reflects the DMA requests received by the SDMA for event"
        "s 47-32.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_XTRIG_CONF1.
static const field_t hw_sdmaarm_xtrig_conf1[] =
{
    {
        "NUM0",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF0",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM1",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF1",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM2",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF2",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM3",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF3",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_XTRIG_CONF2.
static const field_t hw_sdmaarm_xtrig_conf2[] =
{
    {
        "NUM4",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF4",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM5",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF5",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM6",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF6",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM7",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF7",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI0.
static const field_t hw_sdmaarm_sdma_chnpri0[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI1.
static const field_t hw_sdmaarm_sdma_chnpri1[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI2.
static const field_t hw_sdmaarm_sdma_chnpri2[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI3.
static const field_t hw_sdmaarm_sdma_chnpri3[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI4.
static const field_t hw_sdmaarm_sdma_chnpri4[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI5.
static const field_t hw_sdmaarm_sdma_chnpri5[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI6.
static const field_t hw_sdmaarm_sdma_chnpri6[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI7.
static const field_t hw_sdmaarm_sdma_chnpri7[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI8.
static const field_t hw_sdmaarm_sdma_chnpri8[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI9.
static const field_t hw_sdmaarm_sdma_chnpri9[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI10.
static const field_t hw_sdmaarm_sdma_chnpri10[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI11.
static const field_t hw_sdmaarm_sdma_chnpri11[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI12.
static const field_t hw_sdmaarm_sdma_chnpri12[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI13.
static const field_t hw_sdmaarm_sdma_chnpri13[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI14.
static const field_t hw_sdmaarm_sdma_chnpri14[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI15.
static const field_t hw_sdmaarm_sdma_chnpri15[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI16.
static const field_t hw_sdmaarm_sdma_chnpri16[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI17.
static const field_t hw_sdmaarm_sdma_chnpri17[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI18.
static const field_t hw_sdmaarm_sdma_chnpri18[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI19.
static const field_t hw_sdmaarm_sdma_chnpri19[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI20.
static const field_t hw_sdmaarm_sdma_chnpri20[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI21.
static const field_t hw_sdmaarm_sdma_chnpri21[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI22.
static const field_t hw_sdmaarm_sdma_chnpri22[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI23.
static const field_t hw_sdmaarm_sdma_chnpri23[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI24.
static const field_t hw_sdmaarm_sdma_chnpri24[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI25.
static const field_t hw_sdmaarm_sdma_chnpri25[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI26.
static const field_t hw_sdmaarm_sdma_chnpri26[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI27.
static const field_t hw_sdmaarm_sdma_chnpri27[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI28.
static const field_t hw_sdmaarm_sdma_chnpri28[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI29.
static const field_t hw_sdmaarm_sdma_chnpri29[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI30.
static const field_t hw_sdmaarm_sdma_chnpri30[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI31.
static const field_t hw_sdmaarm_sdma_chnpri31[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL0.
static const field_t hw_sdmaarm_chnenbl0[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL1.
static const field_t hw_sdmaarm_chnenbl1[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL2.
static const field_t hw_sdmaarm_chnenbl2[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL3.
static const field_t hw_sdmaarm_chnenbl3[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL4.
static const field_t hw_sdmaarm_chnenbl4[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL5.
static const field_t hw_sdmaarm_chnenbl5[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL6.
static const field_t hw_sdmaarm_chnenbl6[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL7.
static const field_t hw_sdmaarm_chnenbl7[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL8.
static const field_t hw_sdmaarm_chnenbl8[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL9.
static const field_t hw_sdmaarm_chnenbl9[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL10.
static const field_t hw_sdmaarm_chnenbl10[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL11.
static const field_t hw_sdmaarm_chnenbl11[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL12.
static const field_t hw_sdmaarm_chnenbl12[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL13.
static const field_t hw_sdmaarm_chnenbl13[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL14.
static const field_t hw_sdmaarm_chnenbl14[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL15.
static const field_t hw_sdmaarm_chnenbl15[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL16.
static const field_t hw_sdmaarm_chnenbl16[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL17.
static const field_t hw_sdmaarm_chnenbl17[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL18.
static const field_t hw_sdmaarm_chnenbl18[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL19.
static const field_t hw_sdmaarm_chnenbl19[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL20.
static const field_t hw_sdmaarm_chnenbl20[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL21.
static const field_t hw_sdmaarm_chnenbl21[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL22.
static const field_t hw_sdmaarm_chnenbl22[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL23.
static const field_t hw_sdmaarm_chnenbl23[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL24.
static const field_t hw_sdmaarm_chnenbl24[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL25.
static const field_t hw_sdmaarm_chnenbl25[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL26.
static const field_t hw_sdmaarm_chnenbl26[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL27.
static const field_t hw_sdmaarm_chnenbl27[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL28.
static const field_t hw_sdmaarm_chnenbl28[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL29.
static const field_t hw_sdmaarm_chnenbl29[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL30.
static const field_t hw_sdmaarm_chnenbl30[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL31.
static const field_t hw_sdmaarm_chnenbl31[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL32.
static const field_t hw_sdmaarm_chnenbl32[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL33.
static const field_t hw_sdmaarm_chnenbl33[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL34.
static const field_t hw_sdmaarm_chnenbl34[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL35.
static const field_t hw_sdmaarm_chnenbl35[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL36.
static const field_t hw_sdmaarm_chnenbl36[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL37.
static const field_t hw_sdmaarm_chnenbl37[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL38.
static const field_t hw_sdmaarm_chnenbl38[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL39.
static const field_t hw_sdmaarm_chnenbl39[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL40.
static const field_t hw_sdmaarm_chnenbl40[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL41.
static const field_t hw_sdmaarm_chnenbl41[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL42.
static const field_t hw_sdmaarm_chnenbl42[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL43.
static const field_t hw_sdmaarm_chnenbl43[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL44.
static const field_t hw_sdmaarm_chnenbl44[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL45.
static const field_t hw_sdmaarm_chnenbl45[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL46.
static const field_t hw_sdmaarm_chnenbl46[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL47.
static const field_t hw_sdmaarm_chnenbl47[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMAARM module.
static const reg_t hw_sdmaarm[] =
{
    {
        "MC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_mc0ptr
    },
    {
        "INTR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_intr
    },
    {
        "STOP_STAT",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_stop_stat
    },
    {
        "HSTART",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_hstart
    },
    {
        "EVTOVR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evtovr
    },
    {
        "DSPOVR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_dspovr
    },
    {
        "HOSTOVR",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_hostovr
    },
    {
        "EVTPEND",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evtpend
    },
    {
        "RESET",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sdmaarm_reset
    },
    {
        "EVTERR",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evterr
    },
    {
        "INTRMASK",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_intrmask
    },
    {
        "PSW",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sdmaarm_psw
    },
    {
        "EVTERRDBG",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evterrdbg
    },
    {
        "CONFIG",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_sdmaarm_config
    },
    {
        "SDMA_LOCK",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sdmaarm_sdma_lock
    },
    {
        "ONCE_ENB",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_enb
    },
    {
        "ONCE_DATA",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_data
    },
    {
        "ONCE_INSTR",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_instr
    },
    {
        "ONCE_STAT",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_sdmaarm_once_stat
    },
    {
        "ONCE_CMD",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_cmd
    },
    {
        "ILLINSTADDR",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_illinstaddr
    },
    {
        "CHN0ADDR",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sdmaarm_chn0addr
    },
    {
        "EVT_MIRROR",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evt_mirror
    },
    {
        "EVT_MIRROR2",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evt_mirror2
    },
    {
        "XTRIG_CONF1",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmaarm_xtrig_conf1
    },
    {
        "XTRIG_CONF2",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmaarm_xtrig_conf2
    },
    {
        "SDMA_CHNPRI0",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri0
    },
    {
        "SDMA_CHNPRI1",
        "",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri1
    },
    {
        "SDMA_CHNPRI2",
        "",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri2
    },
    {
        "SDMA_CHNPRI3",
        "",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri3
    },
    {
        "SDMA_CHNPRI4",
        "",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri4
    },
    {
        "SDMA_CHNPRI5",
        "",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri5
    },
    {
        "SDMA_CHNPRI6",
        "",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri6
    },
    {
        "SDMA_CHNPRI7",
        "",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri7
    },
    {
        "SDMA_CHNPRI8",
        "",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri8
    },
    {
        "SDMA_CHNPRI9",
        "",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri9
    },
    {
        "SDMA_CHNPRI10",
        "",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri10
    },
    {
        "SDMA_CHNPRI11",
        "",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri11
    },
    {
        "SDMA_CHNPRI12",
        "",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri12
    },
    {
        "SDMA_CHNPRI13",
        "",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri13
    },
    {
        "SDMA_CHNPRI14",
        "",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri14
    },
    {
        "SDMA_CHNPRI15",
        "",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri15
    },
    {
        "SDMA_CHNPRI16",
        "",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri16
    },
    {
        "SDMA_CHNPRI17",
        "",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri17
    },
    {
        "SDMA_CHNPRI18",
        "",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri18
    },
    {
        "SDMA_CHNPRI19",
        "",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri19
    },
    {
        "SDMA_CHNPRI20",
        "",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri20
    },
    {
        "SDMA_CHNPRI21",
        "",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri21
    },
    {
        "SDMA_CHNPRI22",
        "",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri22
    },
    {
        "SDMA_CHNPRI23",
        "",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri23
    },
    {
        "SDMA_CHNPRI24",
        "",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri24
    },
    {
        "SDMA_CHNPRI25",
        "",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri25
    },
    {
        "SDMA_CHNPRI26",
        "",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri26
    },
    {
        "SDMA_CHNPRI27",
        "",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri27
    },
    {
        "SDMA_CHNPRI28",
        "",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri28
    },
    {
        "SDMA_CHNPRI29",
        "",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri29
    },
    {
        "SDMA_CHNPRI30",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri30
    },
    {
        "SDMA_CHNPRI31",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri31
    },
    {
        "CHNENBL0",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl0
    },
    {
        "CHNENBL1",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl1
    },
    {
        "CHNENBL2",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl2
    },
    {
        "CHNENBL3",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl3
    },
    {
        "CHNENBL4",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl4
    },
    {
        "CHNENBL5",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl5
    },
    {
        "CHNENBL6",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl6
    },
    {
        "CHNENBL7",
        "",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl7
    },
    {
        "CHNENBL8",
        "",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl8
    },
    {
        "CHNENBL9",
        "",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl9
    },
    {
        "CHNENBL10",
        "",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl10
    },
    {
        "CHNENBL11",
        "",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl11
    },
    {
        "CHNENBL12",
        "",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl12
    },
    {
        "CHNENBL13",
        "",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl13
    },
    {
        "CHNENBL14",
        "",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl14
    },
    {
        "CHNENBL15",
        "",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl15
    },
    {
        "CHNENBL16",
        "",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl16
    },
    {
        "CHNENBL17",
        "",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl17
    },
    {
        "CHNENBL18",
        "",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl18
    },
    {
        "CHNENBL19",
        "",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl19
    },
    {
        "CHNENBL20",
        "",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl20
    },
    {
        "CHNENBL21",
        "",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl21
    },
    {
        "CHNENBL22",
        "",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl22
    },
    {
        "CHNENBL23",
        "",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl23
    },
    {
        "CHNENBL24",
        "",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl24
    },
    {
        "CHNENBL25",
        "",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl25
    },
    {
        "CHNENBL26",
        "",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl26
    },
    {
        "CHNENBL27",
        "",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl27
    },
    {
        "CHNENBL28",
        "",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl28
    },
    {
        "CHNENBL29",
        "",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl29
    },
    {
        "CHNENBL30",
        "",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl30
    },
    {
        "CHNENBL31",
        "",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl31
    },
    {
        "CHNENBL32",
        "",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl32
    },
    {
        "CHNENBL33",
        "",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl33
    },
    {
        "CHNENBL34",
        "",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl34
    },
    {
        "CHNENBL35",
        "",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl35
    },
    {
        "CHNENBL36",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl36
    },
    {
        "CHNENBL37",
        "",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl37
    },
    {
        "CHNENBL38",
        "",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl38
    },
    {
        "CHNENBL39",
        "",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl39
    },
    {
        "CHNENBL40",
        "",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl40
    },
    {
        "CHNENBL41",
        "",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl41
    },
    {
        "CHNENBL42",
        "",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl42
    },
    {
        "CHNENBL43",
        "",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl43
    },
    {
        "CHNENBL44",
        "",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl44
    },
    {
        "CHNENBL45",
        "",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl45
    },
    {
        "CHNENBL46",
        "",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl46
    },
    {
        "CHNENBL47",
        "",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl47
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMABP
#endif

// Bitfields in register SDMABP_DC0PTR.
static const field_t hw_sdmabp_dc0ptr[] =
{
    {
        "DC0PTR",
        "Channel 0 Pointer contains the 32-bit address, in BP memory, of the ar"
        "ray of channel control blocks starting with the one for channel 0 (the"
        " control channel).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_INTR.
static const field_t hw_sdmabp_intr[] =
{
    {
        "DI",
        "The BP Interrupts register contains the 32 DI[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_STOP_STAT.
static const field_t hw_sdmabp_stop_stat[] =
{
    {
        "DE",
        "This 32-bit register gives access to the BP (DSP) Enable bits, DE.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_DSTART.
static const field_t hw_sdmabp_dstart[] =
{
    {
        "DSTART_DE",
        "The DSTART_DE registers are 32 bits wide with one bit for every channe"
        "l.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_EVTERR.
static const field_t hw_sdmabp_evterr[] =
{
    {
        "CHNERR",
        "This register is used by the SDMA to warn the BP when an incoming DMA "
        "request was detected; it then triggers a channel that is already pendi"
        "ng or being serviced, which may mean there is an overflow of data for "
        "that channel.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_INTRMASK.
static const field_t hw_sdmabp_intrmask[] =
{
    {
        "DIMASK",
        "The Interrupt Mask Register contains 32 interrupt generation mask bits"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_EVTERRDBG.
static const field_t hw_sdmabp_evterrdbg[] =
{
    {
        "CHNERR",
        "This register is the same as EVTERR except reading it does not clear i"
        "ts contents.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMABP module.
static const reg_t hw_sdmabp[] =
{
    {
        "DC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_dc0ptr
    },
    {
        "INTR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_intr
    },
    {
        "STOP_STAT",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_stop_stat
    },
    {
        "DSTART",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_dstart
    },
    {
        "EVTERR",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_evterr
    },
    {
        "INTRMASK",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_intrmask
    },
    {
        "EVTERRDBG",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_evterrdbg
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMACORE
#endif

// Bitfields in register SDMACORE_MC0PTR.
static const field_t hw_sdmacore_mc0ptr[] =
{
    {
        "MC0PTR",
        "Contains the address-in the ARM platform memory space-of the initial S"
        "DMA context and scripts that are loaded by the SDMA boot script runnin"
        "g on channel 0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCPTR.
static const field_t hw_sdmacore_ccptr[] =
{
    {
        "CCPTR",
        "Contains the start address of the context data for the current channel"
        ": Its value is CONTEXT_BASE + 24* CCR or CONTEXT_BASE + 32* CCR where "
        "CONTEXT_BASE = 0x0800.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCR.
static const field_t hw_sdmacore_ccr[] =
{
    {
        "CCR",
        "Contains the number of the current running channel whose context is in"
        "stalled.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_NCR.
static const field_t hw_sdmacore_ncr[] =
{
    {
        "NCR",
        "Contains the number of the pending channel that the scheduler has sele"
        "cted to run next.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EVENTS.
static const field_t hw_sdmacore_events[] =
{
    {
        "EVENTS",
        "Reflects the status of the SDMA's external DMA requests.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCPRI.
static const field_t hw_sdmacore_ccpri[] =
{
    {
        "CCPRI",
        "Contains the 3-bit priority of the channel whose context is installed.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_NCPRI.
static const field_t hw_sdmacore_ncpri[] =
{
    {
        "NCPRI",
        "Contains the 3-bit priority of the channel the scheduler has selected "
        "to run next.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ECOUNT.
static const field_t hw_sdmacore_ecount[] =
{
    {
        "ECOUNT",
        "The event cell counter contains the number of times minus one that an "
        "event detection must occur before generating a debug request.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ECTL.
static const field_t hw_sdmacore_ectl[] =
{
    {
        "ATS",
        "The access type select bits define the memory access type required on "
        "the SDMA memory bus.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AATC",
        "The Address A Trigger Condition (AATC) controls the operations perform"
        "ed by address comparator A.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABTC",
        "The Address B Trigger Condition (ABTC) controls the operations perform"
        "ed by address comparator B.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATC",
        "The address trigger condition bits select how the two address conditio"
        "ns (addressA and addressB) are combined to define the global address m"
        "atching condition.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTC",
        "The data trigger condition bits define when data is considered matchin"
        "g after comparison with the data register of the event detection unit.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECTC",
        "The event cell trigger condition bits select the combination of addres"
        "s and data matching conditions that generate the final address/data co"
        "ndition.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNT",
        "Event Counter Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN",
        "Event Cell Enable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAA.
static const field_t hw_sdmacore_eaa[] =
{
    {
        "EAA",
        "Event Cell Address Register A computes an address A condition.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAB.
static const field_t hw_sdmacore_eab[] =
{
    {
        "EAB",
        "Event Cell Address Register B computes an address B condition.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAM.
static const field_t hw_sdmacore_eam[] =
{
    {
        "EAM",
        "The Event Cell Address Mask contains a user-defined address mask value"
        ".",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ED.
static const field_t hw_sdmacore_ed[] =
{
    {
        "ED",
        "The event cell data register contains a user defined data value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EDM.
static const field_t hw_sdmacore_edm[] =
{
    {
        "EDM",
        "The event cell data mask register contains the user-defined data mask "
        "value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_RTB.
static const field_t hw_sdmacore_rtb[] =
{
    {
        "RTB",
        "The Real Time Buffer register stores and retrieves run time informatio"
        "n without putting the SDMA in debug mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_TB.
static const field_t hw_sdmacore_tb[] =
{
    {
        "CHFADDR",
        "The change of flow address is the address where the change of flow is "
        "taken when executing a change of flow instruction.",
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TADDR",
        "The target address is the address taken after the execution of the cha"
        "nge of flow instruction.",
        14, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TBF",
        "The Trace Buffer Flag is set when the buffer contains the addresses of"
        " a valid change of flow.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_OSTAT.
static const field_t hw_sdmacore_ostat[] =
{
    {
        "ECDR",
        "Event Cell Debug Request.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST",
        "This flag is raised when the OnCE is controlled from the ARM platform "
        "peripheral interface.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWB",
        "This flag is raised when the SDMA has entered debug mode after a softw"
        "are breakpoint.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODR",
        "This flag is raised when the SDMA has entered debug mode after a OnCE "
        "debug request.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EDR",
        "This flag is raised when the SDMA has entered debug mode after an exte"
        "rnal debug request.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCV",
        "After each write access to the real time buffer (RTB), the RCV bit is "
        "set.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "The Processor Status bits reflect the state of the SDMA RISC engine.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_MCHN0ADDR.
static const field_t hw_sdmacore_mchn0addr[] =
{
    {
        "CHN0ADDR",
        "Contains the address of the channel 0 routine programmed by the ARM pl"
        "atform; it is loaded into a general register at the very start of the "
        "boot and the SDMA jumps to the address it contains.",
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SMSZ",
        "The bit 14 (Scratch Memory Size) determines if scratch memory must be "
        "available after every channel context.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ENDIANNESS.
static const field_t hw_sdmacore_endianness[] =
{
    {
        "APEND",
        "APEND indicates the endian mode of the Peripheral and Burst DMA interf"
        "aces.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_SDMA_LOCK.
static const field_t hw_sdmacore_sdma_lock[] =
{
    {
        "LOCK",
        "The LOCK bit reports the value of the LOCK bit in the SDMA_LOCK status"
        " register.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EVENTS2.
static const field_t hw_sdmacore_events2[] =
{
    {
        "EVENTS",
        "Reflects the status of the SDMA's external DMA requests.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMACORE module.
static const reg_t hw_sdmacore[] =
{
    {
        "MC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_mc0ptr
    },
    {
        "CCPTR",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccptr
    },
    {
        "CCR",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccr
    },
    {
        "NCR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ncr
    },
    {
        "EVENTS",
        "This register is very useful in the case of DMA requests that are acti"
        "ve when a peripheral FIFO level is above the programmed watermark.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_events
    },
    {
        "CCPRI",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccpri
    },
    {
        "NCPRI",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ncpri
    },
    {
        "ECOUNT",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_ecount
    },
    {
        "ECTL",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmacore_ectl
    },
    {
        "EAA",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eaa
    },
    {
        "EAB",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eab
    },
    {
        "EAM",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eam
    },
    {
        "ED",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_ed
    },
    {
        "EDM",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_edm
    },
    {
        "RTB",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_rtb
    },
    {
        "TB",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sdmacore_tb
    },
    {
        "OSTAT",
        "",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_sdmacore_ostat
    },
    {
        "MCHN0ADDR",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sdmacore_mchn0addr
    },
    {
        "ENDIANNESS",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_endianness
    },
    {
        "SDMA_LOCK",
        "",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_sdma_lock
    },
    {
        "EVENTS2",
        "",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_events2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SEMA4
#endif

// Bitfields in register SEMA4_Gate00.
static const field_t hw_sema4_gate00[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate01.
static const field_t hw_sema4_gate01[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate02.
static const field_t hw_sema4_gate02[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate03.
static const field_t hw_sema4_gate03[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate04.
static const field_t hw_sema4_gate04[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate05.
static const field_t hw_sema4_gate05[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate06.
static const field_t hw_sema4_gate06[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate07.
static const field_t hw_sema4_gate07[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate08.
static const field_t hw_sema4_gate08[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate09.
static const field_t hw_sema4_gate09[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate10.
static const field_t hw_sema4_gate10[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate11.
static const field_t hw_sema4_gate11[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate12.
static const field_t hw_sema4_gate12[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate13.
static const field_t hw_sema4_gate13[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate14.
static const field_t hw_sema4_gate14[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_Gate15.
static const field_t hw_sema4_gate15[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_CP0INE.
static const field_t hw_sema4_cp0ine[] =
{
    {
        "INE7",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE6",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE5",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE4",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE3",
        "Interrupt Request Notification Enable 3.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE2",
        "Interrupt Request Notification Enable 2.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE1",
        "Interrupt Request Notification Enable 1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE0",
        "Interrupt Request Notification Enable 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE15",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE14",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE13",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE12",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE11",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE10",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE9",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE8",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_CP1INE.
static const field_t hw_sema4_cp1ine[] =
{
    {
        "INE7",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE6",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE5",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE4",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE3",
        "Interrupt Request Notification Enable 3.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE2",
        "Interrupt Request Notification Enable 2.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE1",
        "Interrupt Request Notification Enable 1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE0",
        "Interrupt Request Notification Enable 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE15",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE14",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE13",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE12",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE11",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE10",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE9",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INE8",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_CP0NTF.
static const field_t hw_sema4_cp0ntf[] =
{
    {
        "GN7",
        "Gate 7 Notification.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN6",
        "Gate 6 Notification.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN5",
        "Gate 5 Notification.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN4",
        "Gate 4 Notification.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN3",
        "Gate 3 Notification.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN2",
        "Gate 2 Notification.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN1",
        "Gate 1 Notification.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN0",
        "Gate 0 Notification.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN15",
        "Gate 15 Notification.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN14",
        "Gate 14 Notification.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN13",
        "Gate 13 Notification.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN12",
        "Gate 12 Notification.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN11",
        "Gate 11 Notification.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN10",
        "Gate 10 Notification.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN9",
        "Gate 9 Notification.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN8",
        "Gate 8 Notification.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_CP1NTF.
static const field_t hw_sema4_cp1ntf[] =
{
    {
        "GN7",
        "Gate 7 Notification.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN6",
        "Gate 6 Notification.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN5",
        "Gate 5 Notification.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN4",
        "Gate 4 Notification.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN3",
        "Gate 3 Notification.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN2",
        "Gate 2 Notification.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN1",
        "Gate 1 Notification.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN0",
        "Gate 0 Notification.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN15",
        "Gate 15 Notification.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN14",
        "Gate 14 Notification.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN13",
        "Gate 13 Notification.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN12",
        "Gate 12 Notification.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN11",
        "Gate 11 Notification.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN10",
        "Gate 10 Notification.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN9",
        "Gate 9 Notification.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GN8",
        "Gate 8 Notification.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_RSTGT.
static const field_t hw_sema4_rstgt[] =
{
    {
        "RSTGSM_RSTGMS_RSTGDP",
        "This field contains subfields that vary depending on whether it is bei"
        "ng read or written.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTGTN",
        "Reset Gate Number.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA4_RSTNTF.
static const field_t hw_sema4_rstntf[] =
{
    {
        "RSTNSM_RSTNMS_RSTNDP",
        "This field contains subfields that vary depending on whether it is bei"
        "ng read or written.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTNTN",
        "Reset Notification Number.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SEMA4 module.
static const reg_t hw_sema4[] =
{
    {
        "Gate00",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate00
    },
    {
        "Gate01",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000001, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate01
    },
    {
        "Gate02",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate02
    },
    {
        "Gate03",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000003, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate03
    },
    {
        "Gate04",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate04
    },
    {
        "Gate05",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000005, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate05
    },
    {
        "Gate06",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate06
    },
    {
        "Gate07",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000007, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate07
    },
    {
        "Gate08",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate08
    },
    {
        "Gate09",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000009, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate09
    },
    {
        "Gate10",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate10
    },
    {
        "Gate11",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate11
    },
    {
        "Gate12",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate12
    },
    {
        "Gate13",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate13
    },
    {
        "Gate14",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate14
    },
    {
        "Gate15",
        "Each semaphore gate is implemented in a 2-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema4_gate15
    },
    {
        "CP0INE",
        "The application of a hardware semaphore module provides an opportunity"
        " for implementation of helpful system-level features.",
        2, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_sema4_cp0ine
    },
    {
        "CP1INE",
        "The application of a hardware semaphore module provides an opportunity"
        " for implementation of helpful system-level features.",
        2, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_sema4_cp1ine
    },
    {
        "CP0NTF",
        "The Semaphores module optionally allows the processor that fails in th"
        "e lock attempt to continue with other tasks and allow a properly-enabl"
        "ed notification interrupt to return its execution to the original lock"
        " function rather than simply execute in a spin-wait loop.",
        2, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_sema4_cp0ntf
    },
    {
        "CP1NTF",
        "The Semaphores module optionally allows the processor that fails in th"
        "e lock attempt to continue with other tasks and allow a properly-enabl"
        "ed notification interrupt to return its execution to the original lock"
        " function rather than simply execute in a spin-wait loop.",
        2, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_sema4_cp1ntf
    },
    {
        "RSTGT",
        "Although the intent of the hardware gate implementation specifies a pr"
        "otocol where the locking processor must unlock the gate, it is recogni"
        "zed that system operation may require a reset function to re-initializ"
        "e the state of any gate(s) without requiring a system-level reset.",
        2, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sema4_rstgt
    },
    {
        "RSTNTF",
        "As with the case of the secure reset function and the hardware gates, "
        "it is recognized that system operation may require a reset function to"
        " re-initialize the state of the IRQ notification logic without requiri"
        "ng a system-level reset.",
        2, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sema4_rstntf
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SJC
#endif

// Bitfields in register SJC_GPUSR1.
static const field_t hw_sjc_gpusr1[] =
{
    {
        "A_DBG",
        "ARM core debug status bit Bit 0 is the ARM core DBGACK (debug acknowle"
        "dge) DBGACK can be overwritten in the ARM core DCR to force a particul"
        "ar DBGACK value.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A_WFI",
        "ARM core wait-for interrupt bit Bit 1 is the ARM core standbywfi (stan"
        "d by wait-for interrupt).",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S_STAT",
        "3 LSBits of SDMA core statusH.",
        2, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PLL_LOCK",
        "PLL_LOCK A Combined PLL-Lock flag indicator, for all the PLL's.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPUSR2.
static const field_t hw_sjc_gpusr2[] =
{
    {
        "STBYWFI",
        "STBYWFI[3:0] These bits provide status of \"Standby Wait-For-Interrupt"
        "\" state of all ARM cores.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S_STAT",
        "S_STAT[3:0] SDMA debug status bits: debug_core_state[3:0]",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STBYWFE",
        "STBYWFE[3:0] Reflecting the \"Standby Wait For Event\" signals of all "
        "cores.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPUSR3.
static const field_t hw_sjc_gpusr3[] =
{
    {
        "IPG_WAIT",
        "IPG_WAIT CCM's \"ipg_wait\" signal indication",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPG_STOP",
        "IPG_STOP CCM's \"ipg_stop\" signal indication",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYS_WAIT",
        "System In wait Indication on System in wait mode (from CCM).",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPSSR.
static const field_t hw_sjc_gpssr[] =
{
    {
        "GPSSR",
        "General Purpose Secured Status Register Register is used for testing a"
        "nd debug.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_DCR.
static const field_t hw_sjc_dcr[] =
{
    {
        "DE_TO_ARM",
        "ARM platform debug request input propagation This bit controls the pro"
        "pagation of debug request to ARM platform (\"dbgreq\"), when the JTAG "
        "state machine is put in \"ENTER_DEBUG\" IR instruction.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_TO_SDMA",
        "SDMA debug request input propagation This bit controls the propagation"
        " of debug request to SDMA, when the JTAG state machine is put in \"ENT"
        "ER_DEBUG\" IR instruction.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_OBS",
        "Debug observability This bit controls the propagation of the \"system "
        "debug\" input to SJC For i.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIRECT_SDMA_REQ_EN",
        "Debug enable of the sdma debug request This bit controls the propagati"
        "on of debug request DE_B to the sdma.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIRECT_ARM_REQ_EN",
        "Pass Debug Enable event from DE_B pin to ARM platform debug request si"
        "gnal(s).",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_SSR.
static const field_t hw_sjc_ssr[] =
{
    {
        "KTF",
        "Kill Trace Enable fuse value",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KTA",
        "Kill Trace is active",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWF",
        "Software JTAG enable fuse Status of the no SW disable JTAG fuse",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWE",
        "SW enable SW JTAG enable status",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EBF",
        "External Boot fuse Status of the external boot disable fuse",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EBG",
        "External boot granted External boot enabled, requested and granted",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FT",
        "Fuse type Fuse type bit - e-fuse or laser fuse",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SJM",
        "SJC Secure mode Secure JTAG mode, as set by external fuses.",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSSTAT",
        "Response status Response status bits",
        11, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOTIND",
        "Boot Indication Inverted Internal Boot indication, i.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPCCR.
static const field_t hw_sjc_gpccr[] =
{
    {
        "SCLKR",
        "SDMA Clock ON Register - This bit forces the clock on of the SDMA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLKOFFDIS",
        "Disable/prevent ARM platform clock/power shutdown",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SJC module.
static const reg_t hw_sjc[] =
{
    {
        "GPUSR1",
        "The General Purpose Unsecured Status Register 1 is a read only registe"
        "rs used to check the status of the different Cores and of the PLL.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sjc_gpusr1
    },
    {
        "GPUSR2",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sjc_gpusr2
    },
    {
        "GPUSR3",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sjc_gpusr3
    },
    {
        "GPSSR",
        "The General Purpose Secured Status Register is a read-only register us"
        "ed to check the status of the different critical information in the So"
        "C.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sjc_gpssr
    },
    {
        "DCR",
        "This register is used to control propagation of debug request from DE_"
        "B pad to the cores and debug signals from internal logic to the DE_B p"
        "ad.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_sjc_dcr
    },
    {
        "SSR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_sjc_ssr
    },
    {
        "GPCCR",
        "This register is used to configure clock related modes in SOC, see Sys"
        "tem Configuration chapter for more information.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sjc_gpccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SNVS
#endif

// Bitfields in register SNVS_HPLR.
static const field_t hw_snvs_hplr[] =
{
    {
        "MC_SL",
        "Monotonic Counter Soft Lock When set, prevents any writes (increments)"
        " to the MC Registers and MC_ENV bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_SL",
        "General Purpose Register Soft Lock When set, prevents any writes to th"
        "e GPR.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPCOMR.
static const field_t hw_snvs_hpcomr[] =
{
    {
        "LP_SWR",
        "LP Software Reset When set, it resets the SNVS_LP section.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LP_SWR_DIS",
        "LP Software Reset Disable When set, disables the LP software reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NPSWA_EN",
        "Non-Privileged Software Access Enable When set, allows non-privileged "
        "software to access all SNVS registers, including those that are privil"
        "eged software read/write access only.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPCR.
static const field_t hw_snvs_hpcr[] =
{
    {
        "RTC_EN",
        "HP Real Time Counter Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPTA_EN",
        "HP Time Alarm Enable When set, the time alarm interrupt is generated i"
        "f the value in the HP Time Alarm Registers is equal to the value of th"
        "e HP Real Time Counter.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PI_EN",
        "HP Periodic Interrupt Enable The periodic interrupt can be generated o"
        "nly if the HP Real Time Counter is enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PI_FREQ",
        "Periodic Interrupt Frequency Defines frequency of the periodic interru"
        "pt.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPCALB_EN",
        "HP Real Time Counter Calibration Enabled Indicates that the time calib"
        "ration mechanism is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPCALB_VAL",
        "HP Calibration Value Defines signed calibration value for the HP Real "
        "Time Counter.",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_CONFIG",
        "Button Configuration.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_MASK",
        "Button interrupt mask.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPSR.
static const field_t hw_snvs_hpsr[] =
{
    {
        "BTN",
        "Value of the BTN input.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BI",
        "Button Interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPRTCMR.
static const field_t hw_snvs_hprtcmr[] =
{
    {
        "RTC",
        "HP Real Time Counter Most significant 32 bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPRTCLR.
static const field_t hw_snvs_hprtclr[] =
{
    {
        "RTC",
        "HP Real Time Counter Least significant 32 bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPTAMR.
static const field_t hw_snvs_hptamr[] =
{
    {
        "HPTA",
        "HP Time Alarm Most significant 15 bits.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPTALR.
static const field_t hw_snvs_hptalr[] =
{
    {
        "HPTA",
        "HP Time Alarm Least significant bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPLR.
static const field_t hw_snvs_lplr[] =
{
    {
        "MC_HL",
        "Monotonic Counter Hard Lock When set, prevents any writes (increments)"
        " to the MC Registers and MC_ENV bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_HL",
        "General Purpose Register Hard Lock When set, prevents any writes to th"
        "e GPR.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPCR.
static const field_t hw_snvs_lpcr[] =
{
    {
        "MC_ENV",
        "Monotonic Counter Enable and Valid When set, the MC can be incremented"
        " (by write transaction to the LPSMCMR or LPSMCLR).",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_EN",
        "Dumb PMIC Enabled When set, software can control the system power.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOP",
        "Turn off System Power Asserting this bit causes a signal to be sent to"
        " the Power Management IC to turn off the system power.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_GLITCH_EN",
        "By default the detection of a power glitch does not cause the pmic_en_"
        "b signal to be asserted.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_PRESS_TIME",
        "Button press time out values for PMIC Logic.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBOUNCE",
        "This field configures the amount of debounce time for the BTN input si"
        "gnal.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ON_TIME",
        "The ON_TIME field is used to configure the period of time after BTN is"
        " asserted before pmic_en_b is asserted to turn on the SoCpower.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PK_EN",
        "PMIC On Request Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PK_OVERRIDE",
        "PMIC On Request Override.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSR.
static const field_t hw_snvs_lpsr[] =
{
    {
        "MCR",
        "Monotonic Counter Rollover.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EO",
        "Emergency Off This bit is set when a power off is requested.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPO",
        "Set Power Off The SPO bit is set when the set_pwr_off_irq interrupt is"
        " triggered, which happens when software writes a 1 to the TOP bit in t"
        "he LPCR or when the power button is pressed longer than the configured"
        " debounce time.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSMCMR.
static const field_t hw_snvs_lpsmcmr[] =
{
    {
        "MON_COUNTER",
        "Monotonic Counter Most Significant 16 Bits The MC is incremented by on"
        "e when: A write transaction to the LPSMCMR or LPSMCLR register is dete"
        "cted.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MC_ERA_BITS",
        "Monotonic Counter Era Bits These bits are inputs to the module and typ"
        "ically connect to fuses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSMCLR.
static const field_t hw_snvs_lpsmclr[] =
{
    {
        "MON_COUNTER",
        "Monotonic Counter bits The MC is incremented by one when: A write tran"
        "saction to the LPSMCMR or LPSMCLR Register is detected.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR.
static const field_t hw_snvs_lpgpr[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPVIDR1.
static const field_t hw_snvs_hpvidr1[] =
{
    {
        "MINOR_REV",
        "SNVS block minor version number",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR_REV",
        "SNVS block major version number",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ID",
        "SNVS block ID",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPVIDR2.
static const field_t hw_snvs_hpvidr2[] =
{
    {
        "CONFIG_OPT",
        "SNVS Configuration Option",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ECO_REV",
        "SNVS ECO Revision",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTG_OPT",
        "SNVS Integration Option",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ERA",
        "00h - Era 1 or 2 03h - Era 3 04h - Era 4 05h - Era 5",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SNVS module.
static const reg_t hw_snvs[] =
{
    {
        "HPLR",
        "The SNVS_HP Lock Register contains lock bits for the SNVS registers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_hplr
    },
    {
        "HPCOMR",
        "The SNVS_HP Command Register contains the command, configuration, and "
        "control bits for the SNVS block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_snvs_hpcomr
    },
    {
        "HPCR",
        "The SNVS_HP Control Register contains various control bits of the HP s"
        "ection of SNVS .",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_snvs_hpcr
    },
    {
        "HPSR",
        "The HP Status Register reflects the internal state of the SNVS.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_hpsr
    },
    {
        "HPRTCMR",
        "The SNVS_HP Real Time Counter MSB register contains the most significa"
        "nt bits of the HP Real Time Counter.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hprtcmr
    },
    {
        "HPRTCLR",
        "The SNVS_HP Real Time Counter LSB register contains the 32 least signi"
        "ficant bits of the HP real time counter.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hprtclr
    },
    {
        "HPTAMR",
        "The SNVS_HP Time Alarm MSB register contains the most significant bits"
        " of the SNVS_HP Time Alarm value.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hptamr
    },
    {
        "HPTALR",
        "The SNVS_HP Time Alarm LSB register contains the 32 least significant "
        "bits of the SNVS_HP Time Alarm value.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hptalr
    },
    {
        "LPLR",
        "The SNVS_LP Lock Register contains lock bits for the SNVS_LP registers"
        ".",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_lplr
    },
    {
        "LPCR",
        "The SNVS_LP Control Register contains various control bits of the LP s"
        "ection of SNVS.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_snvs_lpcr
    },
    {
        "LPSR",
        "The SNVS_LP Status Register reflects the internal state and behavior o"
        "f the SNVS_LP.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_snvs_lpsr
    },
    {
        "LPSMCMR",
        "The SNVS_LP Secure Monotonic Counter MSB Register contains the monoton"
        "ic counter era bits and the most significant 16 bits of the monotonic "
        "counter.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_lpsmcmr
    },
    {
        "LPSMCLR",
        "The SNVS_LP Secure Monotonic Counter LSB Register contains the 32 leas"
        "t significant bits of the monotonic counter.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpsmclr
    },
    {
        "LPGPR",
        "The SNVS_LP General Purpose Register is a read/write register located "
        "in the low power domain, which can be used by any application for reta"
        "ining data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr
    },
    {
        "HPVIDR1",
        "The SNVS_HP Version ID Register 1 is a read-only register that contain"
        "s the current version of the SNVS .",
        4, // Width in bytes
        0x00000bf8, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_snvs_hpvidr1
    },
    {
        "HPVIDR2",
        "The SNVS_HP Version ID Register 2 is a read-only register that indicat"
        "es the current version of the SNVS.",
        4, // Width in bytes
        0x00000bfc, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_snvs_hpvidr2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPBA
#endif

// Bitfields in register SPBA_PRR0.
static const field_t hw_spba_prr0[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR1.
static const field_t hw_spba_prr1[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR2.
static const field_t hw_spba_prr2[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR3.
static const field_t hw_spba_prr3[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR4.
static const field_t hw_spba_prr4[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR5.
static const field_t hw_spba_prr5[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR6.
static const field_t hw_spba_prr6[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR7.
static const field_t hw_spba_prr7[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR8.
static const field_t hw_spba_prr8[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR9.
static const field_t hw_spba_prr9[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR10.
static const field_t hw_spba_prr10[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR11.
static const field_t hw_spba_prr11[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR12.
static const field_t hw_spba_prr12[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR13.
static const field_t hw_spba_prr13[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR14.
static const field_t hw_spba_prr14[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR15.
static const field_t hw_spba_prr15[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR16.
static const field_t hw_spba_prr16[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR17.
static const field_t hw_spba_prr17[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR18.
static const field_t hw_spba_prr18[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR19.
static const field_t hw_spba_prr19[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR20.
static const field_t hw_spba_prr20[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR21.
static const field_t hw_spba_prr21[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR22.
static const field_t hw_spba_prr22[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR23.
static const field_t hw_spba_prr23[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR24.
static const field_t hw_spba_prr24[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR25.
static const field_t hw_spba_prr25[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR26.
static const field_t hw_spba_prr26[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR27.
static const field_t hw_spba_prr27[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR28.
static const field_t hw_spba_prr28[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR29.
static const field_t hw_spba_prr29[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR30.
static const field_t hw_spba_prr30[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR31.
static const field_t hw_spba_prr31[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPBA module.
static const reg_t hw_spba[] =
{
    {
        "PRR0",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr0
    },
    {
        "PRR1",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr1
    },
    {
        "PRR2",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr2
    },
    {
        "PRR3",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr3
    },
    {
        "PRR4",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr4
    },
    {
        "PRR5",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr5
    },
    {
        "PRR6",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr6
    },
    {
        "PRR7",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr7
    },
    {
        "PRR8",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr8
    },
    {
        "PRR9",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr9
    },
    {
        "PRR10",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr10
    },
    {
        "PRR11",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr11
    },
    {
        "PRR12",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr12
    },
    {
        "PRR13",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr13
    },
    {
        "PRR14",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr14
    },
    {
        "PRR15",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr15
    },
    {
        "PRR16",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr16
    },
    {
        "PRR17",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr17
    },
    {
        "PRR18",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr18
    },
    {
        "PRR19",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr19
    },
    {
        "PRR20",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr20
    },
    {
        "PRR21",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr21
    },
    {
        "PRR22",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr22
    },
    {
        "PRR23",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr23
    },
    {
        "PRR24",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr24
    },
    {
        "PRR25",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr25
    },
    {
        "PRR26",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr26
    },
    {
        "PRR27",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr27
    },
    {
        "PRR28",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr28
    },
    {
        "PRR29",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr29
    },
    {
        "PRR30",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr30
    },
    {
        "PRR31",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr31
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPDIF
#endif

// Bitfields in register SPDIF_SCR.
static const field_t hw_spdif_scr[] =
{
    {
        "USRC_SEL",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSEL",
        "",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALCTRL",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TX_EN",
        "DMA Transmit Request Enable (Tx FIFO empty)",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_RX_EN",
        "DMA Receive Request Enable (RX FIFO full)",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFO_CTRL",
        "",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOFT_RESET",
        "When write 1 to this bit, it will cause SPDIF software reset.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOW_POWER",
        "When write 1 to this bit, it will cause SPDIF enter low-power mode.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOEMPTY_SEL",
        "",
        15, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXAUTOSYNC",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXAUTOSYNC",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFOFULL_SEL",
        "",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_RST",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_OFF_ON",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_CTRL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCD.
static const field_t hw_spdif_srcd[] =
{
    {
        "USYNCMODE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRPC.
static const field_t hw_spdif_srpc[] =
{
    {
        "GAINSEL",
        "Gain selection:",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "LOCK bit to show that the internal DPLL is locked, read only",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKSRC_SEL",
        "Clock source selection, all other settings not shown are reserved:",
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIE.
static const field_t hw_spdif_sie[] =
{
    {
        "RXFIFOFUL",
        "SPDIF Rx FIFO full, can't be cleared with reg.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEM",
        "SPDIF Tx FIFO empty, can't be cleared with reg.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKLOSS",
        "SPDIF receiver loss of lock",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFORESYN",
        "Rx FIFO resync",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFOUNOV",
        "Rx FIFO underrun/overrun",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UQERR",
        "U/Q Channel framing error",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UQSYNC",
        "U/Q Channel sync found",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QRXOV",
        "Q Channel receive register overrun",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QRXFUL",
        "Q Channel receive register full, can't be cleared with reg.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URXOV",
        "U Channel receive register overrun",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URXFUL",
        "U Channel receive register full, can't be cleared with reg.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BITERR",
        "SPDIF receiver found parity bit error",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYMERR",
        "SPDIF receiver found illegal symbol",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALNOGOOD",
        "SPDIF validity flag no good",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNEW",
        "SPDIF receive change in value of control channel",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRESYN",
        "SPDIF Tx FIFO resync",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXUNOV",
        "SPDIF Tx FIFO under/overrun",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "SPDIF receiver's DPLL is locked",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIS.
static const field_t hw_spdif_sis[] =
{
    {
        "RXFIFOFUL",
        "SPDIF Rx FIFO full, can't be cleared with reg.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEM",
        "SPDIF Tx FIFO empty, can't be cleared with reg.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCKLOSS",
        "SPDIF receiver loss of lock",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFORESYN",
        "Rx FIFO resync",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFOUNOV",
        "Rx FIFO underrun/overrun",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UQERR",
        "U/Q Channel framing error",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UQSYNC",
        "U/Q Channel sync found",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QRXOV",
        "Q Channel receive register overrun",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QRXFUL",
        "Q Channel receive register full, can't be cleared with reg.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "URXOV",
        "U Channel receive register overrun",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "URXFUL",
        "U Channel receive register full, can't be cleared with reg.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BITERR",
        "SPDIF receiver found parity bit error",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYMERR",
        "SPDIF receiver found illegal symbol",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALNOGOOD",
        "SPDIF validity flag no good",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNEW",
        "SPDIF receive change in value of control channel",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXRESYN",
        "SPDIF Tx FIFO resync",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXUNOV",
        "SPDIF Tx FIFO under/overrun",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "SPDIF receiver's DPLL is locked",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIC.
static const field_t hw_spdif_sic[] =
{
    {
        "LOCKLOSS",
        "SPDIF receiver loss of lock",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RXFIFORESYN",
        "Rx FIFO resync",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RXFIFOUNOV",
        "Rx FIFO underrun/overrun",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "UQERR",
        "U/Q Channel framing error",
        5, // LSB
        5, // MSB
        false, // Readable
        false // Writable
    },
    {
        "UQSYNC",
        "U/Q Channel sync found",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "QRXOV",
        "Q Channel receive register overrun",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "URXOV",
        "U Channel receive register overrun",
        9, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BITERR",
        "SPDIF receiver found parity bit error",
        14, // LSB
        14, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SYMERR",
        "SPDIF receiver found illegal symbol",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VALNOGOOD",
        "SPDIF validity flag no good",
        16, // LSB
        16, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CNEW",
        "SPDIF receive change in value of control channel",
        17, // LSB
        17, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXRESYN",
        "SPDIF Tx FIFO resync",
        18, // LSB
        18, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXUNOV",
        "SPDIF Tx FIFO under/overrun",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LOCK",
        "SPDIF receiver's DPLL is locked",
        20, // LSB
        20, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRL.
static const field_t hw_spdif_srl[] =
{
    {
        "RXDATALEFT",
        "Processor receive SPDIF data left",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRR.
static const field_t hw_spdif_srr[] =
{
    {
        "RXDATARIGHT",
        "Processor receive SPDIF data right",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCSH.
static const field_t hw_spdif_srcsh[] =
{
    {
        "RXCCHANNEL_H",
        "SPDIF receive C channel register, contains first 24 bits of C channel "
        "without interpretation",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCSL.
static const field_t hw_spdif_srcsl[] =
{
    {
        "RXCCHANNEL_L",
        "SPDIF receive C channel register, contains next 24 bits of C channel w"
        "ithout interpretation",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRU.
static const field_t hw_spdif_sru[] =
{
    {
        "RXUCHANNEL",
        "SPDIF receive U channel register, contains next 3 U channel bytes",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRQ.
static const field_t hw_spdif_srq[] =
{
    {
        "RXQCHANNEL",
        "SPDIF receive Q channel register, contains next 3 Q channel bytes",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STL.
static const field_t hw_spdif_stl[] =
{
    {
        "TXDATALEFT",
        "SPDIF transmit left channel data.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STR.
static const field_t hw_spdif_str[] =
{
    {
        "TXDATARIGHT",
        "SPDIF transmit right channel data.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STCSCH.
static const field_t hw_spdif_stcsch[] =
{
    {
        "TXCCHANNELCONS_H",
        "SPDIF transmit Cons.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STCSCL.
static const field_t hw_spdif_stcscl[] =
{
    {
        "TXCCHANNELCONS_L",
        "SPDIF transmit Cons.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRFM.
static const field_t hw_spdif_srfm[] =
{
    {
        "FREQMEAS",
        "Frequency measurement data",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STC.
static const field_t hw_spdif_stc[] =
{
    {
        "TXCLK_DF",
        "Divider factor (1-128)",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_ALL_CLK_EN",
        "Spdif transfer clock enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCLK_SOURCE",
        "",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYSCLK_DF",
        "system clock divider factor, 2~512.",
        11, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPDIF module.
static const reg_t hw_spdif[] =
{
    {
        "SCR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_spdif_scr
    },
    {
        "SRCD",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdif_srcd
    },
    {
        "SRPC",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_spdif_srpc
    },
    {
        "SIE",
        "The InterruptEn register (SPDIF_SIE) provides control over the enablin"
        "g of interrupts.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_spdif_sie
    },
    {
        "SIS",
        "The InterruptStat (SPDIF_SIS) register is a read only register that pr"
        "ovides the status on interrupt operations.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        18, // Number of bitfields
        hw_spdif_sis
    },
    {
        "SIC",
        "The InterruptClear (SPDIF_SIC) register is a write only register and i"
        "s used to clear interrupts.",
        4, // Width in bytes
        0x00000010, // Base address offset
        false, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_spdif_sic
    },
    {
        "SRL",
        "SPDIFRxLeft register is an audio data reception register.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srl
    },
    {
        "SRR",
        "SPDIFRxRight register is an audio data reception register.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srr
    },
    {
        "SRCSH",
        "SPDIFRxCChannel_h register is a channel status reception register.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srcsh
    },
    {
        "SRCSL",
        "SPDIFRxCChannel_l register is a channel status reception register.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srcsl
    },
    {
        "SRU",
        "UChannelRx register is a user bits reception register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_sru
    },
    {
        "SRQ",
        "QChannelRx register is a user bits reception register.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srq
    },
    {
        "STL",
        "SPDIFTxLeft register is an audio data transmission register.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_stl
    },
    {
        "STR",
        "SPDIFTxRight register is an audio data transmission register.",
        4, // Width in bytes
        0x00000030, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_str
    },
    {
        "STCSCH",
        "SPDIFTxCChannelCons_h register is a channel status transmission regist"
        "er.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdif_stcsch
    },
    {
        "STCSCL",
        "SPDIFTxCChannelCons_l register is a channel status transmission regist"
        "er.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdif_stcscl
    },
    {
        "SRFM",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srfm
    },
    {
        "STC",
        "The SPDIFTxClk Control register includes the means to select the trans"
        "mit clock and frequency division.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_spdif_stc
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SRC
#endif

// Bitfields in register SRC_SCR.
static const field_t hw_src_scr[] =
{
    {
        "WARM_RESET_ENABLE",
        "WARM reset enable bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_GPU_RST",
        "Software reset for GPU This is a self clearing bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4C_RST",
        "Self-clearing SW reset for M4 core This bit is a self-clearing reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4C_NON_SCLR_RST",
        "Non-self-clearing SW reset for M4 core",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM_RST_BYPASS_COUNT",
        "Defines the XTALI cycles to count before bypassing the MMDC acknowledg"
        "e for WARM reset.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_WDOG_RST",
        "Mask wdog_rst_b source.",
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EIM_RST",
        "EIM reset is needed in order to reconfigure the eim chip select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4P_RST",
        "Self-clearing SW reset for M4 platform This bit is a self-clearing res"
        "et.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_RST",
        "Software reset for core0 only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_DBG_RST",
        "Software reset for core0 debug only.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_TEMPSENSE_RESET",
        "Mask tempsense_reset source.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORES_DBG_RST",
        "Software reset for debug of arm platform only.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_ENABLE",
        "Enable M4 core",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG3_RST_OPTN_M4",
        "wdog3_rst_b option for M4.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG3_RST_OPTN",
        "Wdog3_rst_b option",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST_MSK_PG",
        "Do not assert debug resets after power gating event of core",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIX_RST_STRCH",
        "SoC mix (Audio, ENET, uSDHC, EIM, QSPI, OCRAM, MMDC, etc) power up res"
        "et stretch mix reset width = (mix_rst_strtch +1)* 88 ipg_clk cycles",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_WDOG3_RST",
        "Mask wdog3_rst_b source.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SBMR1.
static const field_t hw_src_sbmr1[] =
{
    {
        "BOOT_CFG1",
        "Refer to fusemap.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG2",
        "Refer to fusemap.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG3",
        "Refer to fusemap.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG4",
        "Refer to fusemap.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SRSR.
static const field_t hw_src_srsr[] =
{
    {
        "IPP_RESET_B",
        "Indicates whether reset was the result of ipp_reset_b pin (Power-up se"
        "quence)",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSU_RESET_B",
        "Indicates whether the reset was the result of the csu_reset_b input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_USER_RESET_B",
        "Indicates whether the reset was the result of the ipp_user_reset_b qua"
        "lified reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_RST_B",
        "IC Watchdog Time-out reset.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_RST_B",
        "HIGH - Z JTAG reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_SW_RST",
        "JTAG software reset.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG3_RST_B",
        "IC Watchdog3 Time-out reset.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEMPSENSE_RST_B",
        "Temper Sensor software reset.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM_BOOT",
        "WARM boot indication shows that WARM boot was initiated by software.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SISR.
static const field_t hw_src_sisr[] =
{
    {
        "GPU_PASSED_RESET",
        "Interrupt generated to indicate that GPU passed software reset and is "
        "ready to be used",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4C_PASSED_RESET",
        "Interrupt generated to indicate that M4 core passed software reset and"
        " is ready to be used",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OPEN_VG_PASSED_RESET",
        "Interrupt generated to indicate that open_vg passed software reset and"
        " is ready to be used",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4P_PASSED_RESET",
        "Interrupt generated to indicate that M4 platform passed software reset"
        " and is ready to be used",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE0_WDOG_RST_REQ",
        "WDOG reset request from core0.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SIMR.
static const field_t hw_src_simr[] =
{
    {
        "MASK_GPU_PASSED_RESET",
        "mask interrupt generation due to GPU passed reset",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_OPEN_VG_PASSED_RESET",
        "mask interrupt generation due to open_vg passed reset",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SBMR2.
static const field_t hw_src_sbmr2[] =
{
    {
        "SEC_CONFIG",
        "SECONFIG[1] shows the state of the SECONFIG[1] fuse.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIR_BT_DIS",
        "DIR_BT_DIS shows the state of the DIR_BT_DIS fuse.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BT_FUSE_SEL",
        "BT_FUSE_SEL (connected to gpio bt_fuse_sel) shows the state of the BT_"
        "FUSE_SEL fuse.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BMOD",
        "BMOD[1:0] shows the latched state of the BOOT_MODE1 and BOOT_MODE0 sig"
        "nals on the rising edge of POR_B.",
        24, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR1.
static const field_t hw_src_gpr1[] =
{
    {
        "PERSISTENT_ENTRY0",
        "Holds entry function for core0 for waking-up from low power mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR2.
static const field_t hw_src_gpr2[] =
{
    {
        "PERSISTENT_ARG0",
        "Holds argument of entry function for core0 for waking-up from low powe"
        "r mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR3.
static const field_t hw_src_gpr3[] =
{
    {
        "PERSISTENT_ENTRY1",
        "Holds entry function for core1.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR4.
static const field_t hw_src_gpr4[] =
{
    {
        "PERSISTENT_ARG1",
        "Holds argument of entry function for core1.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR5.
static const field_t hw_src_gpr5[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR6.
static const field_t hw_src_gpr6[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR7.
static const field_t hw_src_gpr7[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR8.
static const field_t hw_src_gpr8[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR9.
static const field_t hw_src_gpr9[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR10.
static const field_t hw_src_gpr10[] =
{
    { 0 } // Terminator
};

// Registers in a SRC module.
static const reg_t hw_src[] =
{
    {
        "SCR",
        "The Reset control register (SCR), contains bits that control operation"
        " of the reset controller.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_src_scr
    },
    {
        "SBMR1",
        "The Boot Mode register (SBMR) contains bits that reflect the status of"
        " Boot Mode Pins of the chip.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_src_sbmr1
    },
    {
        "SRSR",
        "The SRSR is a write to one clear register which records the source of "
        "the reset events for the chip.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_src_srsr
    },
    {
        "SISR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_src_sisr
    },
    {
        "SIMR",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_src_simr
    },
    {
        "SBMR2",
        "The Boot Mode register (SBMR), contains bits that reflect the status o"
        "f Boot Mode Pins of the chip.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_src_sbmr2
    },
    {
        "GPR1",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_src_gpr1
    },
    {
        "GPR2",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_src_gpr2
    },
    {
        "GPR3",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_src_gpr3
    },
    {
        "GPR4",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_src_gpr4
    },
    {
        "GPR5",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr5
    },
    {
        "GPR6",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr6
    },
    {
        "GPR7",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr7
    },
    {
        "GPR8",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr8
    },
    {
        "GPR9",
        "Reserved for Internal Use.",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_src_gpr9
    },
    {
        "GPR10",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr10
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SSI
#endif

// Bitfields in register SSI_STX0.
static const field_t hw_ssi_stx0[] =
{
    {
        "STXN",
        "SSI Transmit Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_STX1.
static const field_t hw_ssi_stx1[] =
{
    {
        "STXN",
        "SSI Transmit Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SRX0.
static const field_t hw_ssi_srx0[] =
{
    {
        "SRXN",
        "SSI Receive Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SRX1.
static const field_t hw_ssi_srx1[] =
{
    {
        "SRXN",
        "SSI Receive Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SCR.
static const field_t hw_ssi_scr[] =
{
    {
        "SSIEN",
        "SSIEN - SSI Enable This bit is used to enable/disable the SSI.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        "Transmit Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        "Receive Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NET",
        "Network Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYN",
        "Synchronous Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "I2S_MODE",
        "I2S Mode Select.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYS_CLK_EN",
        "Network Clock (Oversampling Clock) Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCH_EN",
        "Two-Channel Operation Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_IST",
        "Clock Idle State.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFR_CLK_DIS",
        "Transmit Frame Clock Disable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFR_CLK_DIS",
        "Receive Frame Clock Disable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_TX_FS",
        "SYNC_FS_TX bit provides a safe window for TE to be visible to the inte"
        "rnal circuit which is just after FS occurrence.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SISR.
static const field_t hw_ssi_sisr[] =
{
    {
        "TFE0",
        "Transmit FIFO Empty 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFE1",
        "Transmit FIFO Empty 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFF0",
        "Receive FIFO Full 0.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFF1",
        "Receive FIFO Full 1.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RLS",
        "Receive Last Time Slot.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TLS",
        "Transmit Last Time Slot.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFS",
        "Receive Frame Sync.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFS",
        "Transmit Frame Sync.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TUE0",
        "Transmitter Underrun Error 0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUE1",
        "Transmitter Underrun Error 1.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROE0",
        "Receiver Overrun Error 0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROE1",
        "Receiver Overrun Error 1.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDE0",
        "Transmit Data Register Empty 0.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDE1",
        "Transmit Data Register Empty 1.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR0",
        "Receive Data Ready 0.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR1",
        "Receive Data Ready 1.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXT",
        "Receive Tag Updated.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDDU",
        "Command Data Register Updated.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDAU",
        "Command Address Register Updated.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFRC",
        "Transmit Frame Complete.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFRC",
        "Receive Frame Complete.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SIER.
static const field_t hw_ssi_sier[] =
{
    {
        "TFE0IE",
        "Transmit FIFO Empty 0 Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFE1IE",
        "Transmit FIFO Empty 1 Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFF0IE",
        "Receive FIFO Full 0 Interrupt Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFF1IE",
        "Receive FIFO Full 1 Interrupt Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RLSIE",
        "Receive Last Time Slot Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TLSIE",
        "Transmit Last Time Slot Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFSIE",
        "Receive Frame Sync Interrupt Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSIE",
        "Transmit Frame Sync Interrupt Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUE0IE",
        "Transmitter Underrun Error 0 Interrupt Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUE1IE",
        "Transmitter Underrun Error 1 Interrupt Enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROE0IE",
        "Receiver Overrun Error 0 Interrupt Enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROE1IE",
        "Receiver Overrun Error 1 Interrupt Enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDE0IE",
        "Transmit Data Register Empty 0 Interrupt Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDE1IE",
        "Transmit Data Register Empty 1 Interrupt Enable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDR0IE",
        "Receive Data Ready 0 Interrupt Enable.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDR1IE",
        "Receive Data Ready 1 Interrupt Enable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXTIE",
        "Receive Tag Updated Interrupt Enable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDDUIE",
        "Command Data Register Updated Interrupt Enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDAUIE",
        "Command Address Register Updated Interrupt Enable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "Transmit Interrupt Enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMAE",
        "Transmit DMA Enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "Receive Interrupt Enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMAE",
        "Receive DMA Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFRCIE",
        "Transmit Frame Complete Interrupt Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFRCIE",
        "Receive Frame Complete Interrupt Enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_STCR.
static const field_t hw_ssi_stcr[] =
{
    {
        "TEFS",
        "Transmit Early Frame Sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSL",
        "Transmit Frame Sync Length.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSI",
        "Transmit Frame Sync Invert.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSCKP",
        "Transmit Clock Polarity.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSHFD",
        "Transmit Shift Direction.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDIR",
        "Transmit Clock Direction.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFDIR",
        "Transmit Frame Direction.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN0",
        "Transmit FIFO Enable 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN1",
        "Transmit FIFO Enable 1.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXBIT0",
        "Transmit Bit 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SRCR.
static const field_t hw_ssi_srcr[] =
{
    {
        "REFS",
        "Receive Early Frame Sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSL",
        "Receive Frame Sync Length.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSI",
        "Receive Frame Sync Invert.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSCKP",
        "Receive Clock Polarity.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSHFD",
        "Receive Shift Direction.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDIR",
        "Receive Clock Direction.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFDIR",
        "Receive Frame Direction.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN0",
        "Receive FIFO Enable 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN1",
        "Receive FIFO Enable 1.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXBIT0",
        "Receive Bit 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEXT",
        "Receive Data Extension.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_STCCR.
static const field_t hw_ssi_stccr[] =
{
    {
        "PM7_PM0",
        "Prescaler Modulus Select.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC4_DC0",
        "Frame Rate Divider Control.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL3_WL0",
        "Word Length Control.",
        13, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSR",
        "Prescaler Range.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV2",
        "Divide By 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SRCCR.
static const field_t hw_ssi_srccr[] =
{
    {
        "PM7_PM0",
        "Prescaler Modulus Select.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC4_DC0",
        "Frame Rate Divider Control.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL3_WL0",
        "Word Length Control.",
        13, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSR",
        "Prescaler Range.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV2",
        "Divide By 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SFCSR.
static const field_t hw_ssi_sfcsr[] =
{
    {
        "TFWM0",
        "Transmit FIFO Empty WaterMark 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFWM0",
        "Receive FIFO Full WaterMark 0.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFCNT0",
        "Transmit FIFO Counter 0.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFCNT0",
        "Receive FIFO Counter 0.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFWM1",
        "Transmit FIFO Empty WaterMark 1.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFWM1",
        "Receive FIFO Full WaterMark 1.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFCNT1",
        "Transmit FIFO Counter1.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFCNT1",
        "Receive FIFO Counter1.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SACNT.
static const field_t hw_ssi_sacnt[] =
{
    {
        "AC97EN",
        "AC97 Mode Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FV",
        "Fixed/Variable Operation.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIF",
        "Tag in FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD",
        "Read Command.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR",
        "Write Command.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRDIV",
        "Frame Rate Divider.",
        5, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SACADD.
static const field_t hw_ssi_sacadd[] =
{
    {
        "SACADD",
        "AC97 Command Address.",
        0, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SACDAT.
static const field_t hw_ssi_sacdat[] =
{
    {
        "SACDAT",
        "AC97 Command Data.",
        0, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SATAG.
static const field_t hw_ssi_satag[] =
{
    {
        "SATAG",
        "AC97 Tag Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_STMSK.
static const field_t hw_ssi_stmsk[] =
{
    {
        "STMSK",
        "Transmit Mask.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SRMSK.
static const field_t hw_ssi_srmsk[] =
{
    {
        "SRMSK",
        "Receive Mask.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SACCST.
static const field_t hw_ssi_saccst[] =
{
    {
        "SACCST",
        "AC97 Channel Status.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SACCEN.
static const field_t hw_ssi_saccen[] =
{
    {
        "SACCEN",
        "AC97 Channel Enable.",
        0, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SACCDIS.
static const field_t hw_ssi_saccdis[] =
{
    {
        "SACCDIS",
        "AC97 Channel Disable.",
        0, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SSI module.
static const reg_t hw_ssi[] =
{
    {
        "STX0",
        "Enable SSI (SSIEN=1) before writing to SSI Transmit Data Registers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_stx0
    },
    {
        "STX1",
        "Enable SSI (SSIEN=1) before writing to SSI Transmit Data Registers.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_stx1
    },
    {
        "SRX0",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_srx0
    },
    {
        "SRX1",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_srx1
    },
    {
        "SCR",
        "The SSI Control Register (SSI_SCR) sets up the SSI reset is controlled"
        " by bit 0 in the SSI_SCR.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ssi_scr
    },
    {
        "SISR",
        "The SSI Interrupt Status Register (SSI_SISR) is used to monitor the SS"
        "I.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_ssi_sisr
    },
    {
        "SIER",
        "The SSI Interrupt Enable Register (SIER) is a 25-bit register used to "
        "set up the SSI interrupts and DMA requests.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_ssi_sier
    },
    {
        "STCR",
        "The SSI Transmit Configuration Register (SSI_STCR) is a read/write con"
        "trol register used to direct the transmit operation of the STCR contro"
        "ls the direction of the bit clock and frame sync ports, STCK and STFS.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ssi_stcr
    },
    {
        "SRCR",
        "The SSI Receive Configuration Register (SSI_SRCR) is a read/write cont"
        "rol register used to direct the receive operation of the SSI.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ssi_srcr
    },
    {
        "STCCR",
        "The SSI Transmit and Receive Control (SSI_STCCR and SSI_SRCCR) registe"
        "rs are 19-bit, read/write control registers used to direct the operati"
        "on of the SSI.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ssi_stccr
    },
    {
        "SRCCR",
        "The SSI Transmit and Receive Control (SSI_STCCR and SSI_SRCCR) registe"
        "rs are 19-bit, read/write control registers used to direct the operati"
        "on of the SSI.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ssi_srccr
    },
    {
        "SFCSR",
        "The SSI FIFO Control / Status Register indicates the status of the Tra"
        "nsmit FIFO Empty flag, with different settings of the Transmit FIFO Wa"
        "terMark bits and varying amounts of data in the Tx FIFO .",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ssi_sfcsr
    },
    {
        "SACNT",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ssi_sacnt
    },
    {
        "SACADD",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_sacadd
    },
    {
        "SACDAT",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_sacdat
    },
    {
        "SATAG",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_satag
    },
    {
        "STMSK",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_stmsk
    },
    {
        "SRMSK",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_srmsk
    },
    {
        "SACCST",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_saccst
    },
    {
        "SACCEN",
        "",
        4, // Width in bytes
        0x00000054, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_saccen
    },
    {
        "SACCDIS",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_saccdis
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TEMPMON
#endif

// Bitfields in register TEMPMON_TEMPSENSE0.
static const field_t hw_tempmon_tempsense0[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE0_SET.
static const field_t hw_tempmon_tempsense0_set[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE0_CLR.
static const field_t hw_tempmon_tempsense0_clr[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE0_TOG.
static const field_t hw_tempmon_tempsense0_tog[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1.
static const field_t hw_tempmon_tempsense1[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1_SET.
static const field_t hw_tempmon_tempsense1_set[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1_CLR.
static const field_t hw_tempmon_tempsense1_clr[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1_TOG.
static const field_t hw_tempmon_tempsense1_tog[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE2.
static const field_t hw_tempmon_tempsense2[] =
{
    {
        "LOW_ALARM_VALUE",
        "This bit field contains the temperature that will generate a low alarm"
        " interrupt when the field is greater than the temperature measurement.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANIC_ALARM_VALUE",
        "This bit field contains the temperature that will generate a panic int"
        "errupt when exceeded by the temperature measurement.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE2_SET.
static const field_t hw_tempmon_tempsense2_set[] =
{
    {
        "LOW_ALARM_VALUE",
        "This bit field contains the temperature that will generate a low alarm"
        " interrupt when the field is greater than the temperature measurement.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANIC_ALARM_VALUE",
        "This bit field contains the temperature that will generate a panic int"
        "errupt when exceeded by the temperature measurement.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE2_CLR.
static const field_t hw_tempmon_tempsense2_clr[] =
{
    {
        "LOW_ALARM_VALUE",
        "This bit field contains the temperature that will generate a low alarm"
        " interrupt when the field is greater than the temperature measurement.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANIC_ALARM_VALUE",
        "This bit field contains the temperature that will generate a panic int"
        "errupt when exceeded by the temperature measurement.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE2_TOG.
static const field_t hw_tempmon_tempsense2_tog[] =
{
    {
        "LOW_ALARM_VALUE",
        "This bit field contains the temperature that will generate a low alarm"
        " interrupt when the field is greater than the temperature measurement.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANIC_ALARM_VALUE",
        "This bit field contains the temperature that will generate a panic int"
        "errupt when exceeded by the temperature measurement.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a TEMPMON module.
static const reg_t hw_tempmon[] =
{
    {
        "TEMPSENSE0",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0
    },
    {
        "TEMPSENSE0_SET",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0_set
    },
    {
        "TEMPSENSE0_CLR",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0_clr
    },
    {
        "TEMPSENSE0_TOG",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0_tog
    },
    {
        "TEMPSENSE1",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1
    },
    {
        "TEMPSENSE1_SET",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1_set
    },
    {
        "TEMPSENSE1_CLR",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1_clr
    },
    {
        "TEMPSENSE1_TOG",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1_tog
    },
    {
        "TEMPSENSE2",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_tempmon_tempsense2
    },
    {
        "TEMPSENSE2_SET",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_tempmon_tempsense2_set
    },
    {
        "TEMPSENSE2_CLR",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_tempmon_tempsense2_clr
    },
    {
        "TEMPSENSE2_TOG",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_tempmon_tempsense2_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark UART
#endif

// Bitfields in register UART_URXD.
static const field_t hw_uart_urxd[] =
{
    {
        "RX_DATA",
        "Received Data.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRERR",
        "In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bi"
        "t RS-485 data In RS232/IrDA mode, it is the Parity Error flag.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BRK",
        "BREAK Detect.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRMERR",
        "Frame Error.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OVRRUN",
        "Receiver Overrun.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR",
        "Error Detect.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHARRDY",
        "Character Ready.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTXD.
static const field_t hw_uart_utxd[] =
{
    {
        "TX_DATA",
        "Transmit Data.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR1.
static const field_t hw_uart_ucr1[] =
{
    {
        "UARTEN",
        "UART Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZE",
        "DOZE.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDMAEN",
        "Aging DMA Timer Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDMAEN",
        "Transmitter Ready DMA Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNDBRK",
        "Send BREAK.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSDEN",
        "RTS Delta Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXMPTYEN",
        "Transmitter Empty Interrupt Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREN",
        "Infrared Interface Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDMAEN",
        "Receive Ready DMA Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRDYEN",
        "Receiver Ready Interrupt Enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICD",
        "Idle Condition Detect.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDEN",
        "Idle Condition Detected Interrupt Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRDYEN",
        "Transmitter Ready Interrupt Enable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADBR",
        "Automatic Detection of Baud Rate.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADEN",
        "Automatic Baud Rate Detection Interrupt Enable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR2.
static const field_t hw_uart_ucr2[] =
{
    {
        "SRST",
        "Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEN",
        "Receiver Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEN",
        "Transmitter Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATEN",
        "Aging Timer Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSEN",
        "Request to Send Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Word Size.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STPB",
        "Stop.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROE",
        "Parity Odd/Even.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREN",
        "Parity Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEC",
        "Request to Send Edge Control.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCEN",
        "Escape Enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTS",
        "Clear to Send.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTSC",
        "CTS Pin Control.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRTS",
        "Ignore RTS Pin.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCI",
        "Escape Sequence Interrupt Enable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR3.
static const field_t hw_uart_ucr3[] =
{
    {
        "ACIEN",
        "Autobaud Counter Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVT",
        "Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA "
        "mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDMUXSEL",
        "RXD Muxed Input Selected.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTRDEN",
        "Data Terminal Ready Delta Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWAKEN",
        "Asynchronous WAKE Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIRINTEN",
        "Asynchronous IR WAKE Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEN",
        "Receive Status Interrupt Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADNIMP",
        "Autobaud Detection Not Improved-.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RI",
        "Ring Indicator.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCD",
        "Data Carrier Detect.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSR",
        "Data Set Ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAERREN",
        "Frame Error Interrupt Enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARERREN",
        "Parity Error Interrupt Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTREN",
        "Data Terminal Ready Interrupt Enable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPEC",
        "DTR/DSR Interrupt Edge Control.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR4.
static const field_t hw_uart_ucr4[] =
{
    {
        "DREN",
        "Receive Data Ready Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OREN",
        "Receiver Overrun Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BKEN",
        "BREAK Condition Detected Interrupt Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCEN",
        "Transmit Complete Interrupt Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBYP",
        "Low Power Bypass.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRSC",
        "IR Special Case.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDDMAEN",
        "DMA IDLE Condition Detected Interrupt Enable Enables/Disables the rece"
        "ive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE"
        " flag in USR2[12]).",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKEN",
        "WAKE Interrupt Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRI",
        "Serial Infrared Interrupt Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVR",
        "Invert RXD input in RS-232/RS-485 Mode, determine RXD input logic leve"
        "l being sampled in In IrDA mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTSTL",
        "CTS Trigger Level.",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UFCR.
static const field_t hw_uart_ufcr[] =
{
    {
        "RXTL",
        "Receiver Trigger Level.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEDTE",
        "DCE/DTE mode select.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFDIV",
        "Reference Frequency Divider.",
        7, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXTL",
        "Transmitter Trigger Level.",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_USR1.
static const field_t hw_uart_usr1[] =
{
    {
        "SAD",
        "RS-485 Slave Address Detected Interrupt Flag.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWAKE",
        "Asynchronous WAKE Interrupt Flag.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIRINT",
        "Asynchronous IR WAKE Interrupt Flag.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDS",
        "Receiver IDLE Interrupt Flag.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DTRD",
        "DTR Delta.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AGTIM",
        "Ageing Timer Interrupt Flag.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRDY",
        "Receiver Ready Interrupt / DMA Flag.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRAMERR",
        "Frame Error Interrupt Flag.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCF",
        "Escape Sequence Interrupt Flag.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSD",
        "RTS Delta.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRDY",
        "Transmitter Ready Interrupt / DMA Flag.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTSS",
        "RTS_B Pin Status.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PARITYERR",
        "Parity Error Interrupt Flag.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_USR2.
static const field_t hw_uart_usr2[] =
{
    {
        "RDR",
        "Receive Data Ready-Indicates that at least 1 character is received and"
        " written to the RxFIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ORE",
        "Overrun Error.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRCD",
        "BREAK Condition Detected.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDC",
        "Transmitter Complete.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTSF",
        "RTS Edge Triggered Interrupt Flag.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCDIN",
        "Data Carrier Detect Input.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DCDDELT",
        "Data Carrier Detect Delta.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKE",
        "Wake.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRINT",
        "Serial Infrared Interrupt Flag.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIIN",
        "Ring Indicator Input.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIDELT",
        "Ring Indicator Delta.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACST",
        "Autobaud Counter Stopped.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE",
        "Idle Condition.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTRF",
        "DTR edge triggered interrupt flag.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFE",
        "Transmit Buffer FIFO Empty.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADET",
        "Automatic Baud Rate Detect Complete.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UESC.
static const field_t hw_uart_uesc[] =
{
    {
        "ESC_CHAR",
        "UART Escape Character.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTIM.
static const field_t hw_uart_utim[] =
{
    {
        "TIM",
        "UART Escape Timer.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBIR.
static const field_t hw_uart_ubir[] =
{
    {
        "INC",
        "Incremental Numerator.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBMR.
static const field_t hw_uart_ubmr[] =
{
    {
        "MOD",
        "Modulator Denominator.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBRC.
static const field_t hw_uart_ubrc[] =
{
    {
        "BCNT",
        "Baud Rate Count Register.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_ONEMS.
static const field_t hw_uart_onems[] =
{
    {
        "ONEMS",
        "One Millisecond Register.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTS.
static const field_t hw_uart_uts[] =
{
    {
        "SOFTRST",
        "Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFULL",
        "RxFIFO FULL.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFULL",
        "TxFIFO FULL.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEMPTY",
        "RxFIFO Empty.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEMPTY",
        "TxFIFO Empty.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBG",
        "RX_fifo_debug_mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOPIR",
        "Loop TX and RX for IR Test (LOOPIR).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "debug_enable_B.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Loop TX and RX for Test.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRCPERR",
        "Force Parity Error.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UMCR.
static const field_t hw_uart_umcr[] =
{
    {
        "MDEN",
        "9-bit data or Multidrop Mode (RS-485) Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLAM",
        "RS-485 Slave Address Detect Mode Selection.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB8",
        "Transmit RS-485 bit 8 (the ninth bit or 9th bit).",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SADEN",
        "RS-485 Slave Address Detected Interrupt Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLADDR",
        "RS-485 Slave Address Character.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a UART module.
static const reg_t hw_uart[] =
{
    {
        "URXD",
        "The UART will yield a transfer error on the peripheral bus when core i"
        "s reading URXD register with receive interface disabled (RXEN=0 or UAR"
        "TEN=0).",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_uart_urxd
    },
    {
        "UTXD",
        "The UART will yield a transfer error on the peripheral bus when core i"
        "s writing into UART_URXD register with transmit interface disabled (TX"
        "EN=0 or UARTEN=0).",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_uart_utxd
    },
    {
        "UCR1",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr1
    },
    {
        "UCR2",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr2
    },
    {
        "UCR3",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr3
    },
    {
        "UCR4",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_uart_ucr4
    },
    {
        "UFCR",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_uart_ufcr
    },
    {
        "USR1",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_uart_usr1
    },
    {
        "USR2",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_uart_usr2
    },
    {
        "UESC",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_uesc
    },
    {
        "UTIM",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_utim
    },
    {
        "UBIR",
        "This register can be written by both software and hardware.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_ubir
    },
    {
        "UBMR",
        "This register can be written by both software and hardware.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_ubmr
    },
    {
        "UBRC",
        "",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_uart_ubrc
    },
    {
        "ONEMS",
        "This register has been expanded from 16 bits to 24 bits.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_onems
    },
    {
        "UTS",
        "",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_uart_uts
    },
    {
        "UMCR",
        "",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_uart_umcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBC
#endif

// Bitfields in register USBC_UOG1_ID.
static const field_t hw_usbc_uog1_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWGENERAL.
static const field_t hw_usbc_uog1_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type PHYM bit reset value: '0000b' for OTG controller core"
        ", '0100b' for Host-only controller core.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability SM bit reset value is '00b'",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWHOST.
static const field_t hw_usbc_uog1_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWDEVICE.
static const field_t hw_usbc_uog1_hwdevice[] =
{
    {
        "DC",
        "Device Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVEP",
        "Device Endpoint Number",
        1, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWTXBUF.
static const field_t hw_usbc_uog1_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWRXBUF.
static const field_t hw_usbc_uog1_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_GPTIMER0LD.
static const field_t hw_usbc_uog1_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_GPTIMER0CTRL.
static const field_t hw_usbc_uog1_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software; In repeat mode, the timer will count down to zero, generat"
        "e an interrupt and automatically reload the counter value from GPTLD b"
        "its to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_GPTIMER1LD.
static const field_t hw_usbc_uog1_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_GPTIMER1CTRL.
static const field_t hw_usbc_uog1_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_SBUSCFG.
static const field_t hw_usbc_uog1_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration These bits control AHB master"
        " transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_CAPLENGTH.
static const field_t hw_usbc_uog1_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HCIVERSION.
static const field_t hw_usbc_uog1_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number Default value is '10h', which"
        " means EHCI rev1.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HCSPARAMS.
static const field_t hw_usbc_uog1_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control This field indicates whether the host controller im"
        "plementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller This field indicates the numb"
        "er of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR) This bit indicates whether the ports sup"
        "port port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HCCPARAMS.
static const field_t hw_usbc_uog1_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability This bit is set '0b' in all controller co"
        "re, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag If this bit is set to zero, then the syst"
        "em software must use a frame list length of 1024 elements with this ho"
        "st controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability If this bit is set to a one, the"
        "n the host controller supports the park feature for high-speed queue h"
        "eads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_DCIVERSION.
static const field_t hw_usbc_uog1_dciversion[] =
{
    {
        "DCIVERSION",
        "Device Controller Interface Version Number Default value is '01h', whi"
        "ch means rev0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_DCCPARAMS.
static const field_t hw_usbc_uog1_dccparams[] =
{
    {
        "DEN",
        "Device Endpoint Number This field indicates the number of endpoints bu"
        "ilt into the device controller.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        "Device Capable When this bit is 1, this controller is capable of opera"
        "ting as a USB 2.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HC",
        "Host Capable When this bit is 1, this controller is capable of operati"
        "ng as an EHCI compatible USB 2.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_USBCMD.
static const field_t hw_usbc_uog1_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_1",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_2",
        "See also bits 3-2 Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_USBSTS.
static const field_t hw_usbc_uog1_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_USBINTR.
static const field_t hw_usbc_uog1_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS r"
        "egister is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable When this bit is one and the UEI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable When this bit is one and the PCI b"
        "it in n_USBSTS register is a one the controller will issue an interrup"
        "t.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable When this bit is one and the FRI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable When this bit is one and the SEI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable When this bit is one and the AAI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable When this bit is one and the URI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable When this bit is one and the SRI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USB"
        "STS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBS"
        "TS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS"
        " register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable When this bit is one, and the U"
        "AI bit in the n_USBSTS register is one, host controller will issue an "
        "interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable When this bit is one, and the UPI b"
        "it in the n_USBSTS register is one, host controller will issue an inte"
        "rrupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable When this bit is one and the"
        " TI0 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable When this bit is one and the"
        " TI1 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_FRINDEX.
static const field_t hw_usbc_uog1_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_PERIODICLISTBASE.
static const field_t hw_usbc_uog1_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_DEVICEADDR.
static const field_t hw_usbc_uog1_deviceaddr[] =
{
    {
        "USBADRA",
        "Device Address Advance.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USBADR",
        "Device Address.",
        25, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ASYNCLISTADDR.
static const field_t hw_usbc_uog1_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTLISTADDR.
static const field_t hw_usbc_uog1_endptlistaddr[] =
{
    {
        "EPBASE",
        "Endpoint List Pointer(Low).",
        11, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_BURSTSIZE.
static const field_t hw_usbc_uog1_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_TXFILLTUNING.
static const field_t hw_usbc_uog1_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTNAK.
static const field_t hw_usbc_uog1_endptnak[] =
{
    {
        "EPRN",
        "RX Endpoint NAK - R/WC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTN",
        "TX Endpoint NAK - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTNAKEN.
static const field_t hw_usbc_uog1_endptnaken[] =
{
    {
        "EPRNE",
        "RX Endpoint NAK Enable - R/W.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTNE",
        "TX Endpoint NAK Enable - R/W.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_CONFIGFLAG.
static const field_t hw_usbc_uog1_configflag[] =
{
    {
        "CF",
        "Configure Flag Host software sets this bit as the last action in its p"
        "rocess of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_PORTSC1.
static const field_t hw_usbc_uog1_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_2",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width This bit has no effect if serial interface "
        "engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select - Read Only Serial Transceiver Select 1 Seri"
        "al Interface Engine is selected 0 Parallel Interface signals is select"
        "ed Serial Interface Engine can be used in combination with UTMI+/ULPI "
        "physical interface to provide FS/LS signaling instead of the parallel "
        "interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_1",
        "Bit field {bit25, bit31, bit30}: \"000b\" UTMI/UTMI+ \"001b\" Reserved"
        " \"010b\" ULPI \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only) \"100b\" H"
        "SIC All USB port interface modes are listed in this field description,"
        " but not all are supported.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_OTGSC.
static const field_t hw_usbc_uog1_otgsc[] =
{
    {
        "VD",
        "VBUS_Discharge - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC",
        "VBUS Charge - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OT",
        "OTG Termination - Read/Write.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP",
        "Data Pulsing - Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDPU",
        "ID Pullup - Read/Write This bit provide control over the ID pull-up re"
        "sister; 0 = off, 1 = on [default].",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID",
        "USB ID - Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVV",
        "A VBus Valid - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASV",
        "A Session Valid - Read Only.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSV",
        "B Session Valid - Read Only.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSE",
        "B Session End - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "1MST",
        "1 millisecond timer toggle - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        "Data Bus Pulsing Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDIS",
        "USB ID Interrupt Status - Read/Write.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIS",
        "A VBus Valid Interrupt Status - Read/Write to Clear.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIS",
        "A Session Valid Interrupt Status - Read/Write to Clear.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIS",
        "B Session Valid Interrupt Status - Read/Write to Clear.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIS",
        "B Session End Interrupt Status - Read/Write to Clear.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "1MSS",
        "1 millisecond timer Interrupt Status - Read/Write to Clear.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIS",
        "Data Pulse Interrupt Status - Read/Write to Clear.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDIE",
        "USB ID Interrupt Enable - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIE",
        "A VBus Valid Interrupt Enable - Read/Write.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIE",
        "A Session Valid Interrupt Enable - Read/Write.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIE",
        "B Session Valid Interrupt Enable - Read/Write.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIE",
        "B Session End Interrupt Enable - Read/Write.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "1MSE",
        "1 millisecond timer Interrupt Enable - Read/Write",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIE",
        "Data Pulse Interrupt Enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_USBMODE.
static const field_t hw_usbc_uog1_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTSETUPSTAT.
static const field_t hw_usbc_uog1_endptsetupstat[] =
{
    {
        "ENDPTSETUPSTAT",
        "Setup Endpoint Status.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTPRIME.
static const field_t hw_usbc_uog1_endptprime[] =
{
    {
        "PERB",
        "Prime Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PETB",
        "Prime Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTFLUSH.
static const field_t hw_usbc_uog1_endptflush[] =
{
    {
        "FERB",
        "Flush Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FETB",
        "Flush Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTSTAT.
static const field_t hw_usbc_uog1_endptstat[] =
{
    {
        "ERBR",
        "Endpoint Receive Buffer Ready -- Read Only.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETBR",
        "Endpoint Transmit Buffer Ready -- Read Only.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCOMPLETE.
static const field_t hw_usbc_uog1_endptcomplete[] =
{
    {
        "ERCE",
        "Endpoint Receive Complete Event - RW/C.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCE",
        "Endpoint Transmit Complete Event - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL0.
static const field_t hw_usbc_uog1_endptctrl0[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Contr"
        "ol End Point.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point St"
        "alled Software can write a one to this bit to force the endpoint to re"
        "turn a STALL handshake to the Host.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Con"
        "trol End Point.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL1.
static const field_t hw_usbc_uog1_endptctrl1[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL2.
static const field_t hw_usbc_uog1_endptctrl2[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL3.
static const field_t hw_usbc_uog1_endptctrl3[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL4.
static const field_t hw_usbc_uog1_endptctrl4[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL5.
static const field_t hw_usbc_uog1_endptctrl5[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL6.
static const field_t hw_usbc_uog1_endptctrl6[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL7.
static const field_t hw_usbc_uog1_endptctrl7[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ID.
static const field_t hw_usbc_uog2_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWGENERAL.
static const field_t hw_usbc_uog2_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type PHYM bit reset value: '0000b' for OTG controller core"
        ", '0100b' for Host-only controller core.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability SM bit reset value is '00b'",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWHOST.
static const field_t hw_usbc_uog2_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWDEVICE.
static const field_t hw_usbc_uog2_hwdevice[] =
{
    {
        "DC",
        "Device Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVEP",
        "Device Endpoint Number",
        1, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWTXBUF.
static const field_t hw_usbc_uog2_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWRXBUF.
static const field_t hw_usbc_uog2_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_GPTIMER0LD.
static const field_t hw_usbc_uog2_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_GPTIMER0CTRL.
static const field_t hw_usbc_uog2_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software; In repeat mode, the timer will count down to zero, generat"
        "e an interrupt and automatically reload the counter value from GPTLD b"
        "its to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_GPTIMER1LD.
static const field_t hw_usbc_uog2_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_GPTIMER1CTRL.
static const field_t hw_usbc_uog2_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_SBUSCFG.
static const field_t hw_usbc_uog2_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration These bits control AHB master"
        " transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_CAPLENGTH.
static const field_t hw_usbc_uog2_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HCIVERSION.
static const field_t hw_usbc_uog2_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number Default value is '10h', which"
        " means EHCI rev1.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HCSPARAMS.
static const field_t hw_usbc_uog2_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control This field indicates whether the host controller im"
        "plementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller This field indicates the numb"
        "er of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR) This bit indicates whether the ports sup"
        "port port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HCCPARAMS.
static const field_t hw_usbc_uog2_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability This bit is set '0b' in all controller co"
        "re, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag If this bit is set to zero, then the syst"
        "em software must use a frame list length of 1024 elements with this ho"
        "st controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability If this bit is set to a one, the"
        "n the host controller supports the park feature for high-speed queue h"
        "eads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_DCIVERSION.
static const field_t hw_usbc_uog2_dciversion[] =
{
    {
        "DCIVERSION",
        "Device Controller Interface Version Number Default value is '01h', whi"
        "ch means rev0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_DCCPARAMS.
static const field_t hw_usbc_uog2_dccparams[] =
{
    {
        "DEN",
        "Device Endpoint Number This field indicates the number of endpoints bu"
        "ilt into the device controller.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        "Device Capable When this bit is 1, this controller is capable of opera"
        "ting as a USB 2.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HC",
        "Host Capable When this bit is 1, this controller is capable of operati"
        "ng as an EHCI compatible USB 2.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_USBCMD.
static const field_t hw_usbc_uog2_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_1",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_2",
        "See also bits 3-2 Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_USBSTS.
static const field_t hw_usbc_uog2_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_USBINTR.
static const field_t hw_usbc_uog2_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS r"
        "egister is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable When this bit is one and the UEI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable When this bit is one and the PCI b"
        "it in n_USBSTS register is a one the controller will issue an interrup"
        "t.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable When this bit is one and the FRI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable When this bit is one and the SEI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable When this bit is one and the AAI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable When this bit is one and the URI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable When this bit is one and the SRI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USB"
        "STS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBS"
        "TS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS"
        " register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable When this bit is one, and the U"
        "AI bit in the n_USBSTS register is one, host controller will issue an "
        "interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable When this bit is one, and the UPI b"
        "it in the n_USBSTS register is one, host controller will issue an inte"
        "rrupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable When this bit is one and the"
        " TI0 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable When this bit is one and the"
        " TI1 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_FRINDEX.
static const field_t hw_usbc_uog2_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_PERIODICLISTBASE.
static const field_t hw_usbc_uog2_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_DEVICEADDR.
static const field_t hw_usbc_uog2_deviceaddr[] =
{
    {
        "USBADRA",
        "Device Address Advance.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USBADR",
        "Device Address.",
        25, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ASYNCLISTADDR.
static const field_t hw_usbc_uog2_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTLISTADDR.
static const field_t hw_usbc_uog2_endptlistaddr[] =
{
    {
        "EPBASE",
        "Endpoint List Pointer(Low).",
        11, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_BURSTSIZE.
static const field_t hw_usbc_uog2_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_TXFILLTUNING.
static const field_t hw_usbc_uog2_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTNAK.
static const field_t hw_usbc_uog2_endptnak[] =
{
    {
        "EPRN",
        "RX Endpoint NAK - R/WC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTN",
        "TX Endpoint NAK - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTNAKEN.
static const field_t hw_usbc_uog2_endptnaken[] =
{
    {
        "EPRNE",
        "RX Endpoint NAK Enable - R/W.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTNE",
        "TX Endpoint NAK Enable - R/W.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_CONFIGFLAG.
static const field_t hw_usbc_uog2_configflag[] =
{
    {
        "CF",
        "Configure Flag Host software sets this bit as the last action in its p"
        "rocess of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_PORTSC1.
static const field_t hw_usbc_uog2_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_2",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width This bit has no effect if serial interface "
        "engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select - Read Only Serial Transceiver Select 1 Seri"
        "al Interface Engine is selected 0 Parallel Interface signals is select"
        "ed Serial Interface Engine can be used in combination with UTMI+/ULPI "
        "physical interface to provide FS/LS signaling instead of the parallel "
        "interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_1",
        "Bit field {bit25, bit31, bit30}: \"000b\" UTMI/UTMI+ \"001b\" Reserved"
        " \"010b\" ULPI \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only) \"100b\" H"
        "SIC All USB port interface modes are listed in this field description,"
        " but not all are supported.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_OTGSC.
static const field_t hw_usbc_uog2_otgsc[] =
{
    {
        "VD",
        "VBUS_Discharge - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC",
        "VBUS Charge - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OT",
        "OTG Termination - Read/Write.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP",
        "Data Pulsing - Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDPU",
        "ID Pullup - Read/Write This bit provide control over the ID pull-up re"
        "sister; 0 = off, 1 = on [default].",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID",
        "USB ID - Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVV",
        "A VBus Valid - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASV",
        "A Session Valid - Read Only.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSV",
        "B Session Valid - Read Only.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSE",
        "B Session End - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "1MST",
        "1 millisecond timer toggle - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        "Data Bus Pulsing Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDIS",
        "USB ID Interrupt Status - Read/Write.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIS",
        "A VBus Valid Interrupt Status - Read/Write to Clear.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIS",
        "A Session Valid Interrupt Status - Read/Write to Clear.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIS",
        "B Session Valid Interrupt Status - Read/Write to Clear.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIS",
        "B Session End Interrupt Status - Read/Write to Clear.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "1MSS",
        "1 millisecond timer Interrupt Status - Read/Write to Clear.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIS",
        "Data Pulse Interrupt Status - Read/Write to Clear.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDIE",
        "USB ID Interrupt Enable - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIE",
        "A VBus Valid Interrupt Enable - Read/Write.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIE",
        "A Session Valid Interrupt Enable - Read/Write.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIE",
        "B Session Valid Interrupt Enable - Read/Write.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIE",
        "B Session End Interrupt Enable - Read/Write.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "1MSE",
        "1 millisecond timer Interrupt Enable - Read/Write",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIE",
        "Data Pulse Interrupt Enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_USBMODE.
static const field_t hw_usbc_uog2_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTSETUPSTAT.
static const field_t hw_usbc_uog2_endptsetupstat[] =
{
    {
        "ENDPTSETUPSTAT",
        "Setup Endpoint Status.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTPRIME.
static const field_t hw_usbc_uog2_endptprime[] =
{
    {
        "PERB",
        "Prime Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PETB",
        "Prime Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTFLUSH.
static const field_t hw_usbc_uog2_endptflush[] =
{
    {
        "FERB",
        "Flush Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FETB",
        "Flush Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTSTAT.
static const field_t hw_usbc_uog2_endptstat[] =
{
    {
        "ERBR",
        "Endpoint Receive Buffer Ready -- Read Only.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETBR",
        "Endpoint Transmit Buffer Ready -- Read Only.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCOMPLETE.
static const field_t hw_usbc_uog2_endptcomplete[] =
{
    {
        "ERCE",
        "Endpoint Receive Complete Event - RW/C.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCE",
        "Endpoint Transmit Complete Event - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL0.
static const field_t hw_usbc_uog2_endptctrl0[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Contr"
        "ol End Point.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point St"
        "alled Software can write a one to this bit to force the endpoint to re"
        "turn a STALL handshake to the Host.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Con"
        "trol End Point.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL1.
static const field_t hw_usbc_uog2_endptctrl1[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL2.
static const field_t hw_usbc_uog2_endptctrl2[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL3.
static const field_t hw_usbc_uog2_endptctrl3[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL4.
static const field_t hw_usbc_uog2_endptctrl4[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL5.
static const field_t hw_usbc_uog2_endptctrl5[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL6.
static const field_t hw_usbc_uog2_endptctrl6[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL7.
static const field_t hw_usbc_uog2_endptctrl7[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit is set automatically upon receipt of a SETUP request if this Endp"
        "oint is not configured as a Control Endpoint.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_ID.
static const field_t hw_usbc_uh1_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWGENERAL.
static const field_t hw_usbc_uh1_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type PHYM bit reset value: '0000b' for OTG controller core"
        ", '0100b' for Host-only controller core.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability SM bit reset value is '00b'",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWHOST.
static const field_t hw_usbc_uh1_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWTXBUF.
static const field_t hw_usbc_uh1_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWRXBUF.
static const field_t hw_usbc_uh1_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER0LD.
static const field_t hw_usbc_uh1_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER0CTRL.
static const field_t hw_usbc_uh1_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software; In repeat mode, the timer will count down to zero, generat"
        "e an interrupt and automatically reload the counter value from GPTLD b"
        "its to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER1LD.
static const field_t hw_usbc_uh1_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER1CTRL.
static const field_t hw_usbc_uh1_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_SBUSCFG.
static const field_t hw_usbc_uh1_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration These bits control AHB master"
        " transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_CAPLENGTH.
static const field_t hw_usbc_uh1_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCIVERSION.
static const field_t hw_usbc_uh1_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number Default value is '10h', which"
        " means EHCI rev1.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCSPARAMS.
static const field_t hw_usbc_uh1_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control This field indicates whether the host controller im"
        "plementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller This field indicates the numb"
        "er of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR) This bit indicates whether the ports sup"
        "port port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCCPARAMS.
static const field_t hw_usbc_uh1_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability This bit is set '0b' in all controller co"
        "re, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag If this bit is set to zero, then the syst"
        "em software must use a frame list length of 1024 elements with this ho"
        "st controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability If this bit is set to a one, the"
        "n the host controller supports the park feature for high-speed queue h"
        "eads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBCMD.
static const field_t hw_usbc_uh1_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_1",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_2",
        "See also bits 3-2 Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBSTS.
static const field_t hw_usbc_uh1_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBINTR.
static const field_t hw_usbc_uh1_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS r"
        "egister is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable When this bit is one and the UEI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable When this bit is one and the PCI b"
        "it in n_USBSTS register is a one the controller will issue an interrup"
        "t.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable When this bit is one and the FRI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable When this bit is one and the SEI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable When this bit is one and the AAI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable When this bit is one and the URI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable When this bit is one and the SRI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USB"
        "STS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBS"
        "TS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS"
        " register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable When this bit is one, and the U"
        "AI bit in the n_USBSTS register is one, host controller will issue an "
        "interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable When this bit is one, and the UPI b"
        "it in the n_USBSTS register is one, host controller will issue an inte"
        "rrupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable When this bit is one and the"
        " TI0 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable When this bit is one and the"
        " TI1 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_FRINDEX.
static const field_t hw_usbc_uh1_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_PERIODICLISTBASE.
static const field_t hw_usbc_uh1_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_ASYNCLISTADDR.
static const field_t hw_usbc_uh1_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_BURSTSIZE.
static const field_t hw_usbc_uh1_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_TXFILLTUNING.
static const field_t hw_usbc_uh1_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_CONFIGFLAG.
static const field_t hw_usbc_uh1_configflag[] =
{
    {
        "CF",
        "Configure Flag Host software sets this bit as the last action in its p"
        "rocess of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_PORTSC1.
static const field_t hw_usbc_uh1_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_2",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width This bit has no effect if serial interface "
        "engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select - Read Only Serial Transceiver Select 1 Seri"
        "al Interface Engine is selected 0 Parallel Interface signals is select"
        "ed Serial Interface Engine can be used in combination with UTMI+/ULPI "
        "physical interface to provide FS/LS signaling instead of the parallel "
        "interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_1",
        "Bit field {bit25, bit31, bit30}: \"000b\" UTMI/UTMI+ \"001b\" Reserved"
        " \"010b\" ULPI \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only) \"100b\" H"
        "SIC All USB port interface modes are listed in this field description,"
        " but not all are supported.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBMODE.
static const field_t hw_usbc_uh1_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBC module.
static const reg_t hw_usbc[] =
{
    {
        "UOG1_ID",
        "The ID register identifies the USB 2.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog1_id
    },
    {
        "UOG1_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog1_hwgeneral
    },
    {
        "UOG1_HWHOST",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_hwhost
    },
    {
        "UOG1_HWDEVICE",
        "This register is only available in OTG core.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_hwdevice
    },
    {
        "UOG1_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_hwtxbuf
    },
    {
        "UOG1_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_hwrxbuf
    },
    {
        "UOG1_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_gptimer0ld
    },
    {
        "UOG1_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog1_gptimer0ctrl
    },
    {
        "UOG1_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_gptimer1ld
    },
    {
        "UOG1_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog1_gptimer1ctrl
    },
    {
        "UOG1_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_sbuscfg
    },
    {
        "UOG1_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_caplength
    },
    {
        "UOG1_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000102, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_hciversion
    },
    {
        "UOG1_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uog1_hcsparams
    },
    {
        "UOG1_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uog1_hccparams
    },
    {
        "UOG1_DCIVERSION",
        "This register indicates the two-byte BCD encoding of the device contro"
        "ller interface version number.",
        2, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_dciversion
    },
    {
        "UOG1_DCCPARAMS",
        "These fields describe the overall device capability of the controller.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog1_dccparams
    },
    {
        "UOG1_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_usbcmd
    },
    {
        "UOG1_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uog1_usbsts
    },
    {
        "UOG1_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uog1_usbintr
    },
    {
        "UOG1_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_frindex
    },
    {
        "UOG1_PERIODICLISTBASE",
        "Host Controller only This 32-bit register contains the beginning addre"
        "ss of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_periodiclistbase
    },
    {
        "UOG1_DEVICEADDR",
        "Device Controller only The upper seven bits of this register represent"
        " the device address.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_deviceaddr
    },
    {
        "UOG1_ASYNCLISTADDR",
        "Host Controller only This 32-bit register contains the address of the "
        "next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_asynclistaddr
    },
    {
        "UOG1_ENDPTLISTADDR",
        "Device Controller only In device mode, this register contains the addr"
        "ess of the top of the endpoint list in system memory.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_endptlistaddr
    },
    {
        "UOG1_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_burstsize
    },
    {
        "UOG1_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uog1_txfilltuning
    },
    {
        "UOG1_ENDPTNAK",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptnak
    },
    {
        "UOG1_ENDPTNAKEN",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptnaken
    },
    {
        "UOG1_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_configflag
    },
    {
        "UOG1_PORTSC1",
        "Host Controller A host controller could implement one to eight port st"
        "atus and control registers.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uog1_portsc1
    },
    {
        "UOG1_OTGSC",
        "This register is availabe only in OTG controller core.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_usbc_uog1_otgsc
    },
    {
        "UOG1_USBMODE",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog1_usbmode
    },
    {
        "UOG1_ENDPTSETUPSTAT",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_endptsetupstat
    },
    {
        "UOG1_ENDPTPRIME",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptprime
    },
    {
        "UOG1_ENDPTFLUSH",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptflush
    },
    {
        "UOG1_ENDPTSTAT",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptstat
    },
    {
        "UOG1_ENDPTCOMPLETE",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptcomplete
    },
    {
        "UOG1_ENDPTCTRL0",
        "Every Device implements Endpoint 0 as a control endpoint.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbc_uog1_endptctrl0
    },
    {
        "UOG1_ENDPTCTRL1",
        "This is endpoint control register for endpoint 1 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl1
    },
    {
        "UOG1_ENDPTCTRL2",
        "This is endpoint control register for endpoint 2 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl2
    },
    {
        "UOG1_ENDPTCTRL3",
        "This is endpoint control register for endpoint 3 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl3
    },
    {
        "UOG1_ENDPTCTRL4",
        "This is endpoint control register for endpoint 4 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl4
    },
    {
        "UOG1_ENDPTCTRL5",
        "This is endpoint control register for endpoint 5 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl5
    },
    {
        "UOG1_ENDPTCTRL6",
        "This is endpoint control register for endpoint 6 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl6
    },
    {
        "UOG1_ENDPTCTRL7",
        "This is endpoint control register for endpoint 7 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl7
    },
    {
        "UOG2_ID",
        "The ID register identifies the USB 2.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog2_id
    },
    {
        "UOG2_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog2_hwgeneral
    },
    {
        "UOG2_HWHOST",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_hwhost
    },
    {
        "UOG2_HWDEVICE",
        "This register is only available in OTG core.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_hwdevice
    },
    {
        "UOG2_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_hwtxbuf
    },
    {
        "UOG2_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_hwrxbuf
    },
    {
        "UOG2_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_gptimer0ld
    },
    {
        "UOG2_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog2_gptimer0ctrl
    },
    {
        "UOG2_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_gptimer1ld
    },
    {
        "UOG2_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog2_gptimer1ctrl
    },
    {
        "UOG2_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_sbuscfg
    },
    {
        "UOG2_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_caplength
    },
    {
        "UOG2_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000302, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_hciversion
    },
    {
        "UOG2_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uog2_hcsparams
    },
    {
        "UOG2_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uog2_hccparams
    },
    {
        "UOG2_DCIVERSION",
        "This register indicates the two-byte BCD encoding of the device contro"
        "ller interface version number.",
        2, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_dciversion
    },
    {
        "UOG2_DCCPARAMS",
        "These fields describe the overall device capability of the controller.",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog2_dccparams
    },
    {
        "UOG2_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_usbcmd
    },
    {
        "UOG2_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uog2_usbsts
    },
    {
        "UOG2_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uog2_usbintr
    },
    {
        "UOG2_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_frindex
    },
    {
        "UOG2_PERIODICLISTBASE",
        "Host Controller only This 32-bit register contains the beginning addre"
        "ss of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_periodiclistbase
    },
    {
        "UOG2_DEVICEADDR",
        "Device Controller only The upper seven bits of this register represent"
        " the device address.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_deviceaddr
    },
    {
        "UOG2_ASYNCLISTADDR",
        "Host Controller only This 32-bit register contains the address of the "
        "next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_asynclistaddr
    },
    {
        "UOG2_ENDPTLISTADDR",
        "Device Controller only In device mode, this register contains the addr"
        "ess of the top of the endpoint list in system memory.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_endptlistaddr
    },
    {
        "UOG2_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_burstsize
    },
    {
        "UOG2_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uog2_txfilltuning
    },
    {
        "UOG2_ENDPTNAK",
        "",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptnak
    },
    {
        "UOG2_ENDPTNAKEN",
        "",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptnaken
    },
    {
        "UOG2_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_configflag
    },
    {
        "UOG2_PORTSC1",
        "Host Controller A host controller could implement one to eight port st"
        "atus and control registers.",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uog2_portsc1
    },
    {
        "UOG2_OTGSC",
        "This register is availabe only in OTG controller core.",
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_usbc_uog2_otgsc
    },
    {
        "UOG2_USBMODE",
        "",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog2_usbmode
    },
    {
        "UOG2_ENDPTSETUPSTAT",
        "",
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_endptsetupstat
    },
    {
        "UOG2_ENDPTPRIME",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptprime
    },
    {
        "UOG2_ENDPTFLUSH",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptflush
    },
    {
        "UOG2_ENDPTSTAT",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptstat
    },
    {
        "UOG2_ENDPTCOMPLETE",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptcomplete
    },
    {
        "UOG2_ENDPTCTRL0",
        "Every Device implements Endpoint 0 as a control endpoint.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbc_uog2_endptctrl0
    },
    {
        "UOG2_ENDPTCTRL1",
        "This is endpoint control register for endpoint 1 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl1
    },
    {
        "UOG2_ENDPTCTRL2",
        "This is endpoint control register for endpoint 2 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl2
    },
    {
        "UOG2_ENDPTCTRL3",
        "This is endpoint control register for endpoint 3 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl3
    },
    {
        "UOG2_ENDPTCTRL4",
        "This is endpoint control register for endpoint 4 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl4
    },
    {
        "UOG2_ENDPTCTRL5",
        "This is endpoint control register for endpoint 5 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl5
    },
    {
        "UOG2_ENDPTCTRL6",
        "This is endpoint control register for endpoint 6 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl6
    },
    {
        "UOG2_ENDPTCTRL7",
        "This is endpoint control register for endpoint 7 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl7
    },
    {
        "UH1_ID",
        "The ID register identifies the USB 2.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_id
    },
    {
        "UH1_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_hwgeneral
    },
    {
        "UH1_HWHOST",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwhost
    },
    {
        "UH1_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwtxbuf
    },
    {
        "UH1_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwrxbuf
    },
    {
        "UH1_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_gptimer0ld
    },
    {
        "UH1_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_gptimer0ctrl
    },
    {
        "UH1_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_gptimer1ld
    },
    {
        "UH1_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_gptimer1ctrl
    },
    {
        "UH1_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_sbuscfg
    },
    {
        "UH1_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_caplength
    },
    {
        "UH1_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000502, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_hciversion
    },
    {
        "UH1_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uh1_hcsparams
    },
    {
        "UH1_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uh1_hccparams
    },
    {
        "UH1_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uh1_usbcmd
    },
    {
        "UH1_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000544, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uh1_usbsts
    },
    {
        "UH1_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000548, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uh1_usbintr
    },
    {
        "UH1_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000054c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_frindex
    },
    {
        "UH1_PERIODICLISTBASE",
        "Host Controller only This 32-bit register contains the beginning addre"
        "ss of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000554, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_periodiclistbase
    },
    {
        "UH1_ASYNCLISTADDR",
        "Host Controller only This 32-bit register contains the address of the "
        "next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000558, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_asynclistaddr
    },
    {
        "UH1_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_burstsize
    },
    {
        "UH1_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000564, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_txfilltuning
    },
    {
        "UH1_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_configflag
    },
    {
        "UH1_PORTSC1",
        "Host Controller A host controller could implement one to eight port st"
        "atus and control registers.",
        4, // Width in bytes
        0x00000584, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uh1_portsc1
    },
    {
        "UH1_USBMODE",
        "",
        4, // Width in bytes
        0x000005a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_usbmode
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBNC
#endif

// Bitfields in register USBNC_USB_OTG1_CTRL.
static const field_t hw_usbnc_usb_otg1_ctrl[] =
{
    {
        "OVER_CUR_DIS",
        "Disable OTG1 Overcurrent Detection",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        "OTG1 Polarity of Overcurrent The polarity of OTG1 port overcurrent eve"
        "nt",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        "OTG1 Power Polarity This bit should be set according to PMIC Power Pin"
        " polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "OTG1 Wake-up Interrupt Enable This bit enables or disables the OTG1 wa"
        "ke-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "OTG1 Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "OTG1 Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        "OTG1 Wake-up on ID change enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        "OTG1 wake-up on VBUS change enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "OTG1 Wake-up Interrupt Request This bit indicates that a wake-up inter"
        "rupt request is received on the OTG1 port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG2_CTRL.
static const field_t hw_usbnc_usb_otg2_ctrl[] =
{
    {
        "OVER_CUR_DIS",
        "Disable OTG2 Overcurrent Detection",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        "OTG2 Polarity of Overcurrent The polarity of OTG2 port overcurrent eve"
        "nt",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        "OTG2 Power Polarity This bit should be set according to PMIC Power Pin"
        " polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "OTG2 Wake-up Interrupt Enable This bit enables or disables the OTG2 wa"
        "ke-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "OTG2 Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "OTG2 Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        "OTG2 Wake-up on ID change enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        "OTG2 wake-up on VBUS change enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "OTG2 Wake-up Interrupt Request This bit indicates that a wake-up inter"
        "rupt request is received on the OTG port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH_CTRL.
static const field_t hw_usbnc_usb_uh_ctrl[] =
{
    {
        "WIE",
        "Host Wake-up Interrupt Enable This bit enables or disables the Host wa"
        "ke-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Force Host UTMI PHY Reset This bit is used to force a reset to the UTM"
        "I PHY.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSPENDM",
        "Force Host UTMI PHY Suspend This bit is used to put PHY into suspend m"
        "ode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "480M_CLK_ON",
        "Force OTG UTMI PHY 480M clock output on when Host is not in suspend mo"
        "de.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "Host Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "Host Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "Host Wake-up Interrupt Request This bit indicates that a wake-up inter"
        "rupt request is received on the Host port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH_HSIC_CTRL.
static const field_t hw_usbnc_usb_uh_hsic_ctrl[] =
{
    {
        "HSIC_CLK_ON",
        "Force Host HSIC module 480M clock on, even when in Host is in suspend "
        "mode.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_EN",
        "Host HSIC enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_VLD",
        "Indicating whether Host HSIC clock is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG1_PHY_CTRL_0.
static const field_t hw_usbnc_usb_otg1_phy_ctrl_0[] =
{
    {
        "UTMI_CLK_VLD",
        "Indicating whether OTG1 UTMI PHY clock is valid",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG2_PHY_CTRL_0.
static const field_t hw_usbnc_usb_otg2_phy_ctrl_0[] =
{
    {
        "UTMI_CLK_VLD",
        "Indicating whether OTG2 UTMI PHY clock is valid",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBNC module.
static const reg_t hw_usbnc[] =
{
    {
        "USB_OTG1_CTRL",
        "The USB OTG1 control register controls the integration specific featur"
        "es of the USB OTG1 module.",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbnc_usb_otg1_ctrl
    },
    {
        "USB_OTG2_CTRL",
        "The USB OTG2 control register controls the integration specific featur"
        "es of the USB OTG2 module.",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbnc_usb_otg2_ctrl
    },
    {
        "USB_UH_CTRL",
        "The USB Host control register controls the integration specific featur"
        "es of the USB host module.",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbnc_usb_uh_ctrl
    },
    {
        "USB_UH_HSIC_CTRL",
        "The USB Host HSIC control register controls Host high speed IC configu"
        "ration.",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbnc_usb_uh_hsic_ctrl
    },
    {
        "USB_OTG1_PHY_CTRL_0",
        "USB OTG1 UTMI PHY control register 0 is used to control the on-chip OT"
        "G1 UTMI PHY.",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbnc_usb_otg1_phy_ctrl_0
    },
    {
        "USB_OTG2_PHY_CTRL_0",
        "USB OTG2 UTMI PHY Control Register 0 are used to control the on-chip O"
        "TG2 UTMI PHY.",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbnc_usb_otg2_phy_ctrl_0
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBPHY
#endif

// Bitfields in register USBPHY_PWD.
static const field_t hw_usbphy_pwd[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_SET.
static const field_t hw_usbphy_pwd_set[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_CLR.
static const field_t hw_usbphy_pwd_clr[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_TOG.
static const field_t hw_usbphy_pwd_tog[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX.
static const field_t hw_usbphy_tx[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code: 0000 = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        20, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "USBPHY_TX_EDGECTRL",
        "Controls the edge-rate of the current sensing transistors used in HS t"
        "ransmit.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_SET.
static const field_t hw_usbphy_tx_set[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code: 0000 = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        20, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "USBPHY_TX_EDGECTRL",
        "Controls the edge-rate of the current sensing transistors used in HS t"
        "ransmit.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_CLR.
static const field_t hw_usbphy_tx_clr[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code: 0000 = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        20, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "USBPHY_TX_EDGECTRL",
        "Controls the edge-rate of the current sensing transistors used in HS t"
        "ransmit.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_TOG.
static const field_t hw_usbphy_tx_tog[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code: 0000 = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        20, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "USBPHY_TX_EDGECTRL",
        "Controls the edge-rate of the current sensing transistors used in HS t"
        "ransmit.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX.
static const field_t hw_usbphy_rx[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ": 000 = Trip-Level Voltage is 0.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        7, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        23, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_SET.
static const field_t hw_usbphy_rx_set[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ": 000 = Trip-Level Voltage is 0.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        7, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        23, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_CLR.
static const field_t hw_usbphy_rx_clr[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ": 000 = Trip-Level Voltage is 0.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        7, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        23, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_TOG.
static const field_t hw_usbphy_rx_tog[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ": 000 = Trip-Level Voltage is 0.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        7, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        23, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL.
static const field_t hw_usbphy_ctrl[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        25, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_SET.
static const field_t hw_usbphy_ctrl_set[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        25, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_CLR.
static const field_t hw_usbphy_ctrl_clr[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        25, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_TOG.
static const field_t hw_usbphy_ctrl_tog[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        25, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_STATUS.
static const field_t hw_usbphy_status[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOSTDISCONDETECT_STATUS",
        "Indicates that the device has disconnected while in high-speed host mo"
        "de.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVPLUGIN_STATUS",
        "Indicates that the device has been connected on the USB_DP and USB_DM "
        "lines.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTGID_STATUS",
        "Indicates the results of ID pin on MiniAB plug.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RESUME_STATUS",
        "Indicates that the host is sending a wake-up after suspend and has tri"
        "ggered an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD4",
        "Reserved.",
        11, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG.
static const field_t hw_usbphy_debug[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG_SET.
static const field_t hw_usbphy_debug_set[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG_CLR.
static const field_t hw_usbphy_debug_clr[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG_TOG.
static const field_t hw_usbphy_debug_tog[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG0_STATUS.
static const field_t hw_usbphy_debug0_status[] =
{
    {
        "LOOP_BACK_FAIL_COUNT",
        "Running count of the failed pseudo-random generator loopback.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UTMI_RXERROR_FAIL_COUNT",
        "Running count of the UTMI_RXERROR.",
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCH_COUNT",
        "Running count of the squelch reset instead of normal end for HS RX.",
        26, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1.
static const field_t hw_usbphy_debug1[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Del"
        "ay is +20% 10 = Delay is -20% 11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        15, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_SET.
static const field_t hw_usbphy_debug1_set[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Del"
        "ay is +20% 10 = Delay is -20% 11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        15, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_CLR.
static const field_t hw_usbphy_debug1_clr[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Del"
        "ay is +20% 10 = Delay is -20% 11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        15, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_TOG.
static const field_t hw_usbphy_debug1_tog[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Del"
        "ay is +20% 10 = Delay is -20% 11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        15, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_VERSION.
static const field_t hw_usbphy_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBPHY module.
static const reg_t hw_usbphy[] =
{
    {
        "PWD",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usbphy_pwd
    },
    {
        "PWD_SET",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usbphy_pwd_set
    },
    {
        "PWD_CLR",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usbphy_pwd_clr
    },
    {
        "PWD_TOG",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usbphy_pwd_tog
    },
    {
        "TX",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usbphy_tx
    },
    {
        "TX_SET",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usbphy_tx_set
    },
    {
        "TX_CLR",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usbphy_tx_clr
    },
    {
        "TX_TOG",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usbphy_tx_tog
    },
    {
        "RX",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbphy_rx
    },
    {
        "RX_SET",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbphy_rx_set
    },
    {
        "RX_CLR",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbphy_rx_clr
    },
    {
        "RX_TOG",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbphy_rx_tog
    },
    {
        "CTRL",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        31, // Number of bitfields
        hw_usbphy_ctrl
    },
    {
        "CTRL_SET",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        31, // Number of bitfields
        hw_usbphy_ctrl_set
    },
    {
        "CTRL_CLR",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        31, // Number of bitfields
        hw_usbphy_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        31, // Number of bitfields
        hw_usbphy_ctrl_tog
    },
    {
        "STATUS",
        "The USB PHY Status Register holds results of IRQ and other detects.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbphy_status
    },
    {
        "DEBUG",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_debug
    },
    {
        "DEBUG_SET",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_debug_set
    },
    {
        "DEBUG_CLR",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_debug_clr
    },
    {
        "DEBUG_TOG",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_debug_tog
    },
    {
        "DEBUG0_STATUS",
        "The UTMI Debug Status Register 0 holds multiple views for counters and"
        " status of state machines.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_debug0_status
    },
    {
        "DEBUG1",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1
    },
    {
        "DEBUG1_SET",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_set
    },
    {
        "DEBUG1_CLR",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_clr
    },
    {
        "DEBUG1_TOG",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_tog
    },
    {
        "VERSION",
        "Fields for RTL Version.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USB_ANALOG
#endif

// Bitfields in register USB_ANALOG_ANALOG_USB1_VBUS_DETECT.
static const field_t hw_usb_analog_analog_usb1_vbus_detect[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_VBUS_DETECT_SET.
static const field_t hw_usb_analog_analog_usb1_vbus_detect_set[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_VBUS_DETECT_CLR.
static const field_t hw_usb_analog_analog_usb1_vbus_detect_clr[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_VBUS_DETECT_TOG.
static const field_t hw_usb_analog_analog_usb1_vbus_detect_tog[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_CHRG_DETECT.
static const field_t hw_usb_analog_analog_usb1_chrg_detect[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_CHRG_DETECT_SET.
static const field_t hw_usb_analog_analog_usb1_chrg_detect_set[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_CHRG_DETECT_CLR.
static const field_t hw_usb_analog_analog_usb1_chrg_detect_clr[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_CHRG_DETECT_TOG.
static const field_t hw_usb_analog_analog_usb1_chrg_detect_tog[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_VBUS_DETECT_STAT.
static const field_t hw_usb_analog_analog_usb1_vbus_detect_stat[] =
{
    {
        "SESSEND",
        "Session End for USB OTG.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BVALID",
        "Indicates VBus is valid for a B-peripheral.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVALID",
        "Indicates VBus is valid for a A-peripheral.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBUS_VALID",
        "VBus valid for USB OTG.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_CHRG_DETECT_STAT.
static const field_t hw_usb_analog_analog_usb1_chrg_detect_stat[] =
{
    {
        "PLUG_CONTACT",
        "State of the USB plug contact detector.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHRG_DETECTED",
        "State of charger detection.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DM_STATE",
        "DM line state output of the charger detector.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_STATE",
        "DP line state output of the charger detector.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_MISC.
static const field_t hw_usb_analog_analog_usb1_misc[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_MISC_SET.
static const field_t hw_usb_analog_analog_usb1_misc_set[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_MISC_CLR.
static const field_t hw_usb_analog_analog_usb1_misc_clr[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB1_MISC_TOG.
static const field_t hw_usb_analog_analog_usb1_misc_tog[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_VBUS_DETECT.
static const field_t hw_usb_analog_analog_usb2_vbus_detect[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_VBUS_DETECT_SET.
static const field_t hw_usb_analog_analog_usb2_vbus_detect_set[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_VBUS_DETECT_CLR.
static const field_t hw_usb_analog_analog_usb2_vbus_detect_clr[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_VBUS_DETECT_TOG.
static const field_t hw_usb_analog_analog_usb2_vbus_detect_tog[] =
{
    {
        "VBUSVALID_THRESH",
        "Set the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        "Powers up comparators for vbus_valid detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "USB OTG discharge VBUS.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        "USB OTG charge VBUS.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_CHRG_DETECT.
static const field_t hw_usb_analog_analog_usb2_chrg_detect[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_CHRG_DETECT_SET.
static const field_t hw_usb_analog_analog_usb2_chrg_detect_set[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_CHRG_DETECT_CLR.
static const field_t hw_usb_analog_analog_usb2_chrg_detect_clr[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_CHRG_DETECT_TOG.
static const field_t hw_usb_analog_analog_usb2_chrg_detect_tog[] =
{
    {
        "CHK_CONTACT",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        "Control the charger detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_VBUS_DETECT_STAT.
static const field_t hw_usb_analog_analog_usb2_vbus_detect_stat[] =
{
    {
        "SESSEND",
        "Session End for USB OTG.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BVALID",
        "Indicates VBus is valid for a B-peripheral.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVALID",
        "Indicates VBus is valid for a A-peripheral.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBUS_VALID",
        "VBus valid for USB OTG.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_CHRG_DETECT_STAT.
static const field_t hw_usb_analog_analog_usb2_chrg_detect_stat[] =
{
    {
        "PLUG_CONTACT",
        "State of the USB plug contact detector.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHRG_DETECTED",
        "State of charger detection.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DM_STATE",
        "DM line state output of the charger detector.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_STATE",
        "DP line state output of the charger detector.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_MISC.
static const field_t hw_usb_analog_analog_usb2_misc[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_MISC_SET.
static const field_t hw_usb_analog_analog_usb2_misc_set[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_MISC_CLR.
static const field_t hw_usb_analog_analog_usb2_misc_clr[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_USB2_MISC_TOG.
static const field_t hw_usb_analog_analog_usb2_misc_tog[] =
{
    {
        "HS_USE_EXTERNAL_R",
        "Use external resistor to generate the current bias for the high speed "
        "transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        "Enable the deglitching circuit of the USB PLL output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        "Enables the clk to the UTMI block.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_ANALOG_DIGPROG.
static const field_t hw_usb_analog_analog_digprog[] =
{
    {
        "MINOR",
        "MINOR lower byte - Read-only value representing a minor silicon revisi"
        "on.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR_LOWER",
        "MAJOR lower byte - Read-only value representing a major silicon revisi"
        "on.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR_UPPER",
        "MAJOR upper byte-Read-only value representing the chip type.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USB_ANALOG module.
static const reg_t hw_usb_analog[] =
{
    {
        "ANALOG_USB1_VBUS_DETECT",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb1_vbus_detect
    },
    {
        "ANALOG_USB1_VBUS_DETECT_SET",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb1_vbus_detect_set
    },
    {
        "ANALOG_USB1_VBUS_DETECT_CLR",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb1_vbus_detect_clr
    },
    {
        "ANALOG_USB1_VBUS_DETECT_TOG",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb1_vbus_detect_tog
    },
    {
        "ANALOG_USB1_CHRG_DETECT",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb1_chrg_detect
    },
    {
        "ANALOG_USB1_CHRG_DETECT_SET",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb1_chrg_detect_set
    },
    {
        "ANALOG_USB1_CHRG_DETECT_CLR",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb1_chrg_detect_clr
    },
    {
        "ANALOG_USB1_CHRG_DETECT_TOG",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb1_chrg_detect_tog
    },
    {
        "ANALOG_USB1_VBUS_DETECT_STAT",
        "This register defines fields for USB VBUS Detect status.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb1_vbus_detect_stat
    },
    {
        "ANALOG_USB1_CHRG_DETECT_STAT",
        "This register defines fields for USB charger detect status.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb1_chrg_detect_stat
    },
    {
        "ANALOG_USB1_MISC",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb1_misc
    },
    {
        "ANALOG_USB1_MISC_SET",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x000001f4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb1_misc_set
    },
    {
        "ANALOG_USB1_MISC_CLR",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x000001f8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb1_misc_clr
    },
    {
        "ANALOG_USB1_MISC_TOG",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x000001fc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb1_misc_tog
    },
    {
        "ANALOG_USB2_VBUS_DETECT",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb2_vbus_detect
    },
    {
        "ANALOG_USB2_VBUS_DETECT_SET",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb2_vbus_detect_set
    },
    {
        "ANALOG_USB2_VBUS_DETECT_CLR",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb2_vbus_detect_clr
    },
    {
        "ANALOG_USB2_VBUS_DETECT_TOG",
        "This register defines controls for USB VBUS detect.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb2_vbus_detect_tog
    },
    {
        "ANALOG_USB2_CHRG_DETECT",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb2_chrg_detect
    },
    {
        "ANALOG_USB2_CHRG_DETECT_SET",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb2_chrg_detect_set
    },
    {
        "ANALOG_USB2_CHRG_DETECT_CLR",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb2_chrg_detect_clr
    },
    {
        "ANALOG_USB2_CHRG_DETECT_TOG",
        "This register defines controls for USB charger detect.",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb2_chrg_detect_tog
    },
    {
        "ANALOG_USB2_VBUS_DETECT_STAT",
        "This register defines fields for USB VBUS Detect status.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb2_vbus_detect_stat
    },
    {
        "ANALOG_USB2_CHRG_DETECT_STAT",
        "This register defines fields for USB charger detect status.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_analog_usb2_chrg_detect_stat
    },
    {
        "ANALOG_USB2_MISC",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb2_misc
    },
    {
        "ANALOG_USB2_MISC_SET",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb2_misc_set
    },
    {
        "ANALOG_USB2_MISC_CLR",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb2_misc_clr
    },
    {
        "ANALOG_USB2_MISC_TOG",
        "This register defines controls for USB.",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_usb2_misc_tog
    },
    {
        "ANALOG_DIGPROG",
        "The DIGPROG register returns the digital program ID for the silicon.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_analog_analog_digprog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark uSDHC
#endif

// Bitfields in register uSDHC_DS_ADDR.
static const field_t hw_usdhc_ds_addr[] =
{
    {
        "DS_ADDR",
        "DMA System Address: This register contains the 32-bit system memory ad"
        "dress for a DMA transfer.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_BLK_ATT.
static const field_t hw_usdhc_blk_att[] =
{
    {
        "BLKSIZE",
        "Transfer Block Size: This register specifies the block size for block "
        "data transfers.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLKCNT",
        "Blocks Count For Current Transfer: This register is enabled when the B"
        "lock Count Enable bit in the Transfer Mode register is set to 1 and is"
        " valid only for multiple block transfers.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_ARG.
static const field_t hw_usdhc_cmd_arg[] =
{
    {
        "CMDARG",
        "Command Argument: The SD/MMC Command Argument is specified as bits 39-"
        "8 of the Command Format in the SD or MMC Specification.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_XFR_TYP.
static const field_t hw_usdhc_cmd_xfr_typ[] =
{
    {
        "RSPTYP",
        "Response Type Select:",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCCEN",
        "Command CRC Check Enable: If this bit is set to 1, the uSDHC shall che"
        "ck the CRC field in the response.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CICEN",
        "Command Index Check Enable: If this bit is set to 1, the uSDHC will ch"
        "eck the Index field in the response to see if it has the same value as"
        " the command index.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPSEL",
        "Data Present Select: This bit is set to 1 to indicate that data is pre"
        "sent and shall be transferred using the DATA line.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDTYP",
        "Command Type: There are three types of special commands: Suspend, Resu"
        "me and Abort.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDINX",
        "Command Index: These bits shall be set to the command number that is s"
        "pecified in bits 45-40 of the Command-Format in the SD Memory Card Phy"
        "sical Layer Specification and SDIO Card Specification.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_RSP0.
static const field_t hw_usdhc_cmd_rsp0[] =
{
    {
        "CMDRSP0",
        "Command Response 0: Refer to CMD_RSP3Command Response3 for the mapping"
        " of command responses from the SD Bus to this register for each respon"
        "se type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_RSP1.
static const field_t hw_usdhc_cmd_rsp1[] =
{
    {
        "CMDRSP1",
        "Command Response 1: Refer to CMD_RSP3Command Response3 for the mapping"
        " of command responses from the SD Bus to this register for each respon"
        "se type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_RSP2.
static const field_t hw_usdhc_cmd_rsp2[] =
{
    {
        "CMDRSP2",
        "Command Response 2: Refer to CMD_RSP3Command Response3 for the mapping"
        " of command responses from the SD Bus to this register for each respon"
        "se type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_RSP3.
static const field_t hw_usdhc_cmd_rsp3[] =
{
    {
        "CMDRSP3",
        "Command Response 3: Refer to CMD_RSP3Command Response3 for the mapping"
        " of command responses from the SD Bus to this register for each respon"
        "se type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_DATA_BUFF_ACC_PORT.
static const field_t hw_usdhc_data_buff_acc_port[] =
{
    {
        "DATCONT",
        "Data Content: The Buffer Data Port register is for 32-bit data access "
        "by the ARM platform or the external DMA.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_PRES_STATE.
static const field_t hw_usdhc_pres_state[] =
{
    {
        "CIHB",
        "Command Inhibit (CMD): If this status bit is 0, it indicates that the "
        "CMD line is not in use and the uSDHC can issue a SD/MMC Command using "
        "the CMD line.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDIHB",
        "Command Inhibit (DATA): This status bit is generated if either the DAT"
        " Line Active or the Read Transfer Active is set to 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLA",
        "Data Line Active This status bit indicates whether one of the DATA lin"
        "es on the SD Bus is in use.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDSTB",
        "SD Clock Stable This status bit indicates that the internal card clock"
        " is stable.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPGOFF",
        "ipg_clk Gated Off Internally: This status bit indicates that the ipg_c"
        "lk is internally gated off.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HCKOFF",
        "hclk Gated Off Internally: This status bit indicates that the hclk is "
        "internally gated off.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PEROFF",
        "ipg_perclk Gated Off Internally: This status bit indicates that the ip"
        "g_perclk is internally gated off.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDOFF",
        "SD Clock Gated Off Internally: This status bit indicates that the SD C"
        "lock is internally gated off, because of buffer over/under-run or read"
        " pause without read wait assertion, or the driver set FRC_SDCLK_ON bit"
        " is 0 to stop the SD clock in idle status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WTA",
        "Write Transfer Active: This status bit indicates a write transfer is a"
        "ctive.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTA",
        "Read Transfer Active: This status bit is used for detecting completion"
        " of a read transfer.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BWEN",
        "Buffer Write Enable: This status bit is used for non-DMA write transfe"
        "rs.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BREN",
        "Buffer Read Enable: This status bit is used for non-DMA read transfers"
        ".",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTR",
        "Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may re"
        "quest Host Driver to execute re-tuning sequence by setting this bit wh"
        "en the data window is shifted by temperature drift and a tuned samplin"
        "g point does not have a good margin to receive correct data.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSCD",
        "Tape Select Change Done : This bit indicates the dealy setting is effe"
        "ctive after write CLK_TUNE_CTRL_STATUS register.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CINST",
        "Card Inserted: This bit indicates whether a card has been inserted.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDPL",
        "Card Detect Pin Level: This bit reflects the inverse value of the CD_B"
        " pin for the card socket.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WPSPL",
        "Write Protect Switch Pin Level: The Write Protect Switch is supported "
        "for memory and combo cards.This bit reflects the inverted value of the"
        " WP pin of the card socket.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLSL",
        "CMD Line Signal Level: This status is used to check the CMD line level"
        " to recover from errors, and for debugging.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLSL",
        "DATA[7:0] Line Signal Level: This status is used to check the DATA lin"
        "e level to recover from errors, and for debugging.This is especially u"
        "seful in detecting the busy signal level from DATA0.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_PROT_CTRL.
static const field_t hw_usdhc_prot_ctrl[] =
{
    {
        "LCTL",
        "LED Control: This bit, fully controlled by the Host Driver, is used to"
        " caution the user not to remove the card while the card is being acces"
        "sed.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTW",
        "Data Transfer Width: This bit selects the data width of the SD bus for"
        " a data transfer.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3CD",
        "DATA3 as Card Detection Pin: If this bit is set, DATA3 should be pulle"
        "d down to act as a card detection pin.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EMODE",
        "Endian Mode: The uSDHC supports all three endian modes in data transfe"
        "r.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDTL",
        "Card Detect Test Level: This is bit is enabled while the Card Detectio"
        "n Signal Selection is set to 1 and it indicates card insertion.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDSS",
        "Card Detect Signal Selection: This bit selects the source for the card"
        " detection.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMASEL",
        "DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled an"
        "d selects the DMA operation.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SABGREQ",
        "Stop At Block Gap Request: This bit is used to stop executing a transa"
        "ction at the next block gap for both DMA and non-DMA transfers.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREQ",
        "Continue Request: This bit is used to restart a transaction which was "
        "stopped using the Stop At Block Gap Request.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWCTL",
        "Read Wait Control: The read wait function is optional for SDIO cards.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IABG",
        "Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the S"
        "DIO card, and selects a sample point in the interrupt cycle.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DONE_NO_8CLK",
        "Read done no 8 clock: According to the SD/MMC spec, for read data tran"
        "saction, 8 clocks are needed after the end bit of the last data block.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINT",
        "Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event"
        ", via a Card Interrupt, in the Interrupt Status register.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINS",
        "Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup ev"
        "ent, via a Card Insertion, in the Interrupt Status register.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECRM",
        "Wakeup Event Enable On SD Card Removal: This bit enables a wakeup even"
        "t, via a Card Removal, in the Interrupt Status register.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LEN_EN",
        "BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRA"
        "P/INCR16-WRAP This is used to enable/disable the burst length for the "
        "external AHB2AXI bridge.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_EXACT_BLK_RD",
        "Current block read is non-exact block read.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_SYS_CTRL.
static const field_t hw_usdhc_sys_ctrl[] =
{
    {
        "DVS",
        "Divisor: This register is used to provide a more exact divisor to gene"
        "rate the desired SD clock frequency.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLKFS",
        "SDCLK Frequency Select: This register is used to select the frequency "
        "of the SDCLK pin.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOCV",
        "Data Timeout Counter Value: This value determines the interval by whic"
        "h DAT line timeouts are detected.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_RST_N",
        "This register's value will be output to CARD from pad directly for har"
        "dware reset of the card if the card supports this feature.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTA",
        "Software Reset For ALL: This reset effects the entire Host Controller "
        "except for the card detection circuit.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTC",
        "Software Reset For CMD Line: Only part of the command circuit is reset"
        ".",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTD",
        "Software Reset For DATA Line: Only part of the data circuit is reset.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INITA",
        "Initialization Active: When this bit is set, 80 SD-Clocks are sent to "
        "the card.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTT",
        "Reset Tuning: When set this bit to 1, it will reset tuning circuit.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_INT_STATUS.
static const field_t hw_usdhc_int_status[] =
{
    {
        "CC",
        "Command Complete: This bit is set when you receive the end bit of the "
        "command response (except Auto CMD12).",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        "Transfer Complete: This bit is set when a read or write transfer is co"
        "mpleted.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGE",
        "Block Gap Event: If the Stop At Block Gap Request bit in the Protocol "
        "Control register is set, this bit is set when a read or write transact"
        "ion is stopped at a block gap.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINT",
        "DMA Interrupt: Occurs only when the internal DMA finishes the data tra"
        "nsfer successfully.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWR",
        "Buffer Write Ready: This status bit is set if the Buffer Write Enable "
        "bit, in the Present State register, changes from 0 to 1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRR",
        "Buffer Read Ready: This status bit is set if the Buffer Read Enable bi"
        "t, in the Present State register, changes from 0 to 1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINS",
        "Card Insertion: This status bit is set if the Card Inserted bit in the"
        " Present State register changes from 0 to 1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRM",
        "Card Removal: This status bit is set if the Card Inserted bit in the P"
        "resent State register changes from 1 to 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINT",
        "Card Interrupt: This status bit is set when an interrupt signal is det"
        "ected from the external card.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTE",
        "Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re"
        "-Tuning Request in the Present State register changes from 0 to 1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TP",
        "Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is don"
        "e successfully.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOE",
        "Command Timeout Error: Occurs only if no response is returned within 6"
        "4 SDCLK cycles from the end bit of the command.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCE",
        "Command CRC Error: Command CRC Error is generated in two cases.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBE",
        "Command End Bit Error: Occurs when detecting that the end bit of a com"
        "mand response is 0.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        "Command Index Error: Occurs if a Command Index error occurs in the com"
        "mand response.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOE",
        "Data Timeout Error: Occurs when detecting one of following time-out co"
        "nditions.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCE",
        "Data CRC Error: Occurs when detecting a CRC error when transferring re"
        "ad data, which uses the DATA line, or when detecting the Write CRC sta"
        "tus having a value other than 010.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBE",
        "Data End Bit Error: Occurs either when detecting 0 at the end bit posi"
        "tion of read data, which uses the DATA line, or at the end bit positio"
        "n of the CRC.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12E",
        "Auto CMD12 Error: Occurs when detecting that one of the bits in the Au"
        "to CMD12 Error Status register has changed from 0 to 1.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNE",
        "Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unr"
        "ecoverable error is detected in a tuning circuit.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAE",
        "DMA Error: Occurs when an Internal DMA transfer has failed.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_INT_STATUS_EN.
static const field_t hw_usdhc_int_status_en[] =
{
    {
        "CCSEN",
        "Command Complete Status Enable: 1 Enabled 0 Masked",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEN",
        "Transfer Complete Status Enable:",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGESEN",
        "Block Gap Event Status Enable:",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTSEN",
        "DMA Interrupt Status Enable:",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRSEN",
        "Buffer Write Ready Status Enable:",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRSEN",
        "Buffer Read Ready Status Enable:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSSEN",
        "Card Insertion Status Enable:",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMSEN",
        "Card Removal Status Enable:",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTSEN",
        "Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will "
        "clear the interrupt request to the System.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTESEN",
        "Re-Tuning Event Status Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPSEN",
        "Tuning Pass Status Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOESEN",
        "Command Timeout Error Status Enable:",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCESEN",
        "Command CRC Error Status Enable:",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBESEN",
        "Command End Bit Error Status Enable:",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIESEN",
        "Command Index Error Status Enable:",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOESEN",
        "Data Timeout Error Status Enable:",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCESEN",
        "Data CRC Error Status Enable:",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBESEN",
        "Data End Bit Error Status Enable:",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12ESEN",
        "Auto CMD12 Error Status Enable:",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNESEN",
        "Tuning Error Status Enable:",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAESEN",
        "DMA Error Status Enable:",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_INT_SIGNAL_EN.
static const field_t hw_usdhc_int_signal_en[] =
{
    {
        "CCIEN",
        "Command Complete Interrupt Enable:",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIEN",
        "Transfer Complete Interrupt Enable:",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGEIEN",
        "Block Gap Event Interrupt Enable:",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTIEN",
        "DMA Interrupt Enable:",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRIEN",
        "Buffer Write Ready Interrupt Enable:",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRIEN",
        "Buffer Read Ready Interrupt Enable:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSIEN",
        "Card Insertion Interrupt Enable:",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMIEN",
        "Card Removal Interrupt Enable:",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTIEN",
        "Card Interrupt Interrupt Enable:",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEIEN",
        "Re-Tuning Event Interrupt Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPIEN",
        "Tuning Pass Interrupt Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOEIEN",
        "Command Timeout Error Interrupt Enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCEIEN",
        "Command CRC Error Interrupt Enable:",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBEIEN",
        "Command End Bit Error Interrupt Enable:",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIEIEN",
        "Command Index Error Interrupt Enable:",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOEIEN",
        "Data Timeout Error Interrupt Enable:",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEIEN",
        "Data CRC Error Interrupt Enable:",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBEIEN",
        "Data End Bit Error Interrupt Enable:",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EIEN",
        "Auto CMD12 Error Interrupt Enable:",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNEIEN",
        "Tuning Error Interrupt Enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAEIEN",
        "DMA Error Interrupt Enable:",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_AUTOCMD12_ERR_STATUS.
static const field_t hw_usdhc_autocmd12_err_status[] =
{
    {
        "AC12NE",
        "Auto CMD12 Not Executed: If memory multiple block data transfer is not"
        " started, due to a command error, this bit is not set because it is no"
        "t necessary to issue an Auto CMD12.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12TOE",
        "Auto CMD12/23 Timeout Error: Occurs if no response is returned within "
        "64 SDCLK cycles from the end bit of the command.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12EBE",
        "Auto CMD12/23 End Bit Error: Occurs when detecting that the end bit of"
        " command response is 0 which should be 1.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12CE",
        "Auto CMD12/23 CRC Error: Occurs when detecting a CRC error in the comm"
        "and response.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12IE",
        "Auto CMD12/23 Index Error: Occurs if the Command Index error occurs in"
        " response to a command.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNIBAC12E",
        "Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CM"
        "D_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this "
        "register.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXECUTE_TUNING",
        "Execute Tuning: When std_tuning_en bit is set, this bit is used to sta"
        "rt tuning procedure.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        "Sample Clock Select: When std_tuning_en bit is set, this bit is used t"
        "o select sampling clock to receive CMD and DATA.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_HOST_CTRL_CAP.
static const field_t hw_usdhc_host_ctrl_cap[] =
{
    {
        "SDR50_SUPPORT",
        "SDR50 support: This bit indicates support of SDR50 mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDR104_SUPPORT",
        "SDR104 support: This bit indicates support of SDR104 mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR50_SUPPORT",
        "DDR50 support: This bit indicates support of DDR50 mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TIME_COUNT_RETUNING",
        "Time counter for retuning: This bit indicates an initial value of the "
        "Retuning Timer for Re-Tuning Mode1 and 3.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_TUNING_SDR50",
        "Use Tuning for SDR50: This bit is set to 1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RETUNING_MODE",
        "Retuning Mode: This bit selects retuning method.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MBL",
        "Max Block Length: This value indicates the maximum block size that the"
        " Host Driver can read and write to the buffer in the uSDHC.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMAS",
        "ADMA Support: This bit indicates whether the uSDHC supports the ADMA f"
        "eature.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HSS",
        "High Speed Support: This bit indicates whether the uSDHC supports High"
        " Speed mode and the Host System can supply a SD Clock frequency from 2"
        "5 MHz to 50 MHz.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMAS",
        "DMA Support: This bit indicates whether the uSDHC is capable of using "
        "the internal DMA to transfer data between system memory and the data b"
        "uffer directly.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRS",
        "Suspend / Resume Support: This bit indicates whether the uSDHC support"
        "s Suspend / Resume functionality.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS33",
        "Voltage Support 3.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS30",
        "Voltage Support 3.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS18",
        "Voltage Support 1.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_WTMK_LVL.
static const field_t hw_usdhc_wtmk_lvl[] =
{
    {
        "RD_WML",
        "Read Watermark Level: The number of words used as the watermark level "
        "(FIFO threshold) in a DMA read operation.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_BRST_LEN",
        "Read Burst Length: Due to system restriction, the actual burst length "
        "may not exceed 16.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_WML",
        "Write Watermark Level: The number of words used as the watermark level"
        " (FIFO threshold) in a DMA write operation.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_BRST_LEN",
        "Write Burst Length: Due to system restriction, the actual burst length"
        " may not exceed 16.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_MIX_CTRL.
static const field_t hw_usdhc_mix_ctrl[] =
{
    {
        "DMAEN",
        "DMA Enable: This bit enables DMA functionality.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCEN",
        "Block Count Enable: This bit is used to enable the Block Count registe"
        "r, which is only relevant for multiple block transfers.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EN",
        "Auto CMD12 Enable: Multiple block transfers for memory require a CMD12"
        " to stop the transaction.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_EN",
        "Dual Data Rate mode selection",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTDSEL",
        "Data Transfer Direction Select: This bit defines the direction of DATA"
        " line data transfers.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSBSEL",
        "Multi / Single Block Select: This bit enables multiple block DATA line"
        " data transfers.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIBBLE_POS",
        "In DDR 4-bit mode nibble position indictation.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC23EN",
        "Auto CMD23 Enable When this bit is set to 1, the Host Controller issue"
        "s a CMD23 automatically before issuing a command specified in the Comm"
        "and Register.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXE_TUNE",
        "Execute Tuning: (Only used for SD3.0, SDR104 mode) When std_tuning_en "
        "is 0, this bit is set to 1 to indicate the Host Driver is starting tun"
        "ing procedure.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        "When std_tuning_en is 0, this bit is used to select Tuned clock or Fix"
        "ed clock to sample data/cmd (Only used for SD3.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_TUNE_EN",
        "Auto tuning enable (Only used for SD3.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBCLK_SEL",
        "Feedback clock source selection (Only used for SD3.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_FORCE_EVENT.
static const field_t hw_usdhc_force_event[] =
{
    {
        "FEVTAC12NE",
        "Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the"
        " Auto Command12 Error Status Register to be set",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12TOE",
        "Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in "
        "the Auto Command12 Error Status Register to be set",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12CE",
        "Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Au"
        "to Command12 Error Status Register to be set",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12EBE",
        "Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in t"
        "he Auto Command12 Error Status Register to be set",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12IE",
        "Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the "
        "Auto Command12 Error Status Register to be set",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCNIBAC12E",
        "Force Event Command Not Executed By Auto Command 12 Error: Forces the "
        "CNIBAC12E bit in the Auto Command12 Error Status Register to be set",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCTOE",
        "Force Event Command Time Out Error: Forces the CTOE bit of Interrupt S"
        "tatus Register to be set",
        16, // LSB
        16, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCCE",
        "Force Event Command CRC Error: Forces the CCE bit of Interrupt Status "
        "Register to be set",
        17, // LSB
        17, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCEBE",
        "Force Event Command End Bit Error: Forces the CEBE bit of Interrupt St"
        "atus Register to be set",
        18, // LSB
        18, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCIE",
        "Force Event Command Index Error: Forces the CCE bit of Interrupt Statu"
        "s Register to be set",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDTOE",
        "Force Event Data Time Out Error: Force the DTOE bit of Interrupt Statu"
        "s Register to be set",
        20, // LSB
        20, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDCE",
        "Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Reg"
        "ister to be set",
        21, // LSB
        21, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDEBE",
        "Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Statu"
        "s Register to be set",
        22, // LSB
        22, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12E",
        "Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt S"
        "tatus Register to be set",
        24, // LSB
        24, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTTNE",
        "Force Tuning Error: Forces the TNE bit of Interrupt Status Register to"
        " be set",
        26, // LSB
        26, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDMAE",
        "Force Event DMA Error: Forces the DMAE bit of Interrupt Status Registe"
        "r to be set",
        28, // LSB
        28, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCINT",
        "Force Event Card Interrupt: Writing 1 to this bit generates a short lo"
        "w-level pulse on the internal DATA1 line, as if a self clearing interr"
        "upt was received from the external card.",
        31, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_ADMA_ERR_STATUS.
static const field_t hw_usdhc_adma_err_status[] =
{
    {
        "ADMAES",
        "ADMA Error State (when ADMA Error is occurred.): This field indicates "
        "the state of the ADMA when an error has occurred during an ADMA data t"
        "ransfer.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMALME",
        "ADMA Length Mismatch Error: This error occurs in the following 2 cases"
        ": While the Block Count Enable is being set, the total data length spe"
        "cified by the Descriptor table is different from that specified by the"
        " Block Count and Block Length Total data length can not be divided by "
        "the block length",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMADCE",
        "ADMA Descritor Error: This error occurs when invalid descriptor fetche"
        "d by ADMA:",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_ADMA_SYS_ADDR.
static const field_t hw_usdhc_adma_sys_addr[] =
{
    {
        "ADS_ADDR",
        "ADMA System Address: This register holds the word address of the execu"
        "ting command in the Descriptor table.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_DLL_CTRL.
static const field_t hw_usdhc_dll_ctrl[] =
{
    {
        "DLL_CTRL_ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET0",
        "The delay target for the uSDHC loopback read clock can be programmed i"
        "n 1/16th increments of an ref_clock half-period.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_GATE_UPDATE",
        "Set this bit to 1 to prevent the DLL from updating (since when clock_i"
        "n exists, glitches may appear during DLL updates).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical tap"
        "s manually.",
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET1",
        "Refer to DLL_CTRL_SLV_DLY_TARGET0 below.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_UPDATE_INT",
        "Slave delay line update interval.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_UPDATE_INT",
        "DLL control loop update interval.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_DLL_STATUS.
static const field_t hw_usdhc_dll_status[] =
{
    {
        "DLL_STS_SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_LOCK",
        "Reference DLL lock status.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_SLV_SEL",
        "Slave delay line select status.",
        2, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_SEL",
        "Reference delay line select taps.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CLK_TUNE_CTRL_STATUS.
static const field_t hw_usdhc_clk_tune_ctrl_status[] =
{
    {
        "DLY_CELL_SET_POST",
        "Set the number of delay cells on the feedback clock between CLK_OUT an"
        "d CLK_POST.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_OUT",
        "Set the number of delay cells on the feedback clock between CLK_PRE an"
        "d CLK_OUT.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_PRE",
        "Set the number of delay cells on the feedback clock between the feedba"
        "ck clock and CLK_PRE.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NXT_ERR",
        "NXT error which means the number of delay cells added on the feedback "
        "clock is too large.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_POST",
        "Reflect the number of delay cells added on the feedback clock between "
        "CLK_OUT and CLK_POST.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_OUT",
        "Reflect the number of delay cells added on the feedback clock between "
        "CLK_PRE and CLK_OUT.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_PRE",
        "Reflects the number of delay cells added on the feedback clock between"
        " the feedback clock and CLK_PRE.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRE_ERR",
        "PRE error which means the number of delay cells added on the feedback "
        "clock is too small.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_VEND_SPEC.
static const field_t hw_usdhc_vend_spec[] =
{
    {
        "EXT_DMA_EN",
        "External DMA Request Enable Enable the request to external DMA.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSELECT",
        "Voltage Selection Change the value of output signal VSELECT, to contro"
        "l the voltage on pads for external card.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONFLICT_CHK_EN",
        "It's not implemented in uSDHC IP.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12_WR_CHKBUSY_EN",
        "Check busy enable after auto CMD12 for write data packet",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAT3_CD_POL",
        "Only for debug.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CD_POL",
        "Only for debug.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP_POL",
        "Only for debug.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKONJ_IN_ABORT",
        "Only for debug.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_SDCLK_ON",
        "Force CLK output active:",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_CLK_SOFT_EN",
        "IPG_CLK software enable",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCLK_SOFT_EN",
        "Please note, hardware auto-enables the AHB clock when the internal DMA"
        " is enabled even if HCLK_SOFT_EN is 0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_PERCLK_SOFT_EN",
        "ipg_perclk software enable",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_CLK_SOFT_EN",
        "card clock software enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_CHK_DIS",
        "CRC check disable",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_ST_VAL",
        "Internal State Value Internal state value, reflecting the correspondin"
        "g state value selected by Debug Select field.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMD_BYTE_EN",
        "byte access",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_MMC_BOOT.
static const field_t hw_usdhc_mmc_boot[] =
{
    {
        "DTOCV_ACK",
        "Boot ACK time out counter value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_ACK",
        "Boot ack mode select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_MODE",
        "Boot mode select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_EN",
        "Boot mode enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_SABG_EN",
        "During boot, enable auto stop at block gap function.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_TIME_OUT",
        "Please note, when this bit is set, there is no timeout check no matter"
        " whether boot_en is set or not.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_BLK_CNT",
        "The value defines the Stop At Block Gap value of automatic mode.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_VEND_SPEC2.
static const field_t hw_usdhc_vend_spec2[] =
{
    {
        "SDR104_TIMING_DIS",
        "Timeout counter test.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_OE_DIS",
        "CMD_OE/DATA_OE logic generation test.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_NSD_DIS",
        "Interrupt window after abort command is sent.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_D3_TEST",
        "Card interrupt detection test.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_8BIT_EN",
        "Enable the auto tuning circuit to check the DATA[7:0].",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_1BIT_EN",
        "Enable the auto tuning circuit to check the DATA0 only.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_CMD_EN",
        "Enable the auto tuning circuit to check the CMD line.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_AUTO_CLR_DIS",
        "Disable the feature to clear the Card interrupt status bit when Card I"
        "nterrupt status enable bit is cleared.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_TUNING_CTRL.
static const field_t hw_usdhc_tuning_ctrl[] =
{
    {
        "TUNING_START_TAP",
        "The start dealy cell point when send first CMD19 in tuning procedure.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_COUNTER",
        "The MAX repeat CMD19 times in tuning procedure.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_STEP",
        "The increasing delay cell step in tuning procedure.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_WINDOW",
        "Select data window value for auto tuning",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STD_TUNING_EN",
        "Standard tuning circuit and procedure enable: This bit is used to enab"
        "le standard tuning circuit and procedure.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USDHC module.
static const reg_t hw_usdhc[] =
{
    {
        "DS_ADDR",
        "This register contains the physical system memory address used for DMA"
        " transfers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_ds_addr
    },
    {
        "BLK_ATT",
        "This register is used to configure the number of data blocks and the n"
        "umber of bytes in each block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usdhc_blk_att
    },
    {
        "CMD_ARG",
        "This register contains the SD/MMC Command Argument.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_arg
    },
    {
        "CMD_XFR_TYP",
        "This register is used to control the operation of data transfers.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usdhc_cmd_xfr_typ
    },
    {
        "CMD_RSP0",
        "This register is used to store part 0 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp0
    },
    {
        "CMD_RSP1",
        "This register is used to store part 1 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp1
    },
    {
        "CMD_RSP2",
        "This register is used to store part 2 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp2
    },
    {
        "CMD_RSP3",
        "This register is used to store part 3 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp3
    },
    {
        "DATA_BUFF_ACC_PORT",
        "This is a 32-bit data port register used to access the internal buffer"
        ".",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_data_buff_acc_port
    },
    {
        "PRES_STATE",
        "The Host Driver can get status of the uSDHC from this 32-bit read only"
        " register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_usdhc_pres_state
    },
    {
        "PROT_CTRL",
        "There are three cases to restart the transfer after stop at the block "
        "gap.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_prot_ctrl
    },
    {
        "SYS_CTRL",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usdhc_sys_ctrl
    },
    {
        "INT_STATUS",
        "An interrupt is generated when the Normal Interrupt Signal Enable is e"
        "nabled and at least one of the status bits is set to 1.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status
    },
    {
        "INT_STATUS_EN",
        "Setting the bits in this register to 1 enables the corresponding Inter"
        "rupt Status to be set by the specified event.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status_en
    },
    {
        "INT_SIGNAL_EN",
        "This register is used to select which interrupt status is indicated to"
        " the Host System as the interrupt.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_signal_en
    },
    {
        "AUTOCMD12_ERR_STATUS",
        "When the Auto CMD12 Error Status bit in the Status register is set, th"
        "e Host Driver shall check this register to identify what kind of error"
        " the Auto CMD12 / CMD 23 indicated.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_autocmd12_err_status
    },
    {
        "HOST_CTRL_CAP",
        "This register provides the Host Driver with information specific to th"
        "e uSDHC implementation.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_usdhc_host_ctrl_cap
    },
    {
        "WTMK_LVL",
        "Both write and read watermark levels (FIFO threshold) are configurable"
        ".",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usdhc_wtmk_lvl
    },
    {
        "MIX_CTRL",
        "This register is used to DMA and data transfer.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usdhc_mix_ctrl
    },
    {
        "FORCE_EVENT",
        "The Force Event Register is not a physically implemented register.",
        4, // Width in bytes
        0x00000050, // Base address offset
        false, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_force_event
    },
    {
        "ADMA_ERR_STATUS",
        "When an ADMA Error Interrupt has occurred, the ADMA Error States field"
        " in this register holds the ADMA state and the ADMA System Address reg"
        "ister holds the address around the error descriptor.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usdhc_adma_err_status
    },
    {
        "ADMA_SYS_ADDR",
        "This register contains the physical system memory address used for ADM"
        "A transfers.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_adma_sys_addr
    },
    {
        "DLL_CTRL",
        "This register contains control bits for DLL.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usdhc_dll_ctrl
    },
    {
        "DLL_STATUS",
        "This register contains the DLL status information.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usdhc_dll_status
    },
    {
        "CLK_TUNE_CTRL_STATUS",
        "This register contains the Clock Tuning Control status information.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_clk_tune_ctrl_status
    },
    {
        "VEND_SPEC",
        "This register contains the vendor specific control/status register.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_usdhc_vend_spec
    },
    {
        "MMC_BOOT",
        "This register contains the MMC Fast Boot control register.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usdhc_mmc_boot
    },
    {
        "VEND_SPEC2",
        "This register contains the vendor specific control 2 register.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_vend_spec2
    },
    {
        "TUNING_CTRL",
        "The register contains configuration of tunning circuit.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usdhc_tuning_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark VDEC
#endif

// Bitfields in register VDEC_CFC1.
static const field_t hw_vdec_cfc1[] =
{
    {
        "RC_COMBMODE_OVERRIDE",
        "Overrides the automatic comb mode for various standards.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_DEBUGOUT",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_BRSTGT.
static const field_t hw_vdec_brstgt[] =
{
    {
        "RC_CBURSTSTART",
        "This sets the starting position of the burst measurement gate.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_HZPOS.
static const field_t hw_vdec_hzpos[] =
{
    {
        "RO_HPRAMP_CMP",
        "Horizontal position of output.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VRTPOS.
static const field_t hw_vdec_vrtpos[] =
{
    {
        "RO_VLINE_CMP",
        "Vertical position of output.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_HVSHFT.
static const field_t hw_vdec_hvshft[] =
{
    {
        "RO_HZERO_SEL",
        "When set to 1, the output screen will be shifted by half a screen hori"
        "zontally so the H blank areas can be set for debug.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RO_INVFIELD",
        "Invert the field output pin.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RO_VZERO_SEL",
        "When set to 1, the output screen is shifted vertically so the V blank "
        "areas can be set for debug.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RO_USEACTIVE",
        "Use the output active video signals to enable and blank the output vid"
        "eo.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANTIALIAS_DIS",
        "When set to 1, anti-alias filter is bypassed.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_HSIGS.
static const field_t hw_vdec_hsigs[] =
{
    {
        "RV_IGNORESTART",
        "Line number (in half lines) of the ignore period.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_HSIGE.
static const field_t hw_vdec_hsige[] =
{
    {
        "RV_IGNOREEND",
        "Line number (in half lines) of the ignore period.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VSCON1.
static const field_t hw_vdec_vscon1[] =
{
    {
        "RH_VDET_DBG",
        "Sets the Vsync debug output mode that can be seen by setting VIDOUTDBG"
        "[r_sel2] to 1.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_ROBUST625DET",
        "Selects a more robust method of determining 525 or 625 line mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_DIS_VSYNCDETECT",
        "When set, do not look for any new vsync phases.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_VSYNCHALFMODE",
        "Use half lines instead of quarter lines.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_MODADD_DIS",
        "Debug test mode only",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_8OR16",
        "Select vsync detector",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VSCON2.
static const field_t hw_vdec_vscon2[] =
{
    {
        "RH_VCR_PHASETHR",
        "The higher the value the less likely that we will detect a VCR (ie the"
        " more erratic a VCR needs to be to be detected).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_VCR_FORCE_DIS",
        "",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_HSW_CORING",
        "Coring value for phase variance measurement in headswitch detector.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_SMOOTH_HSW",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_DISABLE_HSW",
        "Disable detection of VCR head switches",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_YCDEL.
static const field_t hw_vdec_ycdel[] =
{
    {
        "RD_NOPALAVE",
        "Turn off the two-line PAL chroma averaging.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_NARROW",
        "Force the chroma output low-pass filter into narrow mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_WIDE",
        "Force the chroma output low pass filter into wide mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_LUMADEL",
        "Luma delay relative to chroma in half pixel increments",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_AFTCLP.
static const field_t hw_vdec_aftclp[] =
{
    {
        "RH_SHORTFRAME",
        "In normal operation, this field should be cleared to 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL_DISOFFSET",
        "Disables the DC offset output.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL_RESETOFFSET",
        "Reset the integrator in the DC offset block",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_AFTERCLAMP_UPDATE_EN",
        "Enables the after clamp line-by-line updates",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_MIDFIELD_DIS",
        "When rc_afterclamp_update_en is set to 1 and this field is:",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_AOUTOAFTERCLAMP_DIS",
        "Disables the auto-level measurement in the after-clamp block.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_DCOFF.
static const field_t hw_vdec_dcoff[] =
{
    {
        "RL_DCOFFSETI",
        "Integrator gain of DC-offset calculation",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL_LINEMEASURE_DIS",
        "Disable line-by-line measurement for input clamp/DC-offset block",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL_DCOFFSETP",
        "Proportional gain of DC offset calculation",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_CSID.
static const field_t hw_vdec_csid[] =
{
    {
        "RD_SWAPCRCB",
        "Swap Cr and Cb outputs.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_INVCR",
        "Invert Cr output",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_INVCB",
        "Invert Cb output",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_NOPALHUE",
        "1 = disable the hue function when in PAL mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_BYPASSHILBERT",
        "Disable the hilbert filter in the chroma demodulator (debug only)",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_CBGN.
static const field_t hw_vdec_cbgn[] =
{
    {
        "RD_CBGAIN",
        "Gain of Cb output.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_CRGN.
static const field_t hw_vdec_crgn[] =
{
    {
        "RD_CRGAIN",
        "Gain of Cr output.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_CNTR.
static const field_t hw_vdec_cntr[] =
{
    {
        "RD_LUMAGAIN",
        "This is equivalent to contrast.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_BRT.
static const field_t hw_vdec_brt[] =
{
    {
        "RC_BLACKLEVEL",
        "This is equivalent to brightness.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_HUE.
static const field_t hw_vdec_hue[] =
{
    {
        "RD_CH_THRESH",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_CHBTH.
static const field_t hw_vdec_chbth[] =
{
    {
        "RD_CH_THRESH",
        "This is the level above which the chroma burst must be in order to pro"
        "cess chroma.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_SHPIMP.
static const field_t hw_vdec_shpimp[] =
{
    {
        "RD_PEAK",
        "Added luma sharpness 0 No sharpness increase 15 Maximum sharpness incr"
        "ease",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_SLOPE",
        "Slope value is a signed number.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_CHPLLIM.
static const field_t hw_vdec_chpllim[] =
{
    {
        "RD_INPUTCABLES",
        "Set the input mode.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_LOCKED_FORCE",
        "Force chroma to always think its locked.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_CHLOCK_ATTEN",
        "Sets the attenuation for the chroma lock detector.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VIDMOD.
static const field_t hw_vdec_vidmod[] =
{
    {
        "HAVESIGNAL",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HLOCKED",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHROMA",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH_LOCKED",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M625",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "F443",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PAL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VIDSTS.
static const field_t hw_vdec_vidsts[] =
{
    {
        "NONARITH",
        "High when an invalid nonarithmetic ratio detected",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NONARITH3D",
        "High when an invalid nonarithmetic ratio for 3D comb is detected",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VCRDETECT",
        "High when a VCR signal is detected",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_NOISE.
static const field_t hw_vdec_noise[] =
{
    {
        "NOISE",
        "Noise detector output.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_STDDBG.
static const field_t hw_vdec_stddbg[] =
{
    {
        "STANDARD_FILTER",
        "This field should be set to 3.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORCE_HAVESIGNAL",
        "Override the video signal detector so as to appear to always have a va"
        "lid video signal.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORCE_2DNTSC443",
        "For the use of the 2D comb filter in NTSC 443 mode",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NTSCJ",
        "When this field is set to 1, detection of NTSC will not remove the ped"
        "estal level.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_FC_MAUAL",
        "Enable manual Fc carrier frequency instead of hardcoded internal frequ"
        "encies.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_MANOVR.
static const field_t hw_vdec_manovr[] =
{
    {
        "MANUAL_625",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FOUR43_MANUAL",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAL_MANUAL",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINE625_OVERRIDE",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F443_OVERRIDE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAL_OVERRIDE",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VSSGTH.
static const field_t hw_vdec_vssgth[] =
{
    {
        "NOSIGTHRESH",
        "Sets the no-signal detection threshold",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RH_VSYNCLENGTH",
        "Sets the length of the vsync detector, which is the number of consecut"
        "ive vsyncs in the same place required to set a new phase/freq.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_DBGFBH.
static const field_t hw_vdec_dbgfbh[] =
{
    {
        "CLAMP_DELAYH",
        "Sets the delay in 13.5MHz clocks for the application of the up/down pu"
        "lses for the AFE DC clamp control.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_DBGFBL.
static const field_t hw_vdec_dbgfbl[] =
{
    {
        "CLAMP_DELAYL",
        "Sets the delay in 13.5MHz clocks for the application of the up/down pu"
        "lses for the AFE DC clamp control.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_HACTS.
static const field_t hw_vdec_hacts[] =
{
    {
        "RO_HACTIVESTART",
        "Programs the start of the Hactive output.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_HACTE.
static const field_t hw_vdec_hacte[] =
{
    {
        "RO_HACTIVEEND",
        "Programs the end of the Hactive output.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VACTS.
static const field_t hw_vdec_vacts[] =
{
    {
        "RO_VACTIVESTART",
        "Programs the start of the Vactive output.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VACTE.
static const field_t hw_vdec_vacte[] =
{
    {
        "RO_VACTIVEEND",
        "Programs the end of the Vactive output.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_HSTIP.
static const field_t hw_vdec_hstip[] =
{
    {
        "RH_TIPGATE_START",
        "Set the position in pixels of the start of the Hsync tip gate, which i"
        "s always 32 pixels.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_BLSCRCR.
static const field_t hw_vdec_blscrcr[] =
{
    {
        "BLUESCREEN_Y",
        "The Y output value when in bluescreen mode, which is set when there is"
        " no valid video signal input detected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_BLSCRCB.
static const field_t hw_vdec_blscrcb[] =
{
    {
        "BLUESCREEN_CB",
        "The Cb output value when in blue screen mode, which is set when there "
        "is no valid video signal input detected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_LMAGC2.
static const field_t hw_vdec_lmagc2[] =
{
    {
        "RAGC_TARGET",
        "Sets the sync tip to black level target value for the AGC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_CHAGC2.
static const field_t hw_vdec_chagc2[] =
{
    {
        "RD_CHAGC_TARGET",
        "Sets the burst target height for the chroma AGC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_MINTH.
static const field_t hw_vdec_minth[] =
{
    {
        "MINTHRESH",
        "Sets the threshold for the minimum filter in the Hsync PLL.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VFRQOH.
static const field_t hw_vdec_vfrqoh[] =
{
    {
        "VFREQO",
        "Number of half vertical lines detected in video field.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_VFRQOL.
static const field_t hw_vdec_vfrqol[] =
{
    {
        "VFREQO",
        "Number of half vertical lines detected in video field.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_ASYNCLKFREQ1.
static const field_t hw_vdec_asynclkfreq1[] =
{
    {
        "ASYNCHCLK_FREQUENCY",
        "This constant is used to setup the resampler and resampler DTO for the"
        " supplied external asynchronous sampling clock frequency.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_ASYNCLKFREQ2.
static const field_t hw_vdec_asynclkfreq2[] =
{
    {
        "ASYNCHCLK_FREQUENCY",
        "This constant is used to setup the resampler and resampler DTO for the"
        " supplied external asynchronous sampling clock frequency.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_ASYNCLKFREQ3.
static const field_t hw_vdec_asynclkfreq3[] =
{
    {
        "ASYNCHCLK_FREQUENCY",
        "This constant is used to setup the resampler and resampler DTO for the"
        " supplied external asynchronous sampling clock frequency.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VDEC_ASYNCLKFREQ4.
static const field_t hw_vdec_asynclkfreq4[] =
{
    {
        "ASYNCHCLK_FREQUENCY",
        "This constant is used to setup the resampler and resampler DTO for the"
        " supplied external asynchronous sampling clock frequency.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a VDEC module.
static const reg_t hw_vdec[] =
{
    {
        "CFC1",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vdec_cfc1
    },
    {
        "BRSTGT",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_brstgt
    },
    {
        "HZPOS",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_hzpos
    },
    {
        "VRTPOS",
        "Vertical position of output.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_vrtpos
    },
    {
        "HVSHFT",
        "",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_vdec_hvshft
    },
    {
        "HSIGS",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_hsigs
    },
    {
        "HSIGE",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_hsige
    },
    {
        "VSCON1",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_vdec_vscon1
    },
    {
        "VSCON2",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_vdec_vscon2
    },
    {
        "YCDEL",
        "",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_vdec_ycdel
    },
    {
        "AFTCLP",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_vdec_aftclp
    },
    {
        "DCOFF",
        "",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_vdec_dcoff
    },
    {
        "CSID",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_vdec_csid
    },
    {
        "CBGN",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_cbgn
    },
    {
        "CRGN",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_crgn
    },
    {
        "CNTR",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_cntr
    },
    {
        "BRT",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_brt
    },
    {
        "HUE",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_hue
    },
    {
        "CHBTH",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_chbth
    },
    {
        "SHPIMP",
        "",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vdec_shpimp
    },
    {
        "CHPLLIM",
        "",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_vdec_chpllim
    },
    {
        "VIDMOD",
        "",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_vdec_vidmod
    },
    {
        "VIDSTS",
        "",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_vdec_vidsts
    },
    {
        "NOISE",
        "",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_vdec_noise
    },
    {
        "STDDBG",
        "",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_vdec_stddbg
    },
    {
        "MANOVR",
        "Pink cast over images in PAL mode can be got rid of by writing a value"
        " of 0xFD in this register.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_vdec_manovr
    },
    {
        "VSSGTH",
        "",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_vdec_vssgth
    },
    {
        "DBGFBH",
        "",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_dbgfbh
    },
    {
        "DBGFBL",
        "",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_dbgfbl
    },
    {
        "HACTS",
        "",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_hacts
    },
    {
        "HACTE",
        "",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_hacte
    },
    {
        "VACTS",
        "",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_vacts
    },
    {
        "VACTE",
        "",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_vacte
    },
    {
        "HSTIP",
        "",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_hstip
    },
    {
        "BLSCRCR",
        "",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_blscrcr
    },
    {
        "BLSCRCB",
        "",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_blscrcb
    },
    {
        "LMAGC2",
        "",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_lmagc2
    },
    {
        "CHAGC2",
        "",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_chagc2
    },
    {
        "MINTH",
        "",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_minth
    },
    {
        "VFRQOH",
        "",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_vdec_vfrqoh
    },
    {
        "VFRQOL",
        "",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_vdec_vfrqol
    },
    {
        "ASYNCLKFREQ1",
        "",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_asynclkfreq1
    },
    {
        "ASYNCLKFREQ2",
        "",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_asynclkfreq2
    },
    {
        "ASYNCLKFREQ3",
        "",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_asynclkfreq3
    },
    {
        "ASYNCLKFREQ4",
        "",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_vdec_asynclkfreq4
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark WDOG
#endif

// Bitfields in register WDOG_WCR.
static const field_t hw_wdog_wcr[] =
{
    {
        "WDZST",
        "Watchdog Low Power.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDBG",
        "Watchdog DEBUG Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDE",
        "Watchdog Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDT",
        "WDOG_B Time-out assertion.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRS",
        "Software Reset Signal.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDA",
        "WDOG_B assertion.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "adopt a new way to generate a more robust software reset.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDW",
        "Watchdog Disable for Wait.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WT",
        "Watchdog Time-out Field.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WSR.
static const field_t hw_wdog_wsr[] =
{
    {
        "WSR",
        "Watchdog Service Register.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WRSR.
static const field_t hw_wdog_wrsr[] =
{
    {
        "SFTW",
        "Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TOUT",
        "Timeout.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POR",
        "Power On Reset.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WICR.
static const field_t hw_wdog_wicr[] =
{
    {
        "WICT",
        "Watchdog Interrupt Count Time-out (WICT) field determines, how long be"
        "fore the counter time-out must the interrupt occur.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTIS",
        "Watchdog TImer Interrupt Status bit will reflect the timer interrupt s"
        "tatus, whether interrupt has occurred or not.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "Watchdog Timer Interrupt enable bit.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WMCR.
static const field_t hw_wdog_wmcr[] =
{
    {
        "PDE",
        "Power Down Enable bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a WDOG module.
static const reg_t hw_wdog[] =
{
    {
        "WCR",
        "The Watchdog Control Register (WDOG_WCR) controls the WDOG operation.",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_wdog_wcr
    },
    {
        "WSR",
        "When enabled, the WDOG requires that a service sequence be written to "
        "the Watchdog Service Register (WSR) to prevent the timeout condition.",
        2, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wdog_wsr
    },
    {
        "WRSR",
        "The WRSR is a read-only register that records the source of the output"
        " reset assertion.",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_wdog_wrsr
    },
    {
        "WICR",
        "The WDOG_WICR controls the WDOG interrupt generation.",
        2, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_wdog_wicr
    },
    {
        "WMCR",
        "WDOG_WMCR Controls the Power Down counter operation.",
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wdog_wmcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark XTALOSC24M
#endif

// Bitfields in register XTALOSC24M_MISC0.
static const field_t hw_xtalosc24m_misc0[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to oscillator.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_RINGOSC_EN",
        "Enables the internal ring oscillator that can be used in lieu of an ex"
        "ternal 32k crystal.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LOWPWR_CTRL.
static const field_t hw_xtalosc24m_lowpwr_ctrl[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LOWPWR_CTRL_SET.
static const field_t hw_xtalosc24m_lowpwr_ctrl_set[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LOWPWR_CTRL_CLR.
static const field_t hw_xtalosc24m_lowpwr_ctrl_clr[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LOWPWR_CTRL_TOG.
static const field_t hw_xtalosc24m_lowpwr_ctrl_tog[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG0.
static const field_t hw_xtalosc24m_osc_config0[] =
{
    {
        "START",
        "Start/stop bit for the RC tuning calculation logic.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enables the tuning logic to calculate new RC tuning values.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypasses any calculated RC tuning value and uses the programmed regist"
        "er value.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERT",
        "Invert the stepping of the calculated RC tuning value.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        4, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_PLUS",
        "Positive hysteresis value.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_MINUS",
        "Negative hysteresis value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG_CUR",
        "The current tuning value in use.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG0_SET.
static const field_t hw_xtalosc24m_osc_config0_set[] =
{
    {
        "START",
        "Start/stop bit for the RC tuning calculation logic.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enables the tuning logic to calculate new RC tuning values.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypasses any calculated RC tuning value and uses the programmed regist"
        "er value.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERT",
        "Invert the stepping of the calculated RC tuning value.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        4, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_PLUS",
        "Positive hysteresis value.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_MINUS",
        "Negative hysteresis value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG_CUR",
        "The current tuning value in use.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG0_CLR.
static const field_t hw_xtalosc24m_osc_config0_clr[] =
{
    {
        "START",
        "Start/stop bit for the RC tuning calculation logic.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enables the tuning logic to calculate new RC tuning values.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypasses any calculated RC tuning value and uses the programmed regist"
        "er value.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERT",
        "Invert the stepping of the calculated RC tuning value.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        4, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_PLUS",
        "Positive hysteresis value.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_MINUS",
        "Negative hysteresis value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG_CUR",
        "The current tuning value in use.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG0_TOG.
static const field_t hw_xtalosc24m_osc_config0_tog[] =
{
    {
        "START",
        "Start/stop bit for the RC tuning calculation logic.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enables the tuning logic to calculate new RC tuning values.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypasses any calculated RC tuning value and uses the programmed regist"
        "er value.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERT",
        "Invert the stepping of the calculated RC tuning value.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        4, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_PLUS",
        "Positive hysteresis value.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_MINUS",
        "Negative hysteresis value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG_CUR",
        "The current tuning value in use.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG1.
static const field_t hw_xtalosc24m_osc_config1[] =
{
    {
        "COUNT_RC_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNT_RC_CUR",
        "The current tuning value in use.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG1_SET.
static const field_t hw_xtalosc24m_osc_config1_set[] =
{
    {
        "COUNT_RC_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNT_RC_CUR",
        "The current tuning value in use.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG1_CLR.
static const field_t hw_xtalosc24m_osc_config1_clr[] =
{
    {
        "COUNT_RC_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNT_RC_CUR",
        "The current tuning value in use.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG1_TOG.
static const field_t hw_xtalosc24m_osc_config1_tog[] =
{
    {
        "COUNT_RC_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNT_RC_CUR",
        "The current tuning value in use.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG2.
static const field_t hw_xtalosc24m_osc_config2[] =
{
    {
        "COUNT_1M_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_1M",
        "Enable the 1MHz clock output.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_1M",
        "Mux the corrected or uncorrected 1MHz clock to the output.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_1M_ERR_FL",
        "Flag indicates that the count_1m count wasn't reached within 1 32KHz p"
        "eriod.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG2_SET.
static const field_t hw_xtalosc24m_osc_config2_set[] =
{
    {
        "COUNT_1M_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_1M",
        "Enable the 1MHz clock output.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_1M",
        "Mux the corrected or uncorrected 1MHz clock to the output.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_1M_ERR_FL",
        "Flag indicates that the count_1m count wasn't reached within 1 32KHz p"
        "eriod.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG2_CLR.
static const field_t hw_xtalosc24m_osc_config2_clr[] =
{
    {
        "COUNT_1M_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_1M",
        "Enable the 1MHz clock output.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_1M",
        "Mux the corrected or uncorrected 1MHz clock to the output.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_1M_ERR_FL",
        "Flag indicates that the count_1m count wasn't reached within 1 32KHz p"
        "eriod.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG2_TOG.
static const field_t hw_xtalosc24m_osc_config2_tog[] =
{
    {
        "COUNT_1M_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_1M",
        "Enable the 1MHz clock output.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_1M",
        "Mux the corrected or uncorrected 1MHz clock to the output.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_1M_ERR_FL",
        "Flag indicates that the count_1m count wasn't reached within 1 32KHz p"
        "eriod.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a XTALOSC24M module.
static const reg_t hw_xtalosc24m[] =
{
    {
        "MISC0",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_xtalosc24m_misc0
    },
    {
        "LOWPWR_CTRL",
        "This register defines xtal osc and low power configuration.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_xtalosc24m_lowpwr_ctrl
    },
    {
        "LOWPWR_CTRL_SET",
        "This register defines xtal osc and low power configuration.",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_xtalosc24m_lowpwr_ctrl_set
    },
    {
        "LOWPWR_CTRL_CLR",
        "This register defines xtal osc and low power configuration.",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_xtalosc24m_lowpwr_ctrl_clr
    },
    {
        "LOWPWR_CTRL_TOG",
        "This register defines xtal osc and low power configuration.",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_xtalosc24m_lowpwr_ctrl_tog
    },
    {
        "OSC_CONFIG0",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xtalosc24m_osc_config0
    },
    {
        "OSC_CONFIG0_SET",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xtalosc24m_osc_config0_set
    },
    {
        "OSC_CONFIG0_CLR",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xtalosc24m_osc_config0_clr
    },
    {
        "OSC_CONFIG0_TOG",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xtalosc24m_osc_config0_tog
    },
    {
        "OSC_CONFIG1",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xtalosc24m_osc_config1
    },
    {
        "OSC_CONFIG1_SET",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xtalosc24m_osc_config1_set
    },
    {
        "OSC_CONFIG1_CLR",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xtalosc24m_osc_config1_clr
    },
    {
        "OSC_CONFIG1_TOG",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xtalosc24m_osc_config1_tog
    },
    {
        "OSC_CONFIG2",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_xtalosc24m_osc_config2
    },
    {
        "OSC_CONFIG2_SET",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_xtalosc24m_osc_config2_set
    },
    {
        "OSC_CONFIG2_CLR",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_xtalosc24m_osc_config2_clr
    },
    {
        "OSC_CONFIG2_TOG",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_xtalosc24m_osc_config2_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark mx6
#endif

const module_t mx6sx[] =
{
    // Module name, instance number, base address, register count, register definitions
    { "ADC1",           1, 0x02280000, 11,   hw_adc },
    { "ADC2",           2, 0x02284000, 11,   hw_adc },
    { "AFE",            1, 0x02228000, 34,   hw_afe },
    { "ASRC",           1, 0x02034000, 38,   hw_asrc },
    { "AUDMUX",         1, 0x021d8000, 14,   hw_audmux },
    { "BCH",            1, 0x01808000, 88,   hw_bch },
    { "CCM",            1, 0x020c4000, 31,   hw_ccm },
    { "CCM_ANALOG",     1, 0x020c8000, 53,   hw_ccm_analog },
    { "CSI1",           1, 0x02214000, 15,   hw_csi },
    { "CSI2",           2, 0x0221c000, 15,   hw_csi },
    { "DCIC1",          1, 0x0220c000, 7,    hw_dcic },
    { "DCIC2",          2, 0x02210000, 7,    hw_dcic },
    { "DVFSC",          1, 0x020dc180, 17,   hw_dvfsc },
    { "ECSPI1",         1, 0x02008000, 10,   hw_ecspi },
    { "ECSPI2",         2, 0x0200c000, 10,   hw_ecspi },
    { "ECSPI3",         3, 0x02010000, 10,   hw_ecspi },
    { "ECSPI4",         4, 0x02014000, 10,   hw_ecspi },
    { "ECSPI5",         5, 0x02018000, 10,   hw_ecspi },
    { "EIM",            1, 0x021b8000, 41,   hw_eim },
    { "ENET1",          1, 0x02188000, 119,  hw_enet },
    { "ENET2",          2, 0x021b4000, 119,  hw_enet },
    { "EPIT1",          1, 0x020d0000, 5,    hw_epit },
    { "EPIT2",          2, 0x020d4000, 5,    hw_epit },
    { "ESAI",           1, 0x02024000, 31,   hw_esai },
    { "FLEXCAN1",       1, 0x02090000, 19,   hw_flexcan },
    { "FLEXCAN2",       2, 0x02094000, 19,   hw_flexcan },
    { "GIS",            1, 0x02204000, 163,  hw_gis },
    { "GPC",            1, 0x020dc000, 13,   hw_gpc },
    { "GPIO1",          1, 0x0209c000, 8,    hw_gpio },
    { "GPIO2",          2, 0x020a0000, 8,    hw_gpio },
    { "GPIO3",          3, 0x020a4000, 8,    hw_gpio },
    { "GPIO4",          4, 0x020a8000, 8,    hw_gpio },
    { "GPIO5",          5, 0x020ac000, 8,    hw_gpio },
    { "GPIO6",          6, 0x020b0000, 8,    hw_gpio },
    { "GPIO7",          7, 0x020b4000, 8,    hw_gpio },
    { "GPMI",           1, 0x01806000, 29,   hw_gpmi },
    { "GPT",            1, 0x02098000, 10,   hw_gpt },
    { "I2C1",           1, 0x021a0000, 5,    hw_i2c },
    { "I2C2",           2, 0x021a4000, 5,    hw_i2c },
    { "I2C3",           3, 0x021a8000, 5,    hw_i2c },
    { "I2C4",           4, 0x021f8000, 5,    hw_i2c },
    { "I2S1",           1, 0x021d4000, 18,   hw_i2s },
    { "I2S2",           2, 0x021dc000, 18,   hw_i2s },
    { "IOMUXC",         1, 0x020e0000, 538,  hw_iomuxc },
    { "IOMUXC_GPR",     1, 0x020e4000, 14,   hw_iomuxc_gpr },
    { "KPP",            1, 0x020b8000, 4,    hw_kpp },
    { "LCDIF1",         1, 0x02220000, 54,   hw_lcdif },
    { "LCDIF2",         2, 0x02224000, 54,   hw_lcdif },
    { "LDB",            1, 0x020e0014, 1,    hw_ldb },
    { "LMEM",           1, 0xe0002000, 8,    hw_lmem },
    { "MCM",            1, 0xe0000000, 5,    hw_mcm },
    { "MLB",            1, 0x0218c000, 30,   hw_mlb },
    { "MMDC",           1, 0x021b0000, 79,   hw_mmdc },
    { "MU",             1, 0x02294000, 10,   hw_mu },
    { "M_CAN1",         1, 0x020e8000, 45,   hw_m_can },
    { "M_CAN2",         2, 0x020f0000, 45,   hw_m_can },
    { "OCOTP",          1, 0x021bc000, 55,   hw_ocotp },
    { "PGC_ARM",        1, 0x020dc040, 20,   hw_pgc },
    { "PGC_GPU",        2, 0x020dc000, 20,   hw_pgc },
    { "PMU",            1, 0x020c8000, 16,   hw_pmu },
    { "PWM1",           1, 0x02080000, 6,    hw_pwm },
    { "PWM2",           2, 0x02084000, 6,    hw_pwm },
    { "PWM3",           3, 0x02088000, 6,    hw_pwm },
    { "PWM4",           4, 0x0208c000, 6,    hw_pwm },
    { "PWM5",           5, 0x022a4000, 6,    hw_pwm },
    { "PWM6",           6, 0x022a8000, 6,    hw_pwm },
    { "PWM7",           7, 0x022ac000, 6,    hw_pwm },
    { "PWM8",           8, 0x022b0000, 6,    hw_pwm },
    { "PXP",            1, 0x02218000, 52,   hw_pxp },
    { "QUADSPI1",       1, 0x021e0000, 124,  hw_quadspi },
    { "QUADSPI2",       2, 0x021e4000, 124,  hw_quadspi },
    { "RDC",            1, 0x020fc000, 366,  hw_rdc },
    { "RDC_SEMAPHORE1", 1, 0x020f4000, 66,   hw_rdc_semaphore },
    { "RDC_SEMAPHORE2", 2, 0x020f8000, 66,   hw_rdc_semaphore },
    { "ROMC",           1, 0x021ac000, 28,   hw_romc },
    { "SDMAARM",        1, 0x020ec000, 106,  hw_sdmaarm },
    { "SDMABP",         1, 0x020ec000, 7,    hw_sdmabp },
    { "SDMACORE",       1, 0x020ec000, 21,   hw_sdmacore },
    { "SEMA4",          1, 0x02290000, 22,   hw_sema4 },
    { "SJC",            1, 0x00000000, 7,    hw_sjc },
    { "SNVS",           1, 0x020cc000, 16,   hw_snvs },
    { "SPBA",           1, 0x00000000, 32,   hw_spba },
    { "SPDIF",          1, 0x02004000, 18,   hw_spdif },
    { "SRC",            1, 0x020d8000, 16,   hw_src },
    { "SSI1",           1, 0x02028000, 21,   hw_ssi },
    { "SSI2",           2, 0x0202c000, 21,   hw_ssi },
    { "SSI3",           3, 0x02030000, 21,   hw_ssi },
    { "TEMPMON",        1, 0x020c8000, 12,   hw_tempmon },
    { "UART1",          1, 0x02020000, 17,   hw_uart },
    { "UART2",          2, 0x021e8000, 17,   hw_uart },
    { "UART3",          3, 0x021ec000, 17,   hw_uart },
    { "UART4",          4, 0x021f0000, 17,   hw_uart },
    { "UART5",          5, 0x021f4000, 17,   hw_uart },
    { "UART6",          6, 0x022a0000, 17,   hw_uart },
    { "USBC",           1, 0x02184000, 117,  hw_usbc },
    { "USBNC",          1, 0x02184000, 6,    hw_usbnc },
    { "USBPHY1",        1, 0x020c9000, 27,   hw_usbphy },
    { "USBPHY2",        2, 0x020ca000, 27,   hw_usbphy },
    { "USB_ANALOG",     1, 0x020c8000, 29,   hw_usb_analog },
    { "USDHC1",         1, 0x02190000, 29,   hw_usdhc },
    { "USDHC2",         2, 0x02194000, 29,   hw_usdhc },
    { "USDHC3",         3, 0x02198000, 29,   hw_usdhc },
    { "USDHC4",         4, 0x0219c000, 29,   hw_usdhc },
    { "VDEC",           1, 0x0222c000, 45,   hw_vdec },
    { "WDOG1",          1, 0x020bc000, 5,    hw_wdog },
    { "WDOG2",          2, 0x020c0000, 5,    hw_wdog },
    { "WDOG3",          3, 0x02288000, 5,    hw_wdog },
    { "XTALOSC24M",     1, 0x020c8000, 17,   hw_xtalosc24m },
    { 0 } // Terminator
};

////////////////////////////////////////////////////////////////////////////////
